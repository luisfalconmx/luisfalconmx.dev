// @ts-nocheck
import { GraphQLResolveInfo, SelectionSetNode, FieldNode, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
import { gql } from '@graphql-mesh/utils';

import type { GetMeshOptions } from '@graphql-mesh/runtime';
import type { YamlConfig } from '@graphql-mesh/types';
import { PubSub } from '@graphql-mesh/utils';
import { DefaultLogger } from '@graphql-mesh/utils';
import MeshCache from "@graphql-mesh/cache-localforage";
import { fetch as fetchFn } from '@whatwg-node/fetch';

import { MeshResolvedSource } from '@graphql-mesh/runtime';
import { MeshTransform, MeshPlugin } from '@graphql-mesh/types';
import GraphqlHandler from "@graphql-mesh/graphql"
import BareMerger from "@graphql-mesh/merger-bare";
import { printWithCache } from '@graphql-mesh/utils';
import { usePersistedOperations } from '@graphql-yoga/plugin-persisted-operations';
import { createMeshHTTPHandler, MeshHTTPHandler } from '@graphql-mesh/http';
import { getMesh, ExecuteMeshFn, SubscribeMeshFn, MeshContext as BaseMeshContext, MeshInstance } from '@graphql-mesh/runtime';
import { MeshStore, FsStoreStorageAdapter } from '@graphql-mesh/store';
import { path as pathModule } from '@graphql-mesh/cross-helpers';
import { ImportFn } from '@graphql-mesh/types';
import type { GithubTypes } from './sources/Github/types';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };



/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** A (potentially binary) string encoded using base64. */
  Base64String: { input: any; output: any; }
  /**
   * Represents non-fractional signed whole numeric values. Since the value may
   * exceed the size of a 32-bit integer, it's encoded as a string.
   */
  BigInt: { input: any; output: any; }
  /** An ISO-8601 encoded date string. */
  Date: { input: any; output: any; }
  /** An ISO-8601 encoded UTC date string. */
  DateTime: { input: any; output: any; }
  /** A Git object ID. */
  GitObjectID: { input: any; output: any; }
  /** A fully qualified reference name (e.g. `refs/heads/master`). */
  GitRefname: { input: any; output: any; }
  /** Git SSH string */
  GitSSHRemote: { input: any; output: any; }
  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
  GitTimestamp: { input: any; output: any; }
  /** A string containing HTML code. */
  HTML: { input: any; output: any; }
  /** An ISO-8601 encoded UTC date string with millisecond precision. */
  PreciseDateTime: { input: any; output: any; }
  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
  URI: { input: any; output: any; }
  /** A valid x509 certificate string */
  X509Certificate: { input: any; output: any; }
};

/** Autogenerated input type of AbortQueuedMigrations */
export type AbortQueuedMigrationsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that is running the migrations. */
  ownerId: Scalars['ID']['input'];
};

/** Autogenerated return type of AbortQueuedMigrations */
export type AbortQueuedMigrationsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Autogenerated input type of AbortRepositoryMigration */
export type AbortRepositoryMigrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the migration to be aborted. */
  migrationId: Scalars['ID']['input'];
};

/** Autogenerated return type of AbortRepositoryMigration */
export type AbortRepositoryMigrationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */
export type AcceptEnterpriseAdministratorInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the invitation being accepted */
  invitationId: Scalars['ID']['input'];
};

/** Autogenerated return type of AcceptEnterpriseAdministratorInvitation */
export type AcceptEnterpriseAdministratorInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The invitation that was accepted. */
  invitation?: Maybe<EnterpriseAdministratorInvitation>;
  /** A message confirming the result of accepting an administrator invitation. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of AcceptTopicSuggestion */
export type AcceptTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The name of the suggested topic.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `name` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  name?: InputMaybe<Scalars['String']['input']>;
  /**
   * The Node ID of the repository.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `repositoryId` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of AcceptTopicSuggestion */
export type AcceptTopicSuggestionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * The accepted topic.
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  topic?: Maybe<Topic>;
};

/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type Actor = {
  /** A URL pointing to the actor's public avatar. */
  avatarUrl: Scalars['URI']['output'];
  /** The username of the actor. */
  login: Scalars['String']['output'];
  /** The HTTP path for this actor. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this actor. */
  url: Scalars['URI']['output'];
};


/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type ActoravatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** Location information for an actor */
export type ActorLocation = {
  /** City */
  city?: Maybe<Scalars['String']['output']>;
  /** Country name */
  country?: Maybe<Scalars['String']['output']>;
  /** Country code */
  countryCode?: Maybe<Scalars['String']['output']>;
  /** Region name */
  region?: Maybe<Scalars['String']['output']>;
  /** Region or state code */
  regionCode?: Maybe<Scalars['String']['output']>;
};

/** The actor's type. */
export type ActorType =
  /** Indicates a team actor. */
  | 'TEAM'
  /** Indicates a user actor. */
  | 'USER';

/** Autogenerated input type of AddAssigneesToAssignable */
export type AddAssigneesToAssignableInput = {
  /** The id of the assignable object to add assignees to. */
  assignableId: Scalars['ID']['input'];
  /** The id of users to add as assignees. */
  assigneeIds: Array<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AddAssigneesToAssignable */
export type AddAssigneesToAssignablePayload = {
  /** The item that was assigned. */
  assignable?: Maybe<Assignable>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of AddComment */
export type AddCommentInput = {
  /** The contents of the comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddComment */
export type AddCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The edge from the subject's comment connection. */
  commentEdge?: Maybe<IssueCommentEdge>;
  /** The subject */
  subject?: Maybe<Node>;
  /** The edge from the subject's timeline connection. */
  timelineEdge?: Maybe<IssueTimelineItemEdge>;
};

/** Autogenerated input type of AddDiscussionComment */
export type AddDiscussionCommentInput = {
  /** The contents of the comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion to comment on. */
  discussionId: Scalars['ID']['input'];
  /** The Node ID of the discussion comment within this discussion to reply to. */
  replyToId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of AddDiscussionComment */
export type AddDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created discussion comment. */
  comment?: Maybe<DiscussionComment>;
};

/** Autogenerated input type of AddDiscussionPollVote */
export type AddDiscussionPollVoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion poll option to vote for. */
  pollOptionId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddDiscussionPollVote */
export type AddDiscussionPollVotePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The poll option that a vote was added to. */
  pollOption?: Maybe<DiscussionPollOption>;
};

/** Autogenerated input type of AddEnterpriseOrganizationMember */
export type AddEnterpriseOrganizationMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise which owns the organization. */
  enterpriseId: Scalars['ID']['input'];
  /** The ID of the organization the users will be added to. */
  organizationId: Scalars['ID']['input'];
  /** The role to assign the users in the organization */
  role?: InputMaybe<OrganizationMemberRole>;
  /** The IDs of the enterprise members to add. */
  userIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of AddEnterpriseOrganizationMember */
export type AddEnterpriseOrganizationMemberPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The users who were added to the organization. */
  users?: Maybe<Array<User>>;
};

/** Autogenerated input type of AddEnterpriseSupportEntitlement */
export type AddEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of a member who will receive the support entitlement. */
  login: Scalars['String']['input'];
};

/** Autogenerated return type of AddEnterpriseSupportEntitlement */
export type AddEnterpriseSupportEntitlementPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of adding the support entitlement. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of AddLabelsToLabelable */
export type AddLabelsToLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ids of the labels to add. */
  labelIds: Array<Scalars['ID']['input']>;
  /** The id of the labelable object to add labels to. */
  labelableId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddLabelsToLabelable */
export type AddLabelsToLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was labeled. */
  labelable?: Maybe<Labelable>;
};

/** Autogenerated input type of AddProjectCard */
export type AddProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The content of the card. Must be a member of the ProjectCardItem union */
  contentId?: InputMaybe<Scalars['ID']['input']>;
  /** The note on the card. */
  note?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the ProjectColumn. */
  projectColumnId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddProjectCard */
export type AddProjectCardPayload = {
  /** The edge from the ProjectColumn's card connection. */
  cardEdge?: Maybe<ProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The ProjectColumn */
  projectColumn?: Maybe<ProjectColumn>;
};

/** Autogenerated input type of AddProjectColumn */
export type AddProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the column. */
  name: Scalars['String']['input'];
  /** The Node ID of the project. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddProjectColumn */
export type AddProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The edge from the project's column connection. */
  columnEdge?: Maybe<ProjectColumnEdge>;
  /** The project */
  project?: Maybe<Project>;
};

/** Autogenerated input type of AddProjectV2DraftIssue */
export type AddProjectV2DraftIssueInput = {
  /** The IDs of the assignees of the draft issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The body of the draft issue. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to add the draft issue to. */
  projectId: Scalars['ID']['input'];
  /**
   * The title of the draft issue. A project item can also be created by providing
   * the URL of an Issue or Pull Request if you have access.
   */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of AddProjectV2DraftIssue */
export type AddProjectV2DraftIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The draft issue added to the project. */
  projectItem?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of AddProjectV2ItemById */
export type AddProjectV2ItemByIdInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the Issue or Pull Request to add. */
  contentId: Scalars['ID']['input'];
  /** The ID of the Project to add the item to. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddProjectV2ItemById */
export type AddProjectV2ItemByIdPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item added to the project. */
  item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of AddPullRequestReviewComment */
export type AddPullRequestReviewCommentInput = {
  /**
   * The text of the comment. This field is required
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `body` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The SHA of the commit to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `commitOID` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  commitOID?: InputMaybe<Scalars['GitObjectID']['input']>;
  /**
   * The comment id to reply to.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `inReplyTo` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  inReplyTo?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The relative path of the file to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `path` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  path?: InputMaybe<Scalars['String']['input']>;
  /**
   * The line index in the diff to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `position` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  position?: InputMaybe<Scalars['Int']['input']>;
  /**
   * The node ID of the pull request reviewing
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `pullRequestId` will be removed. use
   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The Node ID of the review to modify.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `pullRequestReviewId` will be removed. use
   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of AddPullRequestReviewComment */
export type AddPullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created comment. */
  comment?: Maybe<PullRequestReviewComment>;
  /** The edge from the review's comment connection. */
  commentEdge?: Maybe<PullRequestReviewCommentEdge>;
};

/** Autogenerated input type of AddPullRequestReview */
export type AddPullRequestReviewInput = {
  /** The contents of the review body comment. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The review line comments.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `comments` will be removed. use the `threads` argument instead
   * **Reason:** We are deprecating comment fields that use diff-relative positioning
   */
  comments?: InputMaybe<Array<InputMaybe<DraftPullRequestReviewComment>>>;
  /** The commit OID the review pertains to. */
  commitOID?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** The event to perform on the pull request review. */
  event?: InputMaybe<PullRequestReviewEvent>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID']['input'];
  /** The review line comment threads. */
  threads?: InputMaybe<Array<InputMaybe<DraftPullRequestReviewThread>>>;
};

/** Autogenerated return type of AddPullRequestReview */
export type AddPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created pull request review. */
  pullRequestReview?: Maybe<PullRequestReview>;
  /** The edge from the pull request's review connection. */
  reviewEdge?: Maybe<PullRequestReviewEdge>;
};

/** Autogenerated input type of AddPullRequestReviewThread */
export type AddPullRequestReviewThreadInput = {
  /** Body of the thread's first comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The line of the blob to which the thread refers, required for line-level
   * threads. The end of the line range for multi-line comments.
   */
  line?: InputMaybe<Scalars['Int']['input']>;
  /** Path to the file being commented on. */
  path: Scalars['String']['input'];
  /** The node ID of the pull request reviewing */
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  /** The Node ID of the review to modify. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: InputMaybe<DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: InputMaybe<Scalars['Int']['input']>;
  /** The side of the diff on which the start line resides. */
  startSide?: InputMaybe<DiffSide>;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  subjectType?: InputMaybe<PullRequestReviewThreadSubjectType>;
};

/** Autogenerated return type of AddPullRequestReviewThread */
export type AddPullRequestReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created thread. */
  thread?: Maybe<PullRequestReviewThread>;
};

/** Autogenerated input type of AddPullRequestReviewThreadReply */
export type AddPullRequestReviewThreadReplyInput = {
  /** The text of the reply. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pending review to which the reply will belong. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
  /** The Node ID of the thread to which this reply is being written. */
  pullRequestReviewThreadId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddPullRequestReviewThreadReply */
export type AddPullRequestReviewThreadReplyPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created reply. */
  comment?: Maybe<PullRequestReviewComment>;
};

/** Autogenerated input type of AddReaction */
export type AddReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the emoji to react with. */
  content: ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddReaction */
export type AddReactionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The reaction object. */
  reaction?: Maybe<Reaction>;
  /** The reaction groups for the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** The reactable subject. */
  subject?: Maybe<Reactable>;
};

/** Autogenerated input type of AddStar */
export type AddStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Starrable ID to star. */
  starrableId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddStar */
export type AddStarPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The starrable. */
  starrable?: Maybe<Starrable>;
};

/** Autogenerated input type of AddUpvote */
export type AddUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion or comment to upvote. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddUpvote */
export type AddUpvotePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The votable subject. */
  subject?: Maybe<Votable>;
};

/** Autogenerated input type of AddVerifiableDomain */
export type AddVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the domain */
  domain: Scalars['URI']['input'];
  /** The ID of the owner to add the domain to */
  ownerId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddVerifiableDomain */
export type AddVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The verifiable domain that was added. */
  domain?: Maybe<VerifiableDomain>;
};

/** Represents an 'added_to_merge_queue' event on a given pull request. */
export type AddedToMergeQueueEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who added this Pull Request to the merge queue */
  enqueuer?: Maybe<User>;
  /** The Node ID of the AddedToMergeQueueEvent object */
  id: Scalars['ID']['output'];
  /** The merge queue where this pull request was added to. */
  mergeQueue?: Maybe<MergeQueue>;
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'added_to_project' event on a given issue or pull request. */
export type AddedToProjectEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the AddedToProjectEvent object */
  id: Scalars['ID']['output'];
  /** Project referenced by event. */
  project?: Maybe<Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<ProjectCard>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String']['output'];
};

/** Represents an announcement banner. */
export type AnnouncementBanner = {
  /** The text of the announcement */
  announcement?: Maybe<Scalars['String']['output']>;
  /** The expiration date of the announcement, if any */
  announcementExpiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether the announcement can be dismissed by the user */
  announcementUserDismissible?: Maybe<Scalars['Boolean']['output']>;
};

/** A GitHub App. */
export type App = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The description of the app. */
  description?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the App object */
  id: Scalars['ID']['output'];
  /** The IP addresses of the app. */
  ipAllowListEntries: IpAllowListEntryConnection;
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars['String']['output'];
  /** A URL pointing to the app's logo. */
  logoUrl: Scalars['URI']['output'];
  /** The name of the app. */
  name: Scalars['String']['output'];
  /** A slug based on the name of the app for use in URLs. */
  slug: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The URL to the app's homepage. */
  url: Scalars['URI']['output'];
};


/** A GitHub App. */
export type AppipAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IpAllowListEntryOrder>;
};


/** A GitHub App. */
export type ApplogoUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ApproveDeployments */
export type ApproveDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Optional comment for approving deployments */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars['ID']['input']>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars['ID']['input'];
};

/** Autogenerated return type of ApproveDeployments */
export type ApproveDeploymentsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The affected deployments. */
  deployments?: Maybe<Array<Deployment>>;
};

/** Autogenerated input type of ApproveVerifiableDomain */
export type ApproveVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to approve. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ApproveVerifiableDomain */
export type ApproveVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The verifiable domain that was approved. */
  domain?: Maybe<VerifiableDomain>;
};

/** Autogenerated input type of ArchiveProjectV2Item */
export type ArchiveProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the ProjectV2Item to archive. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project to archive the item from. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ArchiveProjectV2Item */
export type ArchiveProjectV2ItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item archived from the project. */
  item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of ArchiveRepository */
export type ArchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to mark as archived. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of ArchiveRepository */
export type ArchiveRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository that was marked as archived. */
  repository?: Maybe<Repository>;
};

/** An object that can have users assigned to it. */
export type Assignable = {
  /** A list of Users assigned to this object. */
  assignees: UserConnection;
};


/** An object that can have users assigned to it. */
export type AssignableassigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an 'assigned' event on any assignable object. */
export type AssignedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the assignable associated with the event. */
  assignable: Assignable;
  /** Identifies the user or mannequin that was assigned. */
  assignee?: Maybe<Assignee>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the AssignedEvent object */
  id: Scalars['ID']['output'];
  /**
   * Identifies the user who was assigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  user?: Maybe<User>;
};

/** Types that can be assigned to issues. */
export type Assignee = Bot | Mannequin | Organization | User;

/** An entry in the audit log. */
export type AuditEntry = {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Types that can initiate an audit log event. */
export type AuditEntryActor = Bot | Organization | User;

/** Ordering options for Audit Log connections. */
export type AuditLogOrder = {
  /** The ordering direction. */
  direction?: InputMaybe<OrderDirection>;
  /** The field to order Audit Logs by. */
  field?: InputMaybe<AuditLogOrderField>;
};

/** Properties by which Audit Log connections can be ordered. */
export type AuditLogOrderField =
  /** Order audit log entries by timestamp */
  | 'CREATED_AT';

/** Represents a 'auto_merge_disabled' event on a given pull request. */
export type AutoMergeDisabledEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who disabled auto-merge for this Pull Request */
  disabler?: Maybe<User>;
  /** The Node ID of the AutoMergeDisabledEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event */
  pullRequest?: Maybe<PullRequest>;
  /** The reason auto-merge was disabled */
  reason?: Maybe<Scalars['String']['output']>;
  /** The reason_code relating to why auto-merge was disabled */
  reasonCode?: Maybe<Scalars['String']['output']>;
};

/** Represents a 'auto_merge_enabled' event on a given pull request. */
export type AutoMergeEnabledEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who enabled auto-merge for this Pull Request */
  enabler?: Maybe<User>;
  /** The Node ID of the AutoMergeEnabledEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents an auto-merge request for a pull request */
export type AutoMergeRequest = {
  /** The email address of the author of this auto-merge request. */
  authorEmail?: Maybe<Scalars['String']['output']>;
  /**
   * The commit message of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging.
   */
  commitBody?: Maybe<Scalars['String']['output']>;
  /**
   * The commit title of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging
   */
  commitHeadline?: Maybe<Scalars['String']['output']>;
  /** When was this auto-merge request was enabled. */
  enabledAt?: Maybe<Scalars['DateTime']['output']>;
  /** The actor who created the auto-merge request. */
  enabledBy?: Maybe<Actor>;
  /**
   * The merge method of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging.
   */
  mergeMethod: PullRequestMergeMethod;
  /** The pull request that this auto-merge request is set against. */
  pullRequest: PullRequest;
};

/** Represents a 'auto_rebase_enabled' event on a given pull request. */
export type AutoRebaseEnabledEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who enabled auto-merge (rebase) for this Pull Request */
  enabler?: Maybe<User>;
  /** The Node ID of the AutoRebaseEnabledEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'auto_squash_enabled' event on a given pull request. */
export type AutoSquashEnabledEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who enabled auto-merge (squash) for this Pull Request */
  enabler?: Maybe<User>;
  /** The Node ID of the AutoSquashEnabledEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'automatic_base_change_failed' event on a given pull request. */
export type AutomaticBaseChangeFailedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the AutomaticBaseChangeFailedEvent object */
  id: Scalars['ID']['output'];
  /** The new base for this PR */
  newBase: Scalars['String']['output'];
  /** The old base for this PR */
  oldBase: Scalars['String']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
export type AutomaticBaseChangeSucceededEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the AutomaticBaseChangeSucceededEvent object */
  id: Scalars['ID']['output'];
  /** The new base for this PR */
  newBase: Scalars['String']['output'];
  /** The old base for this PR */
  oldBase: Scalars['String']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** Represents a 'base_ref_changed' event on a given issue or pull request. */
export type BaseRefChangedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the name of the base ref for the pull request after it was changed. */
  currentRefName: Scalars['String']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the BaseRefChangedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the name of the base ref for the pull request before it was changed. */
  previousRefName: Scalars['String']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** Represents a 'base_ref_deleted' event on a given pull request. */
export type BaseRefDeletedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the name of the Ref associated with the `base_ref_deleted` event. */
  baseRefName?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the BaseRefDeletedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'base_ref_force_pushed' event on a given pull request. */
export type BaseRefForcePushedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */
  afterCommit?: Maybe<Commit>;
  /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */
  beforeCommit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the BaseRefForcePushedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */
  ref?: Maybe<Ref>;
};

/** Represents a Git blame. */
export type Blame = {
  /** The list of ranges from a Git blame. */
  ranges: Array<BlameRange>;
};

/** Represents a range of information from a Git blame. */
export type BlameRange = {
  /**
   * Identifies the recency of the change, from 1 (new) to 10 (old). This is
   * calculated as a 2-quantile and determines the length of distance between the
   * median age of all the changes in the file and the recency of the current
   * range's change.
   */
  age: Scalars['Int']['output'];
  /** Identifies the line author */
  commit: Commit;
  /** The ending line for the range */
  endingLine: Scalars['Int']['output'];
  /** The starting line for the range */
  startingLine: Scalars['Int']['output'];
};

/** Represents a Git blob. */
export type Blob = GitObject & Node & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String']['output'];
  /** Byte size of Blob object */
  byteSize: Scalars['Int']['output'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI']['output'];
  /** The Node ID of the Blob object */
  id: Scalars['ID']['output'];
  /** Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding. */
  isBinary?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the contents is truncated */
  isTruncated: Scalars['Boolean']['output'];
  /** The Git object ID */
  oid: Scalars['GitObjectID']['output'];
  /** The Repository the Git object belongs to */
  repository: Repository;
  /** UTF8 text data or null if the Blob is binary */
  text?: Maybe<Scalars['String']['output']>;
};

/** A special type of user which takes actions on behalf of GitHub Apps. */
export type Bot = Actor & Node & UniformResourceLocatable & {
  /** A URL pointing to the GitHub App's public avatar. */
  avatarUrl: Scalars['URI']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the Bot object */
  id: Scalars['ID']['output'];
  /** The username of the actor. */
  login: Scalars['String']['output'];
  /** The HTTP path for this bot */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this bot */
  url: Scalars['URI']['output'];
};


/** A special type of user which takes actions on behalf of GitHub Apps. */
export type BotavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** Types which can be actors for `BranchActorAllowance` objects. */
export type BranchActorAllowanceActor = App | Team | User;

/** Parameters to be used for the branch_name_pattern rule */
export type BranchNamePatternParameters = {
  /** How this rule will appear to users. */
  name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  operator: Scalars['String']['output'];
  /** The pattern to match with. */
  pattern: Scalars['String']['output'];
};

/** Parameters to be used for the branch_name_pattern rule */
export type BranchNamePatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/** A branch protection rule. */
export type BranchProtectionRule = Node & {
  /** Can this branch be deleted. */
  allowsDeletions: Scalars['Boolean']['output'];
  /** Are force pushes allowed on this branch. */
  allowsForcePushes: Scalars['Boolean']['output'];
  /** Is branch creation a protected operation. */
  blocksCreations: Scalars['Boolean']['output'];
  /** A list of conflicts matching branches protection rule and other branch protection rules */
  branchProtectionRuleConflicts: BranchProtectionRuleConflictConnection;
  /** A list of actors able to force push for this branch protection rule. */
  bypassForcePushAllowances: BypassForcePushAllowanceConnection;
  /** A list of actors able to bypass PRs for this branch protection rule. */
  bypassPullRequestAllowances: BypassPullRequestAllowanceConnection;
  /** The actor who created this branch protection rule. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews: Scalars['Boolean']['output'];
  /** The Node ID of the BranchProtectionRule object */
  id: Scalars['ID']['output'];
  /** Can admins override branch protection. */
  isAdminEnforced: Scalars['Boolean']['output'];
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge: Scalars['Boolean']['output'];
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch: Scalars['Boolean']['output'];
  /** Repository refs that are protected by this rule */
  matchingRefs: RefConnection;
  /** Identifies the protection rule pattern. */
  pattern: Scalars['String']['output'];
  /** A list push allowances for this branch protection rule. */
  pushAllowances: PushAllowanceConnection;
  /** The repository associated with this branch protection rule. */
  repository?: Maybe<Repository>;
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval: Scalars['Boolean']['output'];
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']['output']>;
  /** List of required deployment environments that must be deployed successfully to update matching branches */
  requiredDeploymentEnvironments?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** List of required status checks that must pass for commits to be accepted to matching branches. */
  requiredStatusChecks?: Maybe<Array<RequiredStatusCheckDescription>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews: Scalars['Boolean']['output'];
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews: Scalars['Boolean']['output'];
  /** Are commits required to be signed. */
  requiresCommitSignatures: Scalars['Boolean']['output'];
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution: Scalars['Boolean']['output'];
  /** Does this branch require deployment to specific environments before merging */
  requiresDeployments: Scalars['Boolean']['output'];
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory: Scalars['Boolean']['output'];
  /** Are status checks required to update matching branches. */
  requiresStatusChecks: Scalars['Boolean']['output'];
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks: Scalars['Boolean']['output'];
  /** Is pushing to matching branches restricted. */
  restrictsPushes: Scalars['Boolean']['output'];
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals: Scalars['Boolean']['output'];
  /** A list review dismissal allowances for this branch protection rule. */
  reviewDismissalAllowances: ReviewDismissalAllowanceConnection;
};


/** A branch protection rule. */
export type BranchProtectionRulebranchProtectionRuleConflictsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A branch protection rule. */
export type BranchProtectionRulebypassForcePushAllowancesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A branch protection rule. */
export type BranchProtectionRulebypassPullRequestAllowancesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A branch protection rule. */
export type BranchProtectionRulematchingRefsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A branch protection rule. */
export type BranchProtectionRulepushAllowancesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A branch protection rule. */
export type BranchProtectionRulereviewDismissalAllowancesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A conflict between two branch protection rules. */
export type BranchProtectionRuleConflict = {
  /** Identifies the branch protection rule. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** Identifies the conflicting branch protection rule. */
  conflictingBranchProtectionRule?: Maybe<BranchProtectionRule>;
  /** Identifies the branch ref that has conflicting rules */
  ref?: Maybe<Ref>;
};

/** The connection type for BranchProtectionRuleConflict. */
export type BranchProtectionRuleConflictConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BranchProtectionRuleConflictEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BranchProtectionRuleConflict>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BranchProtectionRuleConflictEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BranchProtectionRuleConflict>;
};

/** The connection type for BranchProtectionRule. */
export type BranchProtectionRuleConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BranchProtectionRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BranchProtectionRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BranchProtectionRuleEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BranchProtectionRule>;
};

/**
 * Information about a sponsorship to make for a user or organization with a GitHub
 * Sponsors profile, as part of sponsoring many users or organizations at once.
 */
export type BulkSponsorship = {
  /** The amount to pay to the sponsorable in US dollars. Valid values: 1-12000. */
  amount: Scalars['Int']['input'];
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Types that can represent a repository ruleset bypass actor. */
export type BypassActor = App | Team;

/** A user, team, or app who has the ability to bypass a force push requirement on a protected branch. */
export type BypassForcePushAllowance = Node & {
  /** The actor that can force push. */
  actor?: Maybe<BranchActorAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** The Node ID of the BypassForcePushAllowance object */
  id: Scalars['ID']['output'];
};

/** The connection type for BypassForcePushAllowance. */
export type BypassForcePushAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BypassForcePushAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BypassForcePushAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BypassForcePushAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BypassForcePushAllowance>;
};

/** A user, team, or app who has the ability to bypass a pull request requirement on a protected branch. */
export type BypassPullRequestAllowance = Node & {
  /** The actor that can bypass. */
  actor?: Maybe<BranchActorAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** The Node ID of the BypassPullRequestAllowance object */
  id: Scalars['ID']['output'];
};

/** The connection type for BypassPullRequestAllowance. */
export type BypassPullRequestAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BypassPullRequestAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BypassPullRequestAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BypassPullRequestAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BypassPullRequestAllowance>;
};

/** The Common Vulnerability Scoring System */
export type CVSS = {
  /** The CVSS score associated with this advisory */
  score: Scalars['Float']['output'];
  /** The CVSS vector string associated with this advisory */
  vectorString?: Maybe<Scalars['String']['output']>;
};

/** A common weakness enumeration */
export type CWE = Node & {
  /** The id of the CWE */
  cweId: Scalars['String']['output'];
  /** A detailed description of this CWE */
  description: Scalars['String']['output'];
  /** The Node ID of the CWE object */
  id: Scalars['ID']['output'];
  /** The name of this CWE */
  name: Scalars['String']['output'];
};

/** The connection type for CWE. */
export type CWEConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CWEEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CWE>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CWEEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CWE>;
};

/** Autogenerated input type of CancelEnterpriseAdminInvitation */
export type CancelEnterpriseAdminInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pending enterprise administrator invitation. */
  invitationId: Scalars['ID']['input'];
};

/** Autogenerated return type of CancelEnterpriseAdminInvitation */
export type CancelEnterpriseAdminInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The invitation that was canceled. */
  invitation?: Maybe<EnterpriseAdministratorInvitation>;
  /** A message confirming the result of canceling an administrator invitation. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CancelSponsorship */
export type CancelSponsorshipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CancelSponsorship */
export type CancelSponsorshipPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The tier that was being used at the time of cancellation. */
  sponsorsTier?: Maybe<SponsorsTier>;
};

/** Autogenerated input type of ChangeUserStatus */
export type ChangeUserStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */
  emoji?: InputMaybe<Scalars['String']['input']>;
  /** If set, the user status will not be shown after this date. */
  expiresAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */
  limitedAvailability?: InputMaybe<Scalars['Boolean']['input']>;
  /** A short description of your current status. */
  message?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the organization whose members will be allowed to see the status. If
   * omitted, the status will be publicly visible.
   */
  organizationId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of ChangeUserStatus */
export type ChangeUserStatusPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Your updated status. */
  status?: Maybe<UserStatus>;
};

/** A single check annotation. */
export type CheckAnnotation = {
  /** The annotation's severity level. */
  annotationLevel?: Maybe<CheckAnnotationLevel>;
  /** The path to the file that this annotation was made on. */
  blobUrl: Scalars['URI']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The position of this annotation. */
  location: CheckAnnotationSpan;
  /** The annotation's message. */
  message: Scalars['String']['output'];
  /** The path that this annotation was made on. */
  path: Scalars['String']['output'];
  /** Additional information about the annotation. */
  rawDetails?: Maybe<Scalars['String']['output']>;
  /** The annotation's title */
  title?: Maybe<Scalars['String']['output']>;
};

/** The connection type for CheckAnnotation. */
export type CheckAnnotationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckAnnotationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckAnnotation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Information from a check run analysis to specific lines of code. */
export type CheckAnnotationData = {
  /** Represents an annotation's information level */
  annotationLevel: CheckAnnotationLevel;
  /** The location of the annotation */
  location: CheckAnnotationRange;
  /** A short description of the feedback for these lines of code. */
  message: Scalars['String']['input'];
  /** The path of the file to add an annotation to. */
  path: Scalars['String']['input'];
  /** Details about this annotation. */
  rawDetails?: InputMaybe<Scalars['String']['input']>;
  /** The title that represents the annotation. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An edge in a connection. */
export type CheckAnnotationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CheckAnnotation>;
};

/** Represents an annotation's information level. */
export type CheckAnnotationLevel =
  /** An annotation indicating an inescapable error. */
  | 'FAILURE'
  /** An annotation indicating some information. */
  | 'NOTICE'
  /** An annotation indicating an ignorable error. */
  | 'WARNING';

/** A character position in a check annotation. */
export type CheckAnnotationPosition = {
  /** Column number (1 indexed). */
  column?: Maybe<Scalars['Int']['output']>;
  /** Line number (1 indexed). */
  line: Scalars['Int']['output'];
};

/** Information from a check run analysis to specific lines of code. */
export type CheckAnnotationRange = {
  /** The ending column of the range. */
  endColumn?: InputMaybe<Scalars['Int']['input']>;
  /** The ending line of the range. */
  endLine: Scalars['Int']['input'];
  /** The starting column of the range. */
  startColumn?: InputMaybe<Scalars['Int']['input']>;
  /** The starting line of the range. */
  startLine: Scalars['Int']['input'];
};

/** An inclusive pair of positions for a check annotation. */
export type CheckAnnotationSpan = {
  /** End position (inclusive). */
  end: CheckAnnotationPosition;
  /** Start position (inclusive). */
  start: CheckAnnotationPosition;
};

/** The possible states for a check suite or run conclusion. */
export type CheckConclusionState =
  /** The check suite or run requires action. */
  | 'ACTION_REQUIRED'
  /** The check suite or run has been cancelled. */
  | 'CANCELLED'
  /** The check suite or run has failed. */
  | 'FAILURE'
  /** The check suite or run was neutral. */
  | 'NEUTRAL'
  /** The check suite or run was skipped. */
  | 'SKIPPED'
  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */
  | 'STALE'
  /** The check suite or run has failed at startup. */
  | 'STARTUP_FAILURE'
  /** The check suite or run has succeeded. */
  | 'SUCCESS'
  /** The check suite or run has timed out. */
  | 'TIMED_OUT';

/** A check run. */
export type CheckRun = Node & RequirableByPullRequest & UniformResourceLocatable & {
  /** The check run's annotations */
  annotations?: Maybe<CheckAnnotationConnection>;
  /** The check suite that this run is a part of. */
  checkSuite: CheckSuite;
  /** Identifies the date and time when the check run was completed. */
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The conclusion of the check run. */
  conclusion?: Maybe<CheckConclusionState>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The corresponding deployment for this job, if any */
  deployment?: Maybe<Deployment>;
  /** The URL from which to find full details of the check run on the integrator's site. */
  detailsUrl?: Maybe<Scalars['URI']['output']>;
  /** A reference for the check run on the integrator's system. */
  externalId?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the CheckRun object */
  id: Scalars['ID']['output'];
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars['Boolean']['output'];
  /** The name of the check for this check run. */
  name: Scalars['String']['output'];
  /** Information about a pending deployment, if any, in this check run */
  pendingDeploymentRequest?: Maybe<DeploymentRequest>;
  /** The permalink to the check run summary. */
  permalink: Scalars['URI']['output'];
  /** The repository associated with this check run. */
  repository: Repository;
  /** The HTTP path for this check run. */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the check run was started. */
  startedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The current status of the check run. */
  status: CheckStatusState;
  /** The check run's steps */
  steps?: Maybe<CheckStepConnection>;
  /** A string representing the check run's summary */
  summary?: Maybe<Scalars['String']['output']>;
  /** A string representing the check run's text */
  text?: Maybe<Scalars['String']['output']>;
  /** A string representing the check run */
  title?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this check run. */
  url: Scalars['URI']['output'];
};


/** A check run. */
export type CheckRunannotationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A check run. */
export type CheckRunisRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']['input']>;
};


/** A check run. */
export type CheckRunstepsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
};

/** Possible further actions the integrator can perform. */
export type CheckRunAction = {
  /** A short explanation of what this action would do. */
  description: Scalars['String']['input'];
  /** A reference for the action on the integrator's system. */
  identifier: Scalars['String']['input'];
  /** The text to be displayed on a button in the web UI. */
  label: Scalars['String']['input'];
};

/** The connection type for CheckRun. */
export type CheckRunConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckRunEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckRun>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CheckRunEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CheckRun>;
};

/** The filters that are available when fetching check runs. */
export type CheckRunFilter = {
  /** Filters the check runs created by this application ID. */
  appId?: InputMaybe<Scalars['Int']['input']>;
  /** Filters the check runs by this name. */
  checkName?: InputMaybe<Scalars['String']['input']>;
  /** Filters the check runs by this type. */
  checkType?: InputMaybe<CheckRunType>;
  /** Filters the check runs by these conclusions. */
  conclusions?: InputMaybe<Array<CheckConclusionState>>;
  /** Filters the check runs by this status. Superceded by statuses. */
  status?: InputMaybe<CheckStatusState>;
  /** Filters the check runs by this status. Overrides status. */
  statuses?: InputMaybe<Array<CheckStatusState>>;
};

/** Descriptive details about the check run. */
export type CheckRunOutput = {
  /** The annotations that are made as part of the check run. */
  annotations?: InputMaybe<Array<CheckAnnotationData>>;
  /** Images attached to the check run output displayed in the GitHub pull request UI. */
  images?: InputMaybe<Array<CheckRunOutputImage>>;
  /** The summary of the check run (supports Commonmark). */
  summary: Scalars['String']['input'];
  /** The details of the check run (supports Commonmark). */
  text?: InputMaybe<Scalars['String']['input']>;
  /** A title to provide for this check run. */
  title: Scalars['String']['input'];
};

/** Images attached to the check run output displayed in the GitHub pull request UI. */
export type CheckRunOutputImage = {
  /** The alternative text for the image. */
  alt: Scalars['String']['input'];
  /** A short image description. */
  caption?: InputMaybe<Scalars['String']['input']>;
  /** The full URL of the image. */
  imageUrl: Scalars['URI']['input'];
};

/** The possible states of a check run in a status rollup. */
export type CheckRunState =
  /** The check run requires action. */
  | 'ACTION_REQUIRED'
  /** The check run has been cancelled. */
  | 'CANCELLED'
  /** The check run has been completed. */
  | 'COMPLETED'
  /** The check run has failed. */
  | 'FAILURE'
  /** The check run is in progress. */
  | 'IN_PROGRESS'
  /** The check run was neutral. */
  | 'NEUTRAL'
  /** The check run is in pending state. */
  | 'PENDING'
  /** The check run has been queued. */
  | 'QUEUED'
  /** The check run was skipped. */
  | 'SKIPPED'
  /** The check run was marked stale by GitHub. Only GitHub can use this conclusion. */
  | 'STALE'
  /** The check run has failed at startup. */
  | 'STARTUP_FAILURE'
  /** The check run has succeeded. */
  | 'SUCCESS'
  /** The check run has timed out. */
  | 'TIMED_OUT'
  /** The check run is in waiting state. */
  | 'WAITING';

/** Represents a count of the state of a check run. */
export type CheckRunStateCount = {
  /** The number of check runs with this state. */
  count: Scalars['Int']['output'];
  /** The state of a check run. */
  state: CheckRunState;
};

/** The possible types of check runs. */
export type CheckRunType =
  /** Every check run available. */
  | 'ALL'
  /** The latest check run. */
  | 'LATEST';

/** The possible states for a check suite or run status. */
export type CheckStatusState =
  /** The check suite or run has been completed. */
  | 'COMPLETED'
  /** The check suite or run is in progress. */
  | 'IN_PROGRESS'
  /** The check suite or run is in pending state. */
  | 'PENDING'
  /** The check suite or run has been queued. */
  | 'QUEUED'
  /** The check suite or run has been requested. */
  | 'REQUESTED'
  /** The check suite or run is in waiting state. */
  | 'WAITING';

/** A single check step. */
export type CheckStep = {
  /** Identifies the date and time when the check step was completed. */
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The conclusion of the check step. */
  conclusion?: Maybe<CheckConclusionState>;
  /** A reference for the check step on the integrator's system. */
  externalId?: Maybe<Scalars['String']['output']>;
  /** The step's name. */
  name: Scalars['String']['output'];
  /** The index of the step in the list of steps of the parent check run. */
  number: Scalars['Int']['output'];
  /** Number of seconds to completion. */
  secondsToCompletion?: Maybe<Scalars['Int']['output']>;
  /** Identifies the date and time when the check step was started. */
  startedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The current status of the check step. */
  status: CheckStatusState;
};

/** The connection type for CheckStep. */
export type CheckStepConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckStepEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckStep>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CheckStepEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CheckStep>;
};

/** A check suite. */
export type CheckSuite = Node & {
  /** The GitHub App which created this check suite. */
  app?: Maybe<App>;
  /** The name of the branch for this check suite. */
  branch?: Maybe<Ref>;
  /** The check runs associated with a check suite. */
  checkRuns?: Maybe<CheckRunConnection>;
  /** The commit for this check suite */
  commit: Commit;
  /** The conclusion of this check suite. */
  conclusion?: Maybe<CheckConclusionState>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who triggered the check suite. */
  creator?: Maybe<User>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the CheckSuite object */
  id: Scalars['ID']['output'];
  /** A list of open pull requests matching the check suite. */
  matchingPullRequests?: Maybe<PullRequestConnection>;
  /** The push that triggered this check suite. */
  push?: Maybe<Push>;
  /** The repository associated with this check suite. */
  repository: Repository;
  /** The HTTP path for this check suite */
  resourcePath: Scalars['URI']['output'];
  /** The status of this check suite. */
  status: CheckStatusState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this check suite */
  url: Scalars['URI']['output'];
  /** The workflow run associated with this check suite. */
  workflowRun?: Maybe<WorkflowRun>;
};


/** A check suite. */
export type CheckSuitecheckRunsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<CheckRunFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A check suite. */
export type CheckSuitematchingPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<PullRequestState>>;
};

/** The auto-trigger preferences that are available for check suites. */
export type CheckSuiteAutoTriggerPreference = {
  /** The node ID of the application that owns the check suite. */
  appId: Scalars['ID']['input'];
  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */
  setting: Scalars['Boolean']['input'];
};

/** The connection type for CheckSuite. */
export type CheckSuiteConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckSuiteEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckSuite>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CheckSuiteEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CheckSuite>;
};

/** The filters that are available when fetching check suites. */
export type CheckSuiteFilter = {
  /** Filters the check suites created by this application ID. */
  appId?: InputMaybe<Scalars['Int']['input']>;
  /** Filters the check suites by this name. */
  checkName?: InputMaybe<Scalars['String']['input']>;
};

/** An object which can have its data claimed or claim data from another. */
export type Claimable = Mannequin | User;

/** Autogenerated input type of ClearLabelsFromLabelable */
export type ClearLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the labelable object to clear the labels from. */
  labelableId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClearLabelsFromLabelable */
export type ClearLabelsFromLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was unlabeled. */
  labelable?: Maybe<Labelable>;
};

/** Autogenerated input type of ClearProjectV2ItemFieldValue */
export type ClearProjectV2ItemFieldValueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the field to be cleared. */
  fieldId: Scalars['ID']['input'];
  /** The ID of the item to be cleared. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClearProjectV2ItemFieldValue */
export type ClearProjectV2ItemFieldValuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated item. */
  projectV2Item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of CloneProject */
export type CloneProjectInput = {
  /** The description of the project. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not to clone the source project's workflows. */
  includeWorkflows: Scalars['Boolean']['input'];
  /** The name of the project. */
  name: Scalars['String']['input'];
  /** The visibility of the project, defaults to false (private). */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  /** The source project to clone. */
  sourceId: Scalars['ID']['input'];
  /** The owner ID to create the project under. */
  targetOwnerId: Scalars['ID']['input'];
};

/** Autogenerated return type of CloneProject */
export type CloneProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The id of the JobStatus for populating cloned fields. */
  jobStatusId?: Maybe<Scalars['String']['output']>;
  /** The new cloned project. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of CloneTemplateRepository */
export type CloneTemplateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A short description of the new repository. */
  description?: InputMaybe<Scalars['String']['input']>;
  /**
   * Whether to copy all branches from the template to the new repository. Defaults
   * to copying only the default branch of the template.
   */
  includeAllBranches?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the new repository. */
  name: Scalars['String']['input'];
  /** The ID of the owner for the new repository. */
  ownerId: Scalars['ID']['input'];
  /** The Node ID of the template repository. */
  repositoryId: Scalars['ID']['input'];
  /** Indicates the repository's visibility level. */
  visibility: RepositoryVisibility;
};

/** Autogenerated return type of CloneTemplateRepository */
export type CloneTemplateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new repository. */
  repository?: Maybe<Repository>;
};

/** An object that can be closed */
export type Closable = {
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
};

/** Autogenerated input type of CloseDiscussion */
export type CloseDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the discussion to be closed. */
  discussionId: Scalars['ID']['input'];
  /** The reason why the discussion is being closed. */
  reason?: InputMaybe<DiscussionCloseReason>;
};

/** Autogenerated return type of CloseDiscussion */
export type CloseDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that was closed. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of CloseIssue */
export type CloseIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue to be closed. */
  issueId: Scalars['ID']['input'];
  /** The reason the issue is to be closed. */
  stateReason?: InputMaybe<IssueClosedStateReason>;
};

/** Autogenerated return type of CloseIssue */
export type CloseIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was closed. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of ClosePullRequest */
export type ClosePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to be closed. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClosePullRequest */
export type ClosePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that was closed. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'closed' event on any `Closable`. */
export type ClosedEvent = Node & UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Object that was closed. */
  closable: Closable;
  /** Object which triggered the creation of this event. */
  closer?: Maybe<Closer>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ClosedEvent object */
  id: Scalars['ID']['output'];
  /** The HTTP path for this closed event. */
  resourcePath: Scalars['URI']['output'];
  /** The reason the issue state was changed to closed. */
  stateReason?: Maybe<IssueStateReason>;
  /** The HTTP URL for this closed event. */
  url: Scalars['URI']['output'];
};

/** The object which triggered a `ClosedEvent`. */
export type Closer = Commit | PullRequest;

/** The Code of Conduct for a repository */
export type CodeOfConduct = Node & {
  /** The body of the Code of Conduct */
  body?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the CodeOfConduct object */
  id: Scalars['ID']['output'];
  /** The key for the Code of Conduct */
  key: Scalars['String']['output'];
  /** The formal name of the Code of Conduct */
  name: Scalars['String']['output'];
  /** The HTTP path for this Code of Conduct */
  resourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this Code of Conduct */
  url?: Maybe<Scalars['URI']['output']>;
};

/** Collaborators affiliation level with a subject. */
export type CollaboratorAffiliation =
  /** All collaborators the authenticated user can see. */
  | 'ALL'
  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */
  | 'DIRECT'
  /** All outside collaborators of an organization-owned subject. */
  | 'OUTSIDE';

/** Represents a comment. */
export type Comment = {
  /** The actor who authored the comment. */
  author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** The actor who edited the comment. */
  editor?: Maybe<Actor>;
  /** The Node ID of the Comment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<UserContentEditConnection>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** Represents a comment. */
export type CommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A comment author association with repository. */
export type CommentAuthorAssociation =
  /** Author has been invited to collaborate on the repository. */
  | 'COLLABORATOR'
  /** Author has previously committed to the repository. */
  | 'CONTRIBUTOR'
  /** Author has not previously committed to GitHub. */
  | 'FIRST_TIMER'
  /** Author has not previously committed to the repository. */
  | 'FIRST_TIME_CONTRIBUTOR'
  /** Author is a placeholder for an unclaimed user. */
  | 'MANNEQUIN'
  /** Author is a member of the organization that owns the repository. */
  | 'MEMBER'
  /** Author has no association with the repository. */
  | 'NONE'
  /** Author is the owner of the repository. */
  | 'OWNER';

/** The possible errors that will prevent a user from updating a comment. */
export type CommentCannotUpdateReason =
  /** Unable to create comment because repository is archived. */
  | 'ARCHIVED'
  /** You cannot update this comment */
  | 'DENIED'
  /** You must be the author or have write access to this repository to update this comment. */
  | 'INSUFFICIENT_ACCESS'
  /** Unable to create comment because issue is locked. */
  | 'LOCKED'
  /** You must be logged in to update this comment. */
  | 'LOGIN_REQUIRED'
  /** Repository is under maintenance. */
  | 'MAINTENANCE'
  /** At least one email address must be verified to update this comment. */
  | 'VERIFIED_EMAIL_REQUIRED';

/** Represents a 'comment_deleted' event on a given issue or pull request. */
export type CommentDeletedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The user who authored the deleted comment. */
  deletedCommentAuthor?: Maybe<Actor>;
  /** The Node ID of the CommentDeletedEvent object */
  id: Scalars['ID']['output'];
};

/** Represents a Git commit. */
export type Commit = GitObject & Node & Subscribable & UniformResourceLocatable & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String']['output'];
  /** The number of additions in this commit. */
  additions: Scalars['Int']['output'];
  /**
   * The merged Pull Request that introduced the commit to the repository. If the
   * commit is not present in the default branch, additionally returns open Pull
   * Requests associated with the commit
   */
  associatedPullRequests?: Maybe<PullRequestConnection>;
  /** Authorship details of the commit. */
  author?: Maybe<GitActor>;
  /** Check if the committer and the author match. */
  authoredByCommitter: Scalars['Boolean']['output'];
  /** The datetime when this commit was authored. */
  authoredDate: Scalars['DateTime']['output'];
  /**
   * The list of authors for this commit based on the git author and the Co-authored-by
   * message trailer. The git author will always be first.
   */
  authors: GitActorConnection;
  /** Fetches `git blame` information. */
  blame: Blame;
  /**
   * We recommend using the `changedFilesIfAvailable` field instead of
   * `changedFiles`, as `changedFiles` will cause your request to return an error
   * if GitHub is unable to calculate the number of changed files.
   * @deprecated `changedFiles` will be removed. Use `changedFilesIfAvailable` instead. Removal on 2023-01-01 UTC.
   */
  changedFiles: Scalars['Int']['output'];
  /**
   * The number of changed files in this commit. If GitHub is unable to calculate
   * the number of changed files (for example due to a timeout), this will return
   * `null`. We recommend using this field instead of `changedFiles`.
   */
  changedFilesIfAvailable?: Maybe<Scalars['Int']['output']>;
  /** The check suites associated with a commit. */
  checkSuites?: Maybe<CheckSuiteConnection>;
  /** Comments made on the commit. */
  comments: CommitCommentConnection;
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI']['output'];
  /** The datetime when this commit was committed. */
  committedDate: Scalars['DateTime']['output'];
  /** Check if committed via GitHub web UI. */
  committedViaWeb: Scalars['Boolean']['output'];
  /** Committer details of the commit. */
  committer?: Maybe<GitActor>;
  /** The number of deletions in this commit. */
  deletions: Scalars['Int']['output'];
  /** The deployments associated with a commit. */
  deployments?: Maybe<DeploymentConnection>;
  /** The tree entry representing the file located at the given path. */
  file?: Maybe<TreeEntry>;
  /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */
  history: CommitHistoryConnection;
  /** The Node ID of the Commit object */
  id: Scalars['ID']['output'];
  /** The Git commit message */
  message: Scalars['String']['output'];
  /** The Git commit message body */
  messageBody: Scalars['String']['output'];
  /** The commit message body rendered to HTML. */
  messageBodyHTML: Scalars['HTML']['output'];
  /** The Git commit message headline */
  messageHeadline: Scalars['String']['output'];
  /** The commit message headline rendered to HTML. */
  messageHeadlineHTML: Scalars['HTML']['output'];
  /** The Git object ID */
  oid: Scalars['GitObjectID']['output'];
  /** The organization this commit was made on behalf of. */
  onBehalfOf?: Maybe<Organization>;
  /** The parents of a commit. */
  parents: CommitConnection;
  /**
   * The datetime when this commit was pushed.
   * @deprecated `pushedDate` is no longer supported. Removal on 2023-07-01 UTC.
   */
  pushedDate?: Maybe<Scalars['DateTime']['output']>;
  /** The Repository this commit belongs to */
  repository: Repository;
  /** The HTTP path for this commit */
  resourcePath: Scalars['URI']['output'];
  /** Commit signing information, if present. */
  signature?: Maybe<GitSignature>;
  /** Status information for this commit */
  status?: Maybe<Status>;
  /** Check and Status rollup information for this commit. */
  statusCheckRollup?: Maybe<StatusCheckRollup>;
  /** Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file. */
  submodules: SubmoduleConnection;
  /**
   * Returns a URL to download a tarball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
   */
  tarballUrl: Scalars['URI']['output'];
  /** Commit's root Tree */
  tree: Tree;
  /** The HTTP path for the tree of this commit */
  treeResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for the tree of this commit */
  treeUrl: Scalars['URI']['output'];
  /** The HTTP URL for this commit */
  url: Scalars['URI']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<SubscriptionState>;
  /**
   * Returns a URL to download a zipball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
   */
  zipballUrl: Scalars['URI']['output'];
};


/** Represents a Git commit. */
export type CommitassociatedPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PullRequestOrder>;
};


/** Represents a Git commit. */
export type CommitauthorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a Git commit. */
export type CommitblameArgs = {
  path: Scalars['String']['input'];
};


/** Represents a Git commit. */
export type CommitcheckSuitesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<CheckSuiteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a Git commit. */
export type CommitcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a Git commit. */
export type CommitdeploymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  environments?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DeploymentOrder>;
};


/** Represents a Git commit. */
export type CommitfileArgs = {
  path: Scalars['String']['input'];
};


/** Represents a Git commit. */
export type CommithistoryArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<CommitAuthor>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  since?: InputMaybe<Scalars['GitTimestamp']['input']>;
  until?: InputMaybe<Scalars['GitTimestamp']['input']>;
};


/** Represents a Git commit. */
export type CommitparentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a Git commit. */
export type CommitsubmodulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Specifies an author for filtering Git commits. */
export type CommitAuthor = {
  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
  emails?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * ID of a User to filter by. If non-null, only commits authored by this user
   * will be returned. This field takes precedence over emails.
   */
  id?: InputMaybe<Scalars['ID']['input']>;
};

/** Parameters to be used for the commit_author_email_pattern rule */
export type CommitAuthorEmailPatternParameters = {
  /** How this rule will appear to users. */
  name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  operator: Scalars['String']['output'];
  /** The pattern to match with. */
  pattern: Scalars['String']['output'];
};

/** Parameters to be used for the commit_author_email_pattern rule */
export type CommitAuthorEmailPatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/** Represents a comment on a given Commit. */
export type CommitComment = Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** Identifies the comment body. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the commit associated with the comment, if the commit exists. */
  commit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Actor>;
  /** The Node ID of the CommitComment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies the file path associated with the comment. */
  path?: Maybe<Scalars['String']['output']>;
  /** Identifies the line position associated with the comment. */
  position?: Maybe<Scalars['Int']['output']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** The repository associated with this node. */
  repository: Repository;
  /** The HTTP path permalink for this commit comment. */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL permalink for this commit comment. */
  url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** Represents a comment on a given Commit. */
export type CommitCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** Represents a comment on a given Commit. */
export type CommitCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for CommitComment. */
export type CommitCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommitCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CommitComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CommitCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CommitComment>;
};

/** A thread of comments on a commit. */
export type CommitCommentThread = Node & RepositoryNode & {
  /** The comments that exist in this thread. */
  comments: CommitCommentConnection;
  /** The commit the comments were made on. */
  commit?: Maybe<Commit>;
  /** The Node ID of the CommitCommentThread object */
  id: Scalars['ID']['output'];
  /** The file the comments were made on. */
  path?: Maybe<Scalars['String']['output']>;
  /** The position in the diff for the commit that the comment was made on. */
  position?: Maybe<Scalars['Int']['output']>;
  /** The repository associated with this node. */
  repository: Repository;
};


/** A thread of comments on a commit. */
export type CommitCommentThreadcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Commit. */
export type CommitConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Ordering options for commit contribution connections. */
export type CommitContributionOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field by which to order commit contributions. */
  field: CommitContributionOrderField;
};

/** Properties by which commit contribution connections can be ordered. */
export type CommitContributionOrderField =
  /** Order commit contributions by how many commits they represent. */
  | 'COMMIT_COUNT'
  /** Order commit contributions by when they were made. */
  | 'OCCURRED_AT';

/** This aggregates commits made by a user within one repository. */
export type CommitContributionsByRepository = {
  /** The commit contributions, each representing a day. */
  contributions: CreatedCommitContributionConnection;
  /** The repository in which the commits were made. */
  repository: Repository;
  /** The HTTP path for the user's commits to the repository in this time range. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for the user's commits to the repository in this time range. */
  url: Scalars['URI']['output'];
};


/** This aggregates commits made by a user within one repository. */
export type CommitContributionsByRepositorycontributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<CommitContributionOrder>;
};

/** An edge in a connection. */
export type CommitEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Commit>;
};

/** The connection type for Commit. */
export type CommitHistoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A message to include with a new commit */
export type CommitMessage = {
  /** The body of the message. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** The headline of the message. */
  headline: Scalars['String']['input'];
};

/** Parameters to be used for the commit_message_pattern rule */
export type CommitMessagePatternParameters = {
  /** How this rule will appear to users. */
  name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  operator: Scalars['String']['output'];
  /** The pattern to match with. */
  pattern: Scalars['String']['output'];
};

/** Parameters to be used for the commit_message_pattern rule */
export type CommitMessagePatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/**
 * A git ref for a commit to be appended to.
 *
 * The ref must be a branch, i.e. its fully qualified name must start
 * with `refs/heads/` (although the input is not required to be fully
 * qualified).
 *
 * The Ref may be specified by its global node ID or by the
 * `repositoryNameWithOwner` and `branchName`.
 *
 * ### Examples
 *
 * Specify a branch using a global node ID:
 *
 *     { "id": "MDM6UmVmMTpyZWZzL2hlYWRzL21haW4=" }
 *
 * Specify a branch using `repositoryNameWithOwner` and `branchName`:
 *
 *     {
 *       "repositoryNameWithOwner": "github/graphql-client",
 *       "branchName": "main"
 *     }
 */
export type CommittableBranch = {
  /** The unqualified name of the branch to append the commit to. */
  branchName?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the Ref to be updated. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The nameWithOwner of the repository to commit to. */
  repositoryNameWithOwner?: InputMaybe<Scalars['String']['input']>;
};

/** Parameters to be used for the committer_email_pattern rule */
export type CommitterEmailPatternParameters = {
  /** How this rule will appear to users. */
  name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  operator: Scalars['String']['output'];
  /** The pattern to match with. */
  pattern: Scalars['String']['output'];
};

/** Parameters to be used for the committer_email_pattern rule */
export type CommitterEmailPatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/** Represents a comparison between two commit revisions. */
export type Comparison = Node & {
  /** The number of commits ahead of the base branch. */
  aheadBy: Scalars['Int']['output'];
  /** The base revision of this comparison. */
  baseTarget: GitObject;
  /** The number of commits behind the base branch. */
  behindBy: Scalars['Int']['output'];
  /** The commits which compose this comparison. */
  commits: ComparisonCommitConnection;
  /** The head revision of this comparison. */
  headTarget: GitObject;
  /** The Node ID of the Comparison object */
  id: Scalars['ID']['output'];
  /** The status of this comparison. */
  status: ComparisonStatus;
};


/** Represents a comparison between two commit revisions. */
export type ComparisoncommitsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Commit. */
export type ComparisonCommitConnection = {
  /** The total count of authors and co-authors across all commits. */
  authorCount: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The status of a git comparison between two refs. */
export type ComparisonStatus =
  /** The head ref is ahead of the base ref. */
  | 'AHEAD'
  /** The head ref is behind the base ref. */
  | 'BEHIND'
  /** The head ref is both ahead and behind of the base ref, indicating git history has diverged. */
  | 'DIVERGED'
  /** The head ref and base ref are identical. */
  | 'IDENTICAL';

/** Represents a 'connected' event on a given issue or pull request. */
export type ConnectedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ConnectedEvent object */
  id: Scalars['ID']['output'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean']['output'];
  /** Issue or pull request that made the reference. */
  source: ReferencedSubject;
  /** Issue or pull request which was connected. */
  subject: ReferencedSubject;
};

/** The Contributing Guidelines for a repository. */
export type ContributingGuidelines = {
  /** The body of the Contributing Guidelines. */
  body?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the Contributing Guidelines. */
  resourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the Contributing Guidelines. */
  url?: Maybe<Scalars['URI']['output']>;
};

/** Represents a contribution a user made on GitHub, such as opening an issue. */
export type Contribution = {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  user: User;
};

/** A calendar of contributions made on GitHub by a user. */
export type ContributionCalendar = {
  /** A list of hex color codes used in this calendar. The darker the color, the more contributions it represents. */
  colors: Array<Scalars['String']['output']>;
  /** Determine if the color set was chosen because it's currently Halloween. */
  isHalloween: Scalars['Boolean']['output'];
  /** A list of the months of contributions in this calendar. */
  months: Array<ContributionCalendarMonth>;
  /** The count of total contributions in the calendar. */
  totalContributions: Scalars['Int']['output'];
  /** A list of the weeks of contributions in this calendar. */
  weeks: Array<ContributionCalendarWeek>;
};

/** Represents a single day of contributions on GitHub by a user. */
export type ContributionCalendarDay = {
  /** The hex color code that represents how many contributions were made on this day compared to others in the calendar. */
  color: Scalars['String']['output'];
  /** How many contributions were made by the user on this day. */
  contributionCount: Scalars['Int']['output'];
  /**
   * Indication of contributions, relative to other days. Can be used to indicate
   * which color to represent this day on a calendar.
   */
  contributionLevel: ContributionLevel;
  /** The day this square represents. */
  date: Scalars['Date']['output'];
  /** A number representing which day of the week this square represents, e.g., 1 is Monday. */
  weekday: Scalars['Int']['output'];
};

/** A month of contributions in a user's contribution graph. */
export type ContributionCalendarMonth = {
  /** The date of the first day of this month. */
  firstDay: Scalars['Date']['output'];
  /** The name of the month. */
  name: Scalars['String']['output'];
  /** How many weeks started in this month. */
  totalWeeks: Scalars['Int']['output'];
  /** The year the month occurred in. */
  year: Scalars['Int']['output'];
};

/** A week of contributions in a user's contribution graph. */
export type ContributionCalendarWeek = {
  /** The days of contributions in this week. */
  contributionDays: Array<ContributionCalendarDay>;
  /** The date of the earliest square in this week. */
  firstDay: Scalars['Date']['output'];
};

/** Varying levels of contributions from none to many. */
export type ContributionLevel =
  /** Lowest 25% of days of contributions. */
  | 'FIRST_QUARTILE'
  /** Highest 25% of days of contributions. More contributions than the third quartile. */
  | 'FOURTH_QUARTILE'
  /** No contributions occurred. */
  | 'NONE'
  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */
  | 'SECOND_QUARTILE'
  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */
  | 'THIRD_QUARTILE';

/** Ordering options for contribution connections. */
export type ContributionOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollection = {
  /** Commit contributions made by the user, grouped by repository. */
  commitContributionsByRepository: Array<CommitContributionsByRepository>;
  /** A calendar of this user's contributions on GitHub. */
  contributionCalendar: ContributionCalendar;
  /** The years the user has been making contributions with the most recent year first. */
  contributionYears: Array<Scalars['Int']['output']>;
  /** Determine if this collection's time span ends in the current month. */
  doesEndInCurrentMonth: Scalars['Boolean']['output'];
  /**
   * The date of the first restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  earliestRestrictedContributionDate?: Maybe<Scalars['Date']['output']>;
  /** The ending date and time of this collection. */
  endedAt: Scalars['DateTime']['output'];
  /**
   * The first issue the user opened on GitHub. This will be null if that issue was
   * opened outside the collection's time range and ignoreTimeRange is false. If
   * the issue is not visible but the user has opted to show private contributions,
   * a RestrictedContribution will be returned.
   */
  firstIssueContribution?: Maybe<CreatedIssueOrRestrictedContribution>;
  /**
   * The first pull request the user opened on GitHub. This will be null if that
   * pull request was opened outside the collection's time range and
   * ignoreTimeRange is not true. If the pull request is not visible but the user
   * has opted to show private contributions, a RestrictedContribution will be returned.
   */
  firstPullRequestContribution?: Maybe<CreatedPullRequestOrRestrictedContribution>;
  /**
   * The first repository the user created on GitHub. This will be null if that
   * first repository was created outside the collection's time range and
   * ignoreTimeRange is false. If the repository is not visible, then a
   * RestrictedContribution is returned.
   */
  firstRepositoryContribution?: Maybe<CreatedRepositoryOrRestrictedContribution>;
  /** Does the user have any more activity in the timeline that occurred prior to the collection's time range? */
  hasActivityInThePast: Scalars['Boolean']['output'];
  /** Determine if there are any contributions in this collection. */
  hasAnyContributions: Scalars['Boolean']['output'];
  /**
   * Determine if the user made any contributions in this time frame whose details
   * are not visible because they were made in a private repository. Can only be
   * true if the user enabled private contribution counts.
   */
  hasAnyRestrictedContributions: Scalars['Boolean']['output'];
  /** Whether or not the collector's time span is all within the same day. */
  isSingleDay: Scalars['Boolean']['output'];
  /** A list of issues the user opened. */
  issueContributions: CreatedIssueContributionConnection;
  /** Issue contributions made by the user, grouped by repository. */
  issueContributionsByRepository: Array<IssueContributionsByRepository>;
  /**
   * When the user signed up for GitHub. This will be null if that sign up date
   * falls outside the collection's time range and ignoreTimeRange is false.
   */
  joinedGitHubContribution?: Maybe<JoinedGitHubContribution>;
  /**
   * The date of the most recent restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  latestRestrictedContributionDate?: Maybe<Scalars['Date']['output']>;
  /**
   * When this collection's time range does not include any activity from the user, use this
   * to get a different collection from an earlier time range that does have activity.
   */
  mostRecentCollectionWithActivity?: Maybe<ContributionsCollection>;
  /**
   * Returns a different contributions collection from an earlier time range than this one
   * that does not have any contributions.
   */
  mostRecentCollectionWithoutActivity?: Maybe<ContributionsCollection>;
  /**
   * The issue the user opened on GitHub that received the most comments in the specified
   * time frame.
   */
  popularIssueContribution?: Maybe<CreatedIssueContribution>;
  /**
   * The pull request the user opened on GitHub that received the most comments in the
   * specified time frame.
   */
  popularPullRequestContribution?: Maybe<CreatedPullRequestContribution>;
  /** Pull request contributions made by the user. */
  pullRequestContributions: CreatedPullRequestContributionConnection;
  /** Pull request contributions made by the user, grouped by repository. */
  pullRequestContributionsByRepository: Array<PullRequestContributionsByRepository>;
  /**
   * Pull request review contributions made by the user. Returns the most recently
   * submitted review for each PR reviewed by the user.
   */
  pullRequestReviewContributions: CreatedPullRequestReviewContributionConnection;
  /** Pull request review contributions made by the user, grouped by repository. */
  pullRequestReviewContributionsByRepository: Array<PullRequestReviewContributionsByRepository>;
  /** A list of repositories owned by the user that the user created in this time range. */
  repositoryContributions: CreatedRepositoryContributionConnection;
  /**
   * A count of contributions made by the user that the viewer cannot access. Only
   * non-zero when the user has chosen to share their private contribution counts.
   */
  restrictedContributionsCount: Scalars['Int']['output'];
  /** The beginning date and time of this collection. */
  startedAt: Scalars['DateTime']['output'];
  /** How many commits were made by the user in this time span. */
  totalCommitContributions: Scalars['Int']['output'];
  /** How many issues the user opened. */
  totalIssueContributions: Scalars['Int']['output'];
  /** How many pull requests the user opened. */
  totalPullRequestContributions: Scalars['Int']['output'];
  /** How many pull request reviews the user left. */
  totalPullRequestReviewContributions: Scalars['Int']['output'];
  /** How many different repositories the user committed to. */
  totalRepositoriesWithContributedCommits: Scalars['Int']['output'];
  /** How many different repositories the user opened issues in. */
  totalRepositoriesWithContributedIssues: Scalars['Int']['output'];
  /** How many different repositories the user left pull request reviews in. */
  totalRepositoriesWithContributedPullRequestReviews: Scalars['Int']['output'];
  /** How many different repositories the user opened pull requests in. */
  totalRepositoriesWithContributedPullRequests: Scalars['Int']['output'];
  /** How many repositories the user created. */
  totalRepositoryContributions: Scalars['Int']['output'];
  /** The user who made the contributions in this collection. */
  user: User;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectioncommitContributionsByRepositoryArgs = {
  maxRepositories?: InputMaybe<Scalars['Int']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionissueContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionissueContributionsByRepositoryArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
  maxRepositories?: InputMaybe<Scalars['Int']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionpullRequestContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionpullRequestContributionsByRepositoryArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
  maxRepositories?: InputMaybe<Scalars['Int']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionpullRequestReviewContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionpullRequestReviewContributionsByRepositoryArgs = {
  maxRepositories?: InputMaybe<Scalars['Int']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectionrepositoryContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectiontotalIssueContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectiontotalPullRequestContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectiontotalRepositoriesWithContributedIssuesArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectiontotalRepositoriesWithContributedPullRequestsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type ContributionsCollectiontotalRepositoryContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of ConvertProjectCardNoteToIssue */
export type ConvertProjectCardNoteToIssueInput = {
  /** The body of the newly created issue. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ProjectCard ID to convert. */
  projectCardId: Scalars['ID']['input'];
  /** The ID of the repository to create the issue in. */
  repositoryId: Scalars['ID']['input'];
  /** The title of the newly created issue. Defaults to the card's note text. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ConvertProjectCardNoteToIssue */
export type ConvertProjectCardNoteToIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated ProjectCard. */
  projectCard?: Maybe<ProjectCard>;
};

/** Autogenerated input type of ConvertPullRequestToDraft */
export type ConvertPullRequestToDraftInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to convert to draft */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of ConvertPullRequestToDraft */
export type ConvertPullRequestToDraftPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that is now a draft. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'convert_to_draft' event on a given pull request. */
export type ConvertToDraftEvent = Node & UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ConvertToDraftEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** The HTTP path for this convert to draft event. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this convert to draft event. */
  url: Scalars['URI']['output'];
};

/** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
export type ConvertedNoteToIssueEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ConvertedNoteToIssueEvent object */
  id: Scalars['ID']['output'];
  /** Project referenced by event. */
  project?: Maybe<Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<ProjectCard>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String']['output'];
};

/** Represents a 'converted_to_discussion' event on a given issue. */
export type ConvertedToDiscussionEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The discussion that the issue was converted into. */
  discussion?: Maybe<Discussion>;
  /** The Node ID of the ConvertedToDiscussionEvent object */
  id: Scalars['ID']['output'];
};

/** Autogenerated input type of CopyProjectV2 */
export type CopyProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Include draft issues in the new project */
  includeDraftIssues?: InputMaybe<Scalars['Boolean']['input']>;
  /** The owner ID of the new project. */
  ownerId: Scalars['ID']['input'];
  /** The ID of the source Project to copy. */
  projectId: Scalars['ID']['input'];
  /** The title of the project. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CopyProjectV2 */
export type CopyProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The copied project. */
  projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of CreateAttributionInvitation */
export type CreateAttributionInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the owner scoping the reattributable data. */
  ownerId: Scalars['ID']['input'];
  /** The Node ID of the account owning the data to reattribute. */
  sourceId: Scalars['ID']['input'];
  /** The Node ID of the account which may claim the data. */
  targetId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateAttributionInvitation */
export type CreateAttributionInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The owner scoping the reattributable data. */
  owner?: Maybe<Organization>;
  /** The account owning the data to reattribute. */
  source?: Maybe<Claimable>;
  /** The account which may claim the data. */
  target?: Maybe<Claimable>;
};

/** Autogenerated input type of CreateBranchProtectionRule */
export type CreateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is branch creation a protected operation. */
  blocksCreations?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */
  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */
  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Can admins override branch protection. */
  isAdminEnforced?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch?: InputMaybe<Scalars['Boolean']['input']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern: Scalars['String']['input'];
  /** A list of User, Team, or App IDs allowed to push to matching branches. */
  pushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The global relay id of the repository in which a new branch protection rule should be created in. */
  repositoryId: Scalars['ID']['input'];
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval?: InputMaybe<Scalars['Boolean']['input']>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']['input']>;
  /** The list of required deployment environments */
  requiredDeploymentEnvironments?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The list of required status checks */
  requiredStatusChecks?: InputMaybe<Array<RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are successful deployments required before merging. */
  requiresDeployments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of CreateBranchProtectionRule */
export type CreateBranchProtectionRulePayload = {
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateCheckRun */
export type CreateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: InputMaybe<Array<CheckRunAction>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The time that the check run finished. */
  completedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The final conclusion of the check. */
  conclusion?: InputMaybe<CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: InputMaybe<Scalars['URI']['input']>;
  /** A reference for the run on the integrator's system. */
  externalId?: InputMaybe<Scalars['String']['input']>;
  /** The SHA of the head commit. */
  headSha: Scalars['GitObjectID']['input'];
  /** The name of the check. */
  name: Scalars['String']['input'];
  /** Descriptive details about the run. */
  output?: InputMaybe<CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** The time that the check run began. */
  startedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The current status. */
  status?: InputMaybe<RequestableCheckStatusState>;
};

/** Autogenerated return type of CreateCheckRun */
export type CreateCheckRunPayload = {
  /** The newly created check run. */
  checkRun?: Maybe<CheckRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateCheckSuite */
export type CreateCheckSuiteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The SHA of the head commit. */
  headSha: Scalars['GitObjectID']['input'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateCheckSuite */
export type CreateCheckSuitePayload = {
  /** The newly created check suite. */
  checkSuite?: Maybe<CheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateCommitOnBranch */
export type CreateCommitOnBranchInput = {
  /** The Ref to be updated.  Must be a branch. */
  branch: CommittableBranch;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The git commit oid expected at the head of the branch prior to the commit */
  expectedHeadOid: Scalars['GitObjectID']['input'];
  /** A description of changes to files in this commit. */
  fileChanges?: InputMaybe<FileChanges>;
  /** The commit message the be included with the commit. */
  message: CommitMessage;
};

/** Autogenerated return type of CreateCommitOnBranch */
export type CreateCommitOnBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new commit. */
  commit?: Maybe<Commit>;
  /** The ref which has been updated to point to the new commit. */
  ref?: Maybe<Ref>;
};

/** Autogenerated input type of CreateDeployment */
export type CreateDeploymentInput = {
  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */
  autoMerge?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Short description of the deployment. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name for the target deployment environment. */
  environment?: InputMaybe<Scalars['String']['input']>;
  /** JSON payload with extra information about the deployment. */
  payload?: InputMaybe<Scalars['String']['input']>;
  /** The node ID of the ref to be deployed. */
  refId: Scalars['ID']['input'];
  /** The node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /**
   * The status contexts to verify against commit status checks. To bypass required
   * contexts, pass an empty array. Defaults to all unique contexts.
   */
  requiredContexts?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Specifies a task to execute. */
  task?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateDeployment */
export type CreateDeploymentPayload = {
  /** True if the default branch has been auto-merged into the deployment ref. */
  autoMerged?: Maybe<Scalars['Boolean']['output']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new deployment. */
  deployment?: Maybe<Deployment>;
};

/** Autogenerated input type of CreateDeploymentStatus */
export type CreateDeploymentStatusInput = {
  /**
   * Adds a new inactive status to all non-transient, non-production environment
   * deployments with the same repository and environment name as the created
   * status's deployment.
   */
  autoInactive?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The node ID of the deployment. */
  deploymentId: Scalars['ID']['input'];
  /** A short description of the status. Maximum length of 140 characters. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */
  environment?: InputMaybe<Scalars['String']['input']>;
  /** Sets the URL for accessing your environment. */
  environmentUrl?: InputMaybe<Scalars['String']['input']>;
  /**
   * The log URL to associate with this status.       This URL should contain
   * output to keep the user updated while the task is running       or serve as
   * historical information for what happened in the deployment.
   */
  logUrl?: InputMaybe<Scalars['String']['input']>;
  /** The state of the deployment. */
  state: DeploymentStatusState;
};

/** Autogenerated return type of CreateDeploymentStatus */
export type CreateDeploymentStatusPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new deployment status. */
  deploymentStatus?: Maybe<DeploymentStatus>;
};

/** Autogenerated input type of CreateDiscussion */
export type CreateDiscussionInput = {
  /** The body of the discussion. */
  body: Scalars['String']['input'];
  /** The id of the discussion category to associate with this discussion. */
  categoryId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the repository on which to create the discussion. */
  repositoryId: Scalars['ID']['input'];
  /** The title of the discussion. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateDiscussion */
export type CreateDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that was just created. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of CreateEnterpriseOrganization */
export type CreateEnterpriseOrganizationInput = {
  /** The logins for the administrators of the new organization. */
  adminLogins: Array<Scalars['String']['input']>;
  /** The email used for sending billing receipts. */
  billingEmail: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise owning the new organization. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of the new organization. */
  login: Scalars['String']['input'];
  /** The profile name of the new organization. */
  profileName: Scalars['String']['input'];
};

/** Autogenerated return type of CreateEnterpriseOrganization */
export type CreateEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise that owns the created organization. */
  enterprise?: Maybe<Enterprise>;
  /** The organization that was created. */
  organization?: Maybe<Organization>;
};

/** Autogenerated input type of CreateEnvironment */
export type CreateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the environment. */
  name: Scalars['String']['input'];
  /** The node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateEnvironment */
export type CreateEnvironmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new or existing environment. */
  environment?: Maybe<Environment>;
};

/** Autogenerated input type of CreateIpAllowListEntry */
export type CreateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean']['input'];
  /** An optional name for the IP allow list entry. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner for which to create the new IP allow list entry. */
  ownerId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateIpAllowListEntry */
export type CreateIpAllowListEntryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list entry that was created. */
  ipAllowListEntry?: Maybe<IpAllowListEntry>;
};

/** Autogenerated input type of CreateIssue */
export type CreateIssueInput = {
  /** The Node ID for the user assignee for this issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The body for the issue description. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */
  issueTemplate?: InputMaybe<Scalars['String']['input']>;
  /** An array of Node IDs of labels for this issue. */
  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: InputMaybe<Scalars['ID']['input']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** The title for the issue. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateIssue */
export type CreateIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new issue. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of CreateLabel */
export type CreateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A 6 character hex code, without the leading #, identifying the color of the label. */
  color: Scalars['String']['input'];
  /** A brief description of the label, such as its purpose. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the label. */
  name: Scalars['String']['input'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateLabel */
export type CreateLabelPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new label. */
  label?: Maybe<Label>;
};

/** Autogenerated input type of CreateLinkedBranch */
export type CreateLinkedBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue to link to. */
  issueId: Scalars['ID']['input'];
  /** The name of the new branch. Defaults to issue number and title. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The commit SHA to base the new branch on. */
  oid: Scalars['GitObjectID']['input'];
  /** ID of the repository to create the branch in. Defaults to the issue repository. */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of CreateLinkedBranch */
export type CreateLinkedBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was linked to. */
  issue?: Maybe<Issue>;
  /** The new branch issue reference. */
  linkedBranch?: Maybe<LinkedBranch>;
};

/** Autogenerated input type of CreateMigrationSource */
export type CreateMigrationSourceInput = {
  /** The migration source access token. */
  accessToken?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The GitHub personal access token of the user importing to the target repository. */
  githubPat?: InputMaybe<Scalars['String']['input']>;
  /** The migration source name. */
  name: Scalars['String']['input'];
  /** The ID of the organization that will own the migration source. */
  ownerId: Scalars['ID']['input'];
  /** The migration source type. */
  type: MigrationSourceType;
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateMigrationSource */
export type CreateMigrationSourcePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The created migration source. */
  migrationSource?: Maybe<MigrationSource>;
};

/** Autogenerated input type of CreateProject */
export type CreateProjectInput = {
  /** The description of project. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of project. */
  name: Scalars['String']['input'];
  /** The owner ID to create the project under. */
  ownerId: Scalars['ID']['input'];
  /** A list of repository IDs to create as linked repositories for the project */
  repositoryIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The name of the GitHub-provided template. */
  template?: InputMaybe<ProjectTemplate>;
};

/** Autogenerated return type of CreateProject */
export type CreateProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new project. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of CreateProjectV2Field */
export type CreateProjectV2FieldInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The data type of the field. */
  dataType: ProjectV2CustomFieldType;
  /** The name of the field. */
  name: Scalars['String']['input'];
  /** The ID of the Project to create the field in. */
  projectId: Scalars['ID']['input'];
  /** Options for a single select field. At least one value is required if data_type is SINGLE_SELECT */
  singleSelectOptions?: InputMaybe<Array<ProjectV2SingleSelectFieldOptionInput>>;
};

/** Autogenerated return type of CreateProjectV2Field */
export type CreateProjectV2FieldPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new field. */
  projectV2Field?: Maybe<ProjectV2FieldConfiguration>;
};

/** Autogenerated input type of CreateProjectV2 */
export type CreateProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The owner ID to create the project under. */
  ownerId: Scalars['ID']['input'];
  /** The repository to link the project to. */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  /** The team to link the project to. The team will be granted read permissions. */
  teamId?: InputMaybe<Scalars['ID']['input']>;
  /** The title of the project. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateProjectV2 */
export type CreateProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new project. */
  projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of CreatePullRequest */
export type CreatePullRequestInput = {
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository. You cannot update the base branch on a pull request to point
   * to another repository.
   */
  baseRefName: Scalars['String']['input'];
  /** The contents of the pull request. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether this pull request should be a draft. */
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The name of the branch where your changes are implemented. For cross-repository pull requests
   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.
   */
  headRefName: Scalars['String']['input'];
  /** The Node ID of the head repository. */
  headRepositoryId?: InputMaybe<Scalars['ID']['input']>;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** The title of the pull request. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CreatePullRequest */
export type CreatePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new pull request. */
  pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of CreateRef */
export type CreateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */
  name: Scalars['String']['input'];
  /** The GitObjectID that the new Ref shall target. Must point to a commit. */
  oid: Scalars['GitObjectID']['input'];
  /** The Node ID of the Repository to create the Ref in. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateRef */
export type CreateRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created ref. */
  ref?: Maybe<Ref>;
};

/** Autogenerated input type of CreateRepository */
export type CreateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A short description of the new repository. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The URL for a web page about this repository. */
  homepageUrl?: InputMaybe<Scalars['URI']['input']>;
  /** The name of the new repository. */
  name: Scalars['String']['input'];
  /** The ID of the owner for the new repository. */
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * When an organization is specified as the owner, this ID identifies the team
   * that should be granted access to the new repository.
   */
  teamId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates the repository's visibility level. */
  visibility: RepositoryVisibility;
};

/** Autogenerated return type of CreateRepository */
export type CreateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new repository. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of CreateRepositoryRuleset */
export type CreateRepositoryRulesetInput = {
  /** A list of actors that are allowed to bypass rules in this ruleset. */
  bypassActors?: InputMaybe<Array<RepositoryRulesetBypassActorInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The set of conditions for this ruleset */
  conditions: RepositoryRuleConditionsInput;
  /** The enforcement level for this ruleset */
  enforcement: RuleEnforcement;
  /** The name of the ruleset. */
  name: Scalars['String']['input'];
  /** The list of rules for this ruleset */
  rules?: InputMaybe<Array<RepositoryRuleInput>>;
  /** The global relay id of the source in which a new ruleset should be created in. */
  sourceId: Scalars['ID']['input'];
  /** The target of the ruleset. */
  target?: InputMaybe<RepositoryRulesetTarget>;
};

/** Autogenerated return type of CreateRepositoryRuleset */
export type CreateRepositoryRulesetPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created Ruleset. */
  ruleset?: Maybe<RepositoryRuleset>;
};

/** Autogenerated input type of CreateSponsorsListing */
export type CreateSponsorsListingInput = {
  /**
   * The country or region where the sponsorable's bank account is located.
   * Required if fiscalHostLogin is not specified, ignored when fiscalHostLogin is specified.
   */
  billingCountryOrRegionCode?: InputMaybe<SponsorsCountryOrRegionCode>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The email address we should use to contact you about the GitHub Sponsors
   * profile being created. This will not be shared publicly. Must be a verified
   * email address already on your GitHub account. Only relevant when the
   * sponsorable is yourself. Defaults to your primary email address on file if omitted.
   */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /**
   * The username of the supported fiscal host's GitHub organization, if you want
   * to receive sponsorship payouts through a fiscal host rather than directly to a
   * bank account. For example, 'Open-Source-Collective' for Open Source Collective
   * or 'numfocus' for numFOCUS. Case insensitive. See https://docs.github.com/sponsors/receiving-sponsorships-through-github-sponsors/using-a-fiscal-host-to-receive-github-sponsors-payouts
   * for more information.
   */
  fiscalHostLogin?: InputMaybe<Scalars['String']['input']>;
  /**
   * The URL for your profile page on the fiscal host's website, e.g.,
   * https://opencollective.com/babel or https://numfocus.org/project/bokeh.
   * Required if fiscalHostLogin is specified.
   */
  fiscallyHostedProjectProfileUrl?: InputMaybe<Scalars['String']['input']>;
  /**
   * Provide an introduction to serve as the main focus that appears on your GitHub
   * Sponsors profile. It's a great opportunity to help potential sponsors learn
   * more about you, your work, and why their sponsorship is important to you.
   * GitHub-flavored Markdown is supported.
   */
  fullDescription?: InputMaybe<Scalars['String']['input']>;
  /**
   * The country or region where the sponsorable resides. This is for tax purposes.
   * Required if the sponsorable is yourself, ignored when sponsorableLogin
   * specifies an organization.
   */
  residenceCountryOrRegionCode?: InputMaybe<SponsorsCountryOrRegionCode>;
  /**
   * The username of the organization to create a GitHub Sponsors profile for, if
   * desired. Defaults to creating a GitHub Sponsors profile for the authenticated
   * user if omitted.
   */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateSponsorsListing */
export type CreateSponsorsListingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new GitHub Sponsors profile. */
  sponsorsListing?: Maybe<SponsorsListing>;
};

/** Autogenerated input type of CreateSponsorsTier */
export type CreateSponsorsTierInput = {
  /** The value of the new tier in US dollars. Valid values: 1-12000. */
  amount: Scalars['Int']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A description of what this tier is, what perks sponsors might receive, what a sponsorship at this tier means for you, etc. */
  description: Scalars['String']['input'];
  /** Whether sponsorships using this tier should happen monthly/yearly or just once. */
  isRecurring?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether to make the tier available immediately for sponsors to choose.
   * Defaults to creating a draft tier that will not be publicly visible.
   */
  publish?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Optional ID of the private repository that sponsors at this tier should gain
   * read-only access to. Must be owned by an organization.
   */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Optional name of the private repository that sponsors at this tier should gain
   * read-only access to. Must be owned by an organization. Necessary if
   * repositoryOwnerLogin is given. Will be ignored if repositoryId is given.
   */
  repositoryName?: InputMaybe<Scalars['String']['input']>;
  /**
   * Optional login of the organization owner of the private repository that
   * sponsors at this tier should gain read-only access to. Necessary if
   * repositoryName is given. Will be ignored if repositoryId is given.
   */
  repositoryOwnerLogin?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the user or organization who owns the GitHub Sponsors profile.
   * Defaults to the current user if omitted and sponsorableLogin is not given.
   */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who owns the GitHub Sponsors profile.
   * Defaults to the current user if omitted and sponsorableId is not given.
   */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
  /** Optional message new sponsors at this tier will receive. */
  welcomeMessage?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateSponsorsTier */
export type CreateSponsorsTierPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new tier. */
  sponsorsTier?: Maybe<SponsorsTier>;
};

/** Autogenerated input type of CreateSponsorship */
export type CreateSponsorshipInput = {
  /** The amount to pay to the sponsorable in US dollars. Required if a tierId is not specified. Valid values: 1-12000. */
  amount?: InputMaybe<Scalars['Int']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether the sponsorship should happen monthly/yearly or just this one time. Required if a tierId is not specified. */
  isRecurring?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  privacyLevel?: InputMaybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of one of sponsorable's existing tiers to sponsor at. Required if amount is not specified. */
  tierId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of CreateSponsorship */
export type CreateSponsorshipPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The sponsorship that was started. */
  sponsorship?: Maybe<Sponsorship>;
};

/** Autogenerated input type of CreateSponsorships */
export type CreateSponsorshipsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorables. Public visibility still does not reveal the dollar value of
   * the sponsorship.
   */
  privacyLevel?: InputMaybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorables. */
  receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;
  /** The username of the user or organization who is acting as the sponsor, paying for the sponsorships. */
  sponsorLogin: Scalars['String']['input'];
  /** The list of maintainers to sponsor and for how much apiece. */
  sponsorships: Array<BulkSponsorship>;
};

/** Autogenerated return type of CreateSponsorships */
export type CreateSponsorshipsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The users and organizations who received a sponsorship. */
  sponsorables?: Maybe<Array<Sponsorable>>;
};

/** Autogenerated input type of CreateTeamDiscussionComment */
export type CreateTeamDiscussionCommentInput = {
  /**
   * The content of the comment. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `body` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the discussion to which the comment belongs. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `discussionId` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  discussionId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of CreateTeamDiscussionComment */
export type CreateTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * The new comment.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  teamDiscussionComment?: Maybe<TeamDiscussionComment>;
};

/** Autogenerated input type of CreateTeamDiscussion */
export type CreateTeamDiscussionInput = {
  /**
   * The content of the discussion. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `body` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * If true, restricts the visibility of this discussion to team members and
   * organization owners. If false or not specified, allows any organization member
   * to view this discussion.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `private` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  private?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ID of the team to which the discussion belongs. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `teamId` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  teamId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The title of the discussion. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `title` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateTeamDiscussion */
export type CreateTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * The new discussion.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  teamDiscussion?: Maybe<TeamDiscussion>;
};

/** Autogenerated input type of CreateUserList */
export type CreateUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A description of the list */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not the list is private */
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the new list */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of CreateUserList */
export type CreateUserListPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The list that was just created */
  list?: Maybe<UserList>;
  /** The user who created the list */
  viewer?: Maybe<User>;
};

/** Represents the contribution a user made by committing to a repository. */
export type CreatedCommitContribution = Contribution & {
  /** How many commits were made on this day to this repository by the user. */
  commitCount: Scalars['Int']['output'];
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The repository the user made a commit in. */
  repository: Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  user: User;
};

/** The connection type for CreatedCommitContribution. */
export type CreatedCommitContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CreatedCommitContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CreatedCommitContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of commits across days and repositories in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CreatedCommitContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CreatedCommitContribution>;
};

/** Represents the contribution a user made on GitHub by opening an issue. */
export type CreatedIssueContribution = Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** The issue that was opened. */
  issue: Issue;
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  user: User;
};

/** The connection type for CreatedIssueContribution. */
export type CreatedIssueContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CreatedIssueContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CreatedIssueContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CreatedIssueContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CreatedIssueContribution>;
};

/** Represents either a issue the viewer can access or a restricted contribution. */
export type CreatedIssueOrRestrictedContribution = CreatedIssueContribution | RestrictedContribution;

/** Represents the contribution a user made on GitHub by opening a pull request. */
export type CreatedPullRequestContribution = Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The pull request that was opened. */
  pullRequest: PullRequest;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  user: User;
};

/** The connection type for CreatedPullRequestContribution. */
export type CreatedPullRequestContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CreatedPullRequestContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CreatedPullRequestContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CreatedPullRequestContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CreatedPullRequestContribution>;
};

/** Represents either a pull request the viewer can access or a restricted contribution. */
export type CreatedPullRequestOrRestrictedContribution = CreatedPullRequestContribution | RestrictedContribution;

/** Represents the contribution a user made by leaving a review on a pull request. */
export type CreatedPullRequestReviewContribution = Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The pull request the user reviewed. */
  pullRequest: PullRequest;
  /** The review the user left on the pull request. */
  pullRequestReview: PullRequestReview;
  /** The repository containing the pull request that the user reviewed. */
  repository: Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  user: User;
};

/** The connection type for CreatedPullRequestReviewContribution. */
export type CreatedPullRequestReviewContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CreatedPullRequestReviewContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CreatedPullRequestReviewContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CreatedPullRequestReviewContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CreatedPullRequestReviewContribution>;
};

/** Represents the contribution a user made on GitHub by creating a repository. */
export type CreatedRepositoryContribution = Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The repository that was created. */
  repository: Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  user: User;
};

/** The connection type for CreatedRepositoryContribution. */
export type CreatedRepositoryContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CreatedRepositoryContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CreatedRepositoryContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CreatedRepositoryContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CreatedRepositoryContribution>;
};

/** Represents either a repository the viewer can access or a restricted contribution. */
export type CreatedRepositoryOrRestrictedContribution = CreatedRepositoryContribution | RestrictedContribution;

/** Represents a mention made by one issue or pull request to another. */
export type CrossReferencedEvent = Node & UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the CrossReferencedEvent object */
  id: Scalars['ID']['output'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean']['output'];
  /** Identifies when the reference was made. */
  referencedAt: Scalars['DateTime']['output'];
  /** The HTTP path for this pull request. */
  resourcePath: Scalars['URI']['output'];
  /** Issue or pull request that made the reference. */
  source: ReferencedSubject;
  /** Issue or pull request to which the reference was made. */
  target: ReferencedSubject;
  /** The HTTP URL for this pull request. */
  url: Scalars['URI']['output'];
  /** Checks if the target will be closed when the source is merged. */
  willCloseTarget: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeclineTopicSuggestion */
export type DeclineTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The name of the suggested topic.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `name` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  name?: InputMaybe<Scalars['String']['input']>;
  /**
   * The reason why the suggested topic is declined.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `reason` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  reason?: InputMaybe<TopicSuggestionDeclineReason>;
  /**
   * The Node ID of the repository.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `repositoryId` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of DeclineTopicSuggestion */
export type DeclineTopicSuggestionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * The declined topic.
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  topic?: Maybe<Topic>;
};

/** The possible base permissions for repositories. */
export type DefaultRepositoryPermissionField =
  /** Can read, write, and administrate repos by default */
  | 'ADMIN'
  /** No access */
  | 'NONE'
  /** Can read repos by default */
  | 'READ'
  /** Can read and write repos by default */
  | 'WRITE';

/** Entities that can be deleted. */
export type Deletable = {
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeleteBranchProtectionRule */
export type DeleteBranchProtectionRuleInput = {
  /** The global relay id of the branch protection rule to be deleted. */
  branchProtectionRuleId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DeleteBranchProtectionRule */
export type DeleteBranchProtectionRulePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteDeployment */
export type DeleteDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the deployment to be deleted. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteDeployment */
export type DeleteDeploymentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteDiscussionComment */
export type DeleteDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node id of the discussion comment to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteDiscussionComment */
export type DeleteDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion comment that was just deleted. */
  comment?: Maybe<DiscussionComment>;
};

/** Autogenerated input type of DeleteDiscussion */
export type DeleteDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the discussion to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteDiscussion */
export type DeleteDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that was just deleted. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of DeleteEnvironment */
export type DeleteEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the environment to be deleted. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteEnvironment */
export type DeleteEnvironmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteIpAllowListEntry */
export type DeleteIpAllowListEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the IP allow list entry to delete. */
  ipAllowListEntryId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteIpAllowListEntry */
export type DeleteIpAllowListEntryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list entry that was deleted. */
  ipAllowListEntry?: Maybe<IpAllowListEntry>;
};

/** Autogenerated input type of DeleteIssueComment */
export type DeleteIssueCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteIssueComment */
export type DeleteIssueCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteIssue */
export type DeleteIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the issue to delete. */
  issueId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteIssue */
export type DeleteIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository the issue belonged to */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of DeleteLabel */
export type DeleteLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the label to be deleted. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteLabel */
export type DeleteLabelPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteLinkedBranch */
export type DeleteLinkedBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the linked branch */
  linkedBranchId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteLinkedBranch */
export type DeleteLinkedBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue the linked branch was unlinked from. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of DeletePackageVersion */
export type DeletePackageVersionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the package version to be deleted. */
  packageVersionId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeletePackageVersion */
export type DeletePackageVersionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Whether or not the operation succeeded. */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Autogenerated input type of DeleteProjectCard */
export type DeleteProjectCardInput = {
  /** The id of the card to delete. */
  cardId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DeleteProjectCard */
export type DeleteProjectCardPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The column the deleted card was in. */
  column?: Maybe<ProjectColumn>;
  /** The deleted card ID. */
  deletedCardId?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DeleteProjectColumn */
export type DeleteProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the column to delete. */
  columnId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectColumn */
export type DeleteProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The deleted column ID. */
  deletedColumnId?: Maybe<Scalars['ID']['output']>;
  /** The project the deleted column was in. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of DeleteProject */
export type DeleteProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Project ID to update. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProject */
export type DeleteProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository or organization the project was removed from. */
  owner?: Maybe<ProjectOwner>;
};

/** Autogenerated input type of DeleteProjectV2Field */
export type DeleteProjectV2FieldInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the field to delete. */
  fieldId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectV2Field */
export type DeleteProjectV2FieldPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The deleted field. */
  projectV2Field?: Maybe<ProjectV2FieldConfiguration>;
};

/** Autogenerated input type of DeleteProjectV2 */
export type DeleteProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to delete. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteProjectV2Item */
export type DeleteProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the item to be removed. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project from which the item should be removed. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectV2Item */
export type DeleteProjectV2ItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The ID of the deleted item. */
  deletedItemId?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated return type of DeleteProjectV2 */
export type DeleteProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The deleted Project. */
  projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of DeleteProjectV2Workflow */
export type DeleteProjectV2WorkflowInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the workflow to be removed. */
  workflowId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectV2Workflow */
export type DeleteProjectV2WorkflowPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The ID of the deleted workflow. */
  deletedWorkflowId?: Maybe<Scalars['ID']['output']>;
  /** The project the deleted workflow was in. */
  projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of DeletePullRequestReviewComment */
export type DeletePullRequestReviewCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeletePullRequestReviewComment */
export type DeletePullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request review the deleted comment belonged to. */
  pullRequestReview?: Maybe<PullRequestReview>;
  /** The deleted pull request review comment. */
  pullRequestReviewComment?: Maybe<PullRequestReviewComment>;
};

/** Autogenerated input type of DeletePullRequestReview */
export type DeletePullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pull request review to delete. */
  pullRequestReviewId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeletePullRequestReview */
export type DeletePullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The deleted pull request review. */
  pullRequestReview?: Maybe<PullRequestReview>;
};

/** Autogenerated input type of DeleteRef */
export type DeleteRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the Ref to be deleted. */
  refId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteRef */
export type DeleteRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteRepositoryRuleset */
export type DeleteRepositoryRulesetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The global relay id of the repository ruleset to be deleted. */
  repositoryRulesetId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteRepositoryRuleset */
export type DeleteRepositoryRulesetPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteTeamDiscussionComment */
export type DeleteTeamDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteTeamDiscussionComment */
export type DeleteTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteTeamDiscussion */
export type DeleteTeamDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The discussion ID to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteTeamDiscussion */
export type DeleteTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteUserList */
export type DeleteUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the list to delete. */
  listId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteUserList */
export type DeleteUserListPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The owner of the list that will be deleted */
  user?: Maybe<User>;
};

/** Autogenerated input type of DeleteVerifiableDomain */
export type DeleteVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteVerifiableDomain */
export type DeleteVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The owning account from which the domain was deleted. */
  owner?: Maybe<VerifiableDomainOwner>;
};

/** Represents a 'demilestoned' event on a given issue or pull request. */
export type DemilestonedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the DemilestonedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the milestone title associated with the 'demilestoned' event. */
  milestoneTitle: Scalars['String']['output'];
  /** Object referenced by event. */
  subject: MilestoneItem;
};

/** A Dependabot Update for a dependency in a repository */
export type DependabotUpdate = RepositoryNode & {
  /** The error from a dependency update */
  error?: Maybe<DependabotUpdateError>;
  /** The associated pull request */
  pullRequest?: Maybe<PullRequest>;
  /** The repository associated with this node. */
  repository: Repository;
};

/** An error produced from a Dependabot Update */
export type DependabotUpdateError = {
  /** The body of the error */
  body: Scalars['String']['output'];
  /** The error code */
  errorType: Scalars['String']['output'];
  /** The title of the error */
  title: Scalars['String']['output'];
};

/** A dependency manifest entry */
export type DependencyGraphDependency = {
  /** Does the dependency itself have dependencies? */
  hasDependencies: Scalars['Boolean']['output'];
  /**
   * The original name of the package, as it appears in the manifest.
   * @deprecated `packageLabel` will be removed. Use normalized `packageName` field instead. Removal on 2022-10-01 UTC.
   */
  packageLabel: Scalars['String']['output'];
  /** The dependency package manager */
  packageManager?: Maybe<Scalars['String']['output']>;
  /** The name of the package in the canonical form used by the package manager. */
  packageName: Scalars['String']['output'];
  /** The repository containing the package */
  repository?: Maybe<Repository>;
  /** The dependency version requirements */
  requirements: Scalars['String']['output'];
};

/** The connection type for DependencyGraphDependency. */
export type DependencyGraphDependencyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyGraphDependencyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyGraphDependency>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DependencyGraphDependencyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyGraphDependency>;
};

/** The possible ecosystems of a dependency graph package. */
export type DependencyGraphEcosystem =
  /** GitHub Actions */
  | 'ACTIONS'
  /** PHP packages hosted at packagist.org */
  | 'COMPOSER'
  /** Go modules */
  | 'GO'
  /** Java artifacts hosted at the Maven central repository */
  | 'MAVEN'
  /** JavaScript packages hosted at npmjs.com */
  | 'NPM'
  /** .NET packages hosted at the NuGet Gallery */
  | 'NUGET'
  /** Python packages hosted at PyPI.org */
  | 'PIP'
  /** Dart packages hosted at pub.dev */
  | 'PUB'
  /** Ruby gems hosted at RubyGems.org */
  | 'RUBYGEMS'
  /** Rust crates */
  | 'RUST'
  /** Swift packages */
  | 'SWIFT';

/** Dependency manifest for a repository */
export type DependencyGraphManifest = Node & {
  /** Path to view the manifest file blob */
  blobPath: Scalars['String']['output'];
  /** A list of manifest dependencies */
  dependencies?: Maybe<DependencyGraphDependencyConnection>;
  /** The number of dependencies listed in the manifest */
  dependenciesCount?: Maybe<Scalars['Int']['output']>;
  /** Is the manifest too big to parse? */
  exceedsMaxSize: Scalars['Boolean']['output'];
  /** Fully qualified manifest filename */
  filename: Scalars['String']['output'];
  /** The Node ID of the DependencyGraphManifest object */
  id: Scalars['ID']['output'];
  /** Were we able to parse the manifest? */
  parseable: Scalars['Boolean']['output'];
  /** The repository containing the manifest */
  repository: Repository;
};


/** Dependency manifest for a repository */
export type DependencyGraphManifestdependenciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DependencyGraphManifest. */
export type DependencyGraphManifestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyGraphManifestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyGraphManifest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DependencyGraphManifestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyGraphManifest>;
};

/** A repository deploy key. */
export type DeployKey = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the DeployKey object */
  id: Scalars['ID']['output'];
  /** The deploy key. */
  key: Scalars['String']['output'];
  /** Whether or not the deploy key is read only. */
  readOnly: Scalars['Boolean']['output'];
  /** The deploy key title. */
  title: Scalars['String']['output'];
  /** Whether or not the deploy key has been verified. */
  verified: Scalars['Boolean']['output'];
};

/** The connection type for DeployKey. */
export type DeployKeyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeployKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DeployKey>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DeployKeyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DeployKey>;
};

/** Represents a 'deployed' event on a given pull request. */
export type DeployedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The deployment associated with the 'deployed' event. */
  deployment: Deployment;
  /** The Node ID of the DeployedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** The ref associated with the 'deployed' event. */
  ref?: Maybe<Ref>;
};

/** Represents triggered deployment instance. */
export type Deployment = Node & {
  /** Identifies the commit sha of the deployment. */
  commit?: Maybe<Commit>;
  /** Identifies the oid of the deployment commit, even if the commit has been deleted. */
  commitOid: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the actor who triggered the deployment. */
  creator: Actor;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The deployment description. */
  description?: Maybe<Scalars['String']['output']>;
  /** The latest environment to which this deployment was made. */
  environment?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the Deployment object */
  id: Scalars['ID']['output'];
  /** The latest environment to which this deployment was made. */
  latestEnvironment?: Maybe<Scalars['String']['output']>;
  /** The latest status of this deployment. */
  latestStatus?: Maybe<DeploymentStatus>;
  /** The original environment to which this deployment was made. */
  originalEnvironment?: Maybe<Scalars['String']['output']>;
  /** Extra information that a deployment system might need. */
  payload?: Maybe<Scalars['String']['output']>;
  /** Identifies the Ref of the deployment, if the deployment was created by ref. */
  ref?: Maybe<Ref>;
  /** Identifies the repository associated with the deployment. */
  repository: Repository;
  /** The current state of the deployment. */
  state?: Maybe<DeploymentState>;
  /** A list of statuses associated with the deployment. */
  statuses?: Maybe<DeploymentStatusConnection>;
  /** The deployment task. */
  task?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};


/** Represents triggered deployment instance. */
export type DeploymentstatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Deployment. */
export type DeploymentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Deployment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DeploymentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Deployment>;
};

/** Represents a 'deployment_environment_changed' event on a given pull request. */
export type DeploymentEnvironmentChangedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The deployment status that updated the deployment environment. */
  deploymentStatus: DeploymentStatus;
  /** The Node ID of the DeploymentEnvironmentChangedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** Ordering options for deployment connections */
export type DeploymentOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order deployments by. */
  field: DeploymentOrderField;
};

/** Properties by which deployment connections can be ordered. */
export type DeploymentOrderField =
  /** Order collection by creation time */
  | 'CREATED_AT';

/** A protection rule. */
export type DeploymentProtectionRule = {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** Whether deployments to this environment can be approved by the user who created the deployment. */
  preventSelfReview?: Maybe<Scalars['Boolean']['output']>;
  /** The teams or users that can review the deployment */
  reviewers: DeploymentReviewerConnection;
  /** The timeout in minutes for this protection rule. */
  timeout: Scalars['Int']['output'];
  /** The type of protection rule. */
  type: DeploymentProtectionRuleType;
};


/** A protection rule. */
export type DeploymentProtectionRulereviewersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DeploymentProtectionRule. */
export type DeploymentProtectionRuleConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentProtectionRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DeploymentProtectionRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DeploymentProtectionRuleEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DeploymentProtectionRule>;
};

/** The possible protection rule types. */
export type DeploymentProtectionRuleType =
  /** Required reviewers */
  | 'REQUIRED_REVIEWERS'
  /** Wait timer */
  | 'WAIT_TIMER';

/** A request to deploy a workflow run to an environment. */
export type DeploymentRequest = {
  /** Whether or not the current user can approve the deployment */
  currentUserCanApprove: Scalars['Boolean']['output'];
  /** The target environment of the deployment */
  environment: Environment;
  /** The teams or users that can review the deployment */
  reviewers: DeploymentReviewerConnection;
  /** The wait timer in minutes configured in the environment */
  waitTimer: Scalars['Int']['output'];
  /** The wait timer in minutes configured in the environment */
  waitTimerStartedAt?: Maybe<Scalars['DateTime']['output']>;
};


/** A request to deploy a workflow run to an environment. */
export type DeploymentRequestreviewersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DeploymentRequest. */
export type DeploymentRequestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DeploymentRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DeploymentRequestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DeploymentRequest>;
};

/** A deployment review. */
export type DeploymentReview = Node & {
  /** The comment the user left. */
  comment: Scalars['String']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The environments approved or rejected */
  environments: EnvironmentConnection;
  /** The Node ID of the DeploymentReview object */
  id: Scalars['ID']['output'];
  /** The decision of the user. */
  state: DeploymentReviewState;
  /** The user that reviewed the deployment. */
  user: User;
};


/** A deployment review. */
export type DeploymentReviewenvironmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DeploymentReview. */
export type DeploymentReviewConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentReviewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DeploymentReview>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DeploymentReviewEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DeploymentReview>;
};

/** The possible states for a deployment review. */
export type DeploymentReviewState =
  /** The deployment was approved. */
  | 'APPROVED'
  /** The deployment was rejected. */
  | 'REJECTED';

/** Users and teams. */
export type DeploymentReviewer = Team | User;

/** The connection type for DeploymentReviewer. */
export type DeploymentReviewerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentReviewerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DeploymentReviewer>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DeploymentReviewerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DeploymentReviewer>;
};

/** The possible states in which a deployment can be. */
export type DeploymentState =
  /** The pending deployment was not updated after 30 minutes. */
  | 'ABANDONED'
  /** The deployment is currently active. */
  | 'ACTIVE'
  /** An inactive transient deployment. */
  | 'DESTROYED'
  /** The deployment experienced an error. */
  | 'ERROR'
  /** The deployment has failed. */
  | 'FAILURE'
  /** The deployment is inactive. */
  | 'INACTIVE'
  /** The deployment is in progress. */
  | 'IN_PROGRESS'
  /** The deployment is pending. */
  | 'PENDING'
  /** The deployment has queued */
  | 'QUEUED'
  /** The deployment was successful. */
  | 'SUCCESS'
  /** The deployment is waiting. */
  | 'WAITING';

/** Describes the status of a given deployment attempt. */
export type DeploymentStatus = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the actor who triggered the deployment. */
  creator: Actor;
  /** Identifies the deployment associated with status. */
  deployment: Deployment;
  /** Identifies the description of the deployment. */
  description?: Maybe<Scalars['String']['output']>;
  /** Identifies the environment of the deployment at the time of this deployment status */
  environment?: Maybe<Scalars['String']['output']>;
  /** Identifies the environment URL of the deployment. */
  environmentUrl?: Maybe<Scalars['URI']['output']>;
  /** The Node ID of the DeploymentStatus object */
  id: Scalars['ID']['output'];
  /** Identifies the log URL of the deployment. */
  logUrl?: Maybe<Scalars['URI']['output']>;
  /** Identifies the current state of the deployment. */
  state: DeploymentStatusState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for DeploymentStatus. */
export type DeploymentStatusConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DeploymentStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DeploymentStatusEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DeploymentStatus>;
};

/** The possible states for a deployment status. */
export type DeploymentStatusState =
  /** The deployment experienced an error. */
  | 'ERROR'
  /** The deployment has failed. */
  | 'FAILURE'
  /** The deployment is inactive. */
  | 'INACTIVE'
  /** The deployment is in progress. */
  | 'IN_PROGRESS'
  /** The deployment is pending. */
  | 'PENDING'
  /** The deployment is queued */
  | 'QUEUED'
  /** The deployment was successful. */
  | 'SUCCESS'
  /** The deployment is waiting. */
  | 'WAITING';

/** Autogenerated input type of DequeuePullRequest */
export type DequeuePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the pull request to be dequeued. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DequeuePullRequest */
export type DequeuePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The merge queue entry of the dequeued pull request. */
  mergeQueueEntry?: Maybe<MergeQueueEntry>;
};

/** The possible sides of a diff. */
export type DiffSide =
  /** The left side of the diff. */
  | 'LEFT'
  /** The right side of the diff. */
  | 'RIGHT';

/** Autogenerated input type of DisablePullRequestAutoMerge */
export type DisablePullRequestAutoMergeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to disable auto merge on. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of DisablePullRequestAutoMerge */
export type DisablePullRequestAutoMergePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request auto merge was disabled on. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'disconnected' event on a given issue or pull request. */
export type DisconnectedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the DisconnectedEvent object */
  id: Scalars['ID']['output'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean']['output'];
  /** Issue or pull request from which the issue was disconnected. */
  source: ReferencedSubject;
  /** Issue or pull request which was disconnected. */
  subject: ReferencedSubject;
};

/** A discussion in a repository. */
export type Discussion = Closable & Comment & Deletable & Labelable & Lockable & Node & Reactable & RepositoryNode & Subscribable & Updatable & Votable & {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<LockReason>;
  /** The comment chosen as this discussion's answer, if any. */
  answer?: Maybe<DiscussionComment>;
  /** The time when a user chose this discussion's answer, if answered. */
  answerChosenAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user who chose this discussion's answer, if answered. */
  answerChosenBy?: Maybe<Actor>;
  /** The actor who authored the comment. */
  author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** The main text of the discussion post. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** The category for this discussion. */
  category: DiscussionCategory;
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The replies to the discussion. */
  comments: DiscussionCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Actor>;
  /** The Node ID of the Discussion object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Only return answered/unanswered discussions */
  isAnswered?: Maybe<Scalars['Boolean']['output']>;
  /** A list of labels associated with the object. */
  labels?: Maybe<LabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** `true` if the object is locked */
  locked: Scalars['Boolean']['output'];
  /** The number identifying this discussion within the repository. */
  number: Scalars['Int']['output'];
  /** The poll associated with this discussion, if one exists. */
  poll?: Maybe<DiscussionPoll>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** The repository associated with this node. */
  repository: Repository;
  /** The path for this discussion. */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the reason for the discussion's state. */
  stateReason?: Maybe<DiscussionStateReason>;
  /** The title of this discussion. */
  title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars['Int']['output'];
  /** The URL for this discussion. */
  url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<UserContentEditConnection>;
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars['Boolean']['output'];
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<SubscriptionState>;
};


/** A discussion in a repository. */
export type DiscussioncommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A discussion in a repository. */
export type DiscussionlabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LabelOrder>;
};


/** A discussion in a repository. */
export type DiscussionreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A discussion in a repository. */
export type DiscussionuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A category for discussions in a repository. */
export type DiscussionCategory = Node & RepositoryNode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** A description of this category. */
  description?: Maybe<Scalars['String']['output']>;
  /** An emoji representing this category. */
  emoji: Scalars['String']['output'];
  /** This category's emoji rendered as HTML. */
  emojiHTML: Scalars['HTML']['output'];
  /** The Node ID of the DiscussionCategory object */
  id: Scalars['ID']['output'];
  /** Whether or not discussions in this category support choosing an answer with the markDiscussionCommentAsAnswer mutation. */
  isAnswerable: Scalars['Boolean']['output'];
  /** The name of this category. */
  name: Scalars['String']['output'];
  /** The repository associated with this node. */
  repository: Repository;
  /** The slug of this category. */
  slug: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for DiscussionCategory. */
export type DiscussionCategoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionCategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscussionCategory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DiscussionCategoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DiscussionCategory>;
};

/** The possible reasons for closing a discussion. */
export type DiscussionCloseReason =
  /** The discussion is a duplicate of another */
  | 'DUPLICATE'
  /** The discussion is no longer relevant */
  | 'OUTDATED'
  /** The discussion has been resolved */
  | 'RESOLVED';

/** A comment on a discussion. */
export type DiscussionComment = Comment & Deletable & Minimizable & Node & Reactable & Updatable & UpdatableComment & Votable & {
  /** The actor who authored the comment. */
  author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The time when this replied-to comment was deleted */
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The discussion this comment was created in */
  discussion?: Maybe<Discussion>;
  /** The actor who edited the comment. */
  editor?: Maybe<Actor>;
  /** The Node ID of the DiscussionComment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Has this comment been chosen as the answer of its discussion? */
  isAnswer: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** The threaded replies to this comment. */
  replies: DiscussionCommentConnection;
  /** The discussion comment this comment is a reply to */
  replyTo?: Maybe<DiscussionComment>;
  /** The path for this discussion comment. */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars['Int']['output'];
  /** The URL for this discussion comment. */
  url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Can the current user mark this comment as an answer? */
  viewerCanMarkAsAnswer: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Can the current user unmark this comment as an answer? */
  viewerCanUnmarkAsAnswer: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars['Boolean']['output'];
};


/** A comment on a discussion. */
export type DiscussionCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A comment on a discussion. */
export type DiscussionCommentrepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A comment on a discussion. */
export type DiscussionCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DiscussionComment. */
export type DiscussionCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscussionComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DiscussionCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DiscussionComment>;
};

/** The connection type for Discussion. */
export type DiscussionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Discussion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DiscussionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Discussion>;
};

/** Ways in which lists of discussions can be ordered upon return. */
export type DiscussionOrder = {
  /** The direction in which to order discussions by the specified field. */
  direction: OrderDirection;
  /** The field by which to order discussions. */
  field: DiscussionOrderField;
};

/** Properties by which discussion connections can be ordered. */
export type DiscussionOrderField =
  /** Order discussions by creation time. */
  | 'CREATED_AT'
  /** Order discussions by most recent modification time. */
  | 'UPDATED_AT';

/** A poll for a discussion. */
export type DiscussionPoll = Node & {
  /** The discussion that this poll belongs to. */
  discussion?: Maybe<Discussion>;
  /** The Node ID of the DiscussionPoll object */
  id: Scalars['ID']['output'];
  /** The options for this poll. */
  options?: Maybe<DiscussionPollOptionConnection>;
  /** The question that is being asked by this poll. */
  question: Scalars['String']['output'];
  /** The total number of votes that have been cast for this poll. */
  totalVoteCount: Scalars['Int']['output'];
  /** Indicates if the viewer has permission to vote in this poll. */
  viewerCanVote: Scalars['Boolean']['output'];
  /** Indicates if the viewer has voted for any option in this poll. */
  viewerHasVoted: Scalars['Boolean']['output'];
};


/** A poll for a discussion. */
export type DiscussionPolloptionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DiscussionPollOptionOrder>;
};

/** An option for a discussion poll. */
export type DiscussionPollOption = Node & {
  /** The Node ID of the DiscussionPollOption object */
  id: Scalars['ID']['output'];
  /** The text for this option. */
  option: Scalars['String']['output'];
  /** The discussion poll that this option belongs to. */
  poll?: Maybe<DiscussionPoll>;
  /** The total number of votes that have been cast for this option. */
  totalVoteCount: Scalars['Int']['output'];
  /** Indicates if the viewer has voted for this option in the poll. */
  viewerHasVoted: Scalars['Boolean']['output'];
};

/** The connection type for DiscussionPollOption. */
export type DiscussionPollOptionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionPollOptionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscussionPollOption>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DiscussionPollOptionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<DiscussionPollOption>;
};

/** Ordering options for discussion poll option connections. */
export type DiscussionPollOptionOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order poll options by. */
  field: DiscussionPollOptionOrderField;
};

/** Properties by which discussion poll option connections can be ordered. */
export type DiscussionPollOptionOrderField =
  /** Order poll options by the order that the poll author specified when creating the poll. */
  | 'AUTHORED_ORDER'
  /** Order poll options by the number of votes it has. */
  | 'VOTE_COUNT';

/** The possible states of a discussion. */
export type DiscussionState =
  /** A discussion that has been closed */
  | 'CLOSED'
  /** A discussion that is open */
  | 'OPEN';

/** The possible state reasons of a discussion. */
export type DiscussionStateReason =
  /** The discussion is a duplicate of another */
  | 'DUPLICATE'
  /** The discussion is no longer relevant */
  | 'OUTDATED'
  /** The discussion was reopened */
  | 'REOPENED'
  /** The discussion has been resolved */
  | 'RESOLVED';

/** Autogenerated input type of DismissPullRequestReview */
export type DismissPullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The contents of the pull request review dismissal message. */
  message: Scalars['String']['input'];
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID']['input'];
};

/** Autogenerated return type of DismissPullRequestReview */
export type DismissPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The dismissed pull request review. */
  pullRequestReview?: Maybe<PullRequestReview>;
};

/** The possible reasons that a Dependabot alert was dismissed. */
export type DismissReason =
  /** A fix has already been started */
  | 'FIX_STARTED'
  /** This alert is inaccurate or incorrect */
  | 'INACCURATE'
  /** Vulnerable code is not actually used */
  | 'NOT_USED'
  /** No bandwidth to fix this */
  | 'NO_BANDWIDTH'
  /** Risk is tolerable to this project */
  | 'TOLERABLE_RISK';

/** Autogenerated input type of DismissRepositoryVulnerabilityAlert */
export type DismissRepositoryVulnerabilityAlertInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The reason the Dependabot alert is being dismissed. */
  dismissReason: DismissReason;
  /** The Dependabot alert ID to dismiss. */
  repositoryVulnerabilityAlertId: Scalars['ID']['input'];
};

/** Autogenerated return type of DismissRepositoryVulnerabilityAlert */
export type DismissRepositoryVulnerabilityAlertPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The Dependabot alert that was dismissed */
  repositoryVulnerabilityAlert?: Maybe<RepositoryVulnerabilityAlert>;
};

/** A draft issue within a project. */
export type DraftIssue = Node & {
  /** A list of users to assigned to this draft issue. */
  assignees: UserConnection;
  /** The body of the draft issue. */
  body: Scalars['String']['output'];
  /** The body of the draft issue rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** The body of the draft issue rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created this draft issue. */
  creator?: Maybe<Actor>;
  /** The Node ID of the DraftIssue object */
  id: Scalars['ID']['output'];
  /** List of items linked with the draft issue (currently draft issue can be linked to only one item). */
  projectV2Items: ProjectV2ItemConnection;
  /** Projects that link to this draft issue (currently draft issue can be linked to only one project). */
  projectsV2: ProjectV2Connection;
  /** The title of the draft issue */
  title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};


/** A draft issue within a project. */
export type DraftIssueassigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A draft issue within a project. */
export type DraftIssueprojectV2ItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A draft issue within a project. */
export type DraftIssueprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Specifies a review comment to be left with a Pull Request Review. */
export type DraftPullRequestReviewComment = {
  /** Body of the comment to leave. */
  body: Scalars['String']['input'];
  /** Path to the file being commented on. */
  path: Scalars['String']['input'];
  /** Position in the file to leave a comment on. */
  position: Scalars['Int']['input'];
};

/** Specifies a review comment thread to be left with a Pull Request Review. */
export type DraftPullRequestReviewThread = {
  /** Body of the comment to leave. */
  body: Scalars['String']['input'];
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  line: Scalars['Int']['input'];
  /** Path to the file being commented on. */
  path: Scalars['String']['input'];
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: InputMaybe<DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: InputMaybe<Scalars['Int']['input']>;
  /** The side of the diff on which the start line resides. */
  startSide?: InputMaybe<DiffSide>;
};

/** Autogenerated input type of EnablePullRequestAutoMerge */
export type EnablePullRequestAutoMergeInput = {
  /** The email address to associate with this merge. */
  authorEmail?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Commit body to use for the commit when the PR is mergable; if omitted, a
   * default message will be used. NOTE: when merging with a merge queue any input
   * value for commit message is ignored.
   */
  commitBody?: InputMaybe<Scalars['String']['input']>;
  /**
   * Commit headline to use for the commit when the PR is mergable; if omitted, a
   * default message will be used. NOTE: when merging with a merge queue any input
   * value for commit headline is ignored.
   */
  commitHeadline?: InputMaybe<Scalars['String']['input']>;
  /** The expected head OID of the pull request. */
  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /**
   * The merge method to use. If omitted, defaults to `MERGE`. NOTE: when merging
   * with a merge queue any input value for merge method is ignored.
   */
  mergeMethod?: InputMaybe<PullRequestMergeMethod>;
  /** ID of the pull request to enable auto-merge on. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of EnablePullRequestAutoMerge */
export type EnablePullRequestAutoMergePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request auto-merge was enabled on. */
  pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of EnqueuePullRequest */
export type EnqueuePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The expected head OID of the pull request. */
  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** Add the pull request to the front of the queue. */
  jump?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the pull request to enqueue. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of EnqueuePullRequest */
export type EnqueuePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The merge queue entry for the enqueued pull request. */
  mergeQueueEntry?: Maybe<MergeQueueEntry>;
};

/** An account to manage multiple organizations with consolidated policy and billing. */
export type Enterprise = AnnouncementBanner & Node & {
  /** The text of the announcement */
  announcement?: Maybe<Scalars['String']['output']>;
  /** The expiration date of the announcement, if any */
  announcementExpiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether the announcement can be dismissed by the user */
  announcementUserDismissible?: Maybe<Scalars['Boolean']['output']>;
  /** A URL pointing to the enterprise's public avatar. */
  avatarUrl: Scalars['URI']['output'];
  /** Enterprise billing information visible to enterprise billing managers. */
  billingInfo?: Maybe<EnterpriseBillingInfo>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The description of the enterprise. */
  description?: Maybe<Scalars['String']['output']>;
  /** The description of the enterprise as HTML. */
  descriptionHTML: Scalars['HTML']['output'];
  /** The Node ID of the Enterprise object */
  id: Scalars['ID']['output'];
  /** The location of the enterprise. */
  location?: Maybe<Scalars['String']['output']>;
  /** A list of users who are members of this enterprise. */
  members: EnterpriseMemberConnection;
  /** The name of the enterprise. */
  name: Scalars['String']['output'];
  /** A list of organizations that belong to this enterprise. */
  organizations: OrganizationConnection;
  /**
   * Enterprise information visible to enterprise owners or enterprise owners'
   * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
   */
  ownerInfo?: Maybe<EnterpriseOwnerInfo>;
  /** The HTTP path for this enterprise. */
  resourcePath: Scalars['URI']['output'];
  /** The URL-friendly identifier for the enterprise. */
  slug: Scalars['String']['output'];
  /** The HTTP URL for this enterprise. */
  url: Scalars['URI']['output'];
  /** Is the current viewer an admin of this enterprise? */
  viewerIsAdmin: Scalars['Boolean']['output'];
  /** The URL of the enterprise website. */
  websiteUrl?: Maybe<Scalars['URI']['output']>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type EnterpriseavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type EnterprisemembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deployment?: InputMaybe<EnterpriseUserDeployment>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type EnterpriseorganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  viewerOrganizationRole?: InputMaybe<RoleInOrganization>;
};

/** The connection type for User. */
export type EnterpriseAdministratorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseAdministratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A User who is an administrator of an enterprise. */
export type EnterpriseAdministratorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
  /** The role of the administrator. */
  role: EnterpriseAdministratorRole;
};

/** An invitation for a user to become an owner or billing manager of an enterprise. */
export type EnterpriseAdministratorInvitation = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The email of the person who was invited to the enterprise. */
  email?: Maybe<Scalars['String']['output']>;
  /** The enterprise the invitation is for. */
  enterprise: Enterprise;
  /** The Node ID of the EnterpriseAdministratorInvitation object */
  id: Scalars['ID']['output'];
  /** The user who was invited to the enterprise. */
  invitee?: Maybe<User>;
  /** The user who created the invitation. */
  inviter?: Maybe<User>;
  /** The invitee's pending role in the enterprise (owner or billing_manager). */
  role: EnterpriseAdministratorRole;
};

/** The connection type for EnterpriseAdministratorInvitation. */
export type EnterpriseAdministratorInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseAdministratorInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseAdministratorInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type EnterpriseAdministratorInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseAdministratorInvitation>;
};

/** Ordering options for enterprise administrator invitation connections */
export type EnterpriseAdministratorInvitationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprise administrator invitations by. */
  field: EnterpriseAdministratorInvitationOrderField;
};

/** Properties by which enterprise administrator invitation connections can be ordered. */
export type EnterpriseAdministratorInvitationOrderField =
  /** Order enterprise administrator member invitations by creation time */
  | 'CREATED_AT';

/** The possible administrator roles in an enterprise account. */
export type EnterpriseAdministratorRole =
  /** Represents a billing manager of the enterprise account. */
  | 'BILLING_MANAGER'
  /** Represents an owner of the enterprise account. */
  | 'OWNER';

/** The possible values for the enterprise allow private repository forking policy value. */
export type EnterpriseAllowPrivateRepositoryForkingPolicyValue =
  /** Members can fork a repository to an organization within this enterprise. */
  | 'ENTERPRISE_ORGANIZATIONS'
  /** Members can fork a repository to their enterprise-managed user account or an organization inside this enterprise. */
  | 'ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS'
  /** Members can fork a repository to their user account or an organization, either inside or outside of this enterprise. */
  | 'EVERYWHERE'
  /** Members can fork a repository only within the same organization (intra-org). */
  | 'SAME_ORGANIZATION'
  /** Members can fork a repository to their user account or within the same organization. */
  | 'SAME_ORGANIZATION_USER_ACCOUNTS'
  /** Members can fork a repository to their user account. */
  | 'USER_ACCOUNTS';

/** Metadata for an audit entry containing enterprise account information. */
export type EnterpriseAuditEntryData = {
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']['output']>;
};

/** Enterprise billing information visible to enterprise billing managers and owners. */
export type EnterpriseBillingInfo = {
  /** The number of licenseable users/emails across the enterprise. */
  allLicensableUsersCount: Scalars['Int']['output'];
  /** The number of data packs used by all organizations owned by the enterprise. */
  assetPacks: Scalars['Int']['output'];
  /** The bandwidth quota in GB for all organizations owned by the enterprise. */
  bandwidthQuota: Scalars['Float']['output'];
  /** The bandwidth usage in GB for all organizations owned by the enterprise. */
  bandwidthUsage: Scalars['Float']['output'];
  /** The bandwidth usage as a percentage of the bandwidth quota. */
  bandwidthUsagePercentage: Scalars['Int']['output'];
  /** The storage quota in GB for all organizations owned by the enterprise. */
  storageQuota: Scalars['Float']['output'];
  /** The storage usage in GB for all organizations owned by the enterprise. */
  storageUsage: Scalars['Float']['output'];
  /** The storage usage as a percentage of the storage quota. */
  storageUsagePercentage: Scalars['Int']['output'];
  /** The number of available licenses across all owned organizations based on the unique number of billable users. */
  totalAvailableLicenses: Scalars['Int']['output'];
  /** The total number of licenses allocated. */
  totalLicenses: Scalars['Int']['output'];
};

/** The connection type for Enterprise. */
export type EnterpriseConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Enterprise>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The possible values for the enterprise base repository permission setting. */
export type EnterpriseDefaultRepositoryPermissionSettingValue =
  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */
  | 'ADMIN'
  /** Organization members will only be able to clone and pull public repositories. */
  | 'NONE'
  /** Organizations in the enterprise choose base repository permissions for their members. */
  | 'NO_POLICY'
  /** Organization members will be able to clone and pull all organization repositories. */
  | 'READ'
  /** Organization members will be able to clone, pull, and push all organization repositories. */
  | 'WRITE';

/** An edge in a connection. */
export type EnterpriseEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Enterprise>;
};

/** The possible values for an enabled/disabled enterprise setting. */
export type EnterpriseEnabledDisabledSettingValue =
  /** The setting is disabled for organizations in the enterprise. */
  | 'DISABLED'
  /** The setting is enabled for organizations in the enterprise. */
  | 'ENABLED'
  /** There is no policy set for organizations in the enterprise. */
  | 'NO_POLICY';

/** The possible values for an enabled/no policy enterprise setting. */
export type EnterpriseEnabledSettingValue =
  /** The setting is enabled for organizations in the enterprise. */
  | 'ENABLED'
  /** There is no policy set for organizations in the enterprise. */
  | 'NO_POLICY';

/** The connection type for OrganizationInvitation. */
export type EnterpriseFailedInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseFailedInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /** Identifies the total count of unique users in the connection. */
  totalUniqueUserCount: Scalars['Int']['output'];
};

/** A failed invitation to be a member in an enterprise organization. */
export type EnterpriseFailedInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<OrganizationInvitation>;
};

/**
 * An identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseIdentityProvider = Node & {
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod?: Maybe<SamlDigestAlgorithm>;
  /** The enterprise this identity provider belongs to. */
  enterprise?: Maybe<Enterprise>;
  /** ExternalIdentities provisioned by this identity provider. */
  externalIdentities: ExternalIdentityConnection;
  /** The Node ID of the EnterpriseIdentityProvider object */
  id: Scalars['ID']['output'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars['X509Certificate']['output']>;
  /** The Issuer Entity ID for the SAML identity provider. */
  issuer?: Maybe<Scalars['String']['output']>;
  /** Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable. */
  recoveryCodes?: Maybe<Array<Scalars['String']['output']>>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod?: Maybe<SamlSignatureAlgorithm>;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars['URI']['output']>;
};


/**
 * An identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseIdentityProviderexternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  membersOnly?: InputMaybe<Scalars['Boolean']['input']>;
  userName?: InputMaybe<Scalars['String']['input']>;
};

/** An object that is a member of an enterprise. */
export type EnterpriseMember = EnterpriseUserAccount | User;

/** The connection type for EnterpriseMember. */
export type EnterpriseMemberConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseMember>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A User who is a member of an enterprise through one or more organizations. */
export type EnterpriseMemberEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseMember>;
};

/** Ordering options for enterprise member connections. */
export type EnterpriseMemberOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprise members by. */
  field: EnterpriseMemberOrderField;
};

/** Properties by which enterprise member connections can be ordered. */
export type EnterpriseMemberOrderField =
  /** Order enterprise members by creation time */
  | 'CREATED_AT'
  /** Order enterprise members by login */
  | 'LOGIN';

/** The possible values for the enterprise members can create repositories setting. */
export type EnterpriseMembersCanCreateRepositoriesSettingValue =
  /** Members will be able to create public and private repositories. */
  | 'ALL'
  /** Members will not be able to create public or private repositories. */
  | 'DISABLED'
  /** Organization owners choose whether to allow members to create repositories. */
  | 'NO_POLICY'
  /** Members will be able to create only private repositories. */
  | 'PRIVATE'
  /** Members will be able to create only public repositories. */
  | 'PUBLIC';

/** The possible values for the members can make purchases setting. */
export type EnterpriseMembersCanMakePurchasesSettingValue =
  /** The setting is disabled for organizations in the enterprise. */
  | 'DISABLED'
  /** The setting is enabled for organizations in the enterprise. */
  | 'ENABLED';

/** The possible values we have for filtering Platform::Objects::User#enterprises. */
export type EnterpriseMembershipType =
  /** Returns all enterprises in which the user is an admin. */
  | 'ADMIN'
  /** Returns all enterprises in which the user is a member, admin, or billing manager. */
  | 'ALL'
  /** Returns all enterprises in which the user is a billing manager. */
  | 'BILLING_MANAGER'
  /** Returns all enterprises in which the user is a member of an org that is owned by the enterprise. */
  | 'ORG_MEMBERSHIP';

/** Ordering options for enterprises. */
export type EnterpriseOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprises by. */
  field: EnterpriseOrderField;
};

/** Properties by which enterprise connections can be ordered. */
export type EnterpriseOrderField =
  /** Order enterprises by name */
  | 'NAME';

/** The connection type for Organization. */
export type EnterpriseOrganizationMembershipConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseOrganizationMembershipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Organization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An enterprise organization that a user is a member of. */
export type EnterpriseOrganizationMembershipEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Organization>;
  /** The role of the user in the enterprise membership. */
  role: EnterpriseUserAccountMembershipRole;
};

/** The connection type for User. */
export type EnterpriseOutsideCollaboratorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseOutsideCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type EnterpriseOutsideCollaboratorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
  /** The enterprise organization repositories this user is a member of. */
  repositories: EnterpriseRepositoryInfoConnection;
};


/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type EnterpriseOutsideCollaboratorEdgerepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfo = {
  /** A list of all of the administrators for this enterprise. */
  admins: EnterpriseAdministratorConnection;
  /** A list of users in the enterprise who currently have two-factor authentication disabled. */
  affiliatedUsersWithTwoFactorDisabled: UserConnection;
  /** Whether or not affiliated users with two-factor authentication disabled exist in the enterprise. */
  affiliatedUsersWithTwoFactorDisabledExist: Scalars['Boolean']['output'];
  /** The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise. */
  allowPrivateRepositoryForkingSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided private repository forking setting value. */
  allowPrivateRepositoryForkingSettingOrganizations: OrganizationConnection;
  /** The value for the allow private repository forking policy on the enterprise. */
  allowPrivateRepositoryForkingSettingPolicyValue?: Maybe<EnterpriseAllowPrivateRepositoryForkingPolicyValue>;
  /** The setting value for base repository permissions for organizations in this enterprise. */
  defaultRepositoryPermissionSetting: EnterpriseDefaultRepositoryPermissionSettingValue;
  /** A list of enterprise organizations configured with the provided base repository permission. */
  defaultRepositoryPermissionSettingOrganizations: OrganizationConnection;
  /**
   * A list of domains owned by the enterprise. Visible to enterprise owners or
   * enterprise owners' personal access tokens (classic) with admin:enterprise scope.
   */
  domains: VerifiableDomainConnection;
  /** Enterprise Server installations owned by the enterprise. */
  enterpriseServerInstallations: EnterpriseServerInstallationConnection;
  /** A list of failed invitations in the enterprise. */
  failedInvitations: EnterpriseFailedInvitationConnection;
  /** The setting value for whether the enterprise has an IP allow list enabled. */
  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;
  /**
   * The IP addresses that are allowed to access resources owned by the enterprise.
   * Visible to enterprise owners or enterprise owners' personal access tokens
   * (classic) with admin:enterprise scope.
   */
  ipAllowListEntries: IpAllowListEntryConnection;
  /** The setting value for whether the enterprise has IP allow list configuration for installed GitHub Apps enabled. */
  ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue;
  /** Whether or not the base repository permission is currently being updated. */
  isUpdatingDefaultRepositoryPermission: Scalars['Boolean']['output'];
  /** Whether the two-factor authentication requirement is currently being enforced. */
  isUpdatingTwoFactorRequirement: Scalars['Boolean']['output'];
  /**
   * The setting value for whether organization members with admin permissions on a
   * repository can change repository visibility.
   */
  membersCanChangeRepositoryVisibilitySetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided can change repository visibility setting value. */
  membersCanChangeRepositoryVisibilitySettingOrganizations: OrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can create internal repositories. */
  membersCanCreateInternalRepositoriesSetting?: Maybe<Scalars['Boolean']['output']>;
  /** The setting value for whether members of organizations in the enterprise can create private repositories. */
  membersCanCreatePrivateRepositoriesSetting?: Maybe<Scalars['Boolean']['output']>;
  /** The setting value for whether members of organizations in the enterprise can create public repositories. */
  membersCanCreatePublicRepositoriesSetting?: Maybe<Scalars['Boolean']['output']>;
  /** The setting value for whether members of organizations in the enterprise can create repositories. */
  membersCanCreateRepositoriesSetting?: Maybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;
  /** A list of enterprise organizations configured with the provided repository creation setting value. */
  membersCanCreateRepositoriesSettingOrganizations: OrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete issues. */
  membersCanDeleteIssuesSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete issues setting value. */
  membersCanDeleteIssuesSettingOrganizations: OrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete or transfer repositories. */
  membersCanDeleteRepositoriesSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete repositories setting value. */
  membersCanDeleteRepositoriesSettingOrganizations: OrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can invite outside collaborators. */
  membersCanInviteCollaboratorsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can invite collaborators setting value. */
  membersCanInviteCollaboratorsSettingOrganizations: OrganizationConnection;
  /** Indicates whether members of this enterprise's organizations can purchase additional services for those organizations. */
  membersCanMakePurchasesSetting: EnterpriseMembersCanMakePurchasesSettingValue;
  /** The setting value for whether members with admin permissions for repositories can update protected branches. */
  membersCanUpdateProtectedBranchesSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can update protected branches setting value. */
  membersCanUpdateProtectedBranchesSettingOrganizations: OrganizationConnection;
  /** The setting value for whether members can view dependency insights. */
  membersCanViewDependencyInsightsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can view dependency insights setting value. */
  membersCanViewDependencyInsightsSettingOrganizations: OrganizationConnection;
  /** Indicates if email notification delivery for this enterprise is restricted to verified or approved domains. */
  notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue;
  /** The OIDC Identity Provider for the enterprise. */
  oidcProvider?: Maybe<OIDCProvider>;
  /** The setting value for whether organization projects are enabled for organizations in this enterprise. */
  organizationProjectsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided organization projects setting value. */
  organizationProjectsSettingOrganizations: OrganizationConnection;
  /** A list of outside collaborators across the repositories in the enterprise. */
  outsideCollaborators: EnterpriseOutsideCollaboratorConnection;
  /** A list of pending administrator invitations for the enterprise. */
  pendingAdminInvitations: EnterpriseAdministratorInvitationConnection;
  /** A list of pending collaborator invitations across the repositories in the enterprise. */
  pendingCollaboratorInvitations: RepositoryInvitationConnection;
  /** A list of pending member invitations for organizations in the enterprise. */
  pendingMemberInvitations: EnterprisePendingMemberInvitationConnection;
  /** The setting value for whether repository projects are enabled in this enterprise. */
  repositoryProjectsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided repository projects setting value. */
  repositoryProjectsSettingOrganizations: OrganizationConnection;
  /** The SAML Identity Provider for the enterprise. */
  samlIdentityProvider?: Maybe<EnterpriseIdentityProvider>;
  /** A list of enterprise organizations configured with the SAML single sign-on setting value. */
  samlIdentityProviderSettingOrganizations: OrganizationConnection;
  /** A list of members with a support entitlement. */
  supportEntitlements: EnterpriseMemberConnection;
  /** The setting value for whether team discussions are enabled for organizations in this enterprise. */
  teamDiscussionsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided team discussions setting value. */
  teamDiscussionsSettingOrganizations: OrganizationConnection;
  /** The setting value for whether the enterprise requires two-factor authentication for its organizations and users. */
  twoFactorRequiredSetting: EnterpriseEnabledSettingValue;
  /** A list of enterprise organizations configured with the two-factor authentication setting value. */
  twoFactorRequiredSettingOrganizations: OrganizationConnection;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoadminsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<EnterpriseAdministratorRole>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoaffiliatedUsersWithTwoFactorDisabledArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoallowPrivateRepositoryForkingSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfodefaultRepositoryPermissionSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: DefaultRepositoryPermissionField;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfodomainsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  isApproved?: InputMaybe<Scalars['Boolean']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<VerifiableDomainOrder>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoenterpriseServerInstallationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  connectedOnly?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseServerInstallationOrder>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfofailedInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoipAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IpAllowListEntryOrder>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfomembersCanChangeRepositoryVisibilitySettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfomembersCanCreateRepositoriesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: OrganizationMembersCanCreateRepositoriesSettingValue;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfomembersCanDeleteIssuesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfomembersCanDeleteRepositoriesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfomembersCanInviteCollaboratorsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfomembersCanUpdateProtectedBranchesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfomembersCanViewDependencyInsightsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoorganizationProjectsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfooutsideCollaboratorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
  visibility?: InputMaybe<RepositoryVisibility>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfopendingAdminInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseAdministratorInvitationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<EnterpriseAdministratorRole>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfopendingCollaboratorInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryInvitationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfopendingMemberInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  invitationSource?: InputMaybe<OrganizationInvitationSource>;
  last?: InputMaybe<Scalars['Int']['input']>;
  organizationLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInforepositoryProjectsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfosamlIdentityProviderSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: IdentityProviderConfigurationState;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfosupportEntitlementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseMemberOrder>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfoteamDiscussionsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type EnterpriseOwnerInfotwoFactorRequiredSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};

/** The connection type for OrganizationInvitation. */
export type EnterprisePendingMemberInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterprisePendingMemberInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /** Identifies the total count of unique users in the connection. */
  totalUniqueUserCount: Scalars['Int']['output'];
};

/** An invitation to be a member in an enterprise organization. */
export type EnterprisePendingMemberInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<OrganizationInvitation>;
};

/** A subset of repository information queryable from an enterprise. */
export type EnterpriseRepositoryInfo = Node & {
  /** The Node ID of the EnterpriseRepositoryInfo object */
  id: Scalars['ID']['output'];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars['Boolean']['output'];
  /** The repository's name. */
  name: Scalars['String']['output'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String']['output'];
};

/** The connection type for EnterpriseRepositoryInfo. */
export type EnterpriseRepositoryInfoConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseRepositoryInfoEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseRepositoryInfo>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type EnterpriseRepositoryInfoEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseRepositoryInfo>;
};

/** An Enterprise Server installation. */
export type EnterpriseServerInstallation = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The customer name to which the Enterprise Server installation belongs. */
  customerName: Scalars['String']['output'];
  /** The host name of the Enterprise Server installation. */
  hostName: Scalars['String']['output'];
  /** The Node ID of the EnterpriseServerInstallation object */
  id: Scalars['ID']['output'];
  /** Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect. */
  isConnected: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** User accounts on this Enterprise Server installation. */
  userAccounts: EnterpriseServerUserAccountConnection;
  /** User accounts uploads for the Enterprise Server installation. */
  userAccountsUploads: EnterpriseServerUserAccountsUploadConnection;
};


/** An Enterprise Server installation. */
export type EnterpriseServerInstallationuserAccountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseServerUserAccountOrder>;
};


/** An Enterprise Server installation. */
export type EnterpriseServerInstallationuserAccountsUploadsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseServerUserAccountsUploadOrder>;
};

/** The connection type for EnterpriseServerInstallation. */
export type EnterpriseServerInstallationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseServerInstallationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseServerInstallation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type EnterpriseServerInstallationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseServerInstallation>;
};

/** The connection type for EnterpriseServerInstallation. */
export type EnterpriseServerInstallationMembershipConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseServerInstallationMembershipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseServerInstallation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An Enterprise Server installation that a user is a member of. */
export type EnterpriseServerInstallationMembershipEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseServerInstallation>;
  /** The role of the user in the enterprise membership. */
  role: EnterpriseUserAccountMembershipRole;
};

/** Ordering options for Enterprise Server installation connections. */
export type EnterpriseServerInstallationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order Enterprise Server installations by. */
  field: EnterpriseServerInstallationOrderField;
};

/** Properties by which Enterprise Server installation connections can be ordered. */
export type EnterpriseServerInstallationOrderField =
  /** Order Enterprise Server installations by creation time */
  | 'CREATED_AT'
  /** Order Enterprise Server installations by customer name */
  | 'CUSTOMER_NAME'
  /** Order Enterprise Server installations by host name */
  | 'HOST_NAME';

/** A user account on an Enterprise Server installation. */
export type EnterpriseServerUserAccount = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** User emails belonging to this user account. */
  emails: EnterpriseServerUserAccountEmailConnection;
  /** The Enterprise Server installation on which this user account exists. */
  enterpriseServerInstallation: EnterpriseServerInstallation;
  /** The Node ID of the EnterpriseServerUserAccount object */
  id: Scalars['ID']['output'];
  /** Whether the user account is a site administrator on the Enterprise Server installation. */
  isSiteAdmin: Scalars['Boolean']['output'];
  /** The login of the user account on the Enterprise Server installation. */
  login: Scalars['String']['output'];
  /** The profile name of the user account on the Enterprise Server installation. */
  profileName?: Maybe<Scalars['String']['output']>;
  /** The date and time when the user account was created on the Enterprise Server installation. */
  remoteCreatedAt: Scalars['DateTime']['output'];
  /** The ID of the user account on the Enterprise Server installation. */
  remoteUserId: Scalars['Int']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};


/** A user account on an Enterprise Server installation. */
export type EnterpriseServerUserAccountemailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseServerUserAccountEmailOrder>;
};

/** The connection type for EnterpriseServerUserAccount. */
export type EnterpriseServerUserAccountConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type EnterpriseServerUserAccountEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseServerUserAccount>;
};

/** An email belonging to a user account on an Enterprise Server installation. */
export type EnterpriseServerUserAccountEmail = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The email address. */
  email: Scalars['String']['output'];
  /** The Node ID of the EnterpriseServerUserAccountEmail object */
  id: Scalars['ID']['output'];
  /** Indicates whether this is the primary email of the associated user account. */
  isPrimary: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The user account to which the email belongs. */
  userAccount: EnterpriseServerUserAccount;
};

/** The connection type for EnterpriseServerUserAccountEmail. */
export type EnterpriseServerUserAccountEmailConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountEmailEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccountEmail>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type EnterpriseServerUserAccountEmailEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseServerUserAccountEmail>;
};

/** Ordering options for Enterprise Server user account email connections. */
export type EnterpriseServerUserAccountEmailOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order emails by. */
  field: EnterpriseServerUserAccountEmailOrderField;
};

/** Properties by which Enterprise Server user account email connections can be ordered. */
export type EnterpriseServerUserAccountEmailOrderField =
  /** Order emails by email */
  | 'EMAIL';

/** Ordering options for Enterprise Server user account connections. */
export type EnterpriseServerUserAccountOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order user accounts by. */
  field: EnterpriseServerUserAccountOrderField;
};

/** Properties by which Enterprise Server user account connections can be ordered. */
export type EnterpriseServerUserAccountOrderField =
  /** Order user accounts by login */
  | 'LOGIN'
  /** Order user accounts by creation time on the Enterprise Server installation */
  | 'REMOTE_CREATED_AT';

/** A user accounts upload from an Enterprise Server installation. */
export type EnterpriseServerUserAccountsUpload = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The enterprise to which this upload belongs. */
  enterprise: Enterprise;
  /** The Enterprise Server installation for which this upload was generated. */
  enterpriseServerInstallation: EnterpriseServerInstallation;
  /** The Node ID of the EnterpriseServerUserAccountsUpload object */
  id: Scalars['ID']['output'];
  /** The name of the file uploaded. */
  name: Scalars['String']['output'];
  /** The synchronization state of the upload */
  syncState: EnterpriseServerUserAccountsUploadSyncState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for EnterpriseServerUserAccountsUpload. */
export type EnterpriseServerUserAccountsUploadConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountsUploadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccountsUpload>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type EnterpriseServerUserAccountsUploadEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EnterpriseServerUserAccountsUpload>;
};

/** Ordering options for Enterprise Server user accounts upload connections. */
export type EnterpriseServerUserAccountsUploadOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order user accounts uploads by. */
  field: EnterpriseServerUserAccountsUploadOrderField;
};

/** Properties by which Enterprise Server user accounts upload connections can be ordered. */
export type EnterpriseServerUserAccountsUploadOrderField =
  /** Order user accounts uploads by creation time */
  | 'CREATED_AT';

/** Synchronization state of the Enterprise Server user accounts upload */
export type EnterpriseServerUserAccountsUploadSyncState =
  /** The synchronization of the upload failed. */
  | 'FAILURE'
  /** The synchronization of the upload is pending. */
  | 'PENDING'
  /** The synchronization of the upload succeeded. */
  | 'SUCCESS';

/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type EnterpriseUserAccount = Actor & Node & {
  /** A URL pointing to the enterprise user account's public avatar. */
  avatarUrl: Scalars['URI']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The enterprise in which this user account exists. */
  enterprise: Enterprise;
  /** A list of Enterprise Server installations this user is a member of. */
  enterpriseInstallations: EnterpriseServerInstallationMembershipConnection;
  /** The Node ID of the EnterpriseUserAccount object */
  id: Scalars['ID']['output'];
  /** An identifier for the enterprise user account, a login or email address */
  login: Scalars['String']['output'];
  /** The name of the enterprise user account */
  name?: Maybe<Scalars['String']['output']>;
  /** A list of enterprise organizations this user is a member of. */
  organizations: EnterpriseOrganizationMembershipConnection;
  /** The HTTP path for this user. */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this user. */
  url: Scalars['URI']['output'];
  /** The user within the enterprise. */
  user?: Maybe<User>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type EnterpriseUserAccountavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type EnterpriseUserAccountenterpriseInstallationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseServerInstallationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type EnterpriseUserAccountorganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;
};

/** The possible roles for enterprise membership. */
export type EnterpriseUserAccountMembershipRole =
  /** The user is a member of an organization in the enterprise. */
  | 'MEMBER'
  /** The user is an owner of an organization in the enterprise. */
  | 'OWNER'
  /**
   * The user is not an owner of the enterprise, and not a member or owner of any
   * organizations in the enterprise; only for EMU-enabled enterprises.
   */
  | 'UNAFFILIATED';

/** The possible GitHub Enterprise deployments where this user can exist. */
export type EnterpriseUserDeployment =
  /** The user is part of a GitHub Enterprise Cloud deployment. */
  | 'CLOUD'
  /** The user is part of a GitHub Enterprise Server deployment. */
  | 'SERVER';

/** An environment. */
export type Environment = Node & {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the Environment object */
  id: Scalars['ID']['output'];
  /** The name of the environment */
  name: Scalars['String']['output'];
  /** The protection rules defined for this environment */
  protectionRules: DeploymentProtectionRuleConnection;
};


/** An environment. */
export type EnvironmentprotectionRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Environment. */
export type EnvironmentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Environment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type EnvironmentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Environment>;
};

/** Properties by which environments connections can be ordered */
export type EnvironmentOrderField =
  /** Order environments by name. */
  | 'NAME';

/** Ordering options for environments */
export type Environments = {
  /** The direction in which to order environments by the specified field. */
  direction: OrderDirection;
  /** The field to order environments by. */
  field: EnvironmentOrderField;
};

/**
 * An external identity provisioned by SAML SSO or SCIM. If SAML is configured on
 * the organization, the external identity is visible to (1) organization owners,
 * (2) organization owners' personal access tokens (classic) with read:org or
 * admin:org scope, (3) GitHub App with an installation token with read or write
 * access to members. If SAML is configured on the enterprise, the external
 * identity is visible to (1) enterprise owners, (2) enterprise owners' personal
 * access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type ExternalIdentity = Node & {
  /** The GUID for this identity */
  guid: Scalars['String']['output'];
  /** The Node ID of the ExternalIdentity object */
  id: Scalars['ID']['output'];
  /** Organization invitation for this SCIM-provisioned external identity */
  organizationInvitation?: Maybe<OrganizationInvitation>;
  /** SAML Identity attributes */
  samlIdentity?: Maybe<ExternalIdentitySamlAttributes>;
  /** SCIM Identity attributes */
  scimIdentity?: Maybe<ExternalIdentityScimAttributes>;
  /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */
  user?: Maybe<User>;
};

/** An attribute for the External Identity attributes collection */
export type ExternalIdentityAttribute = {
  /** The attribute metadata as JSON */
  metadata?: Maybe<Scalars['String']['output']>;
  /** The attribute name */
  name: Scalars['String']['output'];
  /** The attribute value */
  value: Scalars['String']['output'];
};

/** The connection type for ExternalIdentity. */
export type ExternalIdentityConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExternalIdentityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ExternalIdentity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ExternalIdentityEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ExternalIdentity>;
};

/** SAML attributes for the External Identity */
export type ExternalIdentitySamlAttributes = {
  /** SAML Identity attributes */
  attributes: Array<ExternalIdentityAttribute>;
  /** The emails associated with the SAML identity */
  emails?: Maybe<Array<UserEmailMetadata>>;
  /** Family name of the SAML identity */
  familyName?: Maybe<Scalars['String']['output']>;
  /** Given name of the SAML identity */
  givenName?: Maybe<Scalars['String']['output']>;
  /** The groups linked to this identity in IDP */
  groups?: Maybe<Array<Scalars['String']['output']>>;
  /** The NameID of the SAML identity */
  nameId?: Maybe<Scalars['String']['output']>;
  /** The userName of the SAML identity */
  username?: Maybe<Scalars['String']['output']>;
};

/** SCIM attributes for the External Identity */
export type ExternalIdentityScimAttributes = {
  /** The emails associated with the SCIM identity */
  emails?: Maybe<Array<UserEmailMetadata>>;
  /** Family name of the SCIM identity */
  familyName?: Maybe<Scalars['String']['output']>;
  /** Given name of the SCIM identity */
  givenName?: Maybe<Scalars['String']['output']>;
  /** The groups linked to this identity in IDP */
  groups?: Maybe<Array<Scalars['String']['output']>>;
  /** The userName of the SCIM identity */
  username?: Maybe<Scalars['String']['output']>;
};

/**
 * A command to add a file at the given path with the given contents as part of a
 * commit.  Any existing file at that that path will be replaced.
 */
export type FileAddition = {
  /** The base64 encoded contents of the file */
  contents: Scalars['Base64String']['input'];
  /** The path in the repository where the file will be located */
  path: Scalars['String']['input'];
};

/**
 * A description of a set of changes to a file tree to be made as part of
 * a git commit, modeled as zero or more file `additions` and zero or more
 * file `deletions`.
 *
 * Both fields are optional; omitting both will produce a commit with no
 * file changes.
 *
 * `deletions` and `additions` describe changes to files identified
 * by their path in the git tree using unix-style path separators, i.e.
 * `/`.  The root of a git tree is an empty string, so paths are not
 * slash-prefixed.
 *
 * `path` values must be unique across all `additions` and `deletions`
 * provided.  Any duplication will result in a validation error.
 *
 * ### Encoding
 *
 * File contents must be provided in full for each `FileAddition`.
 *
 * The `contents` of a `FileAddition` must be encoded using RFC 4648
 * compliant base64, i.e. correct padding is required and no characters
 * outside the standard alphabet may be used.  Invalid base64
 * encoding will be rejected with a validation error.
 *
 * The encoded contents may be binary.
 *
 * For text files, no assumptions are made about the character encoding of
 * the file contents (after base64 decoding).  No charset transcoding or
 * line-ending normalization will be performed; it is the client's
 * responsibility to manage the character encoding of files they provide.
 * However, for maximum compatibility we recommend using UTF-8 encoding
 * and ensuring that all files in a repository use a consistent
 * line-ending convention (`\n` or `\r\n`), and that all files end
 * with a newline.
 *
 * ### Modeling file changes
 *
 * Each of the the five types of conceptual changes that can be made in a
 * git commit can be described using the `FileChanges` type as follows:
 *
 * 1. New file addition: create file `hello world\n` at path `docs/README.txt`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 * 2. Existing file modification: change existing `docs/README.txt` to have new
 *    content `new content here\n`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("new content here\n")
 *            }
 *          ]
 *        }
 *
 * 3. Existing file deletion: remove existing file `docs/README.txt`.
 *    Note that the path is required to exist -- specifying a
 *    path that does not exist on the given branch will abort the
 *    commit and return an error.
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt"
 *            }
 *          ]
 *        }
 *
 *
 * 4. File rename with no changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to the same content at
 *    `newdocs/README.txt`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 *
 * 5. File rename with changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to a file at path
 *    `newdocs/README.txt` with content `new contents\n`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("new contents\n")
 *            }
 *          ]
 *        }
 */
export type FileChanges = {
  /** File to add or change. */
  additions?: InputMaybe<Array<FileAddition>>;
  /** Files to delete. */
  deletions?: InputMaybe<Array<FileDeletion>>;
};

/** A command to delete the file at the given path as part of a commit. */
export type FileDeletion = {
  /** The path to delete */
  path: Scalars['String']['input'];
};

/** The possible viewed states of a file . */
export type FileViewedState =
  /** The file has new changes since last viewed. */
  | 'DISMISSED'
  /** The file has not been marked as viewed. */
  | 'UNVIEWED'
  /** The file has been marked as viewed. */
  | 'VIEWED';

/** Autogenerated input type of FollowOrganization */
export type FollowOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the organization to follow. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of FollowOrganization */
export type FollowOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organization that was followed. */
  organization?: Maybe<Organization>;
};

/** Autogenerated input type of FollowUser */
export type FollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the user to follow. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of FollowUser */
export type FollowUserPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The user that was followed. */
  user?: Maybe<User>;
};

/** The connection type for User. */
export type FollowerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The connection type for User. */
export type FollowingConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A funding platform link for a repository. */
export type FundingLink = {
  /** The funding platform this link is for. */
  platform: FundingPlatform;
  /** The configured URL for this funding link. */
  url: Scalars['URI']['output'];
};

/** The possible funding platforms for repository funding links. */
export type FundingPlatform =
  /** Community Bridge funding platform. */
  | 'COMMUNITY_BRIDGE'
  /** Custom funding platform. */
  | 'CUSTOM'
  /** GitHub funding platform. */
  | 'GITHUB'
  /** IssueHunt funding platform. */
  | 'ISSUEHUNT'
  /** Ko-fi funding platform. */
  | 'KO_FI'
  /** LFX Crowdfunding funding platform. */
  | 'LFX_CROWDFUNDING'
  /** Liberapay funding platform. */
  | 'LIBERAPAY'
  /** Open Collective funding platform. */
  | 'OPEN_COLLECTIVE'
  /** Otechie funding platform. */
  | 'OTECHIE'
  /** Patreon funding platform. */
  | 'PATREON'
  /** Tidelift funding platform. */
  | 'TIDELIFT';

/** A generic hovercard context with a message and icon */
export type GenericHovercardContext = HovercardContext & {
  /** A string describing this context */
  message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  octicon: Scalars['String']['output'];
};

/** A Gist. */
export type Gist = Node & Starrable & UniformResourceLocatable & {
  /** A list of comments associated with the gist */
  comments: GistCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The gist description. */
  description?: Maybe<Scalars['String']['output']>;
  /** The files in this gist. */
  files?: Maybe<Array<Maybe<GistFile>>>;
  /** A list of forks associated with the gist */
  forks: GistConnection;
  /** The Node ID of the Gist object */
  id: Scalars['ID']['output'];
  /** Identifies if the gist is a fork. */
  isFork: Scalars['Boolean']['output'];
  /** Whether the gist is public or not. */
  isPublic: Scalars['Boolean']['output'];
  /** The gist name. */
  name: Scalars['String']['output'];
  /** The gist owner. */
  owner?: Maybe<RepositoryOwner>;
  /** Identifies when the gist was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The HTML path to this resource. */
  resourcePath: Scalars['URI']['output'];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int']['output'];
  /** A list of users who have starred this starrable. */
  stargazers: StargazerConnection;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this Gist. */
  url: Scalars['URI']['output'];
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean']['output'];
};


/** A Gist. */
export type GistcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A Gist. */
export type GistfilesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  oid?: InputMaybe<Scalars['GitObjectID']['input']>;
};


/** A Gist. */
export type GistforksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<GistOrder>;
};


/** A Gist. */
export type GiststargazersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<StarOrder>;
};

/** Represents a comment on an Gist. */
export type GistComment = Comment & Deletable & Minimizable & Node & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Actor>;
  /** Author's association with the gist. */
  authorAssociation: CommentAuthorAssociation;
  /** Identifies the comment body. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Actor>;
  /** The associated gist. */
  gist: Gist;
  /** The Node ID of the GistComment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** Represents a comment on an Gist. */
export type GistCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for GistComment. */
export type GistCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GistCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GistComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type GistCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GistComment>;
};

/** The connection type for Gist. */
export type GistConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GistEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Gist>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type GistEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Gist>;
};

/** A file in a gist. */
export type GistFile = {
  /** The file name encoded to remove characters that are invalid in URL paths. */
  encodedName?: Maybe<Scalars['String']['output']>;
  /** The gist file encoding. */
  encoding?: Maybe<Scalars['String']['output']>;
  /** The file extension from the file name. */
  extension?: Maybe<Scalars['String']['output']>;
  /** Indicates if this file is an image. */
  isImage: Scalars['Boolean']['output'];
  /** Whether the file's contents were truncated. */
  isTruncated: Scalars['Boolean']['output'];
  /** The programming language this file is written in. */
  language?: Maybe<Language>;
  /** The gist file name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The gist file size in bytes. */
  size?: Maybe<Scalars['Int']['output']>;
  /** UTF8 text data or null if the file is binary */
  text?: Maybe<Scalars['String']['output']>;
};


/** A file in a gist. */
export type GistFiletextArgs = {
  truncate?: InputMaybe<Scalars['Int']['input']>;
};

/** Ordering options for gist connections */
export type GistOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: GistOrderField;
};

/** Properties by which gist connections can be ordered. */
export type GistOrderField =
  /** Order gists by creation time */
  | 'CREATED_AT'
  /** Order gists by push time */
  | 'PUSHED_AT'
  /** Order gists by update time */
  | 'UPDATED_AT';

/** The privacy of a Gist */
export type GistPrivacy =
  /** Gists that are public and secret */
  | 'ALL'
  /** Public */
  | 'PUBLIC'
  /** Secret */
  | 'SECRET';

/** Represents an actor in a Git commit (ie. an author or committer). */
export type GitActor = {
  /** A URL pointing to the author's public avatar. */
  avatarUrl: Scalars['URI']['output'];
  /** The timestamp of the Git action (authoring or committing). */
  date?: Maybe<Scalars['GitTimestamp']['output']>;
  /** The email in the Git commit. */
  email?: Maybe<Scalars['String']['output']>;
  /** The name in the Git commit. */
  name?: Maybe<Scalars['String']['output']>;
  /** The GitHub user corresponding to the email field. Null if no such user exists. */
  user?: Maybe<User>;
};


/** Represents an actor in a Git commit (ie. an author or committer). */
export type GitActoravatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for GitActor. */
export type GitActorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GitActorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GitActor>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type GitActorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GitActor>;
};

/** Represents information about the GitHub instance. */
export type GitHubMetadata = {
  /** Returns a String that's a SHA of `github-services` */
  gitHubServicesSha: Scalars['GitObjectID']['output'];
  /** IP addresses that users connect to for git operations */
  gitIpAddresses?: Maybe<Array<Scalars['String']['output']>>;
  /** IP addresses that GitHub Enterprise Importer uses for outbound connections */
  githubEnterpriseImporterIpAddresses?: Maybe<Array<Scalars['String']['output']>>;
  /** IP addresses that service hooks are sent from */
  hookIpAddresses?: Maybe<Array<Scalars['String']['output']>>;
  /** IP addresses that the importer connects from */
  importerIpAddresses?: Maybe<Array<Scalars['String']['output']>>;
  /** Whether or not users are verified */
  isPasswordAuthenticationVerifiable: Scalars['Boolean']['output'];
  /** IP addresses for GitHub Pages' A records */
  pagesIpAddresses?: Maybe<Array<Scalars['String']['output']>>;
};

/** Represents a Git object. */
export type GitObject = {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String']['output'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI']['output'];
  /** The Node ID of the GitObject object */
  id: Scalars['ID']['output'];
  /** The Git object ID */
  oid: Scalars['GitObjectID']['output'];
  /** The Repository the Git object belongs to */
  repository: Repository;
};

/** Information about a signature (GPG or S/MIME) on a Commit or Tag. */
export type GitSignature = {
  /** Email used to sign this object. */
  email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean']['output'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** The state of a Git signature. */
export type GitSignatureState =
  /** The signing certificate or its chain could not be verified */
  | 'BAD_CERT'
  /** Invalid email used for signing */
  | 'BAD_EMAIL'
  /** Signing key expired */
  | 'EXPIRED_KEY'
  /** Internal error - the GPG verification service misbehaved */
  | 'GPGVERIFY_ERROR'
  /** Internal error - the GPG verification service is unavailable at the moment */
  | 'GPGVERIFY_UNAVAILABLE'
  /** Invalid signature */
  | 'INVALID'
  /** Malformed signature */
  | 'MALFORMED_SIG'
  /** The usage flags for the key that signed this don't allow signing */
  | 'NOT_SIGNING_KEY'
  /** Email used for signing not known to GitHub */
  | 'NO_USER'
  /** Valid signature, though certificate revocation check failed */
  | 'OCSP_ERROR'
  /** Valid signature, pending certificate revocation checking */
  | 'OCSP_PENDING'
  /** One or more certificates in chain has been revoked */
  | 'OCSP_REVOKED'
  /** Key used for signing not known to GitHub */
  | 'UNKNOWN_KEY'
  /** Unknown signature type */
  | 'UNKNOWN_SIG_TYPE'
  /** Unsigned */
  | 'UNSIGNED'
  /** Email used for signing unverified on GitHub */
  | 'UNVERIFIED_EMAIL'
  /** Valid signature and verified by GitHub */
  | 'VALID';

/** Represents a GPG signature on a Commit or Tag. */
export type GpgSignature = GitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean']['output'];
  /** Hex-encoded ID of the key that signed this object. */
  keyId?: Maybe<Scalars['String']['output']>;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** Autogenerated input type of GrantEnterpriseOrganizationsMigratorRole */
export type GrantEnterpriseOrganizationsMigratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of the user to grant the migrator role */
  login: Scalars['String']['input'];
};

/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */
export type GrantEnterpriseOrganizationsMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organizations that had the migrator role applied to for the given user. */
  organizations?: Maybe<OrganizationConnection>;
};


/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */
export type GrantEnterpriseOrganizationsMigratorRolePayloadorganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of GrantMigratorRole */
export type GrantMigratorRoleInput = {
  /** The user login or Team slug to grant the migrator role. */
  actor: Scalars['String']['input'];
  /** Specifies the type of the actor, can be either USER or TEAM. */
  actorType: ActorType;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that the user/team belongs to. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of GrantMigratorRole */
export type GrantMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Represents a 'head_ref_deleted' event on a given pull request. */
export type HeadRefDeletedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the Ref associated with the `head_ref_deleted` event. */
  headRef?: Maybe<Ref>;
  /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */
  headRefName: Scalars['String']['output'];
  /** The Node ID of the HeadRefDeletedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** Represents a 'head_ref_force_pushed' event on a given pull request. */
export type HeadRefForcePushedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */
  afterCommit?: Maybe<Commit>;
  /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */
  beforeCommit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the HeadRefForcePushedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */
  ref?: Maybe<Ref>;
};

/** Represents a 'head_ref_restored' event on a given pull request. */
export type HeadRefRestoredEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the HeadRefRestoredEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** Detail needed to display a hovercard for a user */
export type Hovercard = {
  /** Each of the contexts for this hovercard */
  contexts: Array<HovercardContext>;
};

/** An individual line of a hovercard */
export type HovercardContext = {
  /** A string describing this context */
  message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  octicon: Scalars['String']['output'];
};

/** The possible states in which authentication can be configured with an identity provider. */
export type IdentityProviderConfigurationState =
  /** Authentication with an identity provider is configured but not enforced. */
  | 'CONFIGURED'
  /** Authentication with an identity provider is configured and enforced. */
  | 'ENFORCED'
  /** Authentication with an identity provider is not configured. */
  | 'UNCONFIGURED';

/** Autogenerated input type of ImportProject */
export type ImportProjectInput = {
  /** The description of Project. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A list of columns containing issues and pull requests. */
  columnImports: Array<ProjectColumnImport>;
  /** The name of Project. */
  name: Scalars['String']['input'];
  /** The name of the Organization or User to create the Project under. */
  ownerName: Scalars['String']['input'];
  /** Whether the Project is public or not. */
  public?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of ImportProject */
export type ImportProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new Project! */
  project?: Maybe<Project>;
};

/** Autogenerated input type of InviteEnterpriseAdmin */
export type InviteEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The email of the person to invite as an administrator. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise to which you want to invite an administrator. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of a user to invite as an administrator. */
  invitee?: InputMaybe<Scalars['String']['input']>;
  /** The role of the administrator. */
  role?: InputMaybe<EnterpriseAdministratorRole>;
};

/** Autogenerated return type of InviteEnterpriseAdmin */
export type InviteEnterpriseAdminPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The created enterprise administrator invitation. */
  invitation?: Maybe<EnterpriseAdministratorInvitation>;
};

/** The possible values for the IP allow list enabled setting. */
export type IpAllowListEnabledSettingValue =
  /** The setting is disabled for the owner. */
  | 'DISABLED'
  /** The setting is enabled for the owner. */
  | 'ENABLED';

/** An IP address or range of addresses that is allowed to access an owner's resources. */
export type IpAllowListEntry = Node & {
  /** A single IP address or range of IP addresses in CIDR notation. */
  allowListValue: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the IpAllowListEntry object */
  id: Scalars['ID']['output'];
  /** Whether the entry is currently active. */
  isActive: Scalars['Boolean']['output'];
  /** The name of the IP allow list entry. */
  name?: Maybe<Scalars['String']['output']>;
  /** The owner of the IP allow list entry. */
  owner: IpAllowListOwner;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for IpAllowListEntry. */
export type IpAllowListEntryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IpAllowListEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IpAllowListEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type IpAllowListEntryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<IpAllowListEntry>;
};

/** Ordering options for IP allow list entry connections. */
export type IpAllowListEntryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order IP allow list entries by. */
  field: IpAllowListEntryOrderField;
};

/** Properties by which IP allow list entry connections can be ordered. */
export type IpAllowListEntryOrderField =
  /** Order IP allow list entries by the allow list value. */
  | 'ALLOW_LIST_VALUE'
  /** Order IP allow list entries by creation time. */
  | 'CREATED_AT';

/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */
export type IpAllowListForInstalledAppsEnabledSettingValue =
  /** The setting is disabled for the owner. */
  | 'DISABLED'
  /** The setting is enabled for the owner. */
  | 'ENABLED';

/** Types that can own an IP allow list. */
export type IpAllowListOwner = App | Enterprise | Organization;

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Issue = Assignable & Closable & Comment & Deletable & Labelable & Lockable & Node & ProjectV2Owner & Reactable & RepositoryNode & Subscribable & SubscribableThread & UniformResourceLocatable & Updatable & UpdatableComment & {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<LockReason>;
  /** A list of Users assigned to this object. */
  assignees: UserConnection;
  /** The actor who authored the comment. */
  author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** Identifies the body of the issue. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** The http path for this issue body */
  bodyResourcePath: Scalars['URI']['output'];
  /** Identifies the body of the issue rendered to text. */
  bodyText: Scalars['String']['output'];
  /** The http URL for this issue body */
  bodyUrl: Scalars['URI']['output'];
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of comments associated with the Issue. */
  comments: IssueCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Actor>;
  /** Identifies the primary key from the database as a BigInt. */
  fullDatabaseId?: Maybe<Scalars['BigInt']['output']>;
  /** The hovercard information for this issue */
  hovercard: Hovercard;
  /** The Node ID of the Issue object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Indicates whether or not this issue is currently pinned to the repository issues list */
  isPinned?: Maybe<Scalars['Boolean']['output']>;
  /** Is this issue read by the viewer */
  isReadByViewer?: Maybe<Scalars['Boolean']['output']>;
  /** A list of labels associated with the object. */
  labels?: Maybe<LabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Branches linked to this issue. */
  linkedBranches: LinkedBranchConnection;
  /** `true` if the object is locked */
  locked: Scalars['Boolean']['output'];
  /** Identifies the milestone associated with the issue. */
  milestone?: Maybe<Milestone>;
  /** Identifies the issue number. */
  number: Scalars['Int']['output'];
  /** A list of Users that are participating in the Issue conversation. */
  participants: UserConnection;
  /** List of project cards associated with this issue. */
  projectCards: ProjectCardConnection;
  /** List of project items associated with this issue. */
  projectItems: ProjectV2ItemConnection;
  /** Find a project by number. */
  projectV2?: Maybe<ProjectV2>;
  /** A list of projects under the owner. */
  projectsV2: ProjectV2Connection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** The repository associated with this node. */
  repository: Repository;
  /** The HTTP path for this issue */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the state of the issue. */
  state: IssueState;
  /** Identifies the reason for the issue state. */
  stateReason?: Maybe<IssueStateReason>;
  /**
   * A list of events, comments, commits, etc. associated with the issue.
   * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.
   */
  timeline: IssueTimelineConnection;
  /** A list of events, comments, commits, etc. associated with the issue. */
  timelineItems: IssueTimelineItemsConnection;
  /** Identifies the issue title. */
  title: Scalars['String']['output'];
  /** Identifies the issue title rendered to HTML. */
  titleHTML: Scalars['String']['output'];
  /** A list of issues that track this issue */
  trackedInIssues: IssueConnection;
  /** A list of issues tracked inside the current issue */
  trackedIssues: IssueConnection;
  /** The number of tracked issues for this issue */
  trackedIssuesCount: Scalars['Int']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this issue */
  url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<UserContentEditConnection>;
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<SubscriptionState>;
  /** Identifies the viewer's thread subscription form action. */
  viewerThreadSubscriptionFormAction?: Maybe<ThreadSubscriptionFormAction>;
  /** Identifies the viewer's thread subscription status. */
  viewerThreadSubscriptionStatus?: Maybe<ThreadSubscriptionState>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueassigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssuecommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueCommentOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssuehovercardArgs = {
  includeNotificationContexts?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssuelabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LabelOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssuelinkedBranchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueparticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueprojectCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueprojectItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssuereactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssuetimelineArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssuetimelineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  itemTypes?: InputMaybe<Array<IssueTimelineItemsItemType>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssuetrackedInIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssuetrackedIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssuetrackedIssuesCountArgs = {
  states?: InputMaybe<Array<InputMaybe<TrackedIssueStates>>>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IssueuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The possible state reasons of a closed issue. */
export type IssueClosedStateReason =
  /** An issue that has been closed as completed */
  | 'COMPLETED'
  /** An issue that has been closed as not planned */
  | 'NOT_PLANNED';

/** Represents a comment on an Issue. */
export type IssueComment = Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Actor>;
  /** Identifies the primary key from the database as a BigInt. */
  fullDatabaseId?: Maybe<Scalars['BigInt']['output']>;
  /** The Node ID of the IssueComment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /** Identifies the issue associated with the comment. */
  issue: Issue;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns the pull request associated with the comment, if this comment was made on a
   * pull request.
   */
  pullRequest?: Maybe<PullRequest>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** The repository associated with this node. */
  repository: Repository;
  /** The HTTP path for this issue comment */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this issue comment */
  url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** Represents a comment on an Issue. */
export type IssueCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** Represents a comment on an Issue. */
export type IssueCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for IssueComment. */
export type IssueCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssueCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IssueComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type IssueCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<IssueComment>;
};

/** Ways in which lists of issue comments can be ordered upon return. */
export type IssueCommentOrder = {
  /** The direction in which to order issue comments by the specified field. */
  direction: OrderDirection;
  /** The field in which to order issue comments by. */
  field: IssueCommentOrderField;
};

/** Properties by which issue comment connections can be ordered. */
export type IssueCommentOrderField =
  /** Order issue comments by update time */
  | 'UPDATED_AT';

/** The connection type for Issue. */
export type IssueConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Issue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** This aggregates issues opened by a user within one repository. */
export type IssueContributionsByRepository = {
  /** The issue contributions. */
  contributions: CreatedIssueContributionConnection;
  /** The repository in which the issues were opened. */
  repository: Repository;
};


/** This aggregates issues opened by a user within one repository. */
export type IssueContributionsByRepositorycontributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};

/** An edge in a connection. */
export type IssueEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Issue>;
};

/** Ways in which to filter lists of issues. */
export type IssueFilters = {
  /**
   * List issues assigned to given name. Pass in `null` for issues with no assigned
   * user, and `*` for issues assigned to any user.
   */
  assignee?: InputMaybe<Scalars['String']['input']>;
  /** List issues created by given name. */
  createdBy?: InputMaybe<Scalars['String']['input']>;
  /** List issues where the list of label names exist on the issue. */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List issues where the given name is mentioned in the issue. */
  mentioned?: InputMaybe<Scalars['String']['input']>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its database ID. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  milestone?: InputMaybe<Scalars['String']['input']>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its number field. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  milestoneNumber?: InputMaybe<Scalars['String']['input']>;
  /** List issues that have been updated at or after the given date. */
  since?: InputMaybe<Scalars['DateTime']['input']>;
  /** List issues filtered by the list of states given. */
  states?: InputMaybe<Array<IssueState>>;
  /** List issues subscribed to by viewer. */
  viewerSubscribed?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Used for return value of Repository.issueOrPullRequest. */
export type IssueOrPullRequest = Issue | PullRequest;

/** Ways in which lists of issues can be ordered upon return. */
export type IssueOrder = {
  /** The direction in which to order issues by the specified field. */
  direction: OrderDirection;
  /** The field in which to order issues by. */
  field: IssueOrderField;
};

/** Properties by which issue connections can be ordered. */
export type IssueOrderField =
  /** Order issues by comment count */
  | 'COMMENTS'
  /** Order issues by creation time */
  | 'CREATED_AT'
  /** Order issues by update time */
  | 'UPDATED_AT';

/** The possible states of an issue. */
export type IssueState =
  /** An issue that has been closed */
  | 'CLOSED'
  /** An issue that is still open */
  | 'OPEN';

/** The possible state reasons of an issue. */
export type IssueStateReason =
  /** An issue that has been closed as completed */
  | 'COMPLETED'
  /** An issue that has been closed as not planned */
  | 'NOT_PLANNED'
  /** An issue that has been reopened */
  | 'REOPENED';

/** A repository issue template. */
export type IssueTemplate = {
  /** The template purpose. */
  about?: Maybe<Scalars['String']['output']>;
  /** The suggested assignees. */
  assignees: UserConnection;
  /** The suggested issue body. */
  body?: Maybe<Scalars['String']['output']>;
  /** The template filename. */
  filename: Scalars['String']['output'];
  /** The suggested issue labels */
  labels?: Maybe<LabelConnection>;
  /** The template name. */
  name: Scalars['String']['output'];
  /** The suggested issue title. */
  title?: Maybe<Scalars['String']['output']>;
};


/** A repository issue template. */
export type IssueTemplateassigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository issue template. */
export type IssueTemplatelabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LabelOrder>;
};

/** The connection type for IssueTimelineItem. */
export type IssueTimelineConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssueTimelineItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IssueTimelineItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An item in an issue timeline */
export type IssueTimelineItem = AssignedEvent | ClosedEvent | Commit | CrossReferencedEvent | DemilestonedEvent | IssueComment | LabeledEvent | LockedEvent | MilestonedEvent | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent;

/** An edge in a connection. */
export type IssueTimelineItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<IssueTimelineItem>;
};

/** An item in an issue timeline */
export type IssueTimelineItems = AddedToProjectEvent | AssignedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertedNoteToIssueEvent | ConvertedToDiscussionEvent | CrossReferencedEvent | DemilestonedEvent | DisconnectedEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | ReferencedEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent;

/** The connection type for IssueTimelineItems. */
export type IssueTimelineItemsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssueTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars['Int']['output'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IssueTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars['Int']['output'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** An edge in a connection. */
export type IssueTimelineItemsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<IssueTimelineItems>;
};

/** The possible item types found in a timeline. */
export type IssueTimelineItemsItemType =
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  | 'ADDED_TO_PROJECT_EVENT'
  /** Represents an 'assigned' event on any assignable object. */
  | 'ASSIGNED_EVENT'
  /** Represents a 'closed' event on any `Closable`. */
  | 'CLOSED_EVENT'
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  | 'COMMENT_DELETED_EVENT'
  /** Represents a 'connected' event on a given issue or pull request. */
  | 'CONNECTED_EVENT'
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  | 'CONVERTED_NOTE_TO_ISSUE_EVENT'
  /** Represents a 'converted_to_discussion' event on a given issue. */
  | 'CONVERTED_TO_DISCUSSION_EVENT'
  /** Represents a mention made by one issue or pull request to another. */
  | 'CROSS_REFERENCED_EVENT'
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  | 'DEMILESTONED_EVENT'
  /** Represents a 'disconnected' event on a given issue or pull request. */
  | 'DISCONNECTED_EVENT'
  /** Represents a comment on an Issue. */
  | 'ISSUE_COMMENT'
  /** Represents a 'labeled' event on a given issue or pull request. */
  | 'LABELED_EVENT'
  /** Represents a 'locked' event on a given issue or pull request. */
  | 'LOCKED_EVENT'
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  | 'MARKED_AS_DUPLICATE_EVENT'
  /** Represents a 'mentioned' event on a given issue or pull request. */
  | 'MENTIONED_EVENT'
  /** Represents a 'milestoned' event on a given issue or pull request. */
  | 'MILESTONED_EVENT'
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  | 'MOVED_COLUMNS_IN_PROJECT_EVENT'
  /** Represents a 'pinned' event on a given issue or pull request. */
  | 'PINNED_EVENT'
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  | 'REFERENCED_EVENT'
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  | 'REMOVED_FROM_PROJECT_EVENT'
  /** Represents a 'renamed' event on a given issue or pull request */
  | 'RENAMED_TITLE_EVENT'
  /** Represents a 'reopened' event on any `Closable`. */
  | 'REOPENED_EVENT'
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  | 'SUBSCRIBED_EVENT'
  /** Represents a 'transferred' event on a given issue or pull request. */
  | 'TRANSFERRED_EVENT'
  /** Represents an 'unassigned' event on any assignable object. */
  | 'UNASSIGNED_EVENT'
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  | 'UNLABELED_EVENT'
  /** Represents an 'unlocked' event on a given issue or pull request. */
  | 'UNLOCKED_EVENT'
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  | 'UNMARKED_AS_DUPLICATE_EVENT'
  /** Represents an 'unpinned' event on a given issue or pull request. */
  | 'UNPINNED_EVENT'
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  | 'UNSUBSCRIBED_EVENT'
  /** Represents a 'user_blocked' event on a given user. */
  | 'USER_BLOCKED_EVENT';

/** Represents a user signing up for a GitHub account. */
export type JoinedGitHubContribution = Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  user: User;
};

/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type Label = Node & {
  /** Identifies the label color. */
  color: Scalars['String']['output'];
  /** Identifies the date and time when the label was created. */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** A brief description of this label. */
  description?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the Label object */
  id: Scalars['ID']['output'];
  /** Indicates whether or not this is a default label. */
  isDefault: Scalars['Boolean']['output'];
  /** A list of issues associated with this label. */
  issues: IssueConnection;
  /** Identifies the label name. */
  name: Scalars['String']['output'];
  /** A list of pull requests associated with this label. */
  pullRequests: PullRequestConnection;
  /** The repository associated with this label. */
  repository: Repository;
  /** The HTTP path for this label. */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the label was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The HTTP URL for this label. */
  url: Scalars['URI']['output'];
};


/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type LabelissuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<IssueFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<IssueState>>;
};


/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type LabelpullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<PullRequestState>>;
};

/** The connection type for Label. */
export type LabelConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LabelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Label>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type LabelEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Label>;
};

/** Ways in which lists of labels can be ordered upon return. */
export type LabelOrder = {
  /** The direction in which to order labels by the specified field. */
  direction: OrderDirection;
  /** The field in which to order labels by. */
  field: LabelOrderField;
};

/** Properties by which label connections can be ordered. */
export type LabelOrderField =
  /** Order labels by creation time */
  | 'CREATED_AT'
  /** Order labels by name */
  | 'NAME';

/** An object that can have labels assigned to it. */
export type Labelable = {
  /** A list of labels associated with the object. */
  labels?: Maybe<LabelConnection>;
};


/** An object that can have labels assigned to it. */
export type LabelablelabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LabelOrder>;
};

/** Represents a 'labeled' event on a given issue or pull request. */
export type LabeledEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the LabeledEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the label associated with the 'labeled' event. */
  label: Label;
  /** Identifies the `Labelable` associated with the event. */
  labelable: Labelable;
};

/** Represents a given language found in repositories. */
export type Language = Node & {
  /** The color defined for the current language. */
  color?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the Language object */
  id: Scalars['ID']['output'];
  /** The name of the current language. */
  name: Scalars['String']['output'];
};

/** A list of languages associated with the parent. */
export type LanguageConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LanguageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Language>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /** The total size in bytes of files written in that language. */
  totalSize: Scalars['Int']['output'];
};

/** Represents the language of a repository. */
export type LanguageEdge = {
  cursor: Scalars['String']['output'];
  node: Language;
  /** The number of bytes of code written in the language. */
  size: Scalars['Int']['output'];
};

/** Ordering options for language connections. */
export type LanguageOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order languages by. */
  field: LanguageOrderField;
};

/** Properties by which language connections can be ordered. */
export type LanguageOrderField =
  /** Order languages by the size of all files containing the language */
  | 'SIZE';

/** A repository's open source license */
export type License = Node & {
  /** The full text of the license */
  body: Scalars['String']['output'];
  /** The conditions set by the license */
  conditions: Array<Maybe<LicenseRule>>;
  /** A human-readable description of the license */
  description?: Maybe<Scalars['String']['output']>;
  /** Whether the license should be featured */
  featured: Scalars['Boolean']['output'];
  /** Whether the license should be displayed in license pickers */
  hidden: Scalars['Boolean']['output'];
  /** The Node ID of the License object */
  id: Scalars['ID']['output'];
  /** Instructions on how to implement the license */
  implementation?: Maybe<Scalars['String']['output']>;
  /** The lowercased SPDX ID of the license */
  key: Scalars['String']['output'];
  /** The limitations set by the license */
  limitations: Array<Maybe<LicenseRule>>;
  /** The license full name specified by <https://spdx.org/licenses> */
  name: Scalars['String']['output'];
  /** Customary short name if applicable (e.g, GPLv3) */
  nickname?: Maybe<Scalars['String']['output']>;
  /** The permissions set by the license */
  permissions: Array<Maybe<LicenseRule>>;
  /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */
  pseudoLicense: Scalars['Boolean']['output'];
  /** Short identifier specified by <https://spdx.org/licenses> */
  spdxId?: Maybe<Scalars['String']['output']>;
  /** URL to the license on <https://choosealicense.com> */
  url?: Maybe<Scalars['URI']['output']>;
};

/** Describes a License's conditions, permissions, and limitations */
export type LicenseRule = {
  /** A description of the rule */
  description: Scalars['String']['output'];
  /** The machine-readable rule key */
  key: Scalars['String']['output'];
  /** The human-readable rule label */
  label: Scalars['String']['output'];
};

/** Autogenerated input type of LinkProjectV2ToRepository */
export type LinkProjectV2ToRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to link to the repository. */
  projectId: Scalars['ID']['input'];
  /** The ID of the repository to link to the project. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of LinkProjectV2ToRepository */
export type LinkProjectV2ToRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository the project is linked to. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of LinkProjectV2ToTeam */
export type LinkProjectV2ToTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to link to the team. */
  projectId: Scalars['ID']['input'];
  /** The ID of the team to link to the project. */
  teamId: Scalars['ID']['input'];
};

/** Autogenerated return type of LinkProjectV2ToTeam */
export type LinkProjectV2ToTeamPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The team the project is linked to */
  team?: Maybe<Team>;
};

/** Autogenerated input type of LinkRepositoryToProject */
export type LinkRepositoryToProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to link to a Repository */
  projectId: Scalars['ID']['input'];
  /** The ID of the Repository to link to a Project. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of LinkRepositoryToProject */
export type LinkRepositoryToProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The linked Project. */
  project?: Maybe<Project>;
  /** The linked Repository. */
  repository?: Maybe<Repository>;
};

/** A branch linked to an issue. */
export type LinkedBranch = Node & {
  /** The Node ID of the LinkedBranch object */
  id: Scalars['ID']['output'];
  /** The branch's ref. */
  ref?: Maybe<Ref>;
};

/** The connection type for LinkedBranch. */
export type LinkedBranchConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LinkedBranchEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LinkedBranch>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type LinkedBranchEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<LinkedBranch>;
};

/** Autogenerated input type of LockLockable */
export type LockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A reason for why the item will be locked. */
  lockReason?: InputMaybe<LockReason>;
  /** ID of the item to be locked. */
  lockableId: Scalars['ID']['input'];
};

/** Autogenerated return type of LockLockable */
export type LockLockablePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was locked. */
  lockedRecord?: Maybe<Lockable>;
};

/** The possible reasons that an issue or pull request was locked. */
export type LockReason =
  /** The issue or pull request was locked because the conversation was off-topic. */
  | 'OFF_TOPIC'
  /** The issue or pull request was locked because the conversation was resolved. */
  | 'RESOLVED'
  /** The issue or pull request was locked because the conversation was spam. */
  | 'SPAM'
  /** The issue or pull request was locked because the conversation was too heated. */
  | 'TOO_HEATED';

/** An object that can be locked. */
export type Lockable = {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<LockReason>;
  /** `true` if the object is locked */
  locked: Scalars['Boolean']['output'];
};

/** Represents a 'locked' event on a given issue or pull request. */
export type LockedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the LockedEvent object */
  id: Scalars['ID']['output'];
  /** Reason that the conversation was locked (optional). */
  lockReason?: Maybe<LockReason>;
  /** Object that was locked. */
  lockable: Lockable;
};

/** A placeholder user for attribution of imported data on GitHub. */
export type Mannequin = Actor & Node & UniformResourceLocatable & {
  /** A URL pointing to the GitHub App's public avatar. */
  avatarUrl: Scalars['URI']['output'];
  /** The user that has claimed the data attributed to this mannequin. */
  claimant?: Maybe<User>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The mannequin's email on the source instance. */
  email?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the Mannequin object */
  id: Scalars['ID']['output'];
  /** The username of the actor. */
  login: Scalars['String']['output'];
  /** The HTML path to this resource. */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The URL to this resource. */
  url: Scalars['URI']['output'];
};


/** A placeholder user for attribution of imported data on GitHub. */
export type MannequinavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Mannequin. */
export type MannequinConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MannequinEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Mannequin>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a mannequin. */
export type MannequinEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Mannequin>;
};

/** Ordering options for mannequins. */
export type MannequinOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order mannequins by. */
  field: MannequinOrderField;
};

/** Properties by which mannequins can be ordered. */
export type MannequinOrderField =
  /** Order mannequins why when they were created. */
  | 'CREATED_AT'
  /** Order mannequins alphabetically by their source login. */
  | 'LOGIN';

/** Autogenerated input type of MarkDiscussionCommentAsAnswer */
export type MarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion comment to mark as an answer. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of MarkDiscussionCommentAsAnswer */
export type MarkDiscussionCommentAsAnswerPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that includes the chosen comment. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of MarkFileAsViewed */
export type MarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The path of the file to mark as viewed */
  path: Scalars['String']['input'];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of MarkFileAsViewed */
export type MarkFileAsViewedPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request. */
  pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of MarkProjectV2AsTemplate */
export type MarkProjectV2AsTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to mark as a template. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of MarkProjectV2AsTemplate */
export type MarkProjectV2AsTemplatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The project. */
  projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of MarkPullRequestReadyForReview */
export type MarkPullRequestReadyForReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to be marked as ready for review. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of MarkPullRequestReadyForReview */
export type MarkPullRequestReadyForReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that is ready for review. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
export type MarkedAsDuplicateEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** The authoritative issue or pull request which has been duplicated by another. */
  canonical?: Maybe<IssueOrPullRequest>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The issue or pull request which has been marked as a duplicate of another. */
  duplicate?: Maybe<IssueOrPullRequest>;
  /** The Node ID of the MarkedAsDuplicateEvent object */
  id: Scalars['ID']['output'];
  /** Canonical and duplicate belong to different repositories. */
  isCrossRepository: Scalars['Boolean']['output'];
};

/** A public description of a Marketplace category. */
export type MarketplaceCategory = Node & {
  /** The category's description. */
  description?: Maybe<Scalars['String']['output']>;
  /** The technical description of how apps listed in this category work with GitHub. */
  howItWorks?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the MarketplaceCategory object */
  id: Scalars['ID']['output'];
  /** The category's name. */
  name: Scalars['String']['output'];
  /** How many Marketplace listings have this as their primary category. */
  primaryListingCount: Scalars['Int']['output'];
  /** The HTTP path for this Marketplace category. */
  resourcePath: Scalars['URI']['output'];
  /** How many Marketplace listings have this as their secondary category. */
  secondaryListingCount: Scalars['Int']['output'];
  /** The short name of the category used in its URL. */
  slug: Scalars['String']['output'];
  /** The HTTP URL for this Marketplace category. */
  url: Scalars['URI']['output'];
};

/** A listing in the GitHub integration marketplace. */
export type MarketplaceListing = Node & {
  /** The GitHub App this listing represents. */
  app?: Maybe<App>;
  /** URL to the listing owner's company site. */
  companyUrl?: Maybe<Scalars['URI']['output']>;
  /** The HTTP path for configuring access to the listing's integration or OAuth app */
  configurationResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for configuring access to the listing's integration or OAuth app */
  configurationUrl: Scalars['URI']['output'];
  /** URL to the listing's documentation. */
  documentationUrl?: Maybe<Scalars['URI']['output']>;
  /** The listing's detailed description. */
  extendedDescription?: Maybe<Scalars['String']['output']>;
  /** The listing's detailed description rendered to HTML. */
  extendedDescriptionHTML: Scalars['HTML']['output'];
  /** The listing's introductory description. */
  fullDescription: Scalars['String']['output'];
  /** The listing's introductory description rendered to HTML. */
  fullDescriptionHTML: Scalars['HTML']['output'];
  /** Does this listing have any plans with a free trial? */
  hasPublishedFreeTrialPlans: Scalars['Boolean']['output'];
  /** Does this listing have a terms of service link? */
  hasTermsOfService: Scalars['Boolean']['output'];
  /** Whether the creator of the app is a verified org */
  hasVerifiedOwner: Scalars['Boolean']['output'];
  /** A technical description of how this app works with GitHub. */
  howItWorks?: Maybe<Scalars['String']['output']>;
  /** The listing's technical description rendered to HTML. */
  howItWorksHTML: Scalars['HTML']['output'];
  /** The Node ID of the MarketplaceListing object */
  id: Scalars['ID']['output'];
  /** URL to install the product to the viewer's account or organization. */
  installationUrl?: Maybe<Scalars['URI']['output']>;
  /** Whether this listing's app has been installed for the current viewer */
  installedForViewer: Scalars['Boolean']['output'];
  /** Whether this listing has been removed from the Marketplace. */
  isArchived: Scalars['Boolean']['output'];
  /**
   * Whether this listing is still an editable draft that has not been submitted
   * for review and is not publicly visible in the Marketplace.
   */
  isDraft: Scalars['Boolean']['output'];
  /** Whether the product this listing represents is available as part of a paid plan. */
  isPaid: Scalars['Boolean']['output'];
  /** Whether this listing has been approved for display in the Marketplace. */
  isPublic: Scalars['Boolean']['output'];
  /** Whether this listing has been rejected by GitHub for display in the Marketplace. */
  isRejected: Scalars['Boolean']['output'];
  /** Whether this listing has been approved for unverified display in the Marketplace. */
  isUnverified: Scalars['Boolean']['output'];
  /** Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace. */
  isUnverifiedPending: Scalars['Boolean']['output'];
  /** Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromDraft: Scalars['Boolean']['output'];
  /** Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromUnverified: Scalars['Boolean']['output'];
  /** Whether this listing has been approved for verified display in the Marketplace. */
  isVerified: Scalars['Boolean']['output'];
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars['String']['output'];
  /** URL for the listing's logo image. */
  logoUrl?: Maybe<Scalars['URI']['output']>;
  /** The listing's full name. */
  name: Scalars['String']['output'];
  /** The listing's very short description without a trailing period or ampersands. */
  normalizedShortDescription: Scalars['String']['output'];
  /** URL to the listing's detailed pricing. */
  pricingUrl?: Maybe<Scalars['URI']['output']>;
  /** The category that best describes the listing. */
  primaryCategory: MarketplaceCategory;
  /** URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL. */
  privacyPolicyUrl: Scalars['URI']['output'];
  /** The HTTP path for the Marketplace listing. */
  resourcePath: Scalars['URI']['output'];
  /** The URLs for the listing's screenshots. */
  screenshotUrls: Array<Maybe<Scalars['String']['output']>>;
  /** An alternate category that describes the listing. */
  secondaryCategory?: Maybe<MarketplaceCategory>;
  /** The listing's very short description. */
  shortDescription: Scalars['String']['output'];
  /** The short name of the listing used in its URL. */
  slug: Scalars['String']['output'];
  /** URL to the listing's status page. */
  statusUrl?: Maybe<Scalars['URI']['output']>;
  /** An email address for support for this listing's app. */
  supportEmail?: Maybe<Scalars['String']['output']>;
  /**
   * Either a URL or an email address for support for this listing's app, may
   * return an empty string for listings that do not require a support URL.
   */
  supportUrl: Scalars['URI']['output'];
  /** URL to the listing's terms of service. */
  termsOfServiceUrl?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the Marketplace listing. */
  url: Scalars['URI']['output'];
  /** Can the current viewer add plans for this Marketplace listing. */
  viewerCanAddPlans: Scalars['Boolean']['output'];
  /** Can the current viewer approve this Marketplace listing. */
  viewerCanApprove: Scalars['Boolean']['output'];
  /** Can the current viewer delist this Marketplace listing. */
  viewerCanDelist: Scalars['Boolean']['output'];
  /** Can the current viewer edit this Marketplace listing. */
  viewerCanEdit: Scalars['Boolean']['output'];
  /**
   * Can the current viewer edit the primary and secondary category of this
   * Marketplace listing.
   */
  viewerCanEditCategories: Scalars['Boolean']['output'];
  /** Can the current viewer edit the plans for this Marketplace listing. */
  viewerCanEditPlans: Scalars['Boolean']['output'];
  /**
   * Can the current viewer return this Marketplace listing to draft state
   * so it becomes editable again.
   */
  viewerCanRedraft: Scalars['Boolean']['output'];
  /**
   * Can the current viewer reject this Marketplace listing by returning it to
   * an editable draft state or rejecting it entirely.
   */
  viewerCanReject: Scalars['Boolean']['output'];
  /**
   * Can the current viewer request this listing be reviewed for display in
   * the Marketplace as verified.
   */
  viewerCanRequestApproval: Scalars['Boolean']['output'];
  /** Indicates whether the current user has an active subscription to this Marketplace listing. */
  viewerHasPurchased: Scalars['Boolean']['output'];
  /**
   * Indicates if the current user has purchased a subscription to this Marketplace listing
   * for all of the organizations the user owns.
   */
  viewerHasPurchasedForAllOrganizations: Scalars['Boolean']['output'];
  /** Does the current viewer role allow them to administer this Marketplace listing. */
  viewerIsListingAdmin: Scalars['Boolean']['output'];
};


/** A listing in the GitHub integration marketplace. */
export type MarketplaceListinglogoUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** Look up Marketplace Listings */
export type MarketplaceListingConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MarketplaceListingEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MarketplaceListing>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type MarketplaceListingEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MarketplaceListing>;
};

/** Represents a member feature request notification */
export type MemberFeatureRequestNotification = Node & {
  /** Represents member feature request body containing organization name and the number of feature requests */
  body: Scalars['String']['output'];
  /** The Node ID of the MemberFeatureRequestNotification object */
  id: Scalars['ID']['output'];
  /** Represents member feature request notification title */
  title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** Entities that have members who can set status messages. */
export type MemberStatusable = {
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: UserStatusConnection;
};


/** Entities that have members who can set status messages. */
export type MemberStatusablememberStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserStatusOrder>;
};

/** Audit log entry for a members_can_delete_repos.clear event. */
export type MembersCanDeleteReposClearAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  /** The Node ID of the MembersCanDeleteReposClearAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a members_can_delete_repos.disable event. */
export type MembersCanDeleteReposDisableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  /** The Node ID of the MembersCanDeleteReposDisableAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a members_can_delete_repos.enable event. */
export type MembersCanDeleteReposEnableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  /** The Node ID of the MembersCanDeleteReposEnableAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Represents a 'mentioned' event on a given issue or pull request. */
export type MentionedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the MentionedEvent object */
  id: Scalars['ID']['output'];
};

/** Autogenerated input type of MergeBranch */
export type MergeBranchInput = {
  /** The email address to associate with this commit. */
  authorEmail?: InputMaybe<Scalars['String']['input']>;
  /** The name of the base branch that the provided head will be merged into. */
  base: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Message to use for the merge commit. If omitted, a default will be used. */
  commitMessage?: InputMaybe<Scalars['String']['input']>;
  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */
  head: Scalars['String']['input'];
  /** The Node ID of the Repository containing the base branch that will be modified. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of MergeBranch */
export type MergeBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The resulting merge Commit. */
  mergeCommit?: Maybe<Commit>;
};

/** The possible default commit messages for merges. */
export type MergeCommitMessage =
  /** Default to a blank commit message. */
  | 'BLANK'
  /** Default to the pull request's body. */
  | 'PR_BODY'
  /** Default to the pull request's title. */
  | 'PR_TITLE';

/** The possible default commit titles for merges. */
export type MergeCommitTitle =
  /** Default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name). */
  | 'MERGE_MESSAGE'
  /** Default to the pull request's title. */
  | 'PR_TITLE';

/** Autogenerated input type of MergePullRequest */
export type MergePullRequestInput = {
  /** The email address to associate with this merge. */
  authorEmail?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Commit body to use for the merge commit; if omitted, a default message will be used */
  commitBody?: InputMaybe<Scalars['String']['input']>;
  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */
  commitHeadline?: InputMaybe<Scalars['String']['input']>;
  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */
  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  mergeMethod?: InputMaybe<PullRequestMergeMethod>;
  /** ID of the pull request to be merged. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of MergePullRequest */
export type MergePullRequestPayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that was merged. */
  pullRequest?: Maybe<PullRequest>;
};

/** The queue of pull request entries to be merged into a protected branch in a repository. */
export type MergeQueue = Node & {
  /** The configuration for this merge queue */
  configuration?: Maybe<MergeQueueConfiguration>;
  /** The entries in the queue */
  entries?: Maybe<MergeQueueEntryConnection>;
  /** The Node ID of the MergeQueue object */
  id: Scalars['ID']['output'];
  /** The estimated time in seconds until a newly added entry would be merged */
  nextEntryEstimatedTimeToMerge?: Maybe<Scalars['Int']['output']>;
  /** The repository this merge queue belongs to */
  repository?: Maybe<Repository>;
  /** The HTTP path for this merge queue */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this merge queue */
  url: Scalars['URI']['output'];
};


/** The queue of pull request entries to be merged into a protected branch in a repository. */
export type MergeQueueentriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Configuration for a MergeQueue */
export type MergeQueueConfiguration = {
  /** The amount of time in minutes to wait for a check response before considering it a failure. */
  checkResponseTimeout?: Maybe<Scalars['Int']['output']>;
  /** The maximum number of entries to build at once. */
  maximumEntriesToBuild?: Maybe<Scalars['Int']['output']>;
  /** The maximum number of entries to merge at once. */
  maximumEntriesToMerge?: Maybe<Scalars['Int']['output']>;
  /** The merge method to use for this queue. */
  mergeMethod?: Maybe<PullRequestMergeMethod>;
  /** The strategy to use when merging entries. */
  mergingStrategy?: Maybe<MergeQueueMergingStrategy>;
  /** The minimum number of entries required to merge at once. */
  minimumEntriesToMerge?: Maybe<Scalars['Int']['output']>;
  /**
   * The amount of time in minutes to wait before ignoring the minumum number of
   * entries in the queue requirement and merging a collection of entries
   */
  minimumEntriesToMergeWaitTime?: Maybe<Scalars['Int']['output']>;
};

/** Entries in a MergeQueue */
export type MergeQueueEntry = Node & {
  /** The base commit for this entry */
  baseCommit?: Maybe<Commit>;
  /** The date and time this entry was added to the merge queue */
  enqueuedAt: Scalars['DateTime']['output'];
  /** The actor that enqueued this entry */
  enqueuer: Actor;
  /** The estimated time in seconds until this entry will be merged */
  estimatedTimeToMerge?: Maybe<Scalars['Int']['output']>;
  /** The head commit for this entry */
  headCommit?: Maybe<Commit>;
  /** The Node ID of the MergeQueueEntry object */
  id: Scalars['ID']['output'];
  /** Whether this pull request should jump the queue */
  jump: Scalars['Boolean']['output'];
  /** The merge queue that this entry belongs to */
  mergeQueue?: Maybe<MergeQueue>;
  /** The position of this entry in the queue */
  position: Scalars['Int']['output'];
  /** The pull request that will be added to a merge group */
  pullRequest?: Maybe<PullRequest>;
  /** Does this pull request need to be deployed on its own */
  solo: Scalars['Boolean']['output'];
  /** The state of this entry in the queue */
  state: MergeQueueEntryState;
};

/** The connection type for MergeQueueEntry. */
export type MergeQueueEntryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeQueueEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeQueueEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type MergeQueueEntryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeQueueEntry>;
};

/** The possible states for a merge queue entry. */
export type MergeQueueEntryState =
  /** The entry is currently waiting for checks to pass. */
  | 'AWAITING_CHECKS'
  /** The entry is currently locked. */
  | 'LOCKED'
  /** The entry is currently mergeable. */
  | 'MERGEABLE'
  /** The entry is currently queued. */
  | 'QUEUED'
  /** The entry is currently unmergeable. */
  | 'UNMERGEABLE';

/** The possible merging strategies for a merge queue. */
export type MergeQueueMergingStrategy =
  /** Entries only allowed to merge if they are passing. */
  | 'ALLGREEN'
  /** Failing Entires are allowed to merge if they are with a passing entry. */
  | 'HEADGREEN';

/** Detailed status information about a pull request merge. */
export type MergeStateStatus =
  /** The head ref is out of date. */
  | 'BEHIND'
  /** The merge is blocked. */
  | 'BLOCKED'
  /** Mergeable and passing commit status. */
  | 'CLEAN'
  /** The merge commit cannot be cleanly created. */
  | 'DIRTY'
  /** The merge is blocked due to the pull request being a draft. */
  | 'DRAFT'
  /** Mergeable with passing commit status and pre-receive hooks. */
  | 'HAS_HOOKS'
  /** The state cannot currently be determined. */
  | 'UNKNOWN'
  /** Mergeable with non-passing commit status. */
  | 'UNSTABLE';

/** Whether or not a PullRequest can be merged. */
export type MergeableState =
  /** The pull request cannot be merged due to merge conflicts. */
  | 'CONFLICTING'
  /** The pull request can be merged. */
  | 'MERGEABLE'
  /** The mergeability of the pull request is still being calculated. */
  | 'UNKNOWN';

/** Represents a 'merged' event on a given pull request. */
export type MergedEvent = Node & UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the commit associated with the `merge` event. */
  commit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the MergedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the Ref associated with the `merge` event. */
  mergeRef?: Maybe<Ref>;
  /** Identifies the name of the Ref associated with the `merge` event. */
  mergeRefName: Scalars['String']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** The HTTP path for this merged event. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this merged event. */
  url: Scalars['URI']['output'];
};

/** Represents a GitHub Enterprise Importer (GEI) migration. */
export type Migration = {
  /** The migration flag to continue on error. */
  continueOnError: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['String']['output']>;
  /** The reason the migration failed. */
  failureReason?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the Migration object */
  id: Scalars['ID']['output'];
  /** The URL for the migration log (expires 1 day after migration completes). */
  migrationLogUrl?: Maybe<Scalars['URI']['output']>;
  /** The migration source. */
  migrationSource: MigrationSource;
  /** The target repository name. */
  repositoryName: Scalars['String']['output'];
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  sourceUrl: Scalars['URI']['output'];
  /** The migration state. */
  state: MigrationState;
  /**
   * The number of warnings encountered for this migration. To review the warnings,
   * check the [Migration Log](https://docs.github.com/en/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).
   */
  warningsCount: Scalars['Int']['output'];
};

/** A GitHub Enterprise Importer (GEI) migration source. */
export type MigrationSource = Node & {
  /** The Node ID of the MigrationSource object */
  id: Scalars['ID']['output'];
  /** The migration source name. */
  name: Scalars['String']['output'];
  /** The migration source type. */
  type: MigrationSourceType;
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  url: Scalars['URI']['output'];
};

/** Represents the different GitHub Enterprise Importer (GEI) migration sources. */
export type MigrationSourceType =
  /** An Azure DevOps migration source. */
  | 'AZURE_DEVOPS'
  /** A Bitbucket Server migration source. */
  | 'BITBUCKET_SERVER'
  /** A GitHub Migration API source. */
  | 'GITHUB_ARCHIVE';

/** The GitHub Enterprise Importer (GEI) migration state. */
export type MigrationState =
  /** The migration has failed. */
  | 'FAILED'
  /** The migration has invalid credentials. */
  | 'FAILED_VALIDATION'
  /** The migration is in progress. */
  | 'IN_PROGRESS'
  /** The migration has not started. */
  | 'NOT_STARTED'
  /** The migration needs to have its credentials validated. */
  | 'PENDING_VALIDATION'
  /** The migration has been queued. */
  | 'QUEUED'
  /** The migration has succeeded. */
  | 'SUCCEEDED';

/** Represents a Milestone object on a given repository. */
export type Milestone = Closable & Node & UniformResourceLocatable & {
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the actor who created the milestone. */
  creator?: Maybe<Actor>;
  /** Identifies the description of the milestone. */
  description?: Maybe<Scalars['String']['output']>;
  /** Identifies the due date of the milestone. */
  dueOn?: Maybe<Scalars['DateTime']['output']>;
  /** The Node ID of the Milestone object */
  id: Scalars['ID']['output'];
  /** A list of issues associated with the milestone. */
  issues: IssueConnection;
  /** Identifies the number of the milestone. */
  number: Scalars['Int']['output'];
  /** Identifies the percentage complete for the milestone */
  progressPercentage: Scalars['Float']['output'];
  /** A list of pull requests associated with the milestone. */
  pullRequests: PullRequestConnection;
  /** The repository associated with this milestone. */
  repository: Repository;
  /** The HTTP path for this milestone */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the state of the milestone. */
  state: MilestoneState;
  /** Identifies the title of the milestone. */
  title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this milestone */
  url: Scalars['URI']['output'];
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
};


/** Represents a Milestone object on a given repository. */
export type MilestoneissuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<IssueFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<IssueState>>;
};


/** Represents a Milestone object on a given repository. */
export type MilestonepullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<PullRequestState>>;
};

/** The connection type for Milestone. */
export type MilestoneConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MilestoneEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Milestone>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type MilestoneEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Milestone>;
};

/** Types that can be inside a Milestone. */
export type MilestoneItem = Issue | PullRequest;

/** Ordering options for milestone connections. */
export type MilestoneOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order milestones by. */
  field: MilestoneOrderField;
};

/** Properties by which milestone connections can be ordered. */
export type MilestoneOrderField =
  /** Order milestones by when they were created. */
  | 'CREATED_AT'
  /** Order milestones by when they are due. */
  | 'DUE_DATE'
  /** Order milestones by their number. */
  | 'NUMBER'
  /** Order milestones by when they were last updated. */
  | 'UPDATED_AT';

/** The possible states of a milestone. */
export type MilestoneState =
  /** A milestone that has been closed. */
  | 'CLOSED'
  /** A milestone that is still open. */
  | 'OPEN';

/** Represents a 'milestoned' event on a given issue or pull request. */
export type MilestonedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the MilestonedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the milestone title associated with the 'milestoned' event. */
  milestoneTitle: Scalars['String']['output'];
  /** Object referenced by event. */
  subject: MilestoneItem;
};

/** Entities that can be minimized. */
export type Minimizable = {
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
};

/** Autogenerated input type of MinimizeComment */
export type MinimizeCommentInput = {
  /** The classification of comment */
  classifier: ReportedContentClassifiers;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of MinimizeComment */
export type MinimizeCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The comment that was minimized. */
  minimizedComment?: Maybe<Minimizable>;
};

/** Autogenerated input type of MoveProjectCard */
export type MoveProjectCardInput = {
  /** Place the new card after the card with this id. Pass null to place it at the top. */
  afterCardId?: InputMaybe<Scalars['ID']['input']>;
  /** The id of the card to move. */
  cardId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the column to move it into. */
  columnId: Scalars['ID']['input'];
};

/** Autogenerated return type of MoveProjectCard */
export type MoveProjectCardPayload = {
  /** The new edge of the moved card. */
  cardEdge?: Maybe<ProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of MoveProjectColumn */
export type MoveProjectColumnInput = {
  /** Place the new column after the column with this id. Pass null to place it at the front. */
  afterColumnId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the column to move. */
  columnId: Scalars['ID']['input'];
};

/** Autogenerated return type of MoveProjectColumn */
export type MoveProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new edge of the moved column. */
  columnEdge?: Maybe<ProjectColumnEdge>;
};

/** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
export type MovedColumnsInProjectEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the MovedColumnsInProjectEvent object */
  id: Scalars['ID']['output'];
  /** Column name the issue or pull request was moved from. */
  previousProjectColumnName: Scalars['String']['output'];
  /** Project referenced by event. */
  project?: Maybe<Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<ProjectCard>;
  /** Column name the issue or pull request was moved to. */
  projectColumnName: Scalars['String']['output'];
};

/** The root query for implementing GraphQL mutations. */
export type Mutation = {
  /** Clear all of a customer's queued migrations */
  abortQueuedMigrations?: Maybe<AbortQueuedMigrationsPayload>;
  /** Abort a repository migration queued or in progress. */
  abortRepositoryMigration?: Maybe<AbortRepositoryMigrationPayload>;
  /** Accepts a pending invitation for a user to become an administrator of an enterprise. */
  acceptEnterpriseAdministratorInvitation?: Maybe<AcceptEnterpriseAdministratorInvitationPayload>;
  /** Applies a suggested topic to the repository. */
  acceptTopicSuggestion?: Maybe<AcceptTopicSuggestionPayload>;
  /** Adds assignees to an assignable object. */
  addAssigneesToAssignable?: Maybe<AddAssigneesToAssignablePayload>;
  /** Adds a comment to an Issue or Pull Request. */
  addComment?: Maybe<AddCommentPayload>;
  /** Adds a comment to a Discussion, possibly as a reply to another comment. */
  addDiscussionComment?: Maybe<AddDiscussionCommentPayload>;
  /** Vote for an option in a discussion poll. */
  addDiscussionPollVote?: Maybe<AddDiscussionPollVotePayload>;
  /** Adds enterprise members to an organization within the enterprise. */
  addEnterpriseOrganizationMember?: Maybe<AddEnterpriseOrganizationMemberPayload>;
  /** Adds a support entitlement to an enterprise member. */
  addEnterpriseSupportEntitlement?: Maybe<AddEnterpriseSupportEntitlementPayload>;
  /** Adds labels to a labelable object. */
  addLabelsToLabelable?: Maybe<AddLabelsToLabelablePayload>;
  /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */
  addProjectCard?: Maybe<AddProjectCardPayload>;
  /** Adds a column to a Project. */
  addProjectColumn?: Maybe<AddProjectColumnPayload>;
  /** Creates a new draft issue and add it to a Project. */
  addProjectV2DraftIssue?: Maybe<AddProjectV2DraftIssuePayload>;
  /** Links an existing content instance to a Project. */
  addProjectV2ItemById?: Maybe<AddProjectV2ItemByIdPayload>;
  /** Adds a review to a Pull Request. */
  addPullRequestReview?: Maybe<AddPullRequestReviewPayload>;
  /** Adds a comment to a review. */
  addPullRequestReviewComment?: Maybe<AddPullRequestReviewCommentPayload>;
  /** Adds a new thread to a pending Pull Request Review. */
  addPullRequestReviewThread?: Maybe<AddPullRequestReviewThreadPayload>;
  /** Adds a reply to an existing Pull Request Review Thread. */
  addPullRequestReviewThreadReply?: Maybe<AddPullRequestReviewThreadReplyPayload>;
  /** Adds a reaction to a subject. */
  addReaction?: Maybe<AddReactionPayload>;
  /** Adds a star to a Starrable. */
  addStar?: Maybe<AddStarPayload>;
  /** Add an upvote to a discussion or discussion comment. */
  addUpvote?: Maybe<AddUpvotePayload>;
  /** Adds a verifiable domain to an owning account. */
  addVerifiableDomain?: Maybe<AddVerifiableDomainPayload>;
  /** Approve all pending deployments under one or more environments */
  approveDeployments?: Maybe<ApproveDeploymentsPayload>;
  /** Approve a verifiable domain for notification delivery. */
  approveVerifiableDomain?: Maybe<ApproveVerifiableDomainPayload>;
  /** Archives a ProjectV2Item */
  archiveProjectV2Item?: Maybe<ArchiveProjectV2ItemPayload>;
  /** Marks a repository as archived. */
  archiveRepository?: Maybe<ArchiveRepositoryPayload>;
  /** Cancels a pending invitation for an administrator to join an enterprise. */
  cancelEnterpriseAdminInvitation?: Maybe<CancelEnterpriseAdminInvitationPayload>;
  /** Cancel an active sponsorship. */
  cancelSponsorship?: Maybe<CancelSponsorshipPayload>;
  /** Update your status on GitHub. */
  changeUserStatus?: Maybe<ChangeUserStatusPayload>;
  /** Clears all labels from a labelable object. */
  clearLabelsFromLabelable?: Maybe<ClearLabelsFromLabelablePayload>;
  /**
   * This mutation clears the value of a field for an item in a Project. Currently
   * only text, number, date, assignees, labels, single-select, iteration and
   * milestone fields are supported.
   */
  clearProjectV2ItemFieldValue?: Maybe<ClearProjectV2ItemFieldValuePayload>;
  /** Creates a new project by cloning configuration from an existing project. */
  cloneProject?: Maybe<CloneProjectPayload>;
  /** Create a new repository with the same files and directory structure as a template repository. */
  cloneTemplateRepository?: Maybe<CloneTemplateRepositoryPayload>;
  /** Close a discussion. */
  closeDiscussion?: Maybe<CloseDiscussionPayload>;
  /** Close an issue. */
  closeIssue?: Maybe<CloseIssuePayload>;
  /** Close a pull request. */
  closePullRequest?: Maybe<ClosePullRequestPayload>;
  /** Convert a project note card to one associated with a newly created issue. */
  convertProjectCardNoteToIssue?: Maybe<ConvertProjectCardNoteToIssuePayload>;
  /** Converts a pull request to draft */
  convertPullRequestToDraft?: Maybe<ConvertPullRequestToDraftPayload>;
  /** Copy a project. */
  copyProjectV2?: Maybe<CopyProjectV2Payload>;
  /** Invites a user to claim reattributable data */
  createAttributionInvitation?: Maybe<CreateAttributionInvitationPayload>;
  /** Create a new branch protection rule */
  createBranchProtectionRule?: Maybe<CreateBranchProtectionRulePayload>;
  /** Create a check run. */
  createCheckRun?: Maybe<CreateCheckRunPayload>;
  /** Create a check suite */
  createCheckSuite?: Maybe<CreateCheckSuitePayload>;
  /**
   * Appends a commit to the given branch as the authenticated user.
   *
   * This mutation creates a commit whose parent is the HEAD of the provided
   * branch and also updates that branch to point to the new commit.
   * It can be thought of as similar to `git commit`.
   *
   * ### Locating a Branch
   *
   * Commits are appended to a `branch` of type `Ref`.
   * This must refer to a git branch (i.e.  the fully qualified path must
   * begin with `refs/heads/`, although including this prefix is optional.
   *
   * Callers may specify the `branch` to commit to either by its global node
   * ID or by passing both of `repositoryNameWithOwner` and `refName`.  For
   * more details see the documentation for `CommittableBranch`.
   *
   * ### Describing Changes
   *
   * `fileChanges` are specified as a `FilesChanges` object describing
   * `FileAdditions` and `FileDeletions`.
   *
   * Please see the documentation for `FileChanges` for more information on
   * how to use this argument to describe any set of file changes.
   *
   * ### Authorship
   *
   * Similar to the web commit interface, this mutation does not support
   * specifying the author or committer of the commit and will not add
   * support for this in the future.
   *
   * A commit created by a successful execution of this mutation will be
   * authored by the owner of the credential which authenticates the API
   * request.  The committer will be identical to that of commits authored
   * using the web interface.
   *
   * If you need full control over author and committer information, please
   * use the Git Database REST API instead.
   *
   * ### Commit Signing
   *
   * Commits made using this mutation are automatically signed by GitHub if
   * supported and will be marked as verified in the user interface.
   */
  createCommitOnBranch?: Maybe<CreateCommitOnBranchPayload>;
  /** Creates a new deployment event. */
  createDeployment?: Maybe<CreateDeploymentPayload>;
  /** Create a deployment status. */
  createDeploymentStatus?: Maybe<CreateDeploymentStatusPayload>;
  /** Create a discussion. */
  createDiscussion?: Maybe<CreateDiscussionPayload>;
  /**
   * Creates an organization as part of an enterprise account. A personal access
   * token used to create an organization is implicitly permitted to update the
   * organization it created, if the organization is part of an enterprise that has
   * SAML enabled or uses Enterprise Managed Users. If the organization is not part
   * of such an enterprise, and instead has SAML enabled for it individually, the
   * token will then require SAML authorization to continue working against that organization.
   */
  createEnterpriseOrganization?: Maybe<CreateEnterpriseOrganizationPayload>;
  /** Creates an environment or simply returns it if already exists. */
  createEnvironment?: Maybe<CreateEnvironmentPayload>;
  /** Creates a new IP allow list entry. */
  createIpAllowListEntry?: Maybe<CreateIpAllowListEntryPayload>;
  /** Creates a new issue. */
  createIssue?: Maybe<CreateIssuePayload>;
  /** Creates a new label. */
  createLabel?: Maybe<CreateLabelPayload>;
  /** Create a branch linked to an issue. */
  createLinkedBranch?: Maybe<CreateLinkedBranchPayload>;
  /** Creates a GitHub Enterprise Importer (GEI) migration source. */
  createMigrationSource?: Maybe<CreateMigrationSourcePayload>;
  /** Creates a new project. */
  createProject?: Maybe<CreateProjectPayload>;
  /** Creates a new project. */
  createProjectV2?: Maybe<CreateProjectV2Payload>;
  /** Create a new project field. */
  createProjectV2Field?: Maybe<CreateProjectV2FieldPayload>;
  /** Create a new pull request */
  createPullRequest?: Maybe<CreatePullRequestPayload>;
  /** Create a new Git Ref. */
  createRef?: Maybe<CreateRefPayload>;
  /** Create a new repository. */
  createRepository?: Maybe<CreateRepositoryPayload>;
  /** Create a repository ruleset */
  createRepositoryRuleset?: Maybe<CreateRepositoryRulesetPayload>;
  /** Create a GitHub Sponsors profile to allow others to sponsor you or your organization. */
  createSponsorsListing?: Maybe<CreateSponsorsListingPayload>;
  /** Create a new payment tier for your GitHub Sponsors profile. */
  createSponsorsTier?: Maybe<CreateSponsorsTierPayload>;
  /** Start a new sponsorship of a maintainer in GitHub Sponsors, or reactivate a past sponsorship. */
  createSponsorship?: Maybe<CreateSponsorshipPayload>;
  /**
   * Make many one-time sponsorships for different sponsorable users or
   * organizations at once. Can only sponsor those who have a public GitHub
   * Sponsors profile.
   */
  createSponsorships?: Maybe<CreateSponsorshipsPayload>;
  /** Creates a new team discussion. */
  createTeamDiscussion?: Maybe<CreateTeamDiscussionPayload>;
  /** Creates a new team discussion comment. */
  createTeamDiscussionComment?: Maybe<CreateTeamDiscussionCommentPayload>;
  /** Creates a new user list. */
  createUserList?: Maybe<CreateUserListPayload>;
  /** Rejects a suggested topic for the repository. */
  declineTopicSuggestion?: Maybe<DeclineTopicSuggestionPayload>;
  /** Delete a branch protection rule */
  deleteBranchProtectionRule?: Maybe<DeleteBranchProtectionRulePayload>;
  /** Deletes a deployment. */
  deleteDeployment?: Maybe<DeleteDeploymentPayload>;
  /** Delete a discussion and all of its replies. */
  deleteDiscussion?: Maybe<DeleteDiscussionPayload>;
  /** Delete a discussion comment. If it has replies, wipe it instead. */
  deleteDiscussionComment?: Maybe<DeleteDiscussionCommentPayload>;
  /** Deletes an environment */
  deleteEnvironment?: Maybe<DeleteEnvironmentPayload>;
  /** Deletes an IP allow list entry. */
  deleteIpAllowListEntry?: Maybe<DeleteIpAllowListEntryPayload>;
  /** Deletes an Issue object. */
  deleteIssue?: Maybe<DeleteIssuePayload>;
  /** Deletes an IssueComment object. */
  deleteIssueComment?: Maybe<DeleteIssueCommentPayload>;
  /** Deletes a label. */
  deleteLabel?: Maybe<DeleteLabelPayload>;
  /** Unlink a branch from an issue. */
  deleteLinkedBranch?: Maybe<DeleteLinkedBranchPayload>;
  /** Delete a package version. */
  deletePackageVersion?: Maybe<DeletePackageVersionPayload>;
  /** Deletes a project. */
  deleteProject?: Maybe<DeleteProjectPayload>;
  /** Deletes a project card. */
  deleteProjectCard?: Maybe<DeleteProjectCardPayload>;
  /** Deletes a project column. */
  deleteProjectColumn?: Maybe<DeleteProjectColumnPayload>;
  /** Delete a project. */
  deleteProjectV2?: Maybe<DeleteProjectV2Payload>;
  /** Delete a project field. */
  deleteProjectV2Field?: Maybe<DeleteProjectV2FieldPayload>;
  /** Deletes an item from a Project. */
  deleteProjectV2Item?: Maybe<DeleteProjectV2ItemPayload>;
  /** Deletes a project workflow. */
  deleteProjectV2Workflow?: Maybe<DeleteProjectV2WorkflowPayload>;
  /** Deletes a pull request review. */
  deletePullRequestReview?: Maybe<DeletePullRequestReviewPayload>;
  /** Deletes a pull request review comment. */
  deletePullRequestReviewComment?: Maybe<DeletePullRequestReviewCommentPayload>;
  /** Delete a Git Ref. */
  deleteRef?: Maybe<DeleteRefPayload>;
  /** Delete a repository ruleset */
  deleteRepositoryRuleset?: Maybe<DeleteRepositoryRulesetPayload>;
  /** Deletes a team discussion. */
  deleteTeamDiscussion?: Maybe<DeleteTeamDiscussionPayload>;
  /** Deletes a team discussion comment. */
  deleteTeamDiscussionComment?: Maybe<DeleteTeamDiscussionCommentPayload>;
  /** Deletes a user list. */
  deleteUserList?: Maybe<DeleteUserListPayload>;
  /** Deletes a verifiable domain. */
  deleteVerifiableDomain?: Maybe<DeleteVerifiableDomainPayload>;
  /** Remove a pull request from the merge queue. */
  dequeuePullRequest?: Maybe<DequeuePullRequestPayload>;
  /** Disable auto merge on the given pull request */
  disablePullRequestAutoMerge?: Maybe<DisablePullRequestAutoMergePayload>;
  /** Dismisses an approved or rejected pull request review. */
  dismissPullRequestReview?: Maybe<DismissPullRequestReviewPayload>;
  /** Dismisses the Dependabot alert. */
  dismissRepositoryVulnerabilityAlert?: Maybe<DismissRepositoryVulnerabilityAlertPayload>;
  /** Enable the default auto-merge on a pull request. */
  enablePullRequestAutoMerge?: Maybe<EnablePullRequestAutoMergePayload>;
  /** Add a pull request to the merge queue. */
  enqueuePullRequest?: Maybe<EnqueuePullRequestPayload>;
  /** Follow an organization. */
  followOrganization?: Maybe<FollowOrganizationPayload>;
  /** Follow a user. */
  followUser?: Maybe<FollowUserPayload>;
  /** Grant the migrator role to a user for all organizations under an enterprise account. */
  grantEnterpriseOrganizationsMigratorRole?: Maybe<GrantEnterpriseOrganizationsMigratorRolePayload>;
  /** Grant the migrator role to a user or a team. */
  grantMigratorRole?: Maybe<GrantMigratorRolePayload>;
  /** Creates a new project by importing columns and a list of issues/PRs. */
  importProject?: Maybe<ImportProjectPayload>;
  /** Invite someone to become an administrator of the enterprise. */
  inviteEnterpriseAdmin?: Maybe<InviteEnterpriseAdminPayload>;
  /** Links a project to a repository. */
  linkProjectV2ToRepository?: Maybe<LinkProjectV2ToRepositoryPayload>;
  /** Links a project to a team. */
  linkProjectV2ToTeam?: Maybe<LinkProjectV2ToTeamPayload>;
  /** Creates a repository link for a project. */
  linkRepositoryToProject?: Maybe<LinkRepositoryToProjectPayload>;
  /** Lock a lockable object */
  lockLockable?: Maybe<LockLockablePayload>;
  /** Mark a discussion comment as the chosen answer for discussions in an answerable category. */
  markDiscussionCommentAsAnswer?: Maybe<MarkDiscussionCommentAsAnswerPayload>;
  /** Mark a pull request file as viewed */
  markFileAsViewed?: Maybe<MarkFileAsViewedPayload>;
  /** Mark a project as a template. Note that only projects which are owned by an Organization can be marked as a template. */
  markProjectV2AsTemplate?: Maybe<MarkProjectV2AsTemplatePayload>;
  /** Marks a pull request ready for review. */
  markPullRequestReadyForReview?: Maybe<MarkPullRequestReadyForReviewPayload>;
  /** Merge a head into a branch. */
  mergeBranch?: Maybe<MergeBranchPayload>;
  /** Merge a pull request. */
  mergePullRequest?: Maybe<MergePullRequestPayload>;
  /** Minimizes a comment on an Issue, Commit, Pull Request, or Gist */
  minimizeComment?: Maybe<MinimizeCommentPayload>;
  /** Moves a project card to another place. */
  moveProjectCard?: Maybe<MoveProjectCardPayload>;
  /** Moves a project column to another place. */
  moveProjectColumn?: Maybe<MoveProjectColumnPayload>;
  /** Pin an issue to a repository */
  pinIssue?: Maybe<PinIssuePayload>;
  /** Publish an existing sponsorship tier that is currently still a draft to a GitHub Sponsors profile. */
  publishSponsorsTier?: Maybe<PublishSponsorsTierPayload>;
  /** Regenerates the identity provider recovery codes for an enterprise */
  regenerateEnterpriseIdentityProviderRecoveryCodes?: Maybe<RegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;
  /** Regenerates a verifiable domain's verification token. */
  regenerateVerifiableDomainToken?: Maybe<RegenerateVerifiableDomainTokenPayload>;
  /** Reject all pending deployments under one or more environments */
  rejectDeployments?: Maybe<RejectDeploymentsPayload>;
  /** Removes assignees from an assignable object. */
  removeAssigneesFromAssignable?: Maybe<RemoveAssigneesFromAssignablePayload>;
  /** Removes an administrator from the enterprise. */
  removeEnterpriseAdmin?: Maybe<RemoveEnterpriseAdminPayload>;
  /** Removes the identity provider from an enterprise */
  removeEnterpriseIdentityProvider?: Maybe<RemoveEnterpriseIdentityProviderPayload>;
  /** Removes a user from all organizations within the enterprise */
  removeEnterpriseMember?: Maybe<RemoveEnterpriseMemberPayload>;
  /** Removes an organization from the enterprise */
  removeEnterpriseOrganization?: Maybe<RemoveEnterpriseOrganizationPayload>;
  /** Removes a support entitlement from an enterprise member. */
  removeEnterpriseSupportEntitlement?: Maybe<RemoveEnterpriseSupportEntitlementPayload>;
  /** Removes labels from a Labelable object. */
  removeLabelsFromLabelable?: Maybe<RemoveLabelsFromLabelablePayload>;
  /** Removes outside collaborator from all repositories in an organization. */
  removeOutsideCollaborator?: Maybe<RemoveOutsideCollaboratorPayload>;
  /** Removes a reaction from a subject. */
  removeReaction?: Maybe<RemoveReactionPayload>;
  /** Removes a star from a Starrable. */
  removeStar?: Maybe<RemoveStarPayload>;
  /** Remove an upvote to a discussion or discussion comment. */
  removeUpvote?: Maybe<RemoveUpvotePayload>;
  /** Reopen a discussion. */
  reopenDiscussion?: Maybe<ReopenDiscussionPayload>;
  /** Reopen a issue. */
  reopenIssue?: Maybe<ReopenIssuePayload>;
  /** Reopen a pull request. */
  reopenPullRequest?: Maybe<ReopenPullRequestPayload>;
  /** Set review requests on a pull request. */
  requestReviews?: Maybe<RequestReviewsPayload>;
  /** Rerequests an existing check suite. */
  rerequestCheckSuite?: Maybe<RerequestCheckSuitePayload>;
  /** Marks a review thread as resolved. */
  resolveReviewThread?: Maybe<ResolveReviewThreadPayload>;
  /** Retire a published payment tier from your GitHub Sponsors profile so it cannot be used to start new sponsorships. */
  retireSponsorsTier?: Maybe<RetireSponsorsTierPayload>;
  /** Create a pull request that reverts the changes from a merged pull request. */
  revertPullRequest?: Maybe<RevertPullRequestPayload>;
  /** Revoke the migrator role to a user for all organizations under an enterprise account. */
  revokeEnterpriseOrganizationsMigratorRole?: Maybe<RevokeEnterpriseOrganizationsMigratorRolePayload>;
  /** Revoke the migrator role from a user or a team. */
  revokeMigratorRole?: Maybe<RevokeMigratorRolePayload>;
  /** Creates or updates the identity provider for an enterprise. */
  setEnterpriseIdentityProvider?: Maybe<SetEnterpriseIdentityProviderPayload>;
  /** Set an organization level interaction limit for an organization's public repositories. */
  setOrganizationInteractionLimit?: Maybe<SetOrganizationInteractionLimitPayload>;
  /** Sets an interaction limit setting for a repository. */
  setRepositoryInteractionLimit?: Maybe<SetRepositoryInteractionLimitPayload>;
  /** Set a user level interaction limit for an user's public repositories. */
  setUserInteractionLimit?: Maybe<SetUserInteractionLimitPayload>;
  /** Starts a GitHub Enterprise Importer organization migration. */
  startOrganizationMigration?: Maybe<StartOrganizationMigrationPayload>;
  /** Starts a GitHub Enterprise Importer (GEI) repository migration. */
  startRepositoryMigration?: Maybe<StartRepositoryMigrationPayload>;
  /** Submits a pending pull request review. */
  submitPullRequestReview?: Maybe<SubmitPullRequestReviewPayload>;
  /** Transfer an organization from one enterprise to another enterprise. */
  transferEnterpriseOrganization?: Maybe<TransferEnterpriseOrganizationPayload>;
  /** Transfer an issue to a different repository */
  transferIssue?: Maybe<TransferIssuePayload>;
  /** Unarchives a ProjectV2Item */
  unarchiveProjectV2Item?: Maybe<UnarchiveProjectV2ItemPayload>;
  /** Unarchives a repository. */
  unarchiveRepository?: Maybe<UnarchiveRepositoryPayload>;
  /** Unfollow an organization. */
  unfollowOrganization?: Maybe<UnfollowOrganizationPayload>;
  /** Unfollow a user. */
  unfollowUser?: Maybe<UnfollowUserPayload>;
  /** Unlinks a project from a repository. */
  unlinkProjectV2FromRepository?: Maybe<UnlinkProjectV2FromRepositoryPayload>;
  /** Unlinks a project to a team. */
  unlinkProjectV2FromTeam?: Maybe<UnlinkProjectV2FromTeamPayload>;
  /** Deletes a repository link from a project. */
  unlinkRepositoryFromProject?: Maybe<UnlinkRepositoryFromProjectPayload>;
  /** Unlock a lockable object */
  unlockLockable?: Maybe<UnlockLockablePayload>;
  /** Unmark a discussion comment as the chosen answer for discussions in an answerable category. */
  unmarkDiscussionCommentAsAnswer?: Maybe<UnmarkDiscussionCommentAsAnswerPayload>;
  /** Unmark a pull request file as viewed */
  unmarkFileAsViewed?: Maybe<UnmarkFileAsViewedPayload>;
  /** Unmark an issue as a duplicate of another issue. */
  unmarkIssueAsDuplicate?: Maybe<UnmarkIssueAsDuplicatePayload>;
  /** Unmark a project as a template. */
  unmarkProjectV2AsTemplate?: Maybe<UnmarkProjectV2AsTemplatePayload>;
  /** Unminimizes a comment on an Issue, Commit, Pull Request, or Gist */
  unminimizeComment?: Maybe<UnminimizeCommentPayload>;
  /** Unpin a pinned issue from a repository */
  unpinIssue?: Maybe<UnpinIssuePayload>;
  /** Marks a review thread as unresolved. */
  unresolveReviewThread?: Maybe<UnresolveReviewThreadPayload>;
  /** Unsubscribes from notifications */
  unsubscribeFromNotifications?: Maybe<UnsubscribeFromNotificationsPayload>;
  /** Update a branch protection rule */
  updateBranchProtectionRule?: Maybe<UpdateBranchProtectionRulePayload>;
  /** Update a check run */
  updateCheckRun?: Maybe<UpdateCheckRunPayload>;
  /** Modifies the settings of an existing check suite */
  updateCheckSuitePreferences?: Maybe<UpdateCheckSuitePreferencesPayload>;
  /** Update a discussion */
  updateDiscussion?: Maybe<UpdateDiscussionPayload>;
  /** Update the contents of a comment on a Discussion */
  updateDiscussionComment?: Maybe<UpdateDiscussionCommentPayload>;
  /** Updates the role of an enterprise administrator. */
  updateEnterpriseAdministratorRole?: Maybe<UpdateEnterpriseAdministratorRolePayload>;
  /** Sets whether private repository forks are enabled for an enterprise. */
  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Maybe<UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;
  /** Sets the base repository permission for organizations in an enterprise. */
  updateEnterpriseDefaultRepositoryPermissionSetting?: Maybe<UpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;
  /** Sets whether organization members with admin permissions on a repository can change repository visibility. */
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Maybe<UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;
  /** Sets the members can create repositories setting for an enterprise. */
  updateEnterpriseMembersCanCreateRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;
  /** Sets the members can delete issues setting for an enterprise. */
  updateEnterpriseMembersCanDeleteIssuesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;
  /** Sets the members can delete repositories setting for an enterprise. */
  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;
  /** Sets whether members can invite collaborators are enabled for an enterprise. */
  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Maybe<UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;
  /** Sets whether or not an organization owner can make purchases. */
  updateEnterpriseMembersCanMakePurchasesSetting?: Maybe<UpdateEnterpriseMembersCanMakePurchasesSettingPayload>;
  /** Sets the members can update protected branches setting for an enterprise. */
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Maybe<UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;
  /** Sets the members can view dependency insights for an enterprise. */
  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Maybe<UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;
  /** Sets whether organization projects are enabled for an enterprise. */
  updateEnterpriseOrganizationProjectsSetting?: Maybe<UpdateEnterpriseOrganizationProjectsSettingPayload>;
  /** Updates the role of an enterprise owner with an organization. */
  updateEnterpriseOwnerOrganizationRole?: Maybe<UpdateEnterpriseOwnerOrganizationRolePayload>;
  /** Updates an enterprise's profile. */
  updateEnterpriseProfile?: Maybe<UpdateEnterpriseProfilePayload>;
  /** Sets whether repository projects are enabled for a enterprise. */
  updateEnterpriseRepositoryProjectsSetting?: Maybe<UpdateEnterpriseRepositoryProjectsSettingPayload>;
  /** Sets whether team discussions are enabled for an enterprise. */
  updateEnterpriseTeamDiscussionsSetting?: Maybe<UpdateEnterpriseTeamDiscussionsSettingPayload>;
  /** Sets whether two factor authentication is required for all users in an enterprise. */
  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Maybe<UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;
  /** Updates an environment. */
  updateEnvironment?: Maybe<UpdateEnvironmentPayload>;
  /** Sets whether an IP allow list is enabled on an owner. */
  updateIpAllowListEnabledSetting?: Maybe<UpdateIpAllowListEnabledSettingPayload>;
  /** Updates an IP allow list entry. */
  updateIpAllowListEntry?: Maybe<UpdateIpAllowListEntryPayload>;
  /** Sets whether IP allow list configuration for installed GitHub Apps is enabled on an owner. */
  updateIpAllowListForInstalledAppsEnabledSetting?: Maybe<UpdateIpAllowListForInstalledAppsEnabledSettingPayload>;
  /** Updates an Issue. */
  updateIssue?: Maybe<UpdateIssuePayload>;
  /** Updates an IssueComment object. */
  updateIssueComment?: Maybe<UpdateIssueCommentPayload>;
  /** Updates an existing label. */
  updateLabel?: Maybe<UpdateLabelPayload>;
  /** Update the setting to restrict notifications to only verified or approved domains available to an owner. */
  updateNotificationRestrictionSetting?: Maybe<UpdateNotificationRestrictionSettingPayload>;
  /** Sets whether private repository forks are enabled for an organization. */
  updateOrganizationAllowPrivateRepositoryForkingSetting?: Maybe<UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload>;
  /** Sets whether contributors are required to sign off on web-based commits for repositories in an organization. */
  updateOrganizationWebCommitSignoffSetting?: Maybe<UpdateOrganizationWebCommitSignoffSettingPayload>;
  /**
   * Toggle the setting for your GitHub Sponsors profile that allows other GitHub
   * accounts to sponsor you on GitHub while paying for the sponsorship on Patreon.
   * Only applicable when you have a GitHub Sponsors profile and have connected
   * your GitHub account with Patreon.
   */
  updatePatreonSponsorability?: Maybe<UpdatePatreonSponsorabilityPayload>;
  /** Updates an existing project. */
  updateProject?: Maybe<UpdateProjectPayload>;
  /** Updates an existing project card. */
  updateProjectCard?: Maybe<UpdateProjectCardPayload>;
  /** Updates an existing project column. */
  updateProjectColumn?: Maybe<UpdateProjectColumnPayload>;
  /** Updates an existing project. */
  updateProjectV2?: Maybe<UpdateProjectV2Payload>;
  /** Update the collaborators on a team or a project */
  updateProjectV2Collaborators?: Maybe<UpdateProjectV2CollaboratorsPayload>;
  /** Updates a draft issue within a Project. */
  updateProjectV2DraftIssue?: Maybe<UpdateProjectV2DraftIssuePayload>;
  /**
   * This mutation updates the value of a field for an item in a Project. Currently
   * only single-select, text, number, date, and iteration fields are supported.
   */
  updateProjectV2ItemFieldValue?: Maybe<UpdateProjectV2ItemFieldValuePayload>;
  /** This mutation updates the position of the item in the project, where the position represents the priority of an item. */
  updateProjectV2ItemPosition?: Maybe<UpdateProjectV2ItemPositionPayload>;
  /** Update a pull request */
  updatePullRequest?: Maybe<UpdatePullRequestPayload>;
  /** Merge or Rebase HEAD from upstream branch into pull request branch */
  updatePullRequestBranch?: Maybe<UpdatePullRequestBranchPayload>;
  /** Updates the body of a pull request review. */
  updatePullRequestReview?: Maybe<UpdatePullRequestReviewPayload>;
  /** Updates a pull request review comment. */
  updatePullRequestReviewComment?: Maybe<UpdatePullRequestReviewCommentPayload>;
  /** Update a Git Ref. */
  updateRef?: Maybe<UpdateRefPayload>;
  /**
   * Creates, updates and/or deletes multiple refs in a repository.
   *
   * This mutation takes a list of `RefUpdate`s and performs these updates
   * on the repository. All updates are performed atomically, meaning that
   * if one of them is rejected, no other ref will be modified.
   *
   * `RefUpdate.beforeOid` specifies that the given reference needs to point
   * to the given value before performing any updates. A value of
   * `0000000000000000000000000000000000000000` can be used to verify that
   * the references should not exist.
   *
   * `RefUpdate.afterOid` specifies the value that the given reference
   * will point to after performing all updates. A value of
   * `0000000000000000000000000000000000000000` can be used to delete a
   * reference.
   *
   * If `RefUpdate.force` is set to `true`, a non-fast-forward updates
   * for the given reference will be allowed.
   */
  updateRefs?: Maybe<UpdateRefsPayload>;
  /** Update information about a repository. */
  updateRepository?: Maybe<UpdateRepositoryPayload>;
  /** Update a repository ruleset */
  updateRepositoryRuleset?: Maybe<UpdateRepositoryRulesetPayload>;
  /** Sets whether contributors are required to sign off on web-based commits for a repository. */
  updateRepositoryWebCommitSignoffSetting?: Maybe<UpdateRepositoryWebCommitSignoffSettingPayload>;
  /** Change visibility of your sponsorship and opt in or out of email updates from the maintainer. */
  updateSponsorshipPreferences?: Maybe<UpdateSponsorshipPreferencesPayload>;
  /** Updates the state for subscribable subjects. */
  updateSubscription?: Maybe<UpdateSubscriptionPayload>;
  /** Updates a team discussion. */
  updateTeamDiscussion?: Maybe<UpdateTeamDiscussionPayload>;
  /** Updates a discussion comment. */
  updateTeamDiscussionComment?: Maybe<UpdateTeamDiscussionCommentPayload>;
  /** Updates team review assignment. */
  updateTeamReviewAssignment?: Maybe<UpdateTeamReviewAssignmentPayload>;
  /** Update team repository. */
  updateTeamsRepository?: Maybe<UpdateTeamsRepositoryPayload>;
  /** Replaces the repository's topics with the given topics. */
  updateTopics?: Maybe<UpdateTopicsPayload>;
  /** Updates an existing user list. */
  updateUserList?: Maybe<UpdateUserListPayload>;
  /** Updates which of the viewer's lists an item belongs to */
  updateUserListsForItem?: Maybe<UpdateUserListsForItemPayload>;
  /** Verify that a verifiable domain has the expected DNS record. */
  verifyVerifiableDomain?: Maybe<VerifyVerifiableDomainPayload>;
};


/** The root query for implementing GraphQL mutations. */
export type MutationabortQueuedMigrationsArgs = {
  input: AbortQueuedMigrationsInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationabortRepositoryMigrationArgs = {
  input: AbortRepositoryMigrationInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationacceptEnterpriseAdministratorInvitationArgs = {
  input: AcceptEnterpriseAdministratorInvitationInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationacceptTopicSuggestionArgs = {
  input: AcceptTopicSuggestionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddAssigneesToAssignableArgs = {
  input: AddAssigneesToAssignableInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddCommentArgs = {
  input: AddCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddDiscussionCommentArgs = {
  input: AddDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddDiscussionPollVoteArgs = {
  input: AddDiscussionPollVoteInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddEnterpriseOrganizationMemberArgs = {
  input: AddEnterpriseOrganizationMemberInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddEnterpriseSupportEntitlementArgs = {
  input: AddEnterpriseSupportEntitlementInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddLabelsToLabelableArgs = {
  input: AddLabelsToLabelableInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddProjectCardArgs = {
  input: AddProjectCardInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddProjectColumnArgs = {
  input: AddProjectColumnInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddProjectV2DraftIssueArgs = {
  input: AddProjectV2DraftIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddProjectV2ItemByIdArgs = {
  input: AddProjectV2ItemByIdInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddPullRequestReviewArgs = {
  input: AddPullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddPullRequestReviewCommentArgs = {
  input: AddPullRequestReviewCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddPullRequestReviewThreadArgs = {
  input: AddPullRequestReviewThreadInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddPullRequestReviewThreadReplyArgs = {
  input: AddPullRequestReviewThreadReplyInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddReactionArgs = {
  input: AddReactionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddStarArgs = {
  input: AddStarInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddUpvoteArgs = {
  input: AddUpvoteInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationaddVerifiableDomainArgs = {
  input: AddVerifiableDomainInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationapproveDeploymentsArgs = {
  input: ApproveDeploymentsInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationapproveVerifiableDomainArgs = {
  input: ApproveVerifiableDomainInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationarchiveProjectV2ItemArgs = {
  input: ArchiveProjectV2ItemInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationarchiveRepositoryArgs = {
  input: ArchiveRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcancelEnterpriseAdminInvitationArgs = {
  input: CancelEnterpriseAdminInvitationInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcancelSponsorshipArgs = {
  input: CancelSponsorshipInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationchangeUserStatusArgs = {
  input: ChangeUserStatusInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationclearLabelsFromLabelableArgs = {
  input: ClearLabelsFromLabelableInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationclearProjectV2ItemFieldValueArgs = {
  input: ClearProjectV2ItemFieldValueInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcloneProjectArgs = {
  input: CloneProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcloneTemplateRepositoryArgs = {
  input: CloneTemplateRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcloseDiscussionArgs = {
  input: CloseDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcloseIssueArgs = {
  input: CloseIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationclosePullRequestArgs = {
  input: ClosePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationconvertProjectCardNoteToIssueArgs = {
  input: ConvertProjectCardNoteToIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationconvertPullRequestToDraftArgs = {
  input: ConvertPullRequestToDraftInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcopyProjectV2Args = {
  input: CopyProjectV2Input;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateAttributionInvitationArgs = {
  input: CreateAttributionInvitationInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateBranchProtectionRuleArgs = {
  input: CreateBranchProtectionRuleInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateCheckRunArgs = {
  input: CreateCheckRunInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateCheckSuiteArgs = {
  input: CreateCheckSuiteInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateCommitOnBranchArgs = {
  input: CreateCommitOnBranchInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateDeploymentArgs = {
  input: CreateDeploymentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateDeploymentStatusArgs = {
  input: CreateDeploymentStatusInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateDiscussionArgs = {
  input: CreateDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateEnterpriseOrganizationArgs = {
  input: CreateEnterpriseOrganizationInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateEnvironmentArgs = {
  input: CreateEnvironmentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateIpAllowListEntryArgs = {
  input: CreateIpAllowListEntryInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateIssueArgs = {
  input: CreateIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateLabelArgs = {
  input: CreateLabelInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateLinkedBranchArgs = {
  input: CreateLinkedBranchInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateMigrationSourceArgs = {
  input: CreateMigrationSourceInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateProjectArgs = {
  input: CreateProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateProjectV2Args = {
  input: CreateProjectV2Input;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateProjectV2FieldArgs = {
  input: CreateProjectV2FieldInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreatePullRequestArgs = {
  input: CreatePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateRefArgs = {
  input: CreateRefInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateRepositoryArgs = {
  input: CreateRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateRepositoryRulesetArgs = {
  input: CreateRepositoryRulesetInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateSponsorsListingArgs = {
  input: CreateSponsorsListingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateSponsorsTierArgs = {
  input: CreateSponsorsTierInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateSponsorshipArgs = {
  input: CreateSponsorshipInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateSponsorshipsArgs = {
  input: CreateSponsorshipsInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateTeamDiscussionArgs = {
  input: CreateTeamDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateTeamDiscussionCommentArgs = {
  input: CreateTeamDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationcreateUserListArgs = {
  input: CreateUserListInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeclineTopicSuggestionArgs = {
  input: DeclineTopicSuggestionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteBranchProtectionRuleArgs = {
  input: DeleteBranchProtectionRuleInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteDeploymentArgs = {
  input: DeleteDeploymentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteDiscussionArgs = {
  input: DeleteDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteDiscussionCommentArgs = {
  input: DeleteDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteEnvironmentArgs = {
  input: DeleteEnvironmentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteIpAllowListEntryArgs = {
  input: DeleteIpAllowListEntryInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteIssueArgs = {
  input: DeleteIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteIssueCommentArgs = {
  input: DeleteIssueCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteLabelArgs = {
  input: DeleteLabelInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteLinkedBranchArgs = {
  input: DeleteLinkedBranchInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeletePackageVersionArgs = {
  input: DeletePackageVersionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteProjectArgs = {
  input: DeleteProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteProjectCardArgs = {
  input: DeleteProjectCardInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteProjectColumnArgs = {
  input: DeleteProjectColumnInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteProjectV2Args = {
  input: DeleteProjectV2Input;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteProjectV2FieldArgs = {
  input: DeleteProjectV2FieldInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteProjectV2ItemArgs = {
  input: DeleteProjectV2ItemInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteProjectV2WorkflowArgs = {
  input: DeleteProjectV2WorkflowInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeletePullRequestReviewArgs = {
  input: DeletePullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeletePullRequestReviewCommentArgs = {
  input: DeletePullRequestReviewCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteRefArgs = {
  input: DeleteRefInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteRepositoryRulesetArgs = {
  input: DeleteRepositoryRulesetInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteTeamDiscussionArgs = {
  input: DeleteTeamDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteTeamDiscussionCommentArgs = {
  input: DeleteTeamDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteUserListArgs = {
  input: DeleteUserListInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdeleteVerifiableDomainArgs = {
  input: DeleteVerifiableDomainInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdequeuePullRequestArgs = {
  input: DequeuePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdisablePullRequestAutoMergeArgs = {
  input: DisablePullRequestAutoMergeInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdismissPullRequestReviewArgs = {
  input: DismissPullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationdismissRepositoryVulnerabilityAlertArgs = {
  input: DismissRepositoryVulnerabilityAlertInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationenablePullRequestAutoMergeArgs = {
  input: EnablePullRequestAutoMergeInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationenqueuePullRequestArgs = {
  input: EnqueuePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationfollowOrganizationArgs = {
  input: FollowOrganizationInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationfollowUserArgs = {
  input: FollowUserInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationgrantEnterpriseOrganizationsMigratorRoleArgs = {
  input: GrantEnterpriseOrganizationsMigratorRoleInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationgrantMigratorRoleArgs = {
  input: GrantMigratorRoleInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationimportProjectArgs = {
  input: ImportProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationinviteEnterpriseAdminArgs = {
  input: InviteEnterpriseAdminInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationlinkProjectV2ToRepositoryArgs = {
  input: LinkProjectV2ToRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationlinkProjectV2ToTeamArgs = {
  input: LinkProjectV2ToTeamInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationlinkRepositoryToProjectArgs = {
  input: LinkRepositoryToProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationlockLockableArgs = {
  input: LockLockableInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationmarkDiscussionCommentAsAnswerArgs = {
  input: MarkDiscussionCommentAsAnswerInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationmarkFileAsViewedArgs = {
  input: MarkFileAsViewedInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationmarkProjectV2AsTemplateArgs = {
  input: MarkProjectV2AsTemplateInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationmarkPullRequestReadyForReviewArgs = {
  input: MarkPullRequestReadyForReviewInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationmergeBranchArgs = {
  input: MergeBranchInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationmergePullRequestArgs = {
  input: MergePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationminimizeCommentArgs = {
  input: MinimizeCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationmoveProjectCardArgs = {
  input: MoveProjectCardInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationmoveProjectColumnArgs = {
  input: MoveProjectColumnInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationpinIssueArgs = {
  input: PinIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationpublishSponsorsTierArgs = {
  input: PublishSponsorsTierInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationregenerateEnterpriseIdentityProviderRecoveryCodesArgs = {
  input: RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationregenerateVerifiableDomainTokenArgs = {
  input: RegenerateVerifiableDomainTokenInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationrejectDeploymentsArgs = {
  input: RejectDeploymentsInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationremoveAssigneesFromAssignableArgs = {
  input: RemoveAssigneesFromAssignableInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationremoveEnterpriseAdminArgs = {
  input: RemoveEnterpriseAdminInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationremoveEnterpriseIdentityProviderArgs = {
  input: RemoveEnterpriseIdentityProviderInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationremoveEnterpriseMemberArgs = {
  input: RemoveEnterpriseMemberInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationremoveEnterpriseOrganizationArgs = {
  input: RemoveEnterpriseOrganizationInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationremoveEnterpriseSupportEntitlementArgs = {
  input: RemoveEnterpriseSupportEntitlementInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationremoveLabelsFromLabelableArgs = {
  input: RemoveLabelsFromLabelableInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationremoveOutsideCollaboratorArgs = {
  input: RemoveOutsideCollaboratorInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationremoveReactionArgs = {
  input: RemoveReactionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationremoveStarArgs = {
  input: RemoveStarInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationremoveUpvoteArgs = {
  input: RemoveUpvoteInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationreopenDiscussionArgs = {
  input: ReopenDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationreopenIssueArgs = {
  input: ReopenIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationreopenPullRequestArgs = {
  input: ReopenPullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationrequestReviewsArgs = {
  input: RequestReviewsInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationrerequestCheckSuiteArgs = {
  input: RerequestCheckSuiteInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationresolveReviewThreadArgs = {
  input: ResolveReviewThreadInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationretireSponsorsTierArgs = {
  input: RetireSponsorsTierInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationrevertPullRequestArgs = {
  input: RevertPullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationrevokeEnterpriseOrganizationsMigratorRoleArgs = {
  input: RevokeEnterpriseOrganizationsMigratorRoleInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationrevokeMigratorRoleArgs = {
  input: RevokeMigratorRoleInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationsetEnterpriseIdentityProviderArgs = {
  input: SetEnterpriseIdentityProviderInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationsetOrganizationInteractionLimitArgs = {
  input: SetOrganizationInteractionLimitInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationsetRepositoryInteractionLimitArgs = {
  input: SetRepositoryInteractionLimitInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationsetUserInteractionLimitArgs = {
  input: SetUserInteractionLimitInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationstartOrganizationMigrationArgs = {
  input: StartOrganizationMigrationInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationstartRepositoryMigrationArgs = {
  input: StartRepositoryMigrationInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationsubmitPullRequestReviewArgs = {
  input: SubmitPullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationtransferEnterpriseOrganizationArgs = {
  input: TransferEnterpriseOrganizationInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationtransferIssueArgs = {
  input: TransferIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunarchiveProjectV2ItemArgs = {
  input: UnarchiveProjectV2ItemInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunarchiveRepositoryArgs = {
  input: UnarchiveRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunfollowOrganizationArgs = {
  input: UnfollowOrganizationInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunfollowUserArgs = {
  input: UnfollowUserInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunlinkProjectV2FromRepositoryArgs = {
  input: UnlinkProjectV2FromRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunlinkProjectV2FromTeamArgs = {
  input: UnlinkProjectV2FromTeamInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunlinkRepositoryFromProjectArgs = {
  input: UnlinkRepositoryFromProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunlockLockableArgs = {
  input: UnlockLockableInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunmarkDiscussionCommentAsAnswerArgs = {
  input: UnmarkDiscussionCommentAsAnswerInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunmarkFileAsViewedArgs = {
  input: UnmarkFileAsViewedInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunmarkIssueAsDuplicateArgs = {
  input: UnmarkIssueAsDuplicateInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunmarkProjectV2AsTemplateArgs = {
  input: UnmarkProjectV2AsTemplateInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunminimizeCommentArgs = {
  input: UnminimizeCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunpinIssueArgs = {
  input: UnpinIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunresolveReviewThreadArgs = {
  input: UnresolveReviewThreadInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationunsubscribeFromNotificationsArgs = {
  input: UnsubscribeFromNotificationsInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateBranchProtectionRuleArgs = {
  input: UpdateBranchProtectionRuleInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateCheckRunArgs = {
  input: UpdateCheckRunInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateCheckSuitePreferencesArgs = {
  input: UpdateCheckSuitePreferencesInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateDiscussionArgs = {
  input: UpdateDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateDiscussionCommentArgs = {
  input: UpdateDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseAdministratorRoleArgs = {
  input: UpdateEnterpriseAdministratorRoleInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseAllowPrivateRepositoryForkingSettingArgs = {
  input: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseDefaultRepositoryPermissionSettingArgs = {
  input: UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs = {
  input: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseMembersCanCreateRepositoriesSettingArgs = {
  input: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseMembersCanDeleteIssuesSettingArgs = {
  input: UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseMembersCanDeleteRepositoriesSettingArgs = {
  input: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseMembersCanInviteCollaboratorsSettingArgs = {
  input: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseMembersCanMakePurchasesSettingArgs = {
  input: UpdateEnterpriseMembersCanMakePurchasesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs = {
  input: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseMembersCanViewDependencyInsightsSettingArgs = {
  input: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseOrganizationProjectsSettingArgs = {
  input: UpdateEnterpriseOrganizationProjectsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseOwnerOrganizationRoleArgs = {
  input: UpdateEnterpriseOwnerOrganizationRoleInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseProfileArgs = {
  input: UpdateEnterpriseProfileInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseRepositoryProjectsSettingArgs = {
  input: UpdateEnterpriseRepositoryProjectsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseTeamDiscussionsSettingArgs = {
  input: UpdateEnterpriseTeamDiscussionsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs = {
  input: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateEnvironmentArgs = {
  input: UpdateEnvironmentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateIpAllowListEnabledSettingArgs = {
  input: UpdateIpAllowListEnabledSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateIpAllowListEntryArgs = {
  input: UpdateIpAllowListEntryInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateIpAllowListForInstalledAppsEnabledSettingArgs = {
  input: UpdateIpAllowListForInstalledAppsEnabledSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateIssueArgs = {
  input: UpdateIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateIssueCommentArgs = {
  input: UpdateIssueCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateLabelArgs = {
  input: UpdateLabelInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateNotificationRestrictionSettingArgs = {
  input: UpdateNotificationRestrictionSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateOrganizationAllowPrivateRepositoryForkingSettingArgs = {
  input: UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateOrganizationWebCommitSignoffSettingArgs = {
  input: UpdateOrganizationWebCommitSignoffSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdatePatreonSponsorabilityArgs = {
  input: UpdatePatreonSponsorabilityInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateProjectArgs = {
  input: UpdateProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateProjectCardArgs = {
  input: UpdateProjectCardInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateProjectColumnArgs = {
  input: UpdateProjectColumnInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateProjectV2Args = {
  input: UpdateProjectV2Input;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateProjectV2CollaboratorsArgs = {
  input: UpdateProjectV2CollaboratorsInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateProjectV2DraftIssueArgs = {
  input: UpdateProjectV2DraftIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateProjectV2ItemFieldValueArgs = {
  input: UpdateProjectV2ItemFieldValueInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateProjectV2ItemPositionArgs = {
  input: UpdateProjectV2ItemPositionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdatePullRequestArgs = {
  input: UpdatePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdatePullRequestBranchArgs = {
  input: UpdatePullRequestBranchInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdatePullRequestReviewArgs = {
  input: UpdatePullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdatePullRequestReviewCommentArgs = {
  input: UpdatePullRequestReviewCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateRefArgs = {
  input: UpdateRefInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateRefsArgs = {
  input: UpdateRefsInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateRepositoryArgs = {
  input: UpdateRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateRepositoryRulesetArgs = {
  input: UpdateRepositoryRulesetInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateRepositoryWebCommitSignoffSettingArgs = {
  input: UpdateRepositoryWebCommitSignoffSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateSponsorshipPreferencesArgs = {
  input: UpdateSponsorshipPreferencesInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateSubscriptionArgs = {
  input: UpdateSubscriptionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateTeamDiscussionArgs = {
  input: UpdateTeamDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateTeamDiscussionCommentArgs = {
  input: UpdateTeamDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateTeamReviewAssignmentArgs = {
  input: UpdateTeamReviewAssignmentInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateTeamsRepositoryArgs = {
  input: UpdateTeamsRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateTopicsArgs = {
  input: UpdateTopicsInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateUserListArgs = {
  input: UpdateUserListInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationupdateUserListsForItemArgs = {
  input: UpdateUserListsForItemInput;
};


/** The root query for implementing GraphQL mutations. */
export type MutationverifyVerifiableDomainArgs = {
  input: VerifyVerifiableDomainInput;
};

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars['ID']['output'];
};

/** The possible values for the notification restriction setting. */
export type NotificationRestrictionSettingValue =
  /** The setting is disabled for the owner. */
  | 'DISABLED'
  /** The setting is enabled for the owner. */
  | 'ENABLED';

/**
 * An OIDC identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
export type OIDCProvider = Node & {
  /** The enterprise this identity provider belongs to. */
  enterprise?: Maybe<Enterprise>;
  /** ExternalIdentities provisioned by this identity provider. */
  externalIdentities: ExternalIdentityConnection;
  /** The Node ID of the OIDCProvider object */
  id: Scalars['ID']['output'];
  /** The OIDC identity provider type */
  providerType: OIDCProviderType;
  /** The id of the tenant this provider is attached to */
  tenantId: Scalars['String']['output'];
};


/**
 * An OIDC identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
export type OIDCProviderexternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  membersOnly?: InputMaybe<Scalars['Boolean']['input']>;
  userName?: InputMaybe<Scalars['String']['input']>;
};

/** The OIDC identity provider type */
export type OIDCProviderType =
  /** Azure Active Directory */
  | 'AAD';

/** Metadata for an audit entry with action oauth_application.* */
export type OauthApplicationAuditEntryData = {
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a oauth_application.create event. */
export type OauthApplicationCreateAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The application URL of the OAuth application. */
  applicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The callback URL of the OAuth application. */
  callbackUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OauthApplicationCreateAuditEntry object */
  id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The rate limit of the OAuth application. */
  rateLimit?: Maybe<Scalars['Int']['output']>;
  /** The state of the OAuth application. */
  state?: Maybe<OauthApplicationCreateAuditEntryState>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The state of an OAuth application when it was created. */
export type OauthApplicationCreateAuditEntryState =
  /** The OAuth application was active and allowed to have OAuth Accesses. */
  | 'ACTIVE'
  /** The OAuth application was in the process of being deleted. */
  | 'PENDING_DELETION'
  /** The OAuth application was suspended from generating OAuth Accesses due to abuse or security concerns. */
  | 'SUSPENDED';

/** The corresponding operation type for the action */
export type OperationType =
  /** An existing resource was accessed */
  | 'ACCESS'
  /** A resource performed an authentication event */
  | 'AUTHENTICATION'
  /** A new resource was created */
  | 'CREATE'
  /** An existing resource was modified */
  | 'MODIFY'
  /** An existing resource was removed */
  | 'REMOVE'
  /** An existing resource was restored */
  | 'RESTORE'
  /** An existing resource was transferred between multiple resources */
  | 'TRANSFER';

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export type OrderDirection =
  /** Specifies an ascending order for a given `orderBy` argument. */
  | 'ASC'
  /** Specifies a descending order for a given `orderBy` argument. */
  | 'DESC';

/** Audit log entry for a org.add_billing_manager */
export type OrgAddBillingManagerAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgAddBillingManagerAuditEntry object */
  id: Scalars['ID']['output'];
  /** The email address used to invite a billing manager for the organization. */
  invitationEmail?: Maybe<Scalars['String']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.add_member */
export type OrgAddMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgAddMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The permission level of the member added to the organization. */
  permission?: Maybe<OrgAddMemberAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The permissions available to members on an Organization. */
export type OrgAddMemberAuditEntryPermission =
  /** Can read, clone, push, and add collaborators to repositories. */
  | 'ADMIN'
  /** Can read and clone repositories. */
  | 'READ';

/** Audit log entry for a org.block_user */
export type OrgBlockUserAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The blocked user. */
  blockedUser?: Maybe<User>;
  /** The username of the blocked user. */
  blockedUserName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the blocked user. */
  blockedUserResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the blocked user. */
  blockedUserUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgBlockUserAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.config.disable_collaborators_only event. */
export type OrgConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgConfigDisableCollaboratorsOnlyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.config.enable_collaborators_only event. */
export type OrgConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgConfigEnableCollaboratorsOnlyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.create event. */
export type OrgCreateAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The billing plan for the Organization. */
  billingPlan?: Maybe<OrgCreateAuditEntryBillingPlan>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgCreateAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The billing plans available for organizations. */
export type OrgCreateAuditEntryBillingPlan =
  /** Team Plan */
  | 'BUSINESS'
  /** Enterprise Cloud Plan */
  | 'BUSINESS_PLUS'
  /** Free Plan */
  | 'FREE'
  /** Tiered Per Seat Plan */
  | 'TIERED_PER_SEAT'
  /** Legacy Unlimited Plan */
  | 'UNLIMITED';

/** Audit log entry for a org.disable_oauth_app_restrictions event. */
export type OrgDisableOauthAppRestrictionsAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgDisableOauthAppRestrictionsAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.disable_saml event. */
export type OrgDisableSamlAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The SAML provider's digest algorithm URL. */
  digestMethodUrl?: Maybe<Scalars['URI']['output']>;
  /** The Node ID of the OrgDisableSamlAuditEntry object */
  id: Scalars['ID']['output'];
  /** The SAML provider's issuer URL. */
  issuerUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The SAML provider's signature algorithm URL. */
  signatureMethodUrl?: Maybe<Scalars['URI']['output']>;
  /** The SAML provider's single sign-on URL. */
  singleSignOnUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.disable_two_factor_requirement event. */
export type OrgDisableTwoFactorRequirementAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgDisableTwoFactorRequirementAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.enable_oauth_app_restrictions event. */
export type OrgEnableOauthAppRestrictionsAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgEnableOauthAppRestrictionsAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.enable_saml event. */
export type OrgEnableSamlAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The SAML provider's digest algorithm URL. */
  digestMethodUrl?: Maybe<Scalars['URI']['output']>;
  /** The Node ID of the OrgEnableSamlAuditEntry object */
  id: Scalars['ID']['output'];
  /** The SAML provider's issuer URL. */
  issuerUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The SAML provider's signature algorithm URL. */
  signatureMethodUrl?: Maybe<Scalars['URI']['output']>;
  /** The SAML provider's single sign-on URL. */
  singleSignOnUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.enable_two_factor_requirement event. */
export type OrgEnableTwoFactorRequirementAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgEnableTwoFactorRequirementAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Ordering options for an organization's enterprise owner connections. */
export type OrgEnterpriseOwnerOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprise owners by. */
  field: OrgEnterpriseOwnerOrderField;
};

/** Properties by which enterprise owners can be ordered. */
export type OrgEnterpriseOwnerOrderField =
  /** Order enterprise owners by login. */
  | 'LOGIN';

/** Audit log entry for a org.invite_member event. */
export type OrgInviteMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The email address of the organization invitation. */
  email?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the OrgInviteMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The organization invitation. */
  organizationInvitation?: Maybe<OrganizationInvitation>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.invite_to_business event. */
export type OrgInviteToBusinessAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  /** The Node ID of the OrgInviteToBusinessAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_approved event. */
export type OrgOauthAppAccessApprovedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgOauthAppAccessApprovedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_blocked event. */
export type OrgOauthAppAccessBlockedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgOauthAppAccessBlockedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_denied event. */
export type OrgOauthAppAccessDeniedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgOauthAppAccessDeniedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_requested event. */
export type OrgOauthAppAccessRequestedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgOauthAppAccessRequestedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_unblocked event. */
export type OrgOauthAppAccessUnblockedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgOauthAppAccessUnblockedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.remove_billing_manager event. */
export type OrgRemoveBillingManagerAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgRemoveBillingManagerAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The reason for the billing manager being removed. */
  reason?: Maybe<OrgRemoveBillingManagerAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The reason a billing manager was removed from an Organization. */
export type OrgRemoveBillingManagerAuditEntryReason =
  /** SAML external identity missing */
  | 'SAML_EXTERNAL_IDENTITY_MISSING'
  /** SAML SSO enforcement requires an external identity */
  | 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY'
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  | 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';

/** Audit log entry for a org.remove_member event. */
export type OrgRemoveMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgRemoveMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The types of membership the member has with the organization. */
  membershipTypes?: Maybe<Array<OrgRemoveMemberAuditEntryMembershipType>>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The reason for the member being removed. */
  reason?: Maybe<OrgRemoveMemberAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The type of membership a user has with an Organization. */
export type OrgRemoveMemberAuditEntryMembershipType =
  /**
   * Organization owners have full access and can change several settings,
   * including the names of repositories that belong to the Organization and Owners
   * team membership. In addition, organization owners can delete the organization
   * and all of its repositories.
   */
  | 'ADMIN'
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  | 'BILLING_MANAGER'
  /** A direct member is a user that is a member of the Organization. */
  | 'DIRECT_MEMBER'
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  | 'OUTSIDE_COLLABORATOR'
  /** A suspended member. */
  | 'SUSPENDED'
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the Organization.
   */
  | 'UNAFFILIATED';

/** The reason a member was removed from an Organization. */
export type OrgRemoveMemberAuditEntryReason =
  /** SAML external identity missing */
  | 'SAML_EXTERNAL_IDENTITY_MISSING'
  /** SAML SSO enforcement requires an external identity */
  | 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY'
  /** User was removed from organization during account recovery */
  | 'TWO_FACTOR_ACCOUNT_RECOVERY'
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  | 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'
  /** User account has been deleted */
  | 'USER_ACCOUNT_DELETED';

/** Audit log entry for a org.remove_outside_collaborator event. */
export type OrgRemoveOutsideCollaboratorAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgRemoveOutsideCollaboratorAuditEntry object */
  id: Scalars['ID']['output'];
  /** The types of membership the outside collaborator has with the organization. */
  membershipTypes?: Maybe<Array<OrgRemoveOutsideCollaboratorAuditEntryMembershipType>>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The reason for the outside collaborator being removed from the Organization. */
  reason?: Maybe<OrgRemoveOutsideCollaboratorAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The type of membership a user has with an Organization. */
export type OrgRemoveOutsideCollaboratorAuditEntryMembershipType =
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  | 'BILLING_MANAGER'
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  | 'OUTSIDE_COLLABORATOR'
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the organization.
   */
  | 'UNAFFILIATED';

/** The reason an outside collaborator was removed from an Organization. */
export type OrgRemoveOutsideCollaboratorAuditEntryReason =
  /** SAML external identity missing */
  | 'SAML_EXTERNAL_IDENTITY_MISSING'
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  | 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';

/** Audit log entry for a org.restore_member event. */
export type OrgRestoreMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgRestoreMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The number of custom email routings for the restored member. */
  restoredCustomEmailRoutingsCount?: Maybe<Scalars['Int']['output']>;
  /** The number of issue assignments for the restored member. */
  restoredIssueAssignmentsCount?: Maybe<Scalars['Int']['output']>;
  /** Restored organization membership objects. */
  restoredMemberships?: Maybe<Array<OrgRestoreMemberAuditEntryMembership>>;
  /** The number of restored memberships. */
  restoredMembershipsCount?: Maybe<Scalars['Int']['output']>;
  /** The number of repositories of the restored member. */
  restoredRepositoriesCount?: Maybe<Scalars['Int']['output']>;
  /** The number of starred repositories for the restored member. */
  restoredRepositoryStarsCount?: Maybe<Scalars['Int']['output']>;
  /** The number of watched repositories for the restored member. */
  restoredRepositoryWatchesCount?: Maybe<Scalars['Int']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Types of memberships that can be restored for an Organization member. */
export type OrgRestoreMemberAuditEntryMembership = OrgRestoreMemberMembershipOrganizationAuditEntryData | OrgRestoreMemberMembershipRepositoryAuditEntryData | OrgRestoreMemberMembershipTeamAuditEntryData;

/** Metadata for an organization membership for org.restore_member actions */
export type OrgRestoreMemberMembershipOrganizationAuditEntryData = OrganizationAuditEntryData & {
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
};

/** Metadata for a repository membership for org.restore_member actions */
export type OrgRestoreMemberMembershipRepositoryAuditEntryData = RepositoryAuditEntryData & {
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
};

/** Metadata for a team membership for org.restore_member actions */
export type OrgRestoreMemberMembershipTeamAuditEntryData = TeamAuditEntryData & {
  /** The team associated with the action */
  team?: Maybe<Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.unblock_user */
export type OrgUnblockUserAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The user being unblocked by the organization. */
  blockedUser?: Maybe<User>;
  /** The username of the blocked user. */
  blockedUserName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the blocked user. */
  blockedUserResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the blocked user. */
  blockedUserUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgUnblockUserAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.update_default_repository_permission */
export type OrgUpdateDefaultRepositoryPermissionAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgUpdateDefaultRepositoryPermissionAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The new base repository permission level for the organization. */
  permission?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
  /** The former base repository permission level for the organization. */
  permissionWas?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The default permission a repository can have in an Organization. */
export type OrgUpdateDefaultRepositoryPermissionAuditEntryPermission =
  /** Can read, clone, push, and add collaborators to repositories. */
  | 'ADMIN'
  /** No default permission value. */
  | 'NONE'
  /** Can read and clone repositories. */
  | 'READ'
  /** Can read, clone and push to repositories. */
  | 'WRITE';

/** Audit log entry for a org.update_member event. */
export type OrgUpdateMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgUpdateMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The new member permission level for the organization. */
  permission?: Maybe<OrgUpdateMemberAuditEntryPermission>;
  /** The former member permission level for the organization. */
  permissionWas?: Maybe<OrgUpdateMemberAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The permissions available to members on an Organization. */
export type OrgUpdateMemberAuditEntryPermission =
  /** Can read, clone, push, and add collaborators to repositories. */
  | 'ADMIN'
  /** Can read and clone repositories. */
  | 'READ';

/** Audit log entry for a org.update_member_repository_creation_permission event. */
export type OrgUpdateMemberRepositoryCreationPermissionAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** Can members create repositories in the organization. */
  canCreateRepositories?: Maybe<Scalars['Boolean']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgUpdateMemberRepositoryCreationPermissionAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
  /** The permission for visibility level of repositories for this organization. */
  visibility?: Maybe<OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility>;
};

/** The permissions available for repository creation on an Organization. */
export type OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility =
  /** All organization members are restricted from creating any repositories. */
  | 'ALL'
  /** All organization members are restricted from creating internal repositories. */
  | 'INTERNAL'
  /** All organization members are allowed to create any repositories. */
  | 'NONE'
  /** All organization members are restricted from creating private repositories. */
  | 'PRIVATE'
  /** All organization members are restricted from creating private or internal repositories. */
  | 'PRIVATE_INTERNAL'
  /** All organization members are restricted from creating public repositories. */
  | 'PUBLIC'
  /** All organization members are restricted from creating public or internal repositories. */
  | 'PUBLIC_INTERNAL'
  /** All organization members are restricted from creating public or private repositories. */
  | 'PUBLIC_PRIVATE';

/** Audit log entry for a org.update_member_repository_invitation_permission event. */
export type OrgUpdateMemberRepositoryInvitationPermissionAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** Can outside collaborators be invited to repositories in the organization. */
  canInviteOutsideCollaboratorsToRepositories?: Maybe<Scalars['Boolean']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the OrgUpdateMemberRepositoryInvitationPermissionAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Organization = Actor & AnnouncementBanner & MemberStatusable & Node & PackageOwner & ProfileOwner & ProjectOwner & ProjectV2Owner & ProjectV2Recent & RepositoryDiscussionAuthor & RepositoryDiscussionCommentAuthor & RepositoryOwner & Sponsorable & UniformResourceLocatable & {
  /** The text of the announcement */
  announcement?: Maybe<Scalars['String']['output']>;
  /** The expiration date of the announcement, if any */
  announcementExpiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether the announcement can be dismissed by the user */
  announcementUserDismissible?: Maybe<Scalars['Boolean']['output']>;
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean']['output'];
  /** Identifies the date and time when the organization was archived. */
  archivedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Audit log entries of the organization */
  auditLog: OrganizationAuditEntryConnection;
  /** A URL pointing to the organization's public avatar. */
  avatarUrl: Scalars['URI']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The organization's public profile description. */
  description?: Maybe<Scalars['String']['output']>;
  /** The organization's public profile description rendered to HTML. */
  descriptionHTML?: Maybe<Scalars['String']['output']>;
  /** A list of domains owned by the organization. */
  domains?: Maybe<VerifiableDomainConnection>;
  /** The organization's public email. */
  email?: Maybe<Scalars['String']['output']>;
  /** A list of owners of the organization's enterprise account. */
  enterpriseOwners: OrganizationEnterpriseOwnerConnection;
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars['Int']['output'];
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars['Boolean']['output'];
  /** The Node ID of the Organization object */
  id: Scalars['ID']['output'];
  /** The interaction ability settings for this organization. */
  interactionAbility?: Maybe<RepositoryInteractionAbility>;
  /** The setting value for whether the organization has an IP allow list enabled. */
  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;
  /** The IP addresses that are allowed to access resources owned by the organization. */
  ipAllowListEntries: IpAllowListEntryConnection;
  /** The setting value for whether the organization has IP allow list configuration for installed GitHub Apps enabled. */
  ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue;
  /** Whether the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars['Boolean']['output'];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars['Boolean']['output'];
  /** Whether the organization has verified its profile email and website. */
  isVerified: Scalars['Boolean']['output'];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: ProfileItemShowcase;
  /** The organization's public profile location. */
  location?: Maybe<Scalars['String']['output']>;
  /** The organization's login name. */
  login: Scalars['String']['output'];
  /** A list of all mannequins for this organization. */
  mannequins: MannequinConnection;
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: UserStatusConnection;
  /** Members can fork private repositories in this organization */
  membersCanForkPrivateRepositories: Scalars['Boolean']['output'];
  /** A list of users who are members of this organization. */
  membersWithRole: OrganizationMemberConnection;
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']['output'];
  /** The organization's public profile name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The HTTP path creating a new team */
  newTeamResourcePath: Scalars['URI']['output'];
  /** The HTTP URL creating a new team */
  newTeamUrl: Scalars['URI']['output'];
  /** Indicates if email notification delivery for this organization is restricted to verified or approved domains. */
  notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue;
  /** The billing email for the organization. */
  organizationBillingEmail?: Maybe<Scalars['String']['output']>;
  /** A list of packages under the owner. */
  packages: PackageConnection;
  /** A list of users who have been invited to join this organization. */
  pendingMembers: UserConnection;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int']['output'];
  /** Find project by number. */
  project?: Maybe<Project>;
  /** Find a project by number. */
  projectV2?: Maybe<ProjectV2>;
  /** A list of projects under the owner. */
  projects: ProjectConnection;
  /** The HTTP path listing organization's projects */
  projectsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL listing organization's projects */
  projectsUrl: Scalars['URI']['output'];
  /** A list of projects under the owner. */
  projectsV2: ProjectV2Connection;
  /** Recent projects that this user has modified in the context of the owner. */
  recentProjects: ProjectV2Connection;
  /** A list of repositories that the user owns. */
  repositories: RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<Repository>;
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: DiscussionCommentConnection;
  /** Discussions this user has started. */
  repositoryDiscussions: DiscussionConnection;
  /** A list of all repository migrations for this organization. */
  repositoryMigrations: RepositoryMigrationConnection;
  /**
   * When true the organization requires all members, billing managers, and outside
   * collaborators to enable two-factor authentication.
   */
  requiresTwoFactorAuthentication?: Maybe<Scalars['Boolean']['output']>;
  /** The HTTP path for this organization. */
  resourcePath: Scalars['URI']['output'];
  /** Returns a single ruleset from the current organization by ID. */
  ruleset?: Maybe<RepositoryRuleset>;
  /** A list of rulesets for this organization. */
  rulesets?: Maybe<RepositoryRulesetConnection>;
  /**
   * The Organization's SAML identity provider. Visible to (1) organization owners,
   * (2) organization owners' personal access tokens (classic) with read:org or
   * admin:org scope, (3) GitHub App with an installation token with read or write
   * access to members.
   */
  samlIdentityProvider?: Maybe<OrganizationIdentityProvider>;
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<SponsorsListing>;
  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
  sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;
  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
  sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: SponsorshipNewsletterConnection;
  /** The sponsorships where this user or organization is the maintainer receiving the funds. */
  sponsorshipsAsMaintainer: SponsorshipConnection;
  /** The sponsorships where this user or organization is the funder. */
  sponsorshipsAsSponsor: SponsorshipConnection;
  /** Find an organization's team by its slug. */
  team?: Maybe<Team>;
  /** A list of teams in this organization. */
  teams: TeamConnection;
  /** The HTTP path listing organization's teams */
  teamsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL listing organization's teams */
  teamsUrl: Scalars['URI']['output'];
  /**
   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
   * user themselves or by a user who can manage sponsorships for the requested organization.
   */
  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']['output']>;
  /** The organization's Twitter username. */
  twitterUsername?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this organization. */
  url: Scalars['URI']['output'];
  /** Organization is adminable by the viewer. */
  viewerCanAdminister: Scalars['Boolean']['output'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean']['output'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean']['output'];
  /** Viewer can create repositories on this organization */
  viewerCanCreateRepositories: Scalars['Boolean']['output'];
  /** Viewer can create teams on this organization. */
  viewerCanCreateTeams: Scalars['Boolean']['output'];
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars['Boolean']['output'];
  /** Viewer is an active member of this organization. */
  viewerIsAMember: Scalars['Boolean']['output'];
  /** Whether or not this Organization is followed by the viewer. */
  viewerIsFollowing: Scalars['Boolean']['output'];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars['Boolean']['output'];
  /** Whether contributors are required to sign off on web-based commits for repositories in this organization. */
  webCommitSignoffRequired: Scalars['Boolean']['output'];
  /** The organization's public profile URL. */
  websiteUrl?: Maybe<Scalars['URI']['output']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationanyPinnableItemsArgs = {
  type?: InputMaybe<PinnableItemType>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationauditLogArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<AuditLogOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationdomainsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  isApproved?: InputMaybe<Scalars['Boolean']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<VerifiableDomainOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationenterpriseOwnersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrgEnterpriseOwnerOrder>;
  organizationRole?: InputMaybe<RoleInOrganization>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationipAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IpAllowListEntryOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationisSponsoredByArgs = {
  accountLogin: Scalars['String']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationmannequinsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<MannequinOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationmemberStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserStatusOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationmembersWithRoleArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationpackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<PackageOrder>;
  packageType?: InputMaybe<PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationpendingMembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationpinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<PinnableItemType>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationpinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<PinnableItemType>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationprojectArgs = {
  number: Scalars['Int']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationprojectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<ProjectState>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationrecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationrepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  isFork?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationrepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationrepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']['input']>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationrepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  answered?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  states?: InputMaybe<Array<DiscussionState>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationrepositoryMigrationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryMigrationOrder>;
  repositoryName?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<MigrationState>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationrulesetArgs = {
  databaseId: Scalars['Int']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationrulesetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeParents?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationsponsoringArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationsponsorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationsponsorsActivitiesArgs = {
  actions?: InputMaybe<Array<SponsorsActivityAction>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAsSponsor?: InputMaybe<Scalars['Boolean']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorsActivityOrder>;
  period?: InputMaybe<SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationsponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationsponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationsponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationsponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationsponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  maintainerLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationteamArgs = {
  slug: Scalars['String']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationteamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  ldapMapped?: InputMaybe<Scalars['Boolean']['input']>;
  notificationSetting?: InputMaybe<TeamNotificationSetting>;
  orderBy?: InputMaybe<TeamOrder>;
  privacy?: InputMaybe<TeamPrivacy>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<TeamRole>;
  rootTeamsOnly?: InputMaybe<Scalars['Boolean']['input']>;
  userLogins?: InputMaybe<Array<Scalars['String']['input']>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type OrganizationtotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars['DateTime']['input']>;
  sponsorableLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};

/** An audit entry in an organization audit log. */
export type OrganizationAuditEntry = MembersCanDeleteReposClearAuditEntry | MembersCanDeleteReposDisableAuditEntry | MembersCanDeleteReposEnableAuditEntry | OauthApplicationCreateAuditEntry | OrgAddBillingManagerAuditEntry | OrgAddMemberAuditEntry | OrgBlockUserAuditEntry | OrgConfigDisableCollaboratorsOnlyAuditEntry | OrgConfigEnableCollaboratorsOnlyAuditEntry | OrgCreateAuditEntry | OrgDisableOauthAppRestrictionsAuditEntry | OrgDisableSamlAuditEntry | OrgDisableTwoFactorRequirementAuditEntry | OrgEnableOauthAppRestrictionsAuditEntry | OrgEnableSamlAuditEntry | OrgEnableTwoFactorRequirementAuditEntry | OrgInviteMemberAuditEntry | OrgInviteToBusinessAuditEntry | OrgOauthAppAccessApprovedAuditEntry | OrgOauthAppAccessBlockedAuditEntry | OrgOauthAppAccessDeniedAuditEntry | OrgOauthAppAccessRequestedAuditEntry | OrgOauthAppAccessUnblockedAuditEntry | OrgRemoveBillingManagerAuditEntry | OrgRemoveMemberAuditEntry | OrgRemoveOutsideCollaboratorAuditEntry | OrgRestoreMemberAuditEntry | OrgUnblockUserAuditEntry | OrgUpdateDefaultRepositoryPermissionAuditEntry | OrgUpdateMemberAuditEntry | OrgUpdateMemberRepositoryCreationPermissionAuditEntry | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry | PrivateRepositoryForkingDisableAuditEntry | PrivateRepositoryForkingEnableAuditEntry | RepoAccessAuditEntry | RepoAddMemberAuditEntry | RepoAddTopicAuditEntry | RepoArchivedAuditEntry | RepoChangeMergeSettingAuditEntry | RepoConfigDisableAnonymousGitAccessAuditEntry | RepoConfigDisableCollaboratorsOnlyAuditEntry | RepoConfigDisableContributorsOnlyAuditEntry | RepoConfigDisableSockpuppetDisallowedAuditEntry | RepoConfigEnableAnonymousGitAccessAuditEntry | RepoConfigEnableCollaboratorsOnlyAuditEntry | RepoConfigEnableContributorsOnlyAuditEntry | RepoConfigEnableSockpuppetDisallowedAuditEntry | RepoConfigLockAnonymousGitAccessAuditEntry | RepoConfigUnlockAnonymousGitAccessAuditEntry | RepoCreateAuditEntry | RepoDestroyAuditEntry | RepoRemoveMemberAuditEntry | RepoRemoveTopicAuditEntry | RepositoryVisibilityChangeDisableAuditEntry | RepositoryVisibilityChangeEnableAuditEntry | TeamAddMemberAuditEntry | TeamAddRepositoryAuditEntry | TeamChangeParentTeamAuditEntry | TeamRemoveMemberAuditEntry | TeamRemoveRepositoryAuditEntry;

/** The connection type for OrganizationAuditEntry. */
export type OrganizationAuditEntryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationAuditEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OrganizationAuditEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Metadata for an audit entry with action org.* */
export type OrganizationAuditEntryData = {
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
};

/** An edge in a connection. */
export type OrganizationAuditEntryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<OrganizationAuditEntry>;
};

/** A list of organizations managed by an enterprise. */
export type OrganizationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Organization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type OrganizationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Organization>;
};

/** The connection type for User. */
export type OrganizationEnterpriseOwnerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationEnterpriseOwnerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An enterprise owner in the context of an organization that is part of the enterprise. */
export type OrganizationEnterpriseOwnerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
  /** The role of the owner with respect to the organization. */
  organizationRole: RoleInOrganization;
};

/**
 * An Identity Provider configured to provision SAML and SCIM identities for
 * Organizations. Visible to (1) organization owners, (2) organization owners'
 * personal access tokens (classic) with read:org or admin:org scope, (3) GitHub
 * App with an installation token with read or write access to members.
 */
export type OrganizationIdentityProvider = Node & {
  /** The digest algorithm used to sign SAML requests for the Identity Provider. */
  digestMethod?: Maybe<Scalars['URI']['output']>;
  /** External Identities provisioned by this Identity Provider */
  externalIdentities: ExternalIdentityConnection;
  /** The Node ID of the OrganizationIdentityProvider object */
  id: Scalars['ID']['output'];
  /** The x509 certificate used by the Identity Provider to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars['X509Certificate']['output']>;
  /** The Issuer Entity ID for the SAML Identity Provider */
  issuer?: Maybe<Scalars['String']['output']>;
  /** Organization this Identity Provider belongs to */
  organization?: Maybe<Organization>;
  /** The signature algorithm used to sign SAML requests for the Identity Provider. */
  signatureMethod?: Maybe<Scalars['URI']['output']>;
  /** The URL endpoint for the Identity Provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars['URI']['output']>;
};


/**
 * An Identity Provider configured to provision SAML and SCIM identities for
 * Organizations. Visible to (1) organization owners, (2) organization owners'
 * personal access tokens (classic) with read:org or admin:org scope, (3) GitHub
 * App with an installation token with read or write access to members.
 */
export type OrganizationIdentityProviderexternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  membersOnly?: InputMaybe<Scalars['Boolean']['input']>;
  userName?: InputMaybe<Scalars['String']['input']>;
};

/** An Invitation for a user to an organization. */
export type OrganizationInvitation = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The email address of the user invited to the organization. */
  email?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the OrganizationInvitation object */
  id: Scalars['ID']['output'];
  /** The source of the invitation. */
  invitationSource: OrganizationInvitationSource;
  /** The type of invitation that was sent (e.g. email, user). */
  invitationType: OrganizationInvitationType;
  /** The user who was invited to the organization. */
  invitee?: Maybe<User>;
  /** The user who created the invitation. */
  inviter: User;
  /** The organization the invite is for */
  organization: Organization;
  /** The user's pending role in the organization (e.g. member, owner). */
  role: OrganizationInvitationRole;
};

/** The connection type for OrganizationInvitation. */
export type OrganizationInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type OrganizationInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<OrganizationInvitation>;
};

/** The possible organization invitation roles. */
export type OrganizationInvitationRole =
  /** The user is invited to be an admin of the organization. */
  | 'ADMIN'
  /** The user is invited to be a billing manager of the organization. */
  | 'BILLING_MANAGER'
  /** The user is invited to be a direct member of the organization. */
  | 'DIRECT_MEMBER'
  /** The user's previous role will be reinstated. */
  | 'REINSTATE';

/** The possible organization invitation sources. */
export type OrganizationInvitationSource =
  /** The invitation was created from the web interface or from API */
  | 'MEMBER'
  /** The invitation was created from SCIM */
  | 'SCIM'
  /** The invitation was sent before this feature was added */
  | 'UNKNOWN';

/** The possible organization invitation types. */
export type OrganizationInvitationType =
  /** The invitation was to an email address. */
  | 'EMAIL'
  /** The invitation was to an existing user. */
  | 'USER';

/** The connection type for User. */
export type OrganizationMemberConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a user within an organization. */
export type OrganizationMemberEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer. */
  hasTwoFactorEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** The item at the end of the edge. */
  node?: Maybe<User>;
  /** The role this user has in the organization. */
  role?: Maybe<OrganizationMemberRole>;
};

/** The possible roles within an organization for its members. */
export type OrganizationMemberRole =
  /** The user is an administrator of the organization. */
  | 'ADMIN'
  /** The user is a member of the organization. */
  | 'MEMBER';

/** The possible values for the members can create repositories setting on an organization. */
export type OrganizationMembersCanCreateRepositoriesSettingValue =
  /** Members will be able to create public and private repositories. */
  | 'ALL'
  /** Members will not be able to create public or private repositories. */
  | 'DISABLED'
  /** Members will be able to create only internal repositories. */
  | 'INTERNAL'
  /** Members will be able to create only private repositories. */
  | 'PRIVATE';

/** A GitHub Enterprise Importer (GEI) organization migration. */
export type OrganizationMigration = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['String']['output']>;
  /** The reason the organization migration failed. */
  failureReason?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the OrganizationMigration object */
  id: Scalars['ID']['output'];
  /** The remaining amount of repos to be migrated. */
  remainingRepositoriesCount?: Maybe<Scalars['Int']['output']>;
  /** The name of the source organization to be migrated. */
  sourceOrgName: Scalars['String']['output'];
  /** The URL of the source organization to migrate. */
  sourceOrgUrl: Scalars['URI']['output'];
  /** The migration state. */
  state: OrganizationMigrationState;
  /** The name of the target organization. */
  targetOrgName: Scalars['String']['output'];
  /** The total amount of repositories to be migrated. */
  totalRepositoriesCount?: Maybe<Scalars['Int']['output']>;
};

/** The Octoshift Organization migration state. */
export type OrganizationMigrationState =
  /** The Octoshift migration has failed. */
  | 'FAILED'
  /** The Octoshift migration has invalid credentials. */
  | 'FAILED_VALIDATION'
  /** The Octoshift migration is in progress. */
  | 'IN_PROGRESS'
  /** The Octoshift migration has not started. */
  | 'NOT_STARTED'
  /** The Octoshift migration needs to have its credentials validated. */
  | 'PENDING_VALIDATION'
  /** The Octoshift migration is performing post repository migrations. */
  | 'POST_REPO_MIGRATION'
  /** The Octoshift migration is performing pre repository migrations. */
  | 'PRE_REPO_MIGRATION'
  /** The Octoshift migration has been queued. */
  | 'QUEUED'
  /** The Octoshift org migration is performing repository migrations. */
  | 'REPO_MIGRATION'
  /** The Octoshift migration has succeeded. */
  | 'SUCCEEDED';

/** Used for argument of CreateProjectV2 mutation. */
export type OrganizationOrUser = Organization | User;

/** Ordering options for organization connections. */
export type OrganizationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order organizations by. */
  field: OrganizationOrderField;
};

/** Properties by which organization connections can be ordered. */
export type OrganizationOrderField =
  /** Order organizations by creation time */
  | 'CREATED_AT'
  /** Order organizations by login */
  | 'LOGIN';

/** An organization teams hovercard context */
export type OrganizationTeamsHovercardContext = HovercardContext & {
  /** A string describing this context */
  message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  octicon: Scalars['String']['output'];
  /** Teams in this organization the user is a member of that are relevant */
  relevantTeams: TeamConnection;
  /** The path for the full team list for this user */
  teamsResourcePath: Scalars['URI']['output'];
  /** The URL for the full team list for this user */
  teamsUrl: Scalars['URI']['output'];
  /** The total number of teams the user is on in the organization */
  totalTeamCount: Scalars['Int']['output'];
};


/** An organization teams hovercard context */
export type OrganizationTeamsHovercardContextrelevantTeamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** An organization list hovercard context */
export type OrganizationsHovercardContext = HovercardContext & {
  /** A string describing this context */
  message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  octicon: Scalars['String']['output'];
  /** Organizations this user is a member of that are relevant */
  relevantOrganizations: OrganizationConnection;
  /** The total number of organizations this user is in */
  totalOrganizationCount: Scalars['Int']['output'];
};


/** An organization list hovercard context */
export type OrganizationsHovercardContextrelevantOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
};

/** Information for an uploaded package. */
export type Package = Node & {
  /** The Node ID of the Package object */
  id: Scalars['ID']['output'];
  /** Find the latest version for the package. */
  latestVersion?: Maybe<PackageVersion>;
  /** Identifies the name of the package. */
  name: Scalars['String']['output'];
  /** Identifies the type of the package. */
  packageType: PackageType;
  /** The repository this package belongs to. */
  repository?: Maybe<Repository>;
  /** Statistics about package activity. */
  statistics?: Maybe<PackageStatistics>;
  /** Find package version by version string. */
  version?: Maybe<PackageVersion>;
  /** list of versions for this package */
  versions: PackageVersionConnection;
};


/** Information for an uploaded package. */
export type PackageversionArgs = {
  version: Scalars['String']['input'];
};


/** Information for an uploaded package. */
export type PackageversionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PackageVersionOrder>;
};

/** The connection type for Package. */
export type PackageConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Package>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PackageEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Package>;
};

/** A file in a package version. */
export type PackageFile = Node & {
  /** The Node ID of the PackageFile object */
  id: Scalars['ID']['output'];
  /** MD5 hash of the file. */
  md5?: Maybe<Scalars['String']['output']>;
  /** Name of the file. */
  name: Scalars['String']['output'];
  /** The package version this file belongs to. */
  packageVersion?: Maybe<PackageVersion>;
  /** SHA1 hash of the file. */
  sha1?: Maybe<Scalars['String']['output']>;
  /** SHA256 hash of the file. */
  sha256?: Maybe<Scalars['String']['output']>;
  /** Size of the file in bytes. */
  size?: Maybe<Scalars['Int']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** URL to download the asset. */
  url?: Maybe<Scalars['URI']['output']>;
};

/** The connection type for PackageFile. */
export type PackageFileConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageFile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PackageFileEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageFile>;
};

/** Ways in which lists of package files can be ordered upon return. */
export type PackageFileOrder = {
  /** The direction in which to order package files by the specified field. */
  direction?: InputMaybe<OrderDirection>;
  /** The field in which to order package files by. */
  field?: InputMaybe<PackageFileOrderField>;
};

/** Properties by which package file connections can be ordered. */
export type PackageFileOrderField =
  /** Order package files by creation time */
  | 'CREATED_AT';

/** Ways in which lists of packages can be ordered upon return. */
export type PackageOrder = {
  /** The direction in which to order packages by the specified field. */
  direction?: InputMaybe<OrderDirection>;
  /** The field in which to order packages by. */
  field?: InputMaybe<PackageOrderField>;
};

/** Properties by which package connections can be ordered. */
export type PackageOrderField =
  /** Order packages by creation time */
  | 'CREATED_AT';

/** Represents an owner of a package. */
export type PackageOwner = {
  /** The Node ID of the PackageOwner object */
  id: Scalars['ID']['output'];
  /** A list of packages under the owner. */
  packages: PackageConnection;
};


/** Represents an owner of a package. */
export type PackageOwnerpackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<PackageOrder>;
  packageType?: InputMaybe<PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** Represents a object that contains package activity statistics such as downloads. */
export type PackageStatistics = {
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars['Int']['output'];
};

/** A version tag contains the mapping between a tag name and a version. */
export type PackageTag = Node & {
  /** The Node ID of the PackageTag object */
  id: Scalars['ID']['output'];
  /** Identifies the tag name of the version. */
  name: Scalars['String']['output'];
  /** Version that the tag is associated with. */
  version?: Maybe<PackageVersion>;
};

/** The possible types of a package. */
export type PackageType =
  /** A debian package. */
  | 'DEBIAN'
  /** A docker image. */
  | 'DOCKER'
  /** A maven package. */
  | 'MAVEN'
  /** An npm package. */
  | 'NPM'
  /** A nuget package. */
  | 'NUGET'
  /** A python package. */
  | 'PYPI'
  /** A rubygems package. */
  | 'RUBYGEMS';

/** Information about a specific package version. */
export type PackageVersion = Node & {
  /** List of files associated with this package version */
  files: PackageFileConnection;
  /** The Node ID of the PackageVersion object */
  id: Scalars['ID']['output'];
  /** The package associated with this version. */
  package?: Maybe<Package>;
  /** The platform this version was built for. */
  platform?: Maybe<Scalars['String']['output']>;
  /** Whether or not this version is a pre-release. */
  preRelease: Scalars['Boolean']['output'];
  /** The README of this package version. */
  readme?: Maybe<Scalars['String']['output']>;
  /** The release associated with this package version. */
  release?: Maybe<Release>;
  /** Statistics about package activity. */
  statistics?: Maybe<PackageVersionStatistics>;
  /** The package version summary. */
  summary?: Maybe<Scalars['String']['output']>;
  /** The version string. */
  version: Scalars['String']['output'];
};


/** Information about a specific package version. */
export type PackageVersionfilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PackageFileOrder>;
};

/** The connection type for PackageVersion. */
export type PackageVersionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PackageVersionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageVersion>;
};

/** Ways in which lists of package versions can be ordered upon return. */
export type PackageVersionOrder = {
  /** The direction in which to order package versions by the specified field. */
  direction?: InputMaybe<OrderDirection>;
  /** The field in which to order package versions by. */
  field?: InputMaybe<PackageVersionOrderField>;
};

/** Properties by which package version connections can be ordered. */
export type PackageVersionOrderField =
  /** Order package versions by creation time */
  | 'CREATED_AT';

/** Represents a object that contains package version activity statistics such as downloads. */
export type PackageVersionStatistics = {
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars['Int']['output'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']['output']>;
};

/** The possible types of patch statuses. */
export type PatchStatus =
  /** The file was added. Git status 'A'. */
  | 'ADDED'
  /** The file's type was changed. Git status 'T'. */
  | 'CHANGED'
  /** The file was copied. Git status 'C'. */
  | 'COPIED'
  /** The file was deleted. Git status 'D'. */
  | 'DELETED'
  /** The file's contents were changed. Git status 'M'. */
  | 'MODIFIED'
  /** The file was renamed. Git status 'R'. */
  | 'RENAMED';

/** Types that can grant permissions on a repository to a user */
export type PermissionGranter = Organization | Repository | Team;

/** A level of permission and source for a user's access to a repository. */
export type PermissionSource = {
  /** The organization the repository belongs to. */
  organization: Organization;
  /** The level of access this source has granted to the user. */
  permission: DefaultRepositoryPermissionField;
  /** The name of the role this source has granted to the user. */
  roleName?: Maybe<Scalars['String']['output']>;
  /** The source of this permission. */
  source: PermissionGranter;
};

/** Autogenerated input type of PinIssue */
export type PinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the issue to be pinned */
  issueId: Scalars['ID']['input'];
};

/** Autogenerated return type of PinIssue */
export type PinIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was pinned */
  issue?: Maybe<Issue>;
};

/** Types that can be pinned to a profile page. */
export type PinnableItem = Gist | Repository;

/** The connection type for PinnableItem. */
export type PinnableItemConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PinnableItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PinnableItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PinnableItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PinnableItem>;
};

/** Represents items that can be pinned to a profile page or dashboard. */
export type PinnableItemType =
  /** A gist. */
  | 'GIST'
  /** An issue. */
  | 'ISSUE'
  /** An organization. */
  | 'ORGANIZATION'
  /** A project. */
  | 'PROJECT'
  /** A pull request. */
  | 'PULL_REQUEST'
  /** A repository. */
  | 'REPOSITORY'
  /** A team. */
  | 'TEAM'
  /** A user. */
  | 'USER';

/** A Pinned Discussion is a discussion pinned to a repository's index page. */
export type PinnedDiscussion = Node & RepositoryNode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The discussion that was pinned. */
  discussion: Discussion;
  /** Color stops of the chosen gradient */
  gradientStopColors: Array<Scalars['String']['output']>;
  /** The Node ID of the PinnedDiscussion object */
  id: Scalars['ID']['output'];
  /** Background texture pattern */
  pattern: PinnedDiscussionPattern;
  /** The actor that pinned this discussion. */
  pinnedBy: Actor;
  /** Preconfigured background gradient option */
  preconfiguredGradient?: Maybe<PinnedDiscussionGradient>;
  /** The repository associated with this node. */
  repository: Repository;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for PinnedDiscussion. */
export type PinnedDiscussionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PinnedDiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PinnedDiscussion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PinnedDiscussionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PinnedDiscussion>;
};

/** Preconfigured gradients that may be used to style discussions pinned within a repository. */
export type PinnedDiscussionGradient =
  /** A gradient of blue to mint */
  | 'BLUE_MINT'
  /** A gradient of blue to purple */
  | 'BLUE_PURPLE'
  /** A gradient of pink to blue */
  | 'PINK_BLUE'
  /** A gradient of purple to coral */
  | 'PURPLE_CORAL'
  /** A gradient of red to orange */
  | 'RED_ORANGE';

/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */
export type PinnedDiscussionPattern =
  /** An upward-facing chevron pattern */
  | 'CHEVRON_UP'
  /** A hollow dot pattern */
  | 'DOT'
  /** A solid dot pattern */
  | 'DOT_FILL'
  /** A heart pattern */
  | 'HEART_FILL'
  /** A plus sign pattern */
  | 'PLUS'
  /** A lightning bolt pattern */
  | 'ZAP';

/** Represents a 'pinned' event on a given issue or pull request. */
export type PinnedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the PinnedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the issue associated with the event. */
  issue: Issue;
};

/** A Pinned Issue is a issue pinned to a repository's index page. */
export type PinnedIssue = Node & {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** Identifies the primary key from the database as a BigInt. */
  fullDatabaseId?: Maybe<Scalars['BigInt']['output']>;
  /** The Node ID of the PinnedIssue object */
  id: Scalars['ID']['output'];
  /** The issue that was pinned. */
  issue: Issue;
  /** The actor that pinned this issue. */
  pinnedBy: Actor;
  /** The repository that this issue was pinned to. */
  repository: Repository;
};

/** The connection type for PinnedIssue. */
export type PinnedIssueConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PinnedIssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PinnedIssue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PinnedIssueEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PinnedIssue>;
};

/** Audit log entry for a private_repository_forking.disable event. */
export type PrivateRepositoryForkingDisableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  /** The Node ID of the PrivateRepositoryForkingDisableAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a private_repository_forking.enable event. */
export type PrivateRepositoryForkingEnableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  /** The Node ID of the PrivateRepositoryForkingEnableAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
export type ProfileItemShowcase = {
  /** Whether or not the owner has pinned any repositories or gists. */
  hasPinnedItems: Scalars['Boolean']['output'];
  /**
   * The repositories and gists in the showcase. If the profile owner has any
   * pinned items, those will be returned. Otherwise, the profile owner's popular
   * repositories will be returned.
   */
  items: PinnableItemConnection;
};


/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
export type ProfileItemShowcaseitemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents any entity on GitHub that has a profile page. */
export type ProfileOwner = {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean']['output'];
  /** The public profile email. */
  email?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the ProfileOwner object */
  id: Scalars['ID']['output'];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: ProfileItemShowcase;
  /** The public profile location. */
  location?: Maybe<Scalars['String']['output']>;
  /** The username used to login. */
  login: Scalars['String']['output'];
  /** The public profile name. */
  name?: Maybe<Scalars['String']['output']>;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int']['output'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean']['output'];
  /** The public profile website URL. */
  websiteUrl?: Maybe<Scalars['URI']['output']>;
};


/** Represents any entity on GitHub that has a profile page. */
export type ProfileOwneranyPinnableItemsArgs = {
  type?: InputMaybe<PinnableItemType>;
};


/** Represents any entity on GitHub that has a profile page. */
export type ProfileOwnerpinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<PinnableItemType>>;
};


/** Represents any entity on GitHub that has a profile page. */
export type ProfileOwnerpinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<PinnableItemType>>;
};

/** Projects manage issues, pull requests and notes within a project owner. */
export type Project = Closable & Node & Updatable & {
  /** The project's description body. */
  body?: Maybe<Scalars['String']['output']>;
  /** The projects description body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** List of columns in the project */
  columns: ProjectColumnConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who originally created the project. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the Project object */
  id: Scalars['ID']['output'];
  /** The project's name. */
  name: Scalars['String']['output'];
  /** The project's number. */
  number: Scalars['Int']['output'];
  /** The project's owner. Currently limited to repositories, organizations, and users. */
  owner: ProjectOwner;
  /** List of pending cards in this project */
  pendingCards: ProjectCardConnection;
  /** Project progress details. */
  progress: ProjectProgress;
  /** The HTTP path for this project */
  resourcePath: Scalars['URI']['output'];
  /** Whether the project is open or closed. */
  state: ProjectState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this project */
  url: Scalars['URI']['output'];
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
};


/** Projects manage issues, pull requests and notes within a project owner. */
export type ProjectcolumnsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Projects manage issues, pull requests and notes within a project owner. */
export type ProjectpendingCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A card in a project. */
export type ProjectCard = Node & {
  /**
   * The project column this card is associated under. A card may only belong to one
   * project column at a time. The column field will be null if the card is created
   * in a pending state and has yet to be associated with a column. Once cards are
   * associated with a column, they will not become pending in the future.
   */
  column?: Maybe<ProjectColumn>;
  /** The card content item */
  content?: Maybe<ProjectCardItem>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created this card */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ProjectCard object */
  id: Scalars['ID']['output'];
  /** Whether the card is archived */
  isArchived: Scalars['Boolean']['output'];
  /** The card note */
  note?: Maybe<Scalars['String']['output']>;
  /** The project that contains this card. */
  project: Project;
  /** The HTTP path for this card */
  resourcePath: Scalars['URI']['output'];
  /** The state of ProjectCard */
  state?: Maybe<ProjectCardState>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this card */
  url: Scalars['URI']['output'];
};

/** The possible archived states of a project card. */
export type ProjectCardArchivedState =
  /** A project card that is archived */
  | 'ARCHIVED'
  /** A project card that is not archived */
  | 'NOT_ARCHIVED';

/** The connection type for ProjectCard. */
export type ProjectCardConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectCardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectCard>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProjectCardEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectCard>;
};

/** An issue or PR and its owning repository to be used in a project card. */
export type ProjectCardImport = {
  /** The issue or pull request number. */
  number: Scalars['Int']['input'];
  /** Repository name with owner (owner/repository). */
  repository: Scalars['String']['input'];
};

/** Types that can be inside Project Cards. */
export type ProjectCardItem = Issue | PullRequest;

/** Various content states of a ProjectCard */
export type ProjectCardState =
  /** The card has content only. */
  | 'CONTENT_ONLY'
  /** The card has a note only. */
  | 'NOTE_ONLY'
  /** The card is redacted. */
  | 'REDACTED';

/** A column inside a project. */
export type ProjectColumn = Node & {
  /** List of cards in the column */
  cards: ProjectCardConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ProjectColumn object */
  id: Scalars['ID']['output'];
  /** The project column's name. */
  name: Scalars['String']['output'];
  /** The project that contains this column. */
  project: Project;
  /** The semantic purpose of the column */
  purpose?: Maybe<ProjectColumnPurpose>;
  /** The HTTP path for this project column */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this project column */
  url: Scalars['URI']['output'];
};


/** A column inside a project. */
export type ProjectColumncardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ProjectColumn. */
export type ProjectColumnConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectColumnEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectColumn>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProjectColumnEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectColumn>;
};

/** A project column and a list of its issues and PRs. */
export type ProjectColumnImport = {
  /** The name of the column. */
  columnName: Scalars['String']['input'];
  /** A list of issues and pull requests in the column. */
  issues?: InputMaybe<Array<ProjectCardImport>>;
  /** The position of the column, starting from 0. */
  position: Scalars['Int']['input'];
};

/** The semantic purpose of the column - todo, in progress, or done. */
export type ProjectColumnPurpose =
  /** The column contains cards which are complete */
  | 'DONE'
  /** The column contains cards which are currently being worked on */
  | 'IN_PROGRESS'
  /** The column contains cards still to be worked on */
  | 'TODO';

/** A list of projects associated with the owner. */
export type ProjectConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProjectEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Project>;
};

/** Ways in which lists of projects can be ordered upon return. */
export type ProjectOrder = {
  /** The direction in which to order projects by the specified field. */
  direction: OrderDirection;
  /** The field in which to order projects by. */
  field: ProjectOrderField;
};

/** Properties by which project connections can be ordered. */
export type ProjectOrderField =
  /** Order projects by creation time */
  | 'CREATED_AT'
  /** Order projects by name */
  | 'NAME'
  /** Order projects by update time */
  | 'UPDATED_AT';

/** Represents an owner of a Project. */
export type ProjectOwner = {
  /** The Node ID of the ProjectOwner object */
  id: Scalars['ID']['output'];
  /** Find project by number. */
  project?: Maybe<Project>;
  /** A list of projects under the owner. */
  projects: ProjectConnection;
  /** The HTTP path listing owners projects */
  projectsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL listing owners projects */
  projectsUrl: Scalars['URI']['output'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean']['output'];
};


/** Represents an owner of a Project. */
export type ProjectOwnerprojectArgs = {
  number: Scalars['Int']['input'];
};


/** Represents an owner of a Project. */
export type ProjectOwnerprojectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<ProjectState>>;
};

/** Project progress stats. */
export type ProjectProgress = {
  /** The number of done cards. */
  doneCount: Scalars['Int']['output'];
  /** The percentage of done cards. */
  donePercentage: Scalars['Float']['output'];
  /** Whether progress tracking is enabled and cards with purpose exist for this project */
  enabled: Scalars['Boolean']['output'];
  /** The number of in-progress cards. */
  inProgressCount: Scalars['Int']['output'];
  /** The percentage of in-progress cards. */
  inProgressPercentage: Scalars['Float']['output'];
  /** The number of to do cards. */
  todoCount: Scalars['Int']['output'];
  /** The percentage of to do cards. */
  todoPercentage: Scalars['Float']['output'];
};

/** State of the project; either 'open' or 'closed' */
export type ProjectState =
  /** The project is closed. */
  | 'CLOSED'
  /** The project is open. */
  | 'OPEN';

/** GitHub-provided templates for Projects */
export type ProjectTemplate =
  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */
  | 'AUTOMATED_KANBAN_V2'
  /** Create a board with triggers to automatically move cards across columns with review automation. */
  | 'AUTOMATED_REVIEWS_KANBAN'
  /** Create a board with columns for To do, In progress and Done. */
  | 'BASIC_KANBAN'
  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */
  | 'BUG_TRIAGE';

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2 = Closable & Node & Updatable & {
  /** Returns true if the project is closed. */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who originally created the project. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** A field of the project */
  field?: Maybe<ProjectV2FieldConfiguration>;
  /** List of fields and their constraints in the project */
  fields: ProjectV2FieldConfigurationConnection;
  /** The Node ID of the ProjectV2 object */
  id: Scalars['ID']['output'];
  /** List of items in the project */
  items: ProjectV2ItemConnection;
  /** The project's number. */
  number: Scalars['Int']['output'];
  /** The project's owner. Currently limited to organizations and users. */
  owner: ProjectV2Owner;
  /** Returns true if the project is public. */
  public: Scalars['Boolean']['output'];
  /** The project's readme. */
  readme?: Maybe<Scalars['String']['output']>;
  /** The repositories the project is linked to. */
  repositories: RepositoryConnection;
  /** The HTTP path for this project */
  resourcePath: Scalars['URI']['output'];
  /** The project's short description. */
  shortDescription?: Maybe<Scalars['String']['output']>;
  /** The teams the project is linked to. */
  teams: TeamConnection;
  /** Returns true if this project is a template. */
  template: Scalars['Boolean']['output'];
  /** The project's name. */
  title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this project */
  url: Scalars['URI']['output'];
  /** A view of the project */
  view?: Maybe<ProjectV2View>;
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** List of views in the project */
  views: ProjectV2ViewConnection;
  /** A workflow of the project */
  workflow?: Maybe<ProjectV2Workflow>;
  /** List of the workflows in the project */
  workflows: ProjectV2WorkflowConnection;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2fieldArgs = {
  name: Scalars['String']['input'];
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2fieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2itemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2ItemOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2repositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2teamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TeamOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2viewArgs = {
  number: Scalars['Int']['input'];
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2viewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2ViewOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2workflowArgs = {
  number: Scalars['Int']['input'];
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type ProjectV2workflowsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2WorkflowOrder>;
};

/** Possible collaborators for a project. */
export type ProjectV2Actor = Team | User;

/** The connection type for ProjectV2Actor. */
export type ProjectV2ActorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2ActorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2Actor>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProjectV2ActorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2Actor>;
};

/** A collaborator to update on a project. Only one of the userId or teamId should be provided. */
export type ProjectV2Collaborator = {
  /** The role to grant the collaborator */
  role: ProjectV2Roles;
  /** The ID of the team as a collaborator. */
  teamId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the user as a collaborator. */
  userId?: InputMaybe<Scalars['ID']['input']>;
};

/** The connection type for ProjectV2. */
export type ProjectV2Connection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2Edge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The type of a project field. */
export type ProjectV2CustomFieldType =
  /** Date */
  | 'DATE'
  /** Number */
  | 'NUMBER'
  /** Single Select */
  | 'SINGLE_SELECT'
  /** Text */
  | 'TEXT';

/** An edge in a connection. */
export type ProjectV2Edge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2>;
};

/** A field inside a project. */
export type ProjectV2Field = Node & ProjectV2FieldCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The field's type. */
  dataType: ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ProjectV2Field object */
  id: Scalars['ID']['output'];
  /** The project field's name. */
  name: Scalars['String']['output'];
  /** The project that contains this field. */
  project: ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** Common fields across different project field types */
export type ProjectV2FieldCommon = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The field's type. */
  dataType: ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ProjectV2FieldCommon object */
  id: Scalars['ID']['output'];
  /** The project field's name. */
  name: Scalars['String']['output'];
  /** The project that contains this field. */
  project: ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** Configurations for project fields. */
export type ProjectV2FieldConfiguration = ProjectV2Field | ProjectV2IterationField | ProjectV2SingleSelectField;

/** The connection type for ProjectV2FieldConfiguration. */
export type ProjectV2FieldConfigurationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2FieldConfigurationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2FieldConfiguration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProjectV2FieldConfigurationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2FieldConfiguration>;
};

/** The connection type for ProjectV2Field. */
export type ProjectV2FieldConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2FieldEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2Field>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProjectV2FieldEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2Field>;
};

/** Ordering options for project v2 field connections */
export type ProjectV2FieldOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 fields by. */
  field: ProjectV2FieldOrderField;
};

/** Properties by which project v2 field connections can be ordered. */
export type ProjectV2FieldOrderField =
  /** Order project v2 fields by creation time */
  | 'CREATED_AT'
  /** Order project v2 fields by name */
  | 'NAME'
  /** Order project v2 fields by position */
  | 'POSITION';

/** The type of a project field. */
export type ProjectV2FieldType =
  /** Assignees */
  | 'ASSIGNEES'
  /** Date */
  | 'DATE'
  /** Iteration */
  | 'ITERATION'
  /** Labels */
  | 'LABELS'
  /** Linked Pull Requests */
  | 'LINKED_PULL_REQUESTS'
  /** Milestone */
  | 'MILESTONE'
  /** Number */
  | 'NUMBER'
  /** Repository */
  | 'REPOSITORY'
  /** Reviewers */
  | 'REVIEWERS'
  /** Single Select */
  | 'SINGLE_SELECT'
  /** Text */
  | 'TEXT'
  /** Title */
  | 'TITLE'
  /** Tracked by */
  | 'TRACKED_BY'
  /** Tracks */
  | 'TRACKS';

/** The values that can be used to update a field of an item inside a Project. Only 1 value can be updated at a time. */
export type ProjectV2FieldValue = {
  /** The ISO 8601 date to set on the field. */
  date?: InputMaybe<Scalars['Date']['input']>;
  /** The id of the iteration to set on the field. */
  iterationId?: InputMaybe<Scalars['String']['input']>;
  /** The number to set on the field. */
  number?: InputMaybe<Scalars['Float']['input']>;
  /** The id of the single select option to set on the field. */
  singleSelectOptionId?: InputMaybe<Scalars['String']['input']>;
  /** The text to set on the field. */
  text?: InputMaybe<Scalars['String']['input']>;
};

/** Ways in which to filter lists of projects. */
export type ProjectV2Filters = {
  /** List project v2 filtered by the state given. */
  state?: InputMaybe<ProjectV2State>;
};

/** An item within a Project. */
export type ProjectV2Item = Node & {
  /** The content of the referenced draft issue, issue, or pull request */
  content?: Maybe<ProjectV2ItemContent>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The field value of the first project field which matches the 'name' argument that is set on the item. */
  fieldValueByName?: Maybe<ProjectV2ItemFieldValue>;
  /** The field values that are set on the item. */
  fieldValues: ProjectV2ItemFieldValueConnection;
  /** The Node ID of the ProjectV2Item object */
  id: Scalars['ID']['output'];
  /** Whether the item is archived. */
  isArchived: Scalars['Boolean']['output'];
  /** The project that contains this item. */
  project: ProjectV2;
  /** The type of the item. */
  type: ProjectV2ItemType;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};


/** An item within a Project. */
export type ProjectV2ItemfieldValueByNameArgs = {
  name: Scalars['String']['input'];
};


/** An item within a Project. */
export type ProjectV2ItemfieldValuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2ItemFieldValueOrder>;
};

/** The connection type for ProjectV2Item. */
export type ProjectV2ItemConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2ItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2Item>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Types that can be inside Project Items. */
export type ProjectV2ItemContent = DraftIssue | Issue | PullRequest;

/** An edge in a connection. */
export type ProjectV2ItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2Item>;
};

/** The value of a date field in a Project item. */
export type ProjectV2ItemFieldDateValue = Node & ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** Date value for the field */
  date?: Maybe<Scalars['Date']['output']>;
  /** The project field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The Node ID of the ProjectV2ItemFieldDateValue object */
  id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  item: ProjectV2Item;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The value of an iteration field in a Project item. */
export type ProjectV2ItemFieldIterationValue = Node & ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The duration of the iteration in days. */
  duration: Scalars['Int']['output'];
  /** The project field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The Node ID of the ProjectV2ItemFieldIterationValue object */
  id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  item: ProjectV2Item;
  /** The ID of the iteration. */
  iterationId: Scalars['String']['output'];
  /** The start date of the iteration. */
  startDate: Scalars['Date']['output'];
  /** The title of the iteration. */
  title: Scalars['String']['output'];
  /** The title of the iteration, with HTML. */
  titleHTML: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The value of the labels field in a Project item. */
export type ProjectV2ItemFieldLabelValue = {
  /** The field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** Labels value of a field */
  labels?: Maybe<LabelConnection>;
};


/** The value of the labels field in a Project item. */
export type ProjectV2ItemFieldLabelValuelabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The value of a milestone field in a Project item. */
export type ProjectV2ItemFieldMilestoneValue = {
  /** The field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** Milestone value of a field */
  milestone?: Maybe<Milestone>;
};

/** The value of a number field in a Project item. */
export type ProjectV2ItemFieldNumberValue = Node & ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The project field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The Node ID of the ProjectV2ItemFieldNumberValue object */
  id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  item: ProjectV2Item;
  /** Number as a float(8) */
  number?: Maybe<Scalars['Float']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The value of a pull request field in a Project item. */
export type ProjectV2ItemFieldPullRequestValue = {
  /** The field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The pull requests for this field */
  pullRequests?: Maybe<PullRequestConnection>;
};


/** The value of a pull request field in a Project item. */
export type ProjectV2ItemFieldPullRequestValuepullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PullRequestOrder>;
};

/** The value of a repository field in a Project item. */
export type ProjectV2ItemFieldRepositoryValue = {
  /** The field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The repository for this field. */
  repository?: Maybe<Repository>;
};

/** The value of a reviewers field in a Project item. */
export type ProjectV2ItemFieldReviewerValue = {
  /** The field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The reviewers for this field. */
  reviewers?: Maybe<RequestedReviewerConnection>;
};


/** The value of a reviewers field in a Project item. */
export type ProjectV2ItemFieldReviewerValuereviewersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The value of a single select field in a Project item. */
export type ProjectV2ItemFieldSingleSelectValue = Node & ProjectV2ItemFieldValueCommon & {
  /** The color applied to the selected single-select option. */
  color: ProjectV2SingleSelectFieldOptionColor;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** A plain-text description of the selected single-select option, such as what the option means. */
  description?: Maybe<Scalars['String']['output']>;
  /** The description of the selected single-select option, including HTML tags. */
  descriptionHTML?: Maybe<Scalars['String']['output']>;
  /** The project field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The Node ID of the ProjectV2ItemFieldSingleSelectValue object */
  id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  item: ProjectV2Item;
  /** The name of the selected single select option. */
  name?: Maybe<Scalars['String']['output']>;
  /** The html name of the selected single select option. */
  nameHTML?: Maybe<Scalars['String']['output']>;
  /** The id of the selected single select option. */
  optionId?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The value of a text field in a Project item. */
export type ProjectV2ItemFieldTextValue = Node & ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The project field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The Node ID of the ProjectV2ItemFieldTextValue object */
  id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  item: ProjectV2Item;
  /** Text value of a field */
  text?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The value of a user field in a Project item. */
export type ProjectV2ItemFieldUserValue = {
  /** The field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The users for this field */
  users?: Maybe<UserConnection>;
};


/** The value of a user field in a Project item. */
export type ProjectV2ItemFieldUserValueusersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Project field values */
export type ProjectV2ItemFieldValue = ProjectV2ItemFieldDateValue | ProjectV2ItemFieldIterationValue | ProjectV2ItemFieldLabelValue | ProjectV2ItemFieldMilestoneValue | ProjectV2ItemFieldNumberValue | ProjectV2ItemFieldPullRequestValue | ProjectV2ItemFieldRepositoryValue | ProjectV2ItemFieldReviewerValue | ProjectV2ItemFieldSingleSelectValue | ProjectV2ItemFieldTextValue | ProjectV2ItemFieldUserValue;

/** Common fields across different project field value types */
export type ProjectV2ItemFieldValueCommon = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The project field that contains this value. */
  field: ProjectV2FieldConfiguration;
  /** The Node ID of the ProjectV2ItemFieldValueCommon object */
  id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  item: ProjectV2Item;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for ProjectV2ItemFieldValue. */
export type ProjectV2ItemFieldValueConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2ItemFieldValueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2ItemFieldValue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProjectV2ItemFieldValueEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2ItemFieldValue>;
};

/** Ordering options for project v2 item field value connections */
export type ProjectV2ItemFieldValueOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 item field values by. */
  field: ProjectV2ItemFieldValueOrderField;
};

/** Properties by which project v2 item field value connections can be ordered. */
export type ProjectV2ItemFieldValueOrderField =
  /** Order project v2 item field values by the their position in the project */
  | 'POSITION';

/** Ordering options for project v2 item connections */
export type ProjectV2ItemOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 items by. */
  field: ProjectV2ItemOrderField;
};

/** Properties by which project v2 item connections can be ordered. */
export type ProjectV2ItemOrderField =
  /** Order project v2 items by the their position in the project */
  | 'POSITION';

/** The type of a project item. */
export type ProjectV2ItemType =
  /** Draft Issue */
  | 'DRAFT_ISSUE'
  /** Issue */
  | 'ISSUE'
  /** Pull Request */
  | 'PULL_REQUEST'
  /** Redacted Item */
  | 'REDACTED';

/** An iteration field inside a project. */
export type ProjectV2IterationField = Node & ProjectV2FieldCommon & {
  /** Iteration configuration settings */
  configuration: ProjectV2IterationFieldConfiguration;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The field's type. */
  dataType: ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ProjectV2IterationField object */
  id: Scalars['ID']['output'];
  /** The project field's name. */
  name: Scalars['String']['output'];
  /** The project that contains this field. */
  project: ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** Iteration field configuration for a project. */
export type ProjectV2IterationFieldConfiguration = {
  /** The iteration's completed iterations */
  completedIterations: Array<ProjectV2IterationFieldIteration>;
  /** The iteration's duration in days */
  duration: Scalars['Int']['output'];
  /** The iteration's iterations */
  iterations: Array<ProjectV2IterationFieldIteration>;
  /** The iteration's start day of the week */
  startDay: Scalars['Int']['output'];
};

/** Iteration field iteration settings for a project. */
export type ProjectV2IterationFieldIteration = {
  /** The iteration's duration in days */
  duration: Scalars['Int']['output'];
  /** The iteration's ID. */
  id: Scalars['String']['output'];
  /** The iteration's start date */
  startDate: Scalars['Date']['output'];
  /** The iteration's title. */
  title: Scalars['String']['output'];
  /** The iteration's html title. */
  titleHTML: Scalars['String']['output'];
};

/** Ways in which lists of projects can be ordered upon return. */
export type ProjectV2Order = {
  /** The direction in which to order projects by the specified field. */
  direction: OrderDirection;
  /** The field in which to order projects by. */
  field: ProjectV2OrderField;
};

/** Properties by which projects can be ordered. */
export type ProjectV2OrderField =
  /** The project's date and time of creation */
  | 'CREATED_AT'
  /** The project's number */
  | 'NUMBER'
  /** The project's title */
  | 'TITLE'
  /** The project's date and time of update */
  | 'UPDATED_AT';

/** Represents an owner of a project. */
export type ProjectV2Owner = {
  /** The Node ID of the ProjectV2Owner object */
  id: Scalars['ID']['output'];
  /** Find a project by number. */
  projectV2?: Maybe<ProjectV2>;
  /** A list of projects under the owner. */
  projectsV2: ProjectV2Connection;
};


/** Represents an owner of a project. */
export type ProjectV2OwnerprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** Represents an owner of a project. */
export type ProjectV2OwnerprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};

/** Recent projects for the owner. */
export type ProjectV2Recent = {
  /** Recent projects that this user has modified in the context of the owner. */
  recentProjects: ProjectV2Connection;
};


/** Recent projects for the owner. */
export type ProjectV2RecentrecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The possible roles of a collaborator on a project. */
export type ProjectV2Roles =
  /** The collaborator can view, edit, and maange the settings of the project */
  | 'ADMIN'
  /** The collaborator has no direct access to the project */
  | 'NONE'
  /** The collaborator can view the project */
  | 'READER'
  /** The collaborator can view and edit the project */
  | 'WRITER';

/** A single select field inside a project. */
export type ProjectV2SingleSelectField = Node & ProjectV2FieldCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The field's type. */
  dataType: ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ProjectV2SingleSelectField object */
  id: Scalars['ID']['output'];
  /** The project field's name. */
  name: Scalars['String']['output'];
  /** Options for the single select field */
  options: Array<ProjectV2SingleSelectFieldOption>;
  /** The project that contains this field. */
  project: ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};


/** A single select field inside a project. */
export type ProjectV2SingleSelectFieldoptionsArgs = {
  names?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Single select field option for a configuration for a project. */
export type ProjectV2SingleSelectFieldOption = {
  /** The option's display color. */
  color: ProjectV2SingleSelectFieldOptionColor;
  /** The option's plain-text description. */
  description: Scalars['String']['output'];
  /** The option's description, possibly containing HTML. */
  descriptionHTML: Scalars['String']['output'];
  /** The option's ID. */
  id: Scalars['String']['output'];
  /** The option's name. */
  name: Scalars['String']['output'];
  /** The option's html name. */
  nameHTML: Scalars['String']['output'];
};

/** The display color of a single-select field option. */
export type ProjectV2SingleSelectFieldOptionColor =
  /** BLUE */
  | 'BLUE'
  /** GRAY */
  | 'GRAY'
  /** GREEN */
  | 'GREEN'
  /** ORANGE */
  | 'ORANGE'
  /** PINK */
  | 'PINK'
  /** PURPLE */
  | 'PURPLE'
  /** RED */
  | 'RED'
  /** YELLOW */
  | 'YELLOW';

/** Represents a single select field option */
export type ProjectV2SingleSelectFieldOptionInput = {
  /** The display color of the option */
  color: ProjectV2SingleSelectFieldOptionColor;
  /** The description text of the option */
  description: Scalars['String']['input'];
  /** The name of the option */
  name: Scalars['String']['input'];
};

/** Represents a sort by field and direction. */
export type ProjectV2SortBy = {
  /** The direction of the sorting. Possible values are ASC and DESC. */
  direction: OrderDirection;
  /** The field by which items are sorted. */
  field: ProjectV2Field;
};

/** The connection type for ProjectV2SortBy. */
export type ProjectV2SortByConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2SortByEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2SortBy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProjectV2SortByEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2SortBy>;
};

/** Represents a sort by field and direction. */
export type ProjectV2SortByField = {
  /** The direction of the sorting. Possible values are ASC and DESC. */
  direction: OrderDirection;
  /** The field by which items are sorted. */
  field: ProjectV2FieldConfiguration;
};

/** The connection type for ProjectV2SortByField. */
export type ProjectV2SortByFieldConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2SortByFieldEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2SortByField>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProjectV2SortByFieldEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2SortByField>;
};

/** The possible states of a project v2. */
export type ProjectV2State =
  /** A project v2 that has been closed */
  | 'CLOSED'
  /** A project v2 that is still open */
  | 'OPEN';

/** A view within a ProjectV2. */
export type ProjectV2View = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The view's visible fields. */
  fields?: Maybe<ProjectV2FieldConfigurationConnection>;
  /** The project view's filter. */
  filter?: Maybe<Scalars['String']['output']>;
  /**
   * The view's group-by field.
   * @deprecated The `ProjectV2View#order_by` API is deprecated in favour of the more capable `ProjectV2View#group_by_field` API. Check out the `ProjectV2View#group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  groupBy?: Maybe<ProjectV2FieldConnection>;
  /** The view's group-by field. */
  groupByFields?: Maybe<ProjectV2FieldConfigurationConnection>;
  /** The Node ID of the ProjectV2View object */
  id: Scalars['ID']['output'];
  /** The project view's layout. */
  layout: ProjectV2ViewLayout;
  /** The project view's name. */
  name: Scalars['String']['output'];
  /** The project view's number. */
  number: Scalars['Int']['output'];
  /** The project that contains this view. */
  project: ProjectV2;
  /**
   * The view's sort-by config.
   * @deprecated The `ProjectV2View#sort_by` API is deprecated in favour of the more capable `ProjectV2View#sort_by_fields` API. Check out the `ProjectV2View#sort_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  sortBy?: Maybe<ProjectV2SortByConnection>;
  /** The view's sort-by config. */
  sortByFields?: Maybe<ProjectV2SortByFieldConnection>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /**
   * The view's vertical-group-by field.
   * @deprecated The `ProjectV2View#vertical_group_by` API is deprecated in favour of the more capable `ProjectV2View#vertical_group_by_fields` API. Check out the `ProjectV2View#vertical_group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  verticalGroupBy?: Maybe<ProjectV2FieldConnection>;
  /** The view's vertical-group-by field. */
  verticalGroupByFields?: Maybe<ProjectV2FieldConfigurationConnection>;
  /**
   * The view's visible fields.
   * @deprecated The `ProjectV2View#visibleFields` API is deprecated in favour of the more capable `ProjectV2View#fields` API. Check out the `ProjectV2View#fields` API as an example for the more capable alternative. Removal on 2023-01-01 UTC.
   */
  visibleFields?: Maybe<ProjectV2FieldConnection>;
};


/** A view within a ProjectV2. */
export type ProjectV2ViewfieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type ProjectV2ViewgroupByArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type ProjectV2ViewgroupByFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type ProjectV2ViewsortByArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A view within a ProjectV2. */
export type ProjectV2ViewsortByFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A view within a ProjectV2. */
export type ProjectV2ViewverticalGroupByArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type ProjectV2ViewverticalGroupByFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type ProjectV2ViewvisibleFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};

/** The connection type for ProjectV2View. */
export type ProjectV2ViewConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2ViewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2View>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProjectV2ViewEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2View>;
};

/** The layout of a project v2 view. */
export type ProjectV2ViewLayout =
  /** Board layout */
  | 'BOARD_LAYOUT'
  /** Roadmap layout */
  | 'ROADMAP_LAYOUT'
  /** Table layout */
  | 'TABLE_LAYOUT';

/** Ordering options for project v2 view connections */
export type ProjectV2ViewOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 views by. */
  field: ProjectV2ViewOrderField;
};

/** Properties by which project v2 view connections can be ordered. */
export type ProjectV2ViewOrderField =
  /** Order project v2 views by creation time */
  | 'CREATED_AT'
  /** Order project v2 views by name */
  | 'NAME'
  /** Order project v2 views by position */
  | 'POSITION';

/** A workflow inside a project. */
export type ProjectV2Workflow = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** Whether the workflow is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** The Node ID of the ProjectV2Workflow object */
  id: Scalars['ID']['output'];
  /** The name of the workflow. */
  name: Scalars['String']['output'];
  /** The number of the workflow. */
  number: Scalars['Int']['output'];
  /** The project that contains this workflow. */
  project: ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for ProjectV2Workflow. */
export type ProjectV2WorkflowConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectV2WorkflowEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectV2Workflow>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProjectV2WorkflowEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectV2Workflow>;
};

/** Ordering options for project v2 workflows connections */
export type ProjectV2WorkflowOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 workflows by. */
  field: ProjectV2WorkflowsOrderField;
};

/** Properties by which project workflows can be ordered. */
export type ProjectV2WorkflowsOrderField =
  /** The date and time of the workflow creation */
  | 'CREATED_AT'
  /** The name of the workflow */
  | 'NAME'
  /** The number of the workflow */
  | 'NUMBER'
  /** The date and time of the workflow update */
  | 'UPDATED_AT';

/** A user's public key. */
export type PublicKey = Node & {
  /** The last time this authorization was used to perform an action. Values will be null for keys not owned by the user. */
  accessedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Identifies the date and time when the key was created. Keys created before
   * March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.
   */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** The fingerprint for this PublicKey. */
  fingerprint: Scalars['String']['output'];
  /** The Node ID of the PublicKey object */
  id: Scalars['ID']['output'];
  /** Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user. */
  isReadOnly?: Maybe<Scalars['Boolean']['output']>;
  /** The public key string. */
  key: Scalars['String']['output'];
  /**
   * Identifies the date and time when the key was updated. Keys created before
   * March 5th, 2014 may have inaccurate values. Values will be null for keys not
   * owned by the user.
   */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** The connection type for PublicKey. */
export type PublicKeyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicKey>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PublicKeyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PublicKey>;
};

/** Autogenerated input type of PublishSponsorsTier */
export type PublishSponsorsTierInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the draft tier to publish. */
  tierId: Scalars['ID']['input'];
};

/** Autogenerated return type of PublishSponsorsTier */
export type PublishSponsorsTierPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The tier that was published. */
  sponsorsTier?: Maybe<SponsorsTier>;
};

/** A repository pull request. */
export type PullRequest = Assignable & Closable & Comment & Labelable & Lockable & Node & ProjectV2Owner & Reactable & RepositoryNode & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment & {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<LockReason>;
  /** The number of additions in this pull request. */
  additions: Scalars['Int']['output'];
  /** A list of Users assigned to this object. */
  assignees: UserConnection;
  /** The actor who authored the comment. */
  author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** Returns the auto-merge request object if one exists for this pull request. */
  autoMergeRequest?: Maybe<AutoMergeRequest>;
  /** Identifies the base Ref associated with the pull request. */
  baseRef?: Maybe<Ref>;
  /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */
  baseRefName: Scalars['String']['output'];
  /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */
  baseRefOid: Scalars['GitObjectID']['output'];
  /** The repository associated with this pull request's base Ref. */
  baseRepository?: Maybe<Repository>;
  /** The body as Markdown. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Whether or not the pull request is rebaseable. */
  canBeRebased: Scalars['Boolean']['output'];
  /** The number of changed files in this pull request. */
  changedFiles: Scalars['Int']['output'];
  /** The HTTP path for the checks of this pull request. */
  checksResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for the checks of this pull request. */
  checksUrl: Scalars['URI']['output'];
  /** `true` if the pull request is closed */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** List of issues that were may be closed by this pull request */
  closingIssuesReferences?: Maybe<IssueConnection>;
  /** A list of comments associated with the pull request. */
  comments: IssueCommentConnection;
  /** A list of commits present in this pull request's head branch not present in the base branch. */
  commits: PullRequestCommitConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The number of deletions in this pull request. */
  deletions: Scalars['Int']['output'];
  /** The actor who edited this pull request's body. */
  editor?: Maybe<Actor>;
  /** Lists the files changed within this pull request. */
  files?: Maybe<PullRequestChangedFileConnection>;
  /** Identifies the head Ref associated with the pull request. */
  headRef?: Maybe<Ref>;
  /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */
  headRefName: Scalars['String']['output'];
  /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */
  headRefOid: Scalars['GitObjectID']['output'];
  /** The repository associated with this pull request's head Ref. */
  headRepository?: Maybe<Repository>;
  /** The owner of the repository associated with this pull request's head Ref. */
  headRepositoryOwner?: Maybe<RepositoryOwner>;
  /** The hovercard information for this issue */
  hovercard: Hovercard;
  /** The Node ID of the PullRequest object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** The head and base repositories are different. */
  isCrossRepository: Scalars['Boolean']['output'];
  /** Identifies if the pull request is a draft. */
  isDraft: Scalars['Boolean']['output'];
  /** Is this pull request read by the viewer */
  isReadByViewer?: Maybe<Scalars['Boolean']['output']>;
  /** A list of labels associated with the object. */
  labels?: Maybe<LabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of latest reviews per user associated with the pull request. */
  latestOpinionatedReviews?: Maybe<PullRequestReviewConnection>;
  /** A list of latest reviews per user associated with the pull request that are not also pending review. */
  latestReviews?: Maybe<PullRequestReviewConnection>;
  /** `true` if the pull request is locked */
  locked: Scalars['Boolean']['output'];
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify: Scalars['Boolean']['output'];
  /** The commit that was created when this pull request was merged. */
  mergeCommit?: Maybe<Commit>;
  /** The merge queue entry of the pull request in the base branch's merge queue */
  mergeQueueEntry?: Maybe<MergeQueueEntry>;
  /** Detailed information about the current pull request merge state status. */
  mergeStateStatus: MergeStateStatus;
  /** Whether or not the pull request can be merged based on the existence of merge conflicts. */
  mergeable: MergeableState;
  /** Whether or not the pull request was merged. */
  merged: Scalars['Boolean']['output'];
  /** The date and time that the pull request was merged. */
  mergedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The actor who merged the pull request. */
  mergedBy?: Maybe<Actor>;
  /** Identifies the milestone associated with the pull request. */
  milestone?: Maybe<Milestone>;
  /** Identifies the pull request number. */
  number: Scalars['Int']['output'];
  /** A list of Users that are participating in the Pull Request conversation. */
  participants: UserConnection;
  /** The permalink to the pull request. */
  permalink: Scalars['URI']['output'];
  /**
   * The commit that GitHub automatically generated to test if this pull request
   * could be merged. This field will not return a value if the pull request is
   * merged, or if the test merge commit is still being generated. See the
   * `mergeable` field for more details on the mergeability of the pull request.
   */
  potentialMergeCommit?: Maybe<Commit>;
  /** List of project cards associated with this pull request. */
  projectCards: ProjectCardConnection;
  /** List of project items associated with this pull request. */
  projectItems: ProjectV2ItemConnection;
  /** Find a project by number. */
  projectV2?: Maybe<ProjectV2>;
  /** A list of projects under the owner. */
  projectsV2: ProjectV2Connection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** The repository associated with this node. */
  repository: Repository;
  /** The HTTP path for this pull request. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP path for reverting this pull request. */
  revertResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for reverting this pull request. */
  revertUrl: Scalars['URI']['output'];
  /** The current status of this pull request with respect to code review. */
  reviewDecision?: Maybe<PullRequestReviewDecision>;
  /** A list of review requests associated with the pull request. */
  reviewRequests?: Maybe<ReviewRequestConnection>;
  /** The list of all review threads for this pull request. */
  reviewThreads: PullRequestReviewThreadConnection;
  /** A list of reviews associated with the pull request. */
  reviews?: Maybe<PullRequestReviewConnection>;
  /** Identifies the state of the pull request. */
  state: PullRequestState;
  /** A list of reviewer suggestions based on commit history and past review comments. */
  suggestedReviewers: Array<Maybe<SuggestedReviewer>>;
  /**
   * A list of events, comments, commits, etc. associated with the pull request.
   * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.
   */
  timeline: PullRequestTimelineConnection;
  /** A list of events, comments, commits, etc. associated with the pull request. */
  timelineItems: PullRequestTimelineItemsConnection;
  /** Identifies the pull request title. */
  title: Scalars['String']['output'];
  /** Identifies the pull request title rendered to HTML. */
  titleHTML: Scalars['HTML']['output'];
  /** Returns a count of how many comments this pull request has received. */
  totalCommentsCount?: Maybe<Scalars['Int']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this pull request. */
  url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<UserContentEditConnection>;
  /** Whether or not the viewer can apply suggestion. */
  viewerCanApplySuggestion: Scalars['Boolean']['output'];
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Check if the viewer can restore the deleted head ref. */
  viewerCanDeleteHeadRef: Scalars['Boolean']['output'];
  /** Whether or not the viewer can disable auto-merge */
  viewerCanDisableAutoMerge: Scalars['Boolean']['output'];
  /** Can the viewer edit files within this pull request. */
  viewerCanEditFiles: Scalars['Boolean']['output'];
  /** Whether or not the viewer can enable auto-merge */
  viewerCanEnableAutoMerge: Scalars['Boolean']['output'];
  /** Indicates whether the viewer can bypass branch protections and merge the pull request immediately */
  viewerCanMergeAsAdmin: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /**
   * Whether or not the viewer can update the head ref of this PR, by merging or rebasing the base ref.
   * If the head ref is up to date or unable to be updated by this user, this will return false.
   */
  viewerCanUpdateBranch: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
  /** The latest review given from the viewer. */
  viewerLatestReview?: Maybe<PullRequestReview>;
  /** The person who has requested the viewer for review on this pull request. */
  viewerLatestReviewRequest?: Maybe<ReviewRequest>;
  /** The merge body text for the viewer and method. */
  viewerMergeBodyText: Scalars['String']['output'];
  /** The merge headline text for the viewer and method. */
  viewerMergeHeadlineText: Scalars['String']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<SubscriptionState>;
};


/** A repository pull request. */
export type PullRequestassigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type PullRequestclosingIssuesReferencesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  userLinkedOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository pull request. */
export type PullRequestcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueCommentOrder>;
};


/** A repository pull request. */
export type PullRequestcommitsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type PullRequestfilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type PullRequesthovercardArgs = {
  includeNotificationContexts?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository pull request. */
export type PullRequestlabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LabelOrder>;
};


/** A repository pull request. */
export type PullRequestlatestOpinionatedReviewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  writersOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository pull request. */
export type PullRequestlatestReviewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type PullRequestparticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type PullRequestprojectCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type PullRequestprojectItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type PullRequestprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** A repository pull request. */
export type PullRequestprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository pull request. */
export type PullRequestreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A repository pull request. */
export type PullRequestreviewRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type PullRequestreviewThreadsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type PullRequestreviewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  states?: InputMaybe<Array<PullRequestReviewState>>;
};


/** A repository pull request. */
export type PullRequesttimelineArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A repository pull request. */
export type PullRequesttimelineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  itemTypes?: InputMaybe<Array<PullRequestTimelineItemsItemType>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type PullRequestuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type PullRequestviewerMergeBodyTextArgs = {
  mergeType?: InputMaybe<PullRequestMergeMethod>;
};


/** A repository pull request. */
export type PullRequestviewerMergeHeadlineTextArgs = {
  mergeType?: InputMaybe<PullRequestMergeMethod>;
};

/** The possible methods for updating a pull request's head branch with the base branch. */
export type PullRequestBranchUpdateMethod =
  /** Update branch via merge */
  | 'MERGE'
  /** Update branch via rebase */
  | 'REBASE';

/** A file changed in a pull request. */
export type PullRequestChangedFile = {
  /** The number of additions to the file. */
  additions: Scalars['Int']['output'];
  /** How the file was changed in this PullRequest */
  changeType: PatchStatus;
  /** The number of deletions to the file. */
  deletions: Scalars['Int']['output'];
  /** The path of the file. */
  path: Scalars['String']['output'];
  /** The state of the file for the viewer. */
  viewerViewedState: FileViewedState;
};

/** The connection type for PullRequestChangedFile. */
export type PullRequestChangedFileConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestChangedFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestChangedFile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PullRequestChangedFileEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestChangedFile>;
};

/** Represents a Git commit part of a pull request. */
export type PullRequestCommit = Node & UniformResourceLocatable & {
  /** The Git commit object */
  commit: Commit;
  /** The Node ID of the PullRequestCommit object */
  id: Scalars['ID']['output'];
  /** The pull request this commit belongs to */
  pullRequest: PullRequest;
  /** The HTTP path for this pull request commit */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this pull request commit */
  url: Scalars['URI']['output'];
};

/** Represents a commit comment thread part of a pull request. */
export type PullRequestCommitCommentThread = Node & RepositoryNode & {
  /** The comments that exist in this thread. */
  comments: CommitCommentConnection;
  /** The commit the comments were made on. */
  commit: Commit;
  /** The Node ID of the PullRequestCommitCommentThread object */
  id: Scalars['ID']['output'];
  /** The file the comments were made on. */
  path?: Maybe<Scalars['String']['output']>;
  /** The position in the diff for the commit that the comment was made on. */
  position?: Maybe<Scalars['Int']['output']>;
  /** The pull request this commit comment thread belongs to */
  pullRequest: PullRequest;
  /** The repository associated with this node. */
  repository: Repository;
};


/** Represents a commit comment thread part of a pull request. */
export type PullRequestCommitCommentThreadcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PullRequestCommit. */
export type PullRequestCommitConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestCommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestCommit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PullRequestCommitEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestCommit>;
};

/** The connection type for PullRequest. */
export type PullRequestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** This aggregates pull requests opened by a user within one repository. */
export type PullRequestContributionsByRepository = {
  /** The pull request contributions. */
  contributions: CreatedPullRequestContributionConnection;
  /** The repository in which the pull requests were opened. */
  repository: Repository;
};


/** This aggregates pull requests opened by a user within one repository. */
export type PullRequestContributionsByRepositorycontributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};

/** An edge in a connection. */
export type PullRequestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequest>;
};

/** Represents available types of methods to use when merging a pull request. */
export type PullRequestMergeMethod =
  /** Add all commits from the head branch to the base branch with a merge commit. */
  | 'MERGE'
  /** Add all commits from the head branch onto the base branch individually. */
  | 'REBASE'
  /** Combine all commits from the head branch into a single commit in the base branch. */
  | 'SQUASH';

/** Ways in which lists of issues can be ordered upon return. */
export type PullRequestOrder = {
  /** The direction in which to order pull requests by the specified field. */
  direction: OrderDirection;
  /** The field in which to order pull requests by. */
  field: PullRequestOrderField;
};

/** Properties by which pull_requests connections can be ordered. */
export type PullRequestOrderField =
  /** Order pull_requests by creation time */
  | 'CREATED_AT'
  /** Order pull_requests by update time */
  | 'UPDATED_AT';

/** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
export type PullRequestParameters = {
  /** New, reviewable commits pushed will dismiss previous pull request review approvals. */
  dismissStaleReviewsOnPush: Scalars['Boolean']['output'];
  /** Require an approving review in pull requests that modify files that have a designated code owner. */
  requireCodeOwnerReview: Scalars['Boolean']['output'];
  /** Whether the most recent reviewable push must be approved by someone other than the person who pushed it. */
  requireLastPushApproval: Scalars['Boolean']['output'];
  /** The number of approving reviews that are required before a pull request can be merged. */
  requiredApprovingReviewCount: Scalars['Int']['output'];
  /** All conversations on code must be resolved before a pull request can be merged. */
  requiredReviewThreadResolution: Scalars['Boolean']['output'];
};

/** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
export type PullRequestParametersInput = {
  /** New, reviewable commits pushed will dismiss previous pull request review approvals. */
  dismissStaleReviewsOnPush: Scalars['Boolean']['input'];
  /** Require an approving review in pull requests that modify files that have a designated code owner. */
  requireCodeOwnerReview: Scalars['Boolean']['input'];
  /** Whether the most recent reviewable push must be approved by someone other than the person who pushed it. */
  requireLastPushApproval: Scalars['Boolean']['input'];
  /** The number of approving reviews that are required before a pull request can be merged. */
  requiredApprovingReviewCount: Scalars['Int']['input'];
  /** All conversations on code must be resolved before a pull request can be merged. */
  requiredReviewThreadResolution: Scalars['Boolean']['input'];
};

/** A review object for a given pull request. */
export type PullRequestReview = Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** Indicates whether the author of this review has push access to the repository. */
  authorCanPushToRepository: Scalars['Boolean']['output'];
  /** Identifies the pull request review body. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** The body of this review rendered as plain text. */
  bodyText: Scalars['String']['output'];
  /** A list of review comments for the current pull request review. */
  comments: PullRequestReviewCommentConnection;
  /** Identifies the commit associated with this pull request review. */
  commit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Actor>;
  /** The Node ID of the PullRequestReview object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** A list of teams that this review was made on behalf of. */
  onBehalfOf: TeamConnection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the pull request associated with this pull request review. */
  pullRequest: PullRequest;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** The repository associated with this node. */
  repository: Repository;
  /** The HTTP path permalink for this PullRequestReview. */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the current state of the pull request review. */
  state: PullRequestReviewState;
  /** Identifies when the Pull Request Review was submitted */
  submittedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL permalink for this PullRequestReview. */
  url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** A review object for a given pull request. */
export type PullRequestReviewcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A review object for a given pull request. */
export type PullRequestReviewonBehalfOfArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A review object for a given pull request. */
export type PullRequestReviewreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A review object for a given pull request. */
export type PullRequestReviewuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A review comment associated with a given repository pull request. */
export type PullRequestReviewComment = Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** The comment body of this review comment. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** The comment body of this review comment rendered as plain text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the commit associated with the comment. */
  commit?: Maybe<Commit>;
  /** Identifies when the comment was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The diff hunk to which the comment applies. */
  diffHunk: Scalars['String']['output'];
  /** Identifies when the comment was created in a draft state. */
  draftedAt: Scalars['DateTime']['output'];
  /** The actor who edited the comment. */
  editor?: Maybe<Actor>;
  /** The Node ID of the PullRequestReviewComment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The end line number on the file to which the comment applies */
  line?: Maybe<Scalars['Int']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies the original commit associated with the comment. */
  originalCommit?: Maybe<Commit>;
  /** The end line number on the file to which the comment applied when it was first created */
  originalLine?: Maybe<Scalars['Int']['output']>;
  /**
   * The original line index in the diff to which the comment applies.
   * @deprecated We are phasing out diff-relative positioning for PR comments Removal on 2023-10-01 UTC.
   */
  originalPosition: Scalars['Int']['output'];
  /** The start line number on the file to which the comment applied when it was first created */
  originalStartLine?: Maybe<Scalars['Int']['output']>;
  /** Identifies when the comment body is outdated */
  outdated: Scalars['Boolean']['output'];
  /** The path to which the comment applies. */
  path: Scalars['String']['output'];
  /**
   * The line index in the diff to which the comment applies.
   * @deprecated We are phasing out diff-relative positioning for PR comments Use the `line` and `startLine` fields instead, which are file line numbers instead of diff line numbers Removal on 2023-10-01 UTC.
   */
  position?: Maybe<Scalars['Int']['output']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The pull request associated with this review comment. */
  pullRequest: PullRequest;
  /** The pull request review associated with this review comment. */
  pullRequestReview?: Maybe<PullRequestReview>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** The comment this is a reply to. */
  replyTo?: Maybe<PullRequestReviewComment>;
  /** The repository associated with this node. */
  repository: Repository;
  /** The HTTP path permalink for this review comment. */
  resourcePath: Scalars['URI']['output'];
  /** The start line number on the file to which the comment applies */
  startLine?: Maybe<Scalars['Int']['output']>;
  /** Identifies the state of the comment. */
  state: PullRequestReviewCommentState;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  subjectType: PullRequestReviewThreadSubjectType;
  /** Identifies when the comment was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL permalink for this review comment. */
  url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** A review comment associated with a given repository pull request. */
export type PullRequestReviewCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A review comment associated with a given repository pull request. */
export type PullRequestReviewCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PullRequestReviewComment. */
export type PullRequestReviewCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestReviewCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestReviewComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PullRequestReviewCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestReviewComment>;
};

/** The possible states of a pull request review comment. */
export type PullRequestReviewCommentState =
  /** A comment that is part of a pending review */
  | 'PENDING'
  /** A comment that is part of a submitted review */
  | 'SUBMITTED';

/** The connection type for PullRequestReview. */
export type PullRequestReviewConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestReviewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestReview>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** This aggregates pull request reviews made by a user within one repository. */
export type PullRequestReviewContributionsByRepository = {
  /** The pull request review contributions. */
  contributions: CreatedPullRequestReviewContributionConnection;
  /** The repository in which the pull request reviews were made. */
  repository: Repository;
};


/** This aggregates pull request reviews made by a user within one repository. */
export type PullRequestReviewContributionsByRepositorycontributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};

/** The review status of a pull request. */
export type PullRequestReviewDecision =
  /** The pull request has received an approving review. */
  | 'APPROVED'
  /** Changes have been requested on the pull request. */
  | 'CHANGES_REQUESTED'
  /** A review is required before the pull request can be merged. */
  | 'REVIEW_REQUIRED';

/** An edge in a connection. */
export type PullRequestReviewEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestReview>;
};

/** The possible events to perform on a pull request review. */
export type PullRequestReviewEvent =
  /** Submit feedback and approve merging these changes. */
  | 'APPROVE'
  /** Submit general feedback without explicit approval. */
  | 'COMMENT'
  /** Dismiss review so it now longer effects merging. */
  | 'DISMISS'
  /** Submit feedback that must be addressed before merging. */
  | 'REQUEST_CHANGES';

/** The possible states of a pull request review. */
export type PullRequestReviewState =
  /** A review allowing the pull request to merge. */
  | 'APPROVED'
  /** A review blocking the pull request from merging. */
  | 'CHANGES_REQUESTED'
  /** An informational review. */
  | 'COMMENTED'
  /** A review that has been dismissed. */
  | 'DISMISSED'
  /** A review that has not yet been submitted. */
  | 'PENDING';

/** A threaded list of comments for a given pull request. */
export type PullRequestReviewThread = Node & {
  /** A list of pull request comments associated with the thread. */
  comments: PullRequestReviewCommentConnection;
  /** The side of the diff on which this thread was placed. */
  diffSide: DiffSide;
  /** The Node ID of the PullRequestReviewThread object */
  id: Scalars['ID']['output'];
  /** Whether or not the thread has been collapsed (resolved) */
  isCollapsed: Scalars['Boolean']['output'];
  /** Indicates whether this thread was outdated by newer changes. */
  isOutdated: Scalars['Boolean']['output'];
  /** Whether this thread has been resolved */
  isResolved: Scalars['Boolean']['output'];
  /** The line in the file to which this thread refers */
  line?: Maybe<Scalars['Int']['output']>;
  /** The original line in the file to which this thread refers. */
  originalLine?: Maybe<Scalars['Int']['output']>;
  /** The original start line in the file to which this thread refers (multi-line only). */
  originalStartLine?: Maybe<Scalars['Int']['output']>;
  /** Identifies the file path of this thread. */
  path: Scalars['String']['output'];
  /** Identifies the pull request associated with this thread. */
  pullRequest: PullRequest;
  /** Identifies the repository associated with this thread. */
  repository: Repository;
  /** The user who resolved this thread */
  resolvedBy?: Maybe<User>;
  /** The side of the diff that the first line of the thread starts on (multi-line only) */
  startDiffSide?: Maybe<DiffSide>;
  /** The start line in the file to which this thread refers (multi-line only) */
  startLine?: Maybe<Scalars['Int']['output']>;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  subjectType: PullRequestReviewThreadSubjectType;
  /** Indicates whether the current viewer can reply to this thread. */
  viewerCanReply: Scalars['Boolean']['output'];
  /** Whether or not the viewer can resolve this thread */
  viewerCanResolve: Scalars['Boolean']['output'];
  /** Whether or not the viewer can unresolve this thread */
  viewerCanUnresolve: Scalars['Boolean']['output'];
};


/** A threaded list of comments for a given pull request. */
export type PullRequestReviewThreadcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
};

/** Review comment threads for a pull request review. */
export type PullRequestReviewThreadConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestReviewThreadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestReviewThread>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PullRequestReviewThreadEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestReviewThread>;
};

/** The possible subject types of a pull request review comment. */
export type PullRequestReviewThreadSubjectType =
  /** A comment that has been made against the file of a pull request */
  | 'FILE'
  /** A comment that has been made against the line of a pull request */
  | 'LINE';

/** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
export type PullRequestRevisionMarker = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The last commit the viewer has seen. */
  lastSeenCommit: Commit;
  /** The pull request to which the marker belongs. */
  pullRequest: PullRequest;
};

/** The possible states of a pull request. */
export type PullRequestState =
  /** A pull request that has been closed without being merged. */
  | 'CLOSED'
  /** A pull request that has been closed by being merged. */
  | 'MERGED'
  /** A pull request that is still open. */
  | 'OPEN';

/** A repository pull request template. */
export type PullRequestTemplate = {
  /** The body of the template */
  body?: Maybe<Scalars['String']['output']>;
  /** The filename of the template */
  filename?: Maybe<Scalars['String']['output']>;
  /** The repository the template belongs to */
  repository: Repository;
};

/** A threaded list of comments for a given pull request. */
export type PullRequestThread = Node & {
  /** A list of pull request comments associated with the thread. */
  comments: PullRequestReviewCommentConnection;
  /** The side of the diff on which this thread was placed. */
  diffSide: DiffSide;
  /** The Node ID of the PullRequestThread object */
  id: Scalars['ID']['output'];
  /** Whether or not the thread has been collapsed (resolved) */
  isCollapsed: Scalars['Boolean']['output'];
  /** Indicates whether this thread was outdated by newer changes. */
  isOutdated: Scalars['Boolean']['output'];
  /** Whether this thread has been resolved */
  isResolved: Scalars['Boolean']['output'];
  /** The line in the file to which this thread refers */
  line?: Maybe<Scalars['Int']['output']>;
  /** Identifies the file path of this thread. */
  path: Scalars['String']['output'];
  /** Identifies the pull request associated with this thread. */
  pullRequest: PullRequest;
  /** Identifies the repository associated with this thread. */
  repository: Repository;
  /** The user who resolved this thread */
  resolvedBy?: Maybe<User>;
  /** The side of the diff that the first line of the thread starts on (multi-line only) */
  startDiffSide?: Maybe<DiffSide>;
  /** The line of the first file diff in the thread. */
  startLine?: Maybe<Scalars['Int']['output']>;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  subjectType: PullRequestReviewThreadSubjectType;
  /** Indicates whether the current viewer can reply to this thread. */
  viewerCanReply: Scalars['Boolean']['output'];
  /** Whether or not the viewer can resolve this thread */
  viewerCanResolve: Scalars['Boolean']['output'];
  /** Whether or not the viewer can unresolve this thread */
  viewerCanUnresolve: Scalars['Boolean']['output'];
};


/** A threaded list of comments for a given pull request. */
export type PullRequestThreadcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PullRequestTimelineItem. */
export type PullRequestTimelineConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestTimelineItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestTimelineItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An item in a pull request timeline */
export type PullRequestTimelineItem = AssignedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | Commit | CommitCommentThread | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MergedEvent | MilestonedEvent | PullRequestReview | PullRequestReviewComment | PullRequestReviewThread | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent;

/** An edge in a connection. */
export type PullRequestTimelineItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestTimelineItem>;
};

/** An item in a pull request timeline */
export type PullRequestTimelineItems = AddedToMergeQueueEvent | AddedToProjectEvent | AssignedEvent | AutoMergeDisabledEvent | AutoMergeEnabledEvent | AutoRebaseEnabledEvent | AutoSquashEnabledEvent | AutomaticBaseChangeFailedEvent | AutomaticBaseChangeSucceededEvent | BaseRefChangedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertToDraftEvent | ConvertedNoteToIssueEvent | ConvertedToDiscussionEvent | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | DisconnectedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MergedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | PullRequestCommit | PullRequestCommitCommentThread | PullRequestReview | PullRequestReviewThread | PullRequestRevisionMarker | ReadyForReviewEvent | ReferencedEvent | RemovedFromMergeQueueEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent;

/** The connection type for PullRequestTimelineItems. */
export type PullRequestTimelineItemsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PullRequestTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars['Int']['output'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PullRequestTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars['Int']['output'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** An edge in a connection. */
export type PullRequestTimelineItemsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PullRequestTimelineItems>;
};

/** The possible item types found in a timeline. */
export type PullRequestTimelineItemsItemType =
  /** Represents an 'added_to_merge_queue' event on a given pull request. */
  | 'ADDED_TO_MERGE_QUEUE_EVENT'
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  | 'ADDED_TO_PROJECT_EVENT'
  /** Represents an 'assigned' event on any assignable object. */
  | 'ASSIGNED_EVENT'
  /** Represents a 'automatic_base_change_failed' event on a given pull request. */
  | 'AUTOMATIC_BASE_CHANGE_FAILED_EVENT'
  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
  | 'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT'
  /** Represents a 'auto_merge_disabled' event on a given pull request. */
  | 'AUTO_MERGE_DISABLED_EVENT'
  /** Represents a 'auto_merge_enabled' event on a given pull request. */
  | 'AUTO_MERGE_ENABLED_EVENT'
  /** Represents a 'auto_rebase_enabled' event on a given pull request. */
  | 'AUTO_REBASE_ENABLED_EVENT'
  /** Represents a 'auto_squash_enabled' event on a given pull request. */
  | 'AUTO_SQUASH_ENABLED_EVENT'
  /** Represents a 'base_ref_changed' event on a given issue or pull request. */
  | 'BASE_REF_CHANGED_EVENT'
  /** Represents a 'base_ref_deleted' event on a given pull request. */
  | 'BASE_REF_DELETED_EVENT'
  /** Represents a 'base_ref_force_pushed' event on a given pull request. */
  | 'BASE_REF_FORCE_PUSHED_EVENT'
  /** Represents a 'closed' event on any `Closable`. */
  | 'CLOSED_EVENT'
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  | 'COMMENT_DELETED_EVENT'
  /** Represents a 'connected' event on a given issue or pull request. */
  | 'CONNECTED_EVENT'
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  | 'CONVERTED_NOTE_TO_ISSUE_EVENT'
  /** Represents a 'converted_to_discussion' event on a given issue. */
  | 'CONVERTED_TO_DISCUSSION_EVENT'
  /** Represents a 'convert_to_draft' event on a given pull request. */
  | 'CONVERT_TO_DRAFT_EVENT'
  /** Represents a mention made by one issue or pull request to another. */
  | 'CROSS_REFERENCED_EVENT'
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  | 'DEMILESTONED_EVENT'
  /** Represents a 'deployed' event on a given pull request. */
  | 'DEPLOYED_EVENT'
  /** Represents a 'deployment_environment_changed' event on a given pull request. */
  | 'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT'
  /** Represents a 'disconnected' event on a given issue or pull request. */
  | 'DISCONNECTED_EVENT'
  /** Represents a 'head_ref_deleted' event on a given pull request. */
  | 'HEAD_REF_DELETED_EVENT'
  /** Represents a 'head_ref_force_pushed' event on a given pull request. */
  | 'HEAD_REF_FORCE_PUSHED_EVENT'
  /** Represents a 'head_ref_restored' event on a given pull request. */
  | 'HEAD_REF_RESTORED_EVENT'
  /** Represents a comment on an Issue. */
  | 'ISSUE_COMMENT'
  /** Represents a 'labeled' event on a given issue or pull request. */
  | 'LABELED_EVENT'
  /** Represents a 'locked' event on a given issue or pull request. */
  | 'LOCKED_EVENT'
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  | 'MARKED_AS_DUPLICATE_EVENT'
  /** Represents a 'mentioned' event on a given issue or pull request. */
  | 'MENTIONED_EVENT'
  /** Represents a 'merged' event on a given pull request. */
  | 'MERGED_EVENT'
  /** Represents a 'milestoned' event on a given issue or pull request. */
  | 'MILESTONED_EVENT'
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  | 'MOVED_COLUMNS_IN_PROJECT_EVENT'
  /** Represents a 'pinned' event on a given issue or pull request. */
  | 'PINNED_EVENT'
  /** Represents a Git commit part of a pull request. */
  | 'PULL_REQUEST_COMMIT'
  /** Represents a commit comment thread part of a pull request. */
  | 'PULL_REQUEST_COMMIT_COMMENT_THREAD'
  /** A review object for a given pull request. */
  | 'PULL_REQUEST_REVIEW'
  /** A threaded list of comments for a given pull request. */
  | 'PULL_REQUEST_REVIEW_THREAD'
  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
  | 'PULL_REQUEST_REVISION_MARKER'
  /** Represents a 'ready_for_review' event on a given pull request. */
  | 'READY_FOR_REVIEW_EVENT'
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  | 'REFERENCED_EVENT'
  /** Represents a 'removed_from_merge_queue' event on a given pull request. */
  | 'REMOVED_FROM_MERGE_QUEUE_EVENT'
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  | 'REMOVED_FROM_PROJECT_EVENT'
  /** Represents a 'renamed' event on a given issue or pull request */
  | 'RENAMED_TITLE_EVENT'
  /** Represents a 'reopened' event on any `Closable`. */
  | 'REOPENED_EVENT'
  /** Represents a 'review_dismissed' event on a given issue or pull request. */
  | 'REVIEW_DISMISSED_EVENT'
  /** Represents an 'review_requested' event on a given pull request. */
  | 'REVIEW_REQUESTED_EVENT'
  /** Represents an 'review_request_removed' event on a given pull request. */
  | 'REVIEW_REQUEST_REMOVED_EVENT'
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  | 'SUBSCRIBED_EVENT'
  /** Represents a 'transferred' event on a given issue or pull request. */
  | 'TRANSFERRED_EVENT'
  /** Represents an 'unassigned' event on any assignable object. */
  | 'UNASSIGNED_EVENT'
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  | 'UNLABELED_EVENT'
  /** Represents an 'unlocked' event on a given issue or pull request. */
  | 'UNLOCKED_EVENT'
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  | 'UNMARKED_AS_DUPLICATE_EVENT'
  /** Represents an 'unpinned' event on a given issue or pull request. */
  | 'UNPINNED_EVENT'
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  | 'UNSUBSCRIBED_EVENT'
  /** Represents a 'user_blocked' event on a given user. */
  | 'USER_BLOCKED_EVENT';

/** The possible target states when updating a pull request. */
export type PullRequestUpdateState =
  /** A pull request that has been closed without being merged. */
  | 'CLOSED'
  /** A pull request that is still open. */
  | 'OPEN';

/** A Git push. */
export type Push = Node & {
  /** The Node ID of the Push object */
  id: Scalars['ID']['output'];
  /** The SHA after the push */
  nextSha?: Maybe<Scalars['GitObjectID']['output']>;
  /** The permalink for this push. */
  permalink: Scalars['URI']['output'];
  /** The SHA before the push */
  previousSha?: Maybe<Scalars['GitObjectID']['output']>;
  /** The actor who pushed */
  pusher: Actor;
  /** The repository that was pushed to */
  repository: Repository;
};

/** A team, user, or app who has the ability to push to a protected branch. */
export type PushAllowance = Node & {
  /** The actor that can push. */
  actor?: Maybe<PushAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** The Node ID of the PushAllowance object */
  id: Scalars['ID']['output'];
};

/** Types that can be an actor. */
export type PushAllowanceActor = App | Team | User;

/** The connection type for PushAllowance. */
export type PushAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PushAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PushAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PushAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PushAllowance>;
};

/** The query root of GitHub's GraphQL interface. */
export type Query = {
  /** Look up a code of conduct by its key */
  codeOfConduct?: Maybe<CodeOfConduct>;
  /** Look up a code of conduct by its key */
  codesOfConduct?: Maybe<Array<Maybe<CodeOfConduct>>>;
  /** Look up an enterprise by URL slug. */
  enterprise?: Maybe<Enterprise>;
  /** Look up a pending enterprise administrator invitation by invitee, enterprise and role. */
  enterpriseAdministratorInvitation?: Maybe<EnterpriseAdministratorInvitation>;
  /** Look up a pending enterprise administrator invitation by invitation token. */
  enterpriseAdministratorInvitationByToken?: Maybe<EnterpriseAdministratorInvitation>;
  /** Look up an open source license by its key */
  license?: Maybe<License>;
  /** Return a list of known open source licenses */
  licenses: Array<Maybe<License>>;
  /** Get alphabetically sorted list of Marketplace categories */
  marketplaceCategories: Array<MarketplaceCategory>;
  /** Look up a Marketplace category by its slug. */
  marketplaceCategory?: Maybe<MarketplaceCategory>;
  /** Look up a single Marketplace listing */
  marketplaceListing?: Maybe<MarketplaceListing>;
  /** Look up Marketplace listings */
  marketplaceListings: MarketplaceListingConnection;
  /** Return information about the GitHub instance */
  meta: GitHubMetadata;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  /** Lookup a organization by login. */
  organization?: Maybe<Organization>;
  /** The client's rate limit information. */
  rateLimit?: Maybe<RateLimit>;
  /**
   * Workaround for re-exposing the root query object. (Refer to
   * https://github.com/facebook/relay/issues/112 for more information.)
   */
  relay: Query;
  /** Lookup a given repository by the owner and repository name. */
  repository?: Maybe<Repository>;
  /** Lookup a repository owner (ie. either a User or an Organization) by login. */
  repositoryOwner?: Maybe<RepositoryOwner>;
  /** Lookup resource by a URL. */
  resource?: Maybe<UniformResourceLocatable>;
  /** Perform a search across resources, returning a maximum of 1,000 results. */
  search: SearchResultItemConnection;
  /** GitHub Security Advisories */
  securityAdvisories: SecurityAdvisoryConnection;
  /** Fetch a Security Advisory by its GHSA ID */
  securityAdvisory?: Maybe<SecurityAdvisory>;
  /** Software Vulnerabilities documented by GitHub Security Advisories */
  securityVulnerabilities: SecurityVulnerabilityConnection;
  /** Users and organizations who can be sponsored via GitHub Sponsors. */
  sponsorables: SponsorableItemConnection;
  /** Look up a topic by name. */
  topic?: Maybe<Topic>;
  /** Lookup a user by login. */
  user?: Maybe<User>;
  /** The currently authenticated user. */
  viewer: User;
};


/** The query root of GitHub's GraphQL interface. */
export type QuerycodeOfConductArgs = {
  key: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
export type QueryenterpriseArgs = {
  invitationToken?: InputMaybe<Scalars['String']['input']>;
  slug: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
export type QueryenterpriseAdministratorInvitationArgs = {
  enterpriseSlug: Scalars['String']['input'];
  role: EnterpriseAdministratorRole;
  userLogin: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
export type QueryenterpriseAdministratorInvitationByTokenArgs = {
  invitationToken: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
export type QuerylicenseArgs = {
  key: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
export type QuerymarketplaceCategoriesArgs = {
  excludeEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  excludeSubcategories?: InputMaybe<Scalars['Boolean']['input']>;
  includeCategories?: InputMaybe<Array<Scalars['String']['input']>>;
};


/** The query root of GitHub's GraphQL interface. */
export type QuerymarketplaceCategoryArgs = {
  slug: Scalars['String']['input'];
  useTopicAliases?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The query root of GitHub's GraphQL interface. */
export type QuerymarketplaceListingArgs = {
  slug: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
export type QuerymarketplaceListingsArgs = {
  adminId?: InputMaybe<Scalars['ID']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  allStates?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  categorySlug?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  organizationId?: InputMaybe<Scalars['ID']['input']>;
  primaryCategoryOnly?: InputMaybe<Scalars['Boolean']['input']>;
  slugs?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  useTopicAliases?: InputMaybe<Scalars['Boolean']['input']>;
  viewerCanAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  withFreeTrialsOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The query root of GitHub's GraphQL interface. */
export type QuerynodeArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of GitHub's GraphQL interface. */
export type QuerynodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


/** The query root of GitHub's GraphQL interface. */
export type QueryorganizationArgs = {
  login: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
export type QueryrateLimitArgs = {
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The query root of GitHub's GraphQL interface. */
export type QueryrepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  owner: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
export type QueryrepositoryOwnerArgs = {
  login: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
export type QueryresourceArgs = {
  url: Scalars['URI']['input'];
};


/** The query root of GitHub's GraphQL interface. */
export type QuerysearchArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query: Scalars['String']['input'];
  type: SearchType;
};


/** The query root of GitHub's GraphQL interface. */
export type QuerysecurityAdvisoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  classifications?: InputMaybe<Array<SecurityAdvisoryClassification>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  identifier?: InputMaybe<SecurityAdvisoryIdentifierFilter>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SecurityAdvisoryOrder>;
  publishedSince?: InputMaybe<Scalars['DateTime']['input']>;
  updatedSince?: InputMaybe<Scalars['DateTime']['input']>;
};


/** The query root of GitHub's GraphQL interface. */
export type QuerysecurityAdvisoryArgs = {
  ghsaId: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
export type QuerysecurityVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  classifications?: InputMaybe<Array<SecurityAdvisoryClassification>>;
  ecosystem?: InputMaybe<SecurityAdvisoryEcosystem>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SecurityVulnerabilityOrder>;
  package?: InputMaybe<Scalars['String']['input']>;
  severities?: InputMaybe<Array<SecurityAdvisorySeverity>>;
};


/** The query root of GitHub's GraphQL interface. */
export type QuerysponsorablesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  dependencyEcosystem?: InputMaybe<SecurityAdvisoryEcosystem>;
  ecosystem?: InputMaybe<DependencyGraphEcosystem>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyDependencies?: InputMaybe<Scalars['Boolean']['input']>;
  orderBy?: InputMaybe<SponsorableOrder>;
  orgLoginForDependencies?: InputMaybe<Scalars['String']['input']>;
};


/** The query root of GitHub's GraphQL interface. */
export type QuerytopicArgs = {
  name: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
export type QueryuserArgs = {
  login: Scalars['String']['input'];
};

/** Represents the client's rate limit. */
export type RateLimit = {
  /** The point cost for the current query counting against the rate limit. */
  cost: Scalars['Int']['output'];
  /** The maximum number of points the client is permitted to consume in a 60 minute window. */
  limit: Scalars['Int']['output'];
  /** The maximum number of nodes this query may return */
  nodeCount: Scalars['Int']['output'];
  /** The number of points remaining in the current rate limit window. */
  remaining: Scalars['Int']['output'];
  /** The time at which the current rate limit window resets in UTC epoch seconds. */
  resetAt: Scalars['DateTime']['output'];
  /** The number of points used in the current rate limit window. */
  used: Scalars['Int']['output'];
};

/** Represents a subject that can be reacted on. */
export type Reactable = {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the Reactable object */
  id: Scalars['ID']['output'];
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
};


/** Represents a subject that can be reacted on. */
export type ReactablereactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** The connection type for User. */
export type ReactingUserConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReactingUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a user that's made a reaction. */
export type ReactingUserEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  node: User;
  /** The moment when the user made the reaction. */
  reactedAt: Scalars['DateTime']['output'];
};

/** An emoji reaction to a particular piece of content. */
export type Reaction = Node & {
  /** Identifies the emoji reaction. */
  content: ReactionContent;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the Reaction object */
  id: Scalars['ID']['output'];
  /** The reactable piece of content */
  reactable: Reactable;
  /** Identifies the user who created this reaction. */
  user?: Maybe<User>;
};

/** A list of reactions that have been left on the subject. */
export type ReactionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReactionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Reaction>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars['Boolean']['output'];
};

/** Emojis that can be attached to Issues, Pull Requests and Comments. */
export type ReactionContent =
  /** Represents the `:confused:` emoji. */
  | 'CONFUSED'
  /** Represents the `:eyes:` emoji. */
  | 'EYES'
  /** Represents the `:heart:` emoji. */
  | 'HEART'
  /** Represents the `:hooray:` emoji. */
  | 'HOORAY'
  /** Represents the `:laugh:` emoji. */
  | 'LAUGH'
  /** Represents the `:rocket:` emoji. */
  | 'ROCKET'
  /** Represents the `:-1:` emoji. */
  | 'THUMBS_DOWN'
  /** Represents the `:+1:` emoji. */
  | 'THUMBS_UP';

/** An edge in a connection. */
export type ReactionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Reaction>;
};

/** A group of emoji reactions to a particular piece of content. */
export type ReactionGroup = {
  /** Identifies the emoji reaction. */
  content: ReactionContent;
  /** Identifies when the reaction was created. */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Reactors to the reaction subject with the emotion represented by this reaction group. */
  reactors: ReactorConnection;
  /** The subject that was reacted to. */
  subject: Reactable;
  /**
   * Users who have reacted to the reaction subject with the emotion represented by this reaction group
   * @deprecated Reactors can now be mannequins, bots, and organizations. Use the `reactors` field instead. Removal on 2021-10-01 UTC.
   */
  users: ReactingUserConnection;
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars['Boolean']['output'];
};


/** A group of emoji reactions to a particular piece of content. */
export type ReactionGroupreactorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A group of emoji reactions to a particular piece of content. */
export type ReactionGroupusersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Ways in which lists of reactions can be ordered upon return. */
export type ReactionOrder = {
  /** The direction in which to order reactions by the specified field. */
  direction: OrderDirection;
  /** The field in which to order reactions by. */
  field: ReactionOrderField;
};

/** A list of fields that reactions can be ordered by. */
export type ReactionOrderField =
  /** Allows ordering a list of reactions by when they were created. */
  | 'CREATED_AT';

/** Types that can be assigned to reactions. */
export type Reactor = Bot | Mannequin | Organization | User;

/** The connection type for Reactor. */
export type ReactorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReactorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Reactor>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents an author of a reaction. */
export type ReactorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The author of the reaction. */
  node: Reactor;
  /** The moment when the user made the reaction. */
  reactedAt: Scalars['DateTime']['output'];
};

/** Represents a 'ready_for_review' event on a given pull request. */
export type ReadyForReviewEvent = Node & UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ReadyForReviewEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** The HTTP path for this ready for review event. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this ready for review event. */
  url: Scalars['URI']['output'];
};

/** Represents a Git reference. */
export type Ref = Node & {
  /** A list of pull requests with this ref as the head ref. */
  associatedPullRequests: PullRequestConnection;
  /** Branch protection rules for this ref */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** Compares the current ref as a base ref to another head ref, if the comparison can be made. */
  compare?: Maybe<Comparison>;
  /** The Node ID of the Ref object */
  id: Scalars['ID']['output'];
  /** The ref name. */
  name: Scalars['String']['output'];
  /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */
  prefix: Scalars['String']['output'];
  /** Branch protection rules that are viewable by non-admins */
  refUpdateRule?: Maybe<RefUpdateRule>;
  /** The repository the ref belongs to. */
  repository: Repository;
  /** The object the ref points to. Returns null when object does not exist. */
  target?: Maybe<GitObject>;
};


/** Represents a Git reference. */
export type RefassociatedPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<PullRequestState>>;
};


/** Represents a Git reference. */
export type RefcompareArgs = {
  headRef: Scalars['String']['input'];
};

/** The connection type for Ref. */
export type RefConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RefEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Ref>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type RefEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Ref>;
};

/** Parameters to be used for the ref_name condition */
export type RefNameConditionTarget = {
  /** Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars['String']['output']>;
  /**
   * Array of ref names or patterns to include. One of these patterns must match
   * for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the
   * default branch or `~ALL` to include all branches.
   */
  include: Array<Scalars['String']['output']>;
};

/** Parameters to be used for the ref_name condition */
export type RefNameConditionTargetInput = {
  /** Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars['String']['input']>;
  /**
   * Array of ref names or patterns to include. One of these patterns must match
   * for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the
   * default branch or `~ALL` to include all branches.
   */
  include: Array<Scalars['String']['input']>;
};

/** Ways in which lists of git refs can be ordered upon return. */
export type RefOrder = {
  /** The direction in which to order refs by the specified field. */
  direction: OrderDirection;
  /** The field in which to order refs by. */
  field: RefOrderField;
};

/** Properties by which ref connections can be ordered. */
export type RefOrderField =
  /** Order refs by their alphanumeric name */
  | 'ALPHABETICAL'
  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */
  | 'TAG_COMMIT_DATE';

/** A ref update */
export type RefUpdate = {
  /** The value this ref should be updated to. */
  afterOid: Scalars['GitObjectID']['input'];
  /** The value this ref needs to point to before the update. */
  beforeOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** Force a non fast-forward update. */
  force?: InputMaybe<Scalars['Boolean']['input']>;
  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */
  name: Scalars['GitRefname']['input'];
};

/** Branch protection rules that are enforced on the viewer. */
export type RefUpdateRule = {
  /** Can this branch be deleted. */
  allowsDeletions: Scalars['Boolean']['output'];
  /** Are force pushes allowed on this branch. */
  allowsForcePushes: Scalars['Boolean']['output'];
  /** Can matching branches be created. */
  blocksCreations: Scalars['Boolean']['output'];
  /** Identifies the protection rule pattern. */
  pattern: Scalars['String']['output'];
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']['output']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews: Scalars['Boolean']['output'];
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution: Scalars['Boolean']['output'];
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory: Scalars['Boolean']['output'];
  /** Are commits required to be signed. */
  requiresSignatures: Scalars['Boolean']['output'];
  /** Is the viewer allowed to dismiss reviews. */
  viewerAllowedToDismissReviews: Scalars['Boolean']['output'];
  /** Can the viewer push to the branch */
  viewerCanPush: Scalars['Boolean']['output'];
};

/** Represents a 'referenced' event on a given `ReferencedSubject`. */
export type ReferencedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the commit associated with the 'referenced' event. */
  commit?: Maybe<Commit>;
  /** Identifies the repository associated with the 'referenced' event. */
  commitRepository: Repository;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ReferencedEvent object */
  id: Scalars['ID']['output'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean']['output'];
  /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */
  isDirectReference: Scalars['Boolean']['output'];
  /** Object referenced by event. */
  subject: ReferencedSubject;
};

/** Any referencable object */
export type ReferencedSubject = Issue | PullRequest;

/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID']['input'];
};

/** Autogenerated return type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type RegenerateEnterpriseIdentityProviderRecoveryCodesPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The identity provider for the enterprise. */
  identityProvider?: Maybe<EnterpriseIdentityProvider>;
};

/** Autogenerated input type of RegenerateVerifiableDomainToken */
export type RegenerateVerifiableDomainTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to regenerate the verification token of. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RegenerateVerifiableDomainToken */
export type RegenerateVerifiableDomainTokenPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The verification token that was generated. */
  verificationToken?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RejectDeployments */
export type RejectDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Optional comment for rejecting deployments */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars['ID']['input']>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars['ID']['input'];
};

/** Autogenerated return type of RejectDeployments */
export type RejectDeploymentsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The affected deployments. */
  deployments?: Maybe<Array<Deployment>>;
};

/** A release contains the content for a release. */
export type Release = Node & Reactable & UniformResourceLocatable & {
  /** The author of the release */
  author?: Maybe<User>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The description of the release. */
  description?: Maybe<Scalars['String']['output']>;
  /** The description of this release rendered to HTML. */
  descriptionHTML?: Maybe<Scalars['HTML']['output']>;
  /** The Node ID of the Release object */
  id: Scalars['ID']['output'];
  /** Whether or not the release is a draft */
  isDraft: Scalars['Boolean']['output'];
  /** Whether or not the release is the latest releast */
  isLatest: Scalars['Boolean']['output'];
  /** Whether or not the release is a prerelease */
  isPrerelease: Scalars['Boolean']['output'];
  /** A list of users mentioned in the release description */
  mentions?: Maybe<UserConnection>;
  /** The title of the release. */
  name?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the release was created. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** List of releases assets which are dependent on this release. */
  releaseAssets: ReleaseAssetConnection;
  /** The repository that the release belongs to. */
  repository: Repository;
  /** The HTTP path for this issue */
  resourcePath: Scalars['URI']['output'];
  /** A description of the release, rendered to HTML without any links in it. */
  shortDescriptionHTML?: Maybe<Scalars['HTML']['output']>;
  /** The Git tag the release points to */
  tag?: Maybe<Ref>;
  /** The tag commit for this release. */
  tagCommit?: Maybe<Commit>;
  /** The name of the release's Git tag */
  tagName: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this issue */
  url: Scalars['URI']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
};


/** A release contains the content for a release. */
export type ReleasementionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A release contains the content for a release. */
export type ReleasereactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A release contains the content for a release. */
export type ReleasereleaseAssetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


/** A release contains the content for a release. */
export type ReleaseshortDescriptionHTMLArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** A release asset contains the content for a release asset. */
export type ReleaseAsset = Node & {
  /** The asset's content-type */
  contentType: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The number of times this asset was downloaded */
  downloadCount: Scalars['Int']['output'];
  /** Identifies the URL where you can download the release asset via the browser. */
  downloadUrl: Scalars['URI']['output'];
  /** The Node ID of the ReleaseAsset object */
  id: Scalars['ID']['output'];
  /** Identifies the title of the release asset. */
  name: Scalars['String']['output'];
  /** Release that the asset is associated with */
  release?: Maybe<Release>;
  /** The size (in bytes) of the asset */
  size: Scalars['Int']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The user that performed the upload */
  uploadedBy: User;
  /** Identifies the URL of the release asset. */
  url: Scalars['URI']['output'];
};

/** The connection type for ReleaseAsset. */
export type ReleaseAssetConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseAssetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReleaseAsset>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ReleaseAssetEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ReleaseAsset>;
};

/** The connection type for Release. */
export type ReleaseConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Release>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ReleaseEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Release>;
};

/** Ways in which lists of releases can be ordered upon return. */
export type ReleaseOrder = {
  /** The direction in which to order releases by the specified field. */
  direction: OrderDirection;
  /** The field in which to order releases by. */
  field: ReleaseOrderField;
};

/** Properties by which release connections can be ordered. */
export type ReleaseOrderField =
  /** Order releases by creation time */
  | 'CREATED_AT'
  /** Order releases alphabetically by name */
  | 'NAME';

/** Autogenerated input type of RemoveAssigneesFromAssignable */
export type RemoveAssigneesFromAssignableInput = {
  /** The id of the assignable object to remove assignees from. */
  assignableId: Scalars['ID']['input'];
  /** The id of users to remove as assignees. */
  assigneeIds: Array<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of RemoveAssigneesFromAssignable */
export type RemoveAssigneesFromAssignablePayload = {
  /** The item that was unassigned. */
  assignable?: Maybe<Assignable>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RemoveEnterpriseAdmin */
export type RemoveEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Enterprise ID from which to remove the administrator. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of the user to remove as an administrator. */
  login: Scalars['String']['input'];
};

/** Autogenerated return type of RemoveEnterpriseAdmin */
export type RemoveEnterpriseAdminPayload = {
  /** The user who was removed as an administrator. */
  admin?: Maybe<User>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated enterprise. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of removing an administrator. */
  message?: Maybe<Scalars['String']['output']>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<User>;
};

/** Autogenerated input type of RemoveEnterpriseIdentityProvider */
export type RemoveEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise from which to remove the identity provider. */
  enterpriseId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveEnterpriseIdentityProvider */
export type RemoveEnterpriseIdentityProviderPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The identity provider that was removed from the enterprise. */
  identityProvider?: Maybe<EnterpriseIdentityProvider>;
};

/** Autogenerated input type of RemoveEnterpriseMember */
export type RemoveEnterpriseMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise from which the user should be removed. */
  enterpriseId: Scalars['ID']['input'];
  /** The ID of the user to remove from the enterprise. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveEnterpriseMember */
export type RemoveEnterpriseMemberPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated enterprise. */
  enterprise?: Maybe<Enterprise>;
  /** The user that was removed from the enterprise. */
  user?: Maybe<User>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<User>;
};

/** Autogenerated input type of RemoveEnterpriseOrganization */
export type RemoveEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise from which the organization should be removed. */
  enterpriseId: Scalars['ID']['input'];
  /** The ID of the organization to remove from the enterprise. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveEnterpriseOrganization */
export type RemoveEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated enterprise. */
  enterprise?: Maybe<Enterprise>;
  /** The organization that was removed from the enterprise. */
  organization?: Maybe<Organization>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<User>;
};

/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */
export type RemoveEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of a member who will lose the support entitlement. */
  login: Scalars['String']['input'];
};

/** Autogenerated return type of RemoveEnterpriseSupportEntitlement */
export type RemoveEnterpriseSupportEntitlementPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of removing the support entitlement. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RemoveLabelsFromLabelable */
export type RemoveLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ids of labels to remove. */
  labelIds: Array<Scalars['ID']['input']>;
  /** The id of the Labelable to remove labels from. */
  labelableId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveLabelsFromLabelable */
export type RemoveLabelsFromLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The Labelable the labels were removed from. */
  labelable?: Maybe<Labelable>;
};

/** Autogenerated input type of RemoveOutsideCollaborator */
export type RemoveOutsideCollaboratorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization to remove the outside collaborator from. */
  organizationId: Scalars['ID']['input'];
  /** The ID of the outside collaborator to remove. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveOutsideCollaborator */
export type RemoveOutsideCollaboratorPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The user that was removed as an outside collaborator. */
  removedUser?: Maybe<User>;
};

/** Autogenerated input type of RemoveReaction */
export type RemoveReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the emoji reaction to remove. */
  content: ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveReaction */
export type RemoveReactionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The reaction object. */
  reaction?: Maybe<Reaction>;
  /** The reaction groups for the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** The reactable subject. */
  subject?: Maybe<Reactable>;
};

/** Autogenerated input type of RemoveStar */
export type RemoveStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Starrable ID to unstar. */
  starrableId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveStar */
export type RemoveStarPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The starrable. */
  starrable?: Maybe<Starrable>;
};

/** Autogenerated input type of RemoveUpvote */
export type RemoveUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion or comment to remove upvote. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveUpvote */
export type RemoveUpvotePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The votable subject. */
  subject?: Maybe<Votable>;
};

/** Represents a 'removed_from_merge_queue' event on a given pull request. */
export type RemovedFromMergeQueueEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the before commit SHA for the 'removed_from_merge_queue' event. */
  beforeCommit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who removed this Pull Request from the merge queue */
  enqueuer?: Maybe<User>;
  /** The Node ID of the RemovedFromMergeQueueEvent object */
  id: Scalars['ID']['output'];
  /** The merge queue where this pull request was removed from. */
  mergeQueue?: Maybe<MergeQueue>;
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<PullRequest>;
  /** The reason this pull request was removed from the queue. */
  reason?: Maybe<Scalars['String']['output']>;
};

/** Represents a 'removed_from_project' event on a given issue or pull request. */
export type RemovedFromProjectEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the RemovedFromProjectEvent object */
  id: Scalars['ID']['output'];
  /** Project referenced by event. */
  project?: Maybe<Project>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String']['output'];
};

/** Represents a 'renamed' event on a given issue or pull request */
export type RenamedTitleEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the current title of the issue or pull request. */
  currentTitle: Scalars['String']['output'];
  /** The Node ID of the RenamedTitleEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the previous title of the issue or pull request. */
  previousTitle: Scalars['String']['output'];
  /** Subject that was renamed. */
  subject: RenamedTitleSubject;
};

/** An object which has a renamable title */
export type RenamedTitleSubject = Issue | PullRequest;

/** Autogenerated input type of ReopenDiscussion */
export type ReopenDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the discussion to be reopened. */
  discussionId: Scalars['ID']['input'];
};

/** Autogenerated return type of ReopenDiscussion */
export type ReopenDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that was reopened. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of ReopenIssue */
export type ReopenIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue to be opened. */
  issueId: Scalars['ID']['input'];
};

/** Autogenerated return type of ReopenIssue */
export type ReopenIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was opened. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of ReopenPullRequest */
export type ReopenPullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to be reopened. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of ReopenPullRequest */
export type ReopenPullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that was reopened. */
  pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'reopened' event on any `Closable`. */
export type ReopenedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Object that was reopened. */
  closable: Closable;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ReopenedEvent object */
  id: Scalars['ID']['output'];
  /** The reason the issue state was changed to open. */
  stateReason?: Maybe<IssueStateReason>;
};

/** Audit log entry for a repo.access event. */
export type RepoAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoAccessAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
  /** The visibility of the repository */
  visibility?: Maybe<RepoAccessAuditEntryVisibility>;
};

/** The privacy of a repository */
export type RepoAccessAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.add_member event. */
export type RepoAddMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoAddMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
  /** The visibility of the repository */
  visibility?: Maybe<RepoAddMemberAuditEntryVisibility>;
};

/** The privacy of a repository */
export type RepoAddMemberAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.add_topic event. */
export type RepoAddTopicAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoAddTopicAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The name of the topic added to the repository */
  topic?: Maybe<Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.archived event. */
export type RepoArchivedAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoArchivedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
  /** The visibility of the repository */
  visibility?: Maybe<RepoArchivedAuditEntryVisibility>;
};

/** The privacy of a repository */
export type RepoArchivedAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.change_merge_setting event. */
export type RepoChangeMergeSettingAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoChangeMergeSettingAuditEntry object */
  id: Scalars['ID']['output'];
  /** Whether the change was to enable (true) or disable (false) the merge type */
  isEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** The merge method affected by the change */
  mergeType?: Maybe<RepoChangeMergeSettingAuditEntryMergeType>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The merge options available for pull requests to this repository. */
export type RepoChangeMergeSettingAuditEntryMergeType =
  /** The pull request is added to the base branch in a merge commit. */
  | 'MERGE'
  /** Commits from the pull request are added onto the base branch individually without a merge commit. */
  | 'REBASE'
  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */
  | 'SQUASH';

/** Audit log entry for a repo.config.disable_anonymous_git_access event. */
export type RepoConfigDisableAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigDisableAnonymousGitAccessAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.disable_collaborators_only event. */
export type RepoConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigDisableCollaboratorsOnlyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.disable_contributors_only event. */
export type RepoConfigDisableContributorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigDisableContributorsOnlyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.disable_sockpuppet_disallowed event. */
export type RepoConfigDisableSockpuppetDisallowedAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigDisableSockpuppetDisallowedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.enable_anonymous_git_access event. */
export type RepoConfigEnableAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigEnableAnonymousGitAccessAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.enable_collaborators_only event. */
export type RepoConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigEnableCollaboratorsOnlyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.enable_contributors_only event. */
export type RepoConfigEnableContributorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigEnableContributorsOnlyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.enable_sockpuppet_disallowed event. */
export type RepoConfigEnableSockpuppetDisallowedAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigEnableSockpuppetDisallowedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.lock_anonymous_git_access event. */
export type RepoConfigLockAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigLockAnonymousGitAccessAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.unlock_anonymous_git_access event. */
export type RepoConfigUnlockAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigUnlockAnonymousGitAccessAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.create event. */
export type RepoCreateAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The name of the parent repository for this forked repository. */
  forkParentName?: Maybe<Scalars['String']['output']>;
  /** The name of the root repository for this network. */
  forkSourceName?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the RepoCreateAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
  /** The visibility of the repository */
  visibility?: Maybe<RepoCreateAuditEntryVisibility>;
};

/** The privacy of a repository */
export type RepoCreateAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.destroy event. */
export type RepoDestroyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoDestroyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
  /** The visibility of the repository */
  visibility?: Maybe<RepoDestroyAuditEntryVisibility>;
};

/** The privacy of a repository */
export type RepoDestroyAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.remove_member event. */
export type RepoRemoveMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoRemoveMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
  /** The visibility of the repository */
  visibility?: Maybe<RepoRemoveMemberAuditEntryVisibility>;
};

/** The privacy of a repository */
export type RepoRemoveMemberAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.remove_topic event. */
export type RepoRemoveTopicAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the RepoRemoveTopicAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The name of the topic added to the repository */
  topic?: Maybe<Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The reasons a piece of content can be reported or minimized. */
export type ReportedContentClassifiers =
  /** An abusive or harassing piece of content */
  | 'ABUSE'
  /** A duplicated piece of content */
  | 'DUPLICATE'
  /** An irrelevant piece of content */
  | 'OFF_TOPIC'
  /** An outdated piece of content */
  | 'OUTDATED'
  /** The content has been resolved */
  | 'RESOLVED'
  /** A spammy piece of content */
  | 'SPAM';

/** A repository contains the content for a project. */
export type Repository = Node & PackageOwner & ProjectOwner & ProjectV2Recent & RepositoryInfo & Starrable & Subscribable & UniformResourceLocatable & {
  /**
   * Whether or not a pull request head branch that is behind its base branch can
   * always be updated even if it is not required to be up to date before merging.
   */
  allowUpdateBranch: Scalars['Boolean']['output'];
  /** Identifies the date and time when the repository was archived. */
  archivedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of users that can be assigned to issues in this repository. */
  assignableUsers: UserConnection;
  /** Whether or not Auto-merge can be enabled on pull requests in this repository. */
  autoMergeAllowed: Scalars['Boolean']['output'];
  /** A list of branch protection rules for this repository. */
  branchProtectionRules: BranchProtectionRuleConnection;
  /** Returns the code of conduct for this repository */
  codeOfConduct?: Maybe<CodeOfConduct>;
  /** Information extracted from the repository's `CODEOWNERS` file. */
  codeowners?: Maybe<RepositoryCodeowners>;
  /** A list of collaborators associated with the repository. */
  collaborators?: Maybe<RepositoryCollaboratorConnection>;
  /** A list of commit comments associated with the repository. */
  commitComments: CommitCommentConnection;
  /** Returns a list of contact links associated to the repository */
  contactLinks?: Maybe<Array<RepositoryContactLink>>;
  /** Returns the contributing guidelines for this repository. */
  contributingGuidelines?: Maybe<ContributingGuidelines>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Ref associated with the repository's default branch. */
  defaultBranchRef?: Maybe<Ref>;
  /** Whether or not branches are automatically deleted when merged in this repository. */
  deleteBranchOnMerge: Scalars['Boolean']['output'];
  /** A list of dependency manifests contained in the repository */
  dependencyGraphManifests?: Maybe<DependencyGraphManifestConnection>;
  /** A list of deploy keys that are on this repository. */
  deployKeys: DeployKeyConnection;
  /** Deployments associated with the repository */
  deployments: DeploymentConnection;
  /** The description of the repository. */
  description?: Maybe<Scalars['String']['output']>;
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars['HTML']['output'];
  /** Returns a single discussion from the current repository by number. */
  discussion?: Maybe<Discussion>;
  /** A list of discussion categories that are available in the repository. */
  discussionCategories: DiscussionCategoryConnection;
  /** A discussion category by slug. */
  discussionCategory?: Maybe<DiscussionCategory>;
  /** A list of discussions that have been opened in the repository. */
  discussions: DiscussionConnection;
  /** The number of kilobytes this repository occupies on disk. */
  diskUsage?: Maybe<Scalars['Int']['output']>;
  /** Returns a single active environment from the current repository by name. */
  environment?: Maybe<Environment>;
  /** A list of environments that are in this repository. */
  environments: EnvironmentConnection;
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars['Int']['output'];
  /** Whether this repository allows forks. */
  forkingAllowed: Scalars['Boolean']['output'];
  /** A list of direct forked repositories. */
  forks: RepositoryConnection;
  /** The funding links for this repository */
  fundingLinks: Array<FundingLink>;
  /** Indicates if the repository has the Discussions feature enabled. */
  hasDiscussionsEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has the Projects feature enabled. */
  hasProjectsEnabled: Scalars['Boolean']['output'];
  /** Whether vulnerability alerts are enabled for the repository. */
  hasVulnerabilityAlertsEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars['Boolean']['output'];
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars['URI']['output']>;
  /** The Node ID of the Repository object */
  id: Scalars['ID']['output'];
  /** The interaction ability settings for this repository. */
  interactionAbility?: Maybe<RepositoryInteractionAbility>;
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars['Boolean']['output'];
  /** Returns true if blank issue creation is allowed */
  isBlankIssuesEnabled: Scalars['Boolean']['output'];
  /** Returns whether or not this repository disabled. */
  isDisabled: Scalars['Boolean']['output'];
  /** Returns whether or not this repository is empty. */
  isEmpty: Scalars['Boolean']['output'];
  /** Identifies if the repository is a fork. */
  isFork: Scalars['Boolean']['output'];
  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */
  isInOrganization: Scalars['Boolean']['output'];
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars['Boolean']['output'];
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars['Boolean']['output'];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars['Boolean']['output'];
  /** Returns true if this repository has a security policy */
  isSecurityPolicyEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars['Boolean']['output'];
  /** Is this repository a user configuration repository? */
  isUserConfigurationRepository: Scalars['Boolean']['output'];
  /** Returns a single issue from the current repository by number. */
  issue?: Maybe<Issue>;
  /** Returns a single issue-like object from the current repository by number. */
  issueOrPullRequest?: Maybe<IssueOrPullRequest>;
  /** Returns a list of issue templates associated to the repository */
  issueTemplates?: Maybe<Array<IssueTemplate>>;
  /** A list of issues that have been opened in the repository. */
  issues: IssueConnection;
  /** Returns a single label by name */
  label?: Maybe<Label>;
  /** A list of labels associated with the repository. */
  labels?: Maybe<LabelConnection>;
  /** A list containing a breakdown of the language composition of the repository. */
  languages?: Maybe<LanguageConnection>;
  /** Get the latest release for the repository if one exists. */
  latestRelease?: Maybe<Release>;
  /** The license associated with the repository */
  licenseInfo?: Maybe<License>;
  /** The reason the repository has been locked. */
  lockReason?: Maybe<RepositoryLockReason>;
  /** A list of Users that can be mentioned in the context of the repository. */
  mentionableUsers: UserConnection;
  /** Whether or not PRs are merged with a merge commit on this repository. */
  mergeCommitAllowed: Scalars['Boolean']['output'];
  /** How the default commit message will be generated when merging a pull request. */
  mergeCommitMessage: MergeCommitMessage;
  /** How the default commit title will be generated when merging a pull request. */
  mergeCommitTitle: MergeCommitTitle;
  /** The merge queue for a specified branch, otherwise the default branch if not provided. */
  mergeQueue?: Maybe<MergeQueue>;
  /** Returns a single milestone from the current repository by number. */
  milestone?: Maybe<Milestone>;
  /** A list of milestones associated with the repository. */
  milestones?: Maybe<MilestoneConnection>;
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars['URI']['output']>;
  /** The name of the repository. */
  name: Scalars['String']['output'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String']['output'];
  /** A Git object in the repository */
  object?: Maybe<GitObject>;
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars['URI']['output'];
  /** The User owner of the repository. */
  owner: RepositoryOwner;
  /** A list of packages under the owner. */
  packages: PackageConnection;
  /** The repository parent, if this is a fork. */
  parent?: Maybe<Repository>;
  /** A list of discussions that have been pinned in this repository. */
  pinnedDiscussions: PinnedDiscussionConnection;
  /** A list of pinned issues for this repository. */
  pinnedIssues?: Maybe<PinnedIssueConnection>;
  /** The primary language of the repository's code. */
  primaryLanguage?: Maybe<Language>;
  /** Find project by number. */
  project?: Maybe<Project>;
  /** Finds and returns the Project according to the provided Project number. */
  projectV2?: Maybe<ProjectV2>;
  /** A list of projects under the owner. */
  projects: ProjectConnection;
  /** The HTTP path listing the repository's projects */
  projectsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL listing the repository's projects */
  projectsUrl: Scalars['URI']['output'];
  /** List of projects linked to this repository. */
  projectsV2: ProjectV2Connection;
  /** Returns a single pull request from the current repository by number. */
  pullRequest?: Maybe<PullRequest>;
  /** Returns a list of pull request templates associated to the repository */
  pullRequestTemplates?: Maybe<Array<PullRequestTemplate>>;
  /** A list of pull requests that have been opened in the repository. */
  pullRequests: PullRequestConnection;
  /** Identifies the date and time when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether or not rebase-merging is enabled on this repository. */
  rebaseMergeAllowed: Scalars['Boolean']['output'];
  /** Recent projects that this user has modified in the context of the owner. */
  recentProjects: ProjectV2Connection;
  /** Fetch a given ref from the repository */
  ref?: Maybe<Ref>;
  /** Fetch a list of refs from the repository */
  refs?: Maybe<RefConnection>;
  /** Lookup a single release given various criteria. */
  release?: Maybe<Release>;
  /** List of releases which are dependent on this repository. */
  releases: ReleaseConnection;
  /** A list of applied repository-topic associations for this repository. */
  repositoryTopics: RepositoryTopicConnection;
  /** The HTTP path for this repository */
  resourcePath: Scalars['URI']['output'];
  /** Returns a single ruleset from the current repository by ID. */
  ruleset?: Maybe<RepositoryRuleset>;
  /** A list of rulesets for this repository. */
  rulesets?: Maybe<RepositoryRulesetConnection>;
  /** The security policy URL. */
  securityPolicyUrl?: Maybe<Scalars['URI']['output']>;
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars['HTML']['output'];
  /** Whether or not squash-merging is enabled on this repository. */
  squashMergeAllowed: Scalars['Boolean']['output'];
  /** How the default commit message will be generated when squash merging a pull request. */
  squashMergeCommitMessage: SquashMergeCommitMessage;
  /** How the default commit title will be generated when squash merging a pull request. */
  squashMergeCommitTitle: SquashMergeCommitTitle;
  /**
   * Whether a squash merge commit can use the pull request title as default.
   * @deprecated `squashPrTitleUsedAsDefault` will be removed. Use `Repository.squashMergeCommitTitle` instead. Removal on 2023-04-01 UTC.
   */
  squashPrTitleUsedAsDefault: Scalars['Boolean']['output'];
  /** The SSH URL to clone this repository */
  sshUrl: Scalars['GitSSHRemote']['output'];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int']['output'];
  /** A list of users who have starred this starrable. */
  stargazers: StargazerConnection;
  /**
   * Returns a list of all submodules in this repository parsed from the
   * .gitmodules file as of the default branch's HEAD commit.
   */
  submodules: SubmoduleConnection;
  /** Temporary authentication token for cloning this repository. */
  tempCloneToken?: Maybe<Scalars['String']['output']>;
  /** The repository from which this repository was generated, if any. */
  templateRepository?: Maybe<Repository>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this repository */
  url: Scalars['URI']['output'];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars['Boolean']['output'];
  /** Indicates whether the viewer has admin permissions on this repository. */
  viewerCanAdminister: Scalars['Boolean']['output'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Indicates whether the viewer can update the topics of this repository. */
  viewerCanUpdateTopics: Scalars['Boolean']['output'];
  /** The last commit email for the viewer. */
  viewerDefaultCommitEmail?: Maybe<Scalars['String']['output']>;
  /** The last used merge method by the viewer or the default for the repository. */
  viewerDefaultMergeMethod: PullRequestMergeMethod;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean']['output'];
  /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */
  viewerPermission?: Maybe<RepositoryPermission>;
  /** A list of emails this viewer can commit with. */
  viewerPossibleCommitEmails?: Maybe<Array<Scalars['String']['output']>>;
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<SubscriptionState>;
  /** Indicates the repository's visibility level. */
  visibility: RepositoryVisibility;
  /** Returns a single vulnerability alert from the current repository by number. */
  vulnerabilityAlert?: Maybe<RepositoryVulnerabilityAlert>;
  /** A list of vulnerability alerts that are on this repository. */
  vulnerabilityAlerts?: Maybe<RepositoryVulnerabilityAlertConnection>;
  /** A list of users watching the repository. */
  watchers: UserConnection;
  /** Whether contributors are required to sign off on web-based commits in this repository. */
  webCommitSignoffRequired: Scalars['Boolean']['output'];
};


/** A repository contains the content for a project. */
export type RepositoryassignableUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorybranchProtectionRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorycodeownersArgs = {
  refName?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorycollaboratorsArgs = {
  affiliation?: InputMaybe<CollaboratorAffiliation>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorycommitCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorydependencyGraphManifestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  dependenciesAfter?: InputMaybe<Scalars['String']['input']>;
  dependenciesFirst?: InputMaybe<Scalars['Int']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  withDependencies?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorydeployKeysArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorydeploymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  environments?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DeploymentOrder>;
};


/** A repository contains the content for a project. */
export type RepositorydiscussionArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type RepositorydiscussionCategoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterByAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorydiscussionCategoryArgs = {
  slug: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
export type RepositorydiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  answered?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DiscussionOrder>;
  states?: InputMaybe<Array<DiscussionState>>;
};


/** A repository contains the content for a project. */
export type RepositoryenvironmentArgs = {
  name: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
export type RepositoryenvironmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Environments>;
};


/** A repository contains the content for a project. */
export type RepositoryforksArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
};


/** A repository contains the content for a project. */
export type RepositoryissueArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type RepositoryissueOrPullRequestArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type RepositoryissuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<IssueFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<IssueState>>;
};


/** A repository contains the content for a project. */
export type RepositorylabelArgs = {
  name: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
export type RepositorylabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LabelOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorylanguagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LanguageOrder>;
};


/** A repository contains the content for a project. */
export type RepositorymentionableUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorymergeQueueArgs = {
  branch?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorymilestoneArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type RepositorymilestonesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<MilestoneOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<MilestoneState>>;
};


/** A repository contains the content for a project. */
export type RepositoryobjectArgs = {
  expression?: InputMaybe<Scalars['String']['input']>;
  oid?: InputMaybe<Scalars['GitObjectID']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorypackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<PackageOrder>;
  packageType?: InputMaybe<PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorypinnedDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorypinnedIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type RepositoryprojectArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type RepositoryprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type RepositoryprojectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<ProjectState>>;
};


/** A repository contains the content for a project. */
export type RepositoryprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorypullRequestArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type RepositorypullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<PullRequestState>>;
};


/** A repository contains the content for a project. */
export type RepositoryrecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type RepositoryrefArgs = {
  qualifiedName: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
export type RepositoryrefsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  direction?: InputMaybe<OrderDirection>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RefOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  refPrefix: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
export type RepositoryreleaseArgs = {
  tagName: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
export type RepositoryreleasesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReleaseOrder>;
};


/** A repository contains the content for a project. */
export type RepositoryrepositoryTopicsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type RepositoryrulesetArgs = {
  databaseId: Scalars['Int']['input'];
  includeParents?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository contains the content for a project. */
export type RepositoryrulesetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeParents?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type RepositoryshortDescriptionHTMLArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type RepositorystargazersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<StarOrder>;
};


/** A repository contains the content for a project. */
export type RepositorysubmodulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type RepositoryvulnerabilityAlertArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type RepositoryvulnerabilityAlertsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  dependencyScopes?: InputMaybe<Array<RepositoryVulnerabilityAlertDependencyScope>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  states?: InputMaybe<Array<RepositoryVulnerabilityAlertState>>;
};


/** A repository contains the content for a project. */
export type RepositorywatchersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The affiliation of a user to a repository */
export type RepositoryAffiliation =
  /** Repositories that the user has been added to as a collaborator. */
  | 'COLLABORATOR'
  /**
   * Repositories that the user has access to through being a member of an
   * organization. This includes every repository on every team that the user is on.
   */
  | 'ORGANIZATION_MEMBER'
  /** Repositories that are owned by the authenticated user. */
  | 'OWNER';

/** Metadata for an audit entry with action repo.* */
export type RepositoryAuditEntryData = {
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
};

/** Information extracted from a repository's `CODEOWNERS` file. */
export type RepositoryCodeowners = {
  /** Any problems that were encountered while parsing the `CODEOWNERS` file. */
  errors: Array<RepositoryCodeownersError>;
};

/** An error in a `CODEOWNERS` file. */
export type RepositoryCodeownersError = {
  /** The column number where the error occurs. */
  column: Scalars['Int']['output'];
  /** A short string describing the type of error. */
  kind: Scalars['String']['output'];
  /** The line number where the error occurs. */
  line: Scalars['Int']['output'];
  /** A complete description of the error, combining information from other fields. */
  message: Scalars['String']['output'];
  /** The path to the file when the error occurs. */
  path: Scalars['String']['output'];
  /** The content of the line where the error occurs. */
  source: Scalars['String']['output'];
  /** A suggestion of how to fix the error. */
  suggestion?: Maybe<Scalars['String']['output']>;
};

/** The connection type for User. */
export type RepositoryCollaboratorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a user who is a collaborator of a repository. */
export type RepositoryCollaboratorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  node: User;
  /** The permission the user has on the repository. */
  permission: RepositoryPermission;
  /** A list of sources for the user's access to the repository. */
  permissionSources?: Maybe<Array<PermissionSource>>;
};

/** A list of repositories owned by the subject. */
export type RepositoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /**
   * The total size in kilobytes of all repositories in the connection. Value will
   * never be larger than max 32-bit signed integer.
   */
  totalDiskUsage: Scalars['Int']['output'];
};

/** A repository contact link. */
export type RepositoryContactLink = {
  /** The contact link purpose. */
  about: Scalars['String']['output'];
  /** The contact link name. */
  name: Scalars['String']['output'];
  /** The contact link URL. */
  url: Scalars['URI']['output'];
};

/** The reason a repository is listed as 'contributed'. */
export type RepositoryContributionType =
  /** Created a commit */
  | 'COMMIT'
  /** Created an issue */
  | 'ISSUE'
  /** Created a pull request */
  | 'PULL_REQUEST'
  /** Reviewed a pull request */
  | 'PULL_REQUEST_REVIEW'
  /** Created the repository */
  | 'REPOSITORY';

/** Represents an author of discussions in repositories. */
export type RepositoryDiscussionAuthor = {
  /** Discussions this user has started. */
  repositoryDiscussions: DiscussionConnection;
};


/** Represents an author of discussions in repositories. */
export type RepositoryDiscussionAuthorrepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  answered?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  states?: InputMaybe<Array<DiscussionState>>;
};

/** Represents an author of discussion comments in repositories. */
export type RepositoryDiscussionCommentAuthor = {
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: DiscussionCommentConnection;
};


/** Represents an author of discussion comments in repositories. */
export type RepositoryDiscussionCommentAuthorrepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']['input']>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** An edge in a connection. */
export type RepositoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Repository>;
};

/** Parameters to be used for the repository_id condition */
export type RepositoryIdConditionTarget = {
  /** One of these repo IDs must match the repo. */
  repositoryIds: Array<Scalars['ID']['output']>;
};

/** Parameters to be used for the repository_id condition */
export type RepositoryIdConditionTargetInput = {
  /** One of these repo IDs must match the repo. */
  repositoryIds: Array<Scalars['ID']['input']>;
};

/** A subset of repository info. */
export type RepositoryInfo = {
  /** Identifies the date and time when the repository was archived. */
  archivedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The description of the repository. */
  description?: Maybe<Scalars['String']['output']>;
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars['HTML']['output'];
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars['Int']['output'];
  /** Indicates if the repository has the Discussions feature enabled. */
  hasDiscussionsEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has the Projects feature enabled. */
  hasProjectsEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars['Boolean']['output'];
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars['URI']['output']>;
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars['Boolean']['output'];
  /** Identifies if the repository is a fork. */
  isFork: Scalars['Boolean']['output'];
  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */
  isInOrganization: Scalars['Boolean']['output'];
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars['Boolean']['output'];
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars['Boolean']['output'];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars['Boolean']['output'];
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars['Boolean']['output'];
  /** The license associated with the repository */
  licenseInfo?: Maybe<License>;
  /** The reason the repository has been locked. */
  lockReason?: Maybe<RepositoryLockReason>;
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars['URI']['output']>;
  /** The name of the repository. */
  name: Scalars['String']['output'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String']['output'];
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars['URI']['output'];
  /** The User owner of the repository. */
  owner: RepositoryOwner;
  /** Identifies the date and time when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The HTTP path for this repository */
  resourcePath: Scalars['URI']['output'];
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars['HTML']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this repository */
  url: Scalars['URI']['output'];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars['Boolean']['output'];
  /** Indicates the repository's visibility level. */
  visibility: RepositoryVisibility;
};


/** A subset of repository info. */
export type RepositoryInfoshortDescriptionHTMLArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Repository interaction limit that applies to this object. */
export type RepositoryInteractionAbility = {
  /** The time the currently active limit expires. */
  expiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** The current limit that is enabled on this object. */
  limit: RepositoryInteractionLimit;
  /** The origin of the currently active interaction limit. */
  origin: RepositoryInteractionLimitOrigin;
};

/** A repository interaction limit. */
export type RepositoryInteractionLimit =
  /** Users that are not collaborators will not be able to interact with the repository. */
  | 'COLLABORATORS_ONLY'
  /** Users that have not previously committed to a repository’s default branch will be unable to interact with the repository. */
  | 'CONTRIBUTORS_ONLY'
  /** Users that have recently created their account will be unable to interact with the repository. */
  | 'EXISTING_USERS'
  /** No interaction limits are enabled. */
  | 'NO_LIMIT';

/** The length for a repository interaction limit to be enabled for. */
export type RepositoryInteractionLimitExpiry =
  /** The interaction limit will expire after 1 day. */
  | 'ONE_DAY'
  /** The interaction limit will expire after 1 month. */
  | 'ONE_MONTH'
  /** The interaction limit will expire after 1 week. */
  | 'ONE_WEEK'
  /** The interaction limit will expire after 6 months. */
  | 'SIX_MONTHS'
  /** The interaction limit will expire after 3 days. */
  | 'THREE_DAYS';

/** Indicates where an interaction limit is configured. */
export type RepositoryInteractionLimitOrigin =
  /** A limit that is configured at the organization level. */
  | 'ORGANIZATION'
  /** A limit that is configured at the repository level. */
  | 'REPOSITORY'
  /** A limit that is configured at the user-wide level. */
  | 'USER';

/** An invitation for a user to be added to a repository. */
export type RepositoryInvitation = Node & {
  /** The email address that received the invitation. */
  email?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the RepositoryInvitation object */
  id: Scalars['ID']['output'];
  /** The user who received the invitation. */
  invitee?: Maybe<User>;
  /** The user who created the invitation. */
  inviter: User;
  /** The permalink for this repository invitation. */
  permalink: Scalars['URI']['output'];
  /** The permission granted on this repository by this invitation. */
  permission: RepositoryPermission;
  /** The Repository the user is invited to. */
  repository?: Maybe<RepositoryInfo>;
};

/** A list of repository invitations. */
export type RepositoryInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type RepositoryInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryInvitation>;
};

/** Ordering options for repository invitation connections. */
export type RepositoryInvitationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repository invitations by. */
  field: RepositoryInvitationOrderField;
};

/** Properties by which repository invitation connections can be ordered. */
export type RepositoryInvitationOrderField =
  /** Order repository invitations by creation time */
  | 'CREATED_AT';

/** The possible reasons a given repository could be in a locked state. */
export type RepositoryLockReason =
  /** The repository is locked due to a billing related reason. */
  | 'BILLING'
  /** The repository is locked due to a migration. */
  | 'MIGRATING'
  /** The repository is locked due to a move. */
  | 'MOVING'
  /** The repository is locked due to a rename. */
  | 'RENAME'
  /** The repository is locked due to a trade controls related reason. */
  | 'TRADE_RESTRICTION'
  /** The repository is locked due to an ownership transfer. */
  | 'TRANSFERRING_OWNERSHIP';

/** A GitHub Enterprise Importer (GEI) repository migration. */
export type RepositoryMigration = Migration & Node & {
  /** The migration flag to continue on error. */
  continueOnError: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['String']['output']>;
  /** The reason the migration failed. */
  failureReason?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the RepositoryMigration object */
  id: Scalars['ID']['output'];
  /** The URL for the migration log (expires 1 day after migration completes). */
  migrationLogUrl?: Maybe<Scalars['URI']['output']>;
  /** The migration source. */
  migrationSource: MigrationSource;
  /** The target repository name. */
  repositoryName: Scalars['String']['output'];
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  sourceUrl: Scalars['URI']['output'];
  /** The migration state. */
  state: MigrationState;
  /**
   * The number of warnings encountered for this migration. To review the warnings,
   * check the [Migration Log](https://docs.github.com/en/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).
   */
  warningsCount: Scalars['Int']['output'];
};

/** The connection type for RepositoryMigration. */
export type RepositoryMigrationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryMigrationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryMigration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a repository migration. */
export type RepositoryMigrationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryMigration>;
};

/** Ordering options for repository migrations. */
export type RepositoryMigrationOrder = {
  /** The ordering direction. */
  direction: RepositoryMigrationOrderDirection;
  /** The field to order repository migrations by. */
  field: RepositoryMigrationOrderField;
};

/** Possible directions in which to order a list of repository migrations when provided an `orderBy` argument. */
export type RepositoryMigrationOrderDirection =
  /** Specifies an ascending order for a given `orderBy` argument. */
  | 'ASC'
  /** Specifies a descending order for a given `orderBy` argument. */
  | 'DESC';

/** Properties by which repository migrations can be ordered. */
export type RepositoryMigrationOrderField =
  /** Order mannequins why when they were created. */
  | 'CREATED_AT';

/** Parameters to be used for the repository_name condition */
export type RepositoryNameConditionTarget = {
  /** Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars['String']['output']>;
  /**
   * Array of repository names or patterns to include. One of these patterns must
   * match for the condition to pass. Also accepts `~ALL` to include all repositories.
   */
  include: Array<Scalars['String']['output']>;
  /** Target changes that match these patterns will be prevented except by those with bypass permissions. */
  protected: Scalars['Boolean']['output'];
};

/** Parameters to be used for the repository_name condition */
export type RepositoryNameConditionTargetInput = {
  /** Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars['String']['input']>;
  /**
   * Array of repository names or patterns to include. One of these patterns must
   * match for the condition to pass. Also accepts `~ALL` to include all repositories.
   */
  include: Array<Scalars['String']['input']>;
  /** Target changes that match these patterns will be prevented except by those with bypass permissions. */
  protected?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents a object that belongs to a repository. */
export type RepositoryNode = {
  /** The repository associated with this node. */
  repository: Repository;
};

/** Ordering options for repository connections */
export type RepositoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: RepositoryOrderField;
};

/** Properties by which repository connections can be ordered. */
export type RepositoryOrderField =
  /** Order repositories by creation time */
  | 'CREATED_AT'
  /** Order repositories by name */
  | 'NAME'
  /** Order repositories by push time */
  | 'PUSHED_AT'
  /** Order repositories by number of stargazers */
  | 'STARGAZERS'
  /** Order repositories by update time */
  | 'UPDATED_AT';

/** Represents an owner of a Repository. */
export type RepositoryOwner = {
  /** A URL pointing to the owner's public avatar. */
  avatarUrl: Scalars['URI']['output'];
  /** The Node ID of the RepositoryOwner object */
  id: Scalars['ID']['output'];
  /** The username used to login. */
  login: Scalars['String']['output'];
  /** A list of repositories that the user owns. */
  repositories: RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<Repository>;
  /** The HTTP URL for the owner. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for the owner. */
  url: Scalars['URI']['output'];
};


/** Represents an owner of a Repository. */
export type RepositoryOwneravatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an owner of a Repository. */
export type RepositoryOwnerrepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  isFork?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
};


/** Represents an owner of a Repository. */
export type RepositoryOwnerrepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
};

/** The access level to a repository */
export type RepositoryPermission =
  /**
   * Can read, clone, and push to this repository. Can also manage issues, pull
   * requests, and repository settings, including adding collaborators
   */
  | 'ADMIN'
  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */
  | 'MAINTAIN'
  /** Can read and clone this repository. Can also open and comment on issues and pull requests */
  | 'READ'
  /** Can read and clone this repository. Can also manage issues and pull requests */
  | 'TRIAGE'
  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */
  | 'WRITE';

/** The privacy of a repository */
export type RepositoryPrivacy =
  /** Private */
  | 'PRIVATE'
  /** Public */
  | 'PUBLIC';

/** A repository rule. */
export type RepositoryRule = Node & {
  /** The Node ID of the RepositoryRule object */
  id: Scalars['ID']['output'];
  /** The parameters for this rule. */
  parameters?: Maybe<RuleParameters>;
  /** The repository ruleset associated with this rule configuration */
  repositoryRuleset?: Maybe<RepositoryRuleset>;
  /** The type of rule. */
  type: RepositoryRuleType;
};

/** Set of conditions that determine if a ruleset will evaluate */
export type RepositoryRuleConditions = {
  /** Configuration for the ref_name condition */
  refName?: Maybe<RefNameConditionTarget>;
  /** Configuration for the repository_id condition */
  repositoryId?: Maybe<RepositoryIdConditionTarget>;
  /** Configuration for the repository_name condition */
  repositoryName?: Maybe<RepositoryNameConditionTarget>;
};

/** Specifies the conditions required for a ruleset to evaluate */
export type RepositoryRuleConditionsInput = {
  /** Configuration for the ref_name condition */
  refName?: InputMaybe<RefNameConditionTargetInput>;
  /** Configuration for the repository_id condition */
  repositoryId?: InputMaybe<RepositoryIdConditionTargetInput>;
  /** Configuration for the repository_name condition */
  repositoryName?: InputMaybe<RepositoryNameConditionTargetInput>;
};

/** The connection type for RepositoryRule. */
export type RepositoryRuleConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type RepositoryRuleEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryRule>;
};

/** Specifies the attributes for a new or updated rule. */
export type RepositoryRuleInput = {
  /** Optional ID of this rule when updating */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The parameters for the rule. */
  parameters?: InputMaybe<RuleParametersInput>;
  /** The type of rule to create. */
  type: RepositoryRuleType;
};

/** The rule types supported in rulesets */
export type RepositoryRuleType =
  /** Authorization */
  | 'AUTHORIZATION'
  /** Branch name pattern */
  | 'BRANCH_NAME_PATTERN'
  /** Committer email pattern */
  | 'COMMITTER_EMAIL_PATTERN'
  /** Commit author email pattern */
  | 'COMMIT_AUTHOR_EMAIL_PATTERN'
  /** Commit message pattern */
  | 'COMMIT_MESSAGE_PATTERN'
  /** Only allow users with bypass permission to create matching refs. */
  | 'CREATION'
  /** Only allow users with bypass permissions to delete matching refs. */
  | 'DELETION'
  /** Branch is read-only. Users cannot push to the branch. */
  | 'LOCK_BRANCH'
  /** Max ref updates */
  | 'MAX_REF_UPDATES'
  /** Merges must be performed via a merge queue. */
  | 'MERGE_QUEUE'
  /** Merge queue locked ref */
  | 'MERGE_QUEUE_LOCKED_REF'
  /** Prevent users with push access from force pushing to refs. */
  | 'NON_FAST_FORWARD'
  /** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
  | 'PULL_REQUEST'
  /** Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule. */
  | 'REQUIRED_DEPLOYMENTS'
  /** Prevent merge commits from being pushed to matching refs. */
  | 'REQUIRED_LINEAR_HISTORY'
  /**
   * When enabled, all conversations on code must be resolved before a pull request
   * can be merged into a branch that matches this rule.
   */
  | 'REQUIRED_REVIEW_THREAD_RESOLUTION'
  /** Commits pushed to matching refs must have verified signatures. */
  | 'REQUIRED_SIGNATURES'
  /**
   * Choose which status checks must pass before the ref is updated. When enabled,
   * commits must first be pushed to another ref where the checks pass.
   */
  | 'REQUIRED_STATUS_CHECKS'
  /**
   * Require all commits be made to a non-target branch and submitted via a pull
   * request and required workflow checks to pass before they can be merged.
   */
  | 'REQUIRED_WORKFLOW_STATUS_CHECKS'
  /** Commits pushed to matching refs must have verified signatures. */
  | 'RULESET_REQUIRED_SIGNATURES'
  /** Secret scanning */
  | 'SECRET_SCANNING'
  /** Tag */
  | 'TAG'
  /** Tag name pattern */
  | 'TAG_NAME_PATTERN'
  /** Only allow users with bypass permission to update matching refs. */
  | 'UPDATE'
  /** Require all changes made to a targeted branch to pass the specified workflows before they can be merged. */
  | 'WORKFLOWS'
  /** Workflow files cannot be modified. */
  | 'WORKFLOW_UPDATES';

/** A repository ruleset. */
export type RepositoryRuleset = Node & {
  /** The actors that can bypass this ruleset */
  bypassActors?: Maybe<RepositoryRulesetBypassActorConnection>;
  /** The set of conditions that must evaluate to true for this ruleset to apply */
  conditions: RepositoryRuleConditions;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The enforcement level of this ruleset */
  enforcement: RuleEnforcement;
  /** The Node ID of the RepositoryRuleset object */
  id: Scalars['ID']['output'];
  /** Name of the ruleset. */
  name: Scalars['String']['output'];
  /** List of rules. */
  rules?: Maybe<RepositoryRuleConnection>;
  /** Source of ruleset. */
  source: RuleSource;
  /** Target of the ruleset. */
  target?: Maybe<RepositoryRulesetTarget>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};


/** A repository ruleset. */
export type RepositoryRulesetbypassActorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository ruleset. */
export type RepositoryRulesetrulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<RepositoryRuleType>;
};

/** A team or app that has the ability to bypass a rules defined on a ruleset */
export type RepositoryRulesetBypassActor = Node & {
  /** The actor that can bypass rules. */
  actor?: Maybe<BypassActor>;
  /** The mode for the bypass actor */
  bypassMode?: Maybe<RepositoryRulesetBypassActorBypassMode>;
  /** The Node ID of the RepositoryRulesetBypassActor object */
  id: Scalars['ID']['output'];
  /** This actor represents the ability for an organization owner to bypass */
  organizationAdmin: Scalars['Boolean']['output'];
  /** If the actor is a repository role, the repository role's ID that can bypass */
  repositoryRoleDatabaseId?: Maybe<Scalars['Int']['output']>;
  /** If the actor is a repository role, the repository role's name that can bypass */
  repositoryRoleName?: Maybe<Scalars['String']['output']>;
  /** Identifies the ruleset associated with the allowed actor */
  repositoryRuleset?: Maybe<RepositoryRuleset>;
};

/** The bypass mode for a specific actor on a ruleset. */
export type RepositoryRulesetBypassActorBypassMode =
  /** The actor can always bypass rules */
  | 'ALWAYS'
  /** The actor can only bypass rules via a pull request */
  | 'PULL_REQUEST';

/** The connection type for RepositoryRulesetBypassActor. */
export type RepositoryRulesetBypassActorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryRulesetBypassActorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryRulesetBypassActor>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type RepositoryRulesetBypassActorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryRulesetBypassActor>;
};

/**
 * Specifies the attributes for a new or updated ruleset bypass actor. Only one of
 * `actor_id`, `repository_role_database_id`, or `organization_admin` should be specified.
 */
export type RepositoryRulesetBypassActorInput = {
  /** For Team and Integration bypasses, the Team or Integration ID */
  actorId?: InputMaybe<Scalars['ID']['input']>;
  /** The bypass mode for this actor. */
  bypassMode: RepositoryRulesetBypassActorBypassMode;
  /** For organization owner bypasses, true */
  organizationAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  /** For role bypasses, the role database ID */
  repositoryRoleDatabaseId?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for RepositoryRuleset. */
export type RepositoryRulesetConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryRulesetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryRuleset>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type RepositoryRulesetEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryRuleset>;
};

/** The targets supported for rulesets */
export type RepositoryRulesetTarget =
  /** Branch */
  | 'BRANCH'
  /** Tag */
  | 'TAG';

/** A repository-topic connects a repository to a topic. */
export type RepositoryTopic = Node & UniformResourceLocatable & {
  /** The Node ID of the RepositoryTopic object */
  id: Scalars['ID']['output'];
  /** The HTTP path for this repository-topic. */
  resourcePath: Scalars['URI']['output'];
  /** The topic. */
  topic: Topic;
  /** The HTTP URL for this repository-topic. */
  url: Scalars['URI']['output'];
};

/** The connection type for RepositoryTopic. */
export type RepositoryTopicConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryTopicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryTopic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type RepositoryTopicEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryTopic>;
};

/** The repository's visibility level. */
export type RepositoryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repository_visibility_change.disable event. */
export type RepositoryVisibilityChangeDisableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  /** The Node ID of the RepositoryVisibilityChangeDisableAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repository_visibility_change.enable event. */
export type RepositoryVisibilityChangeEnableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  /** The Node ID of the RepositoryVisibilityChangeEnableAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** A Dependabot alert for a repository with a dependency affected by a security vulnerability. */
export type RepositoryVulnerabilityAlert = Node & RepositoryNode & {
  /** When was the alert auto-dismissed? */
  autoDismissedAt?: Maybe<Scalars['DateTime']['output']>;
  /** When was the alert created? */
  createdAt: Scalars['DateTime']['output'];
  /** The associated Dependabot update */
  dependabotUpdate?: Maybe<DependabotUpdate>;
  /** The scope of an alert's dependency */
  dependencyScope?: Maybe<RepositoryVulnerabilityAlertDependencyScope>;
  /** Comment explaining the reason the alert was dismissed */
  dismissComment?: Maybe<Scalars['String']['output']>;
  /** The reason the alert was dismissed */
  dismissReason?: Maybe<Scalars['String']['output']>;
  /** When was the alert dismissed? */
  dismissedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user who dismissed the alert */
  dismisser?: Maybe<User>;
  /** When was the alert fixed? */
  fixedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The Node ID of the RepositoryVulnerabilityAlert object */
  id: Scalars['ID']['output'];
  /** Identifies the alert number. */
  number: Scalars['Int']['output'];
  /** The associated repository */
  repository: Repository;
  /** The associated security advisory */
  securityAdvisory?: Maybe<SecurityAdvisory>;
  /** The associated security vulnerability */
  securityVulnerability?: Maybe<SecurityVulnerability>;
  /** Identifies the state of the alert. */
  state: RepositoryVulnerabilityAlertState;
  /** The vulnerable manifest filename */
  vulnerableManifestFilename: Scalars['String']['output'];
  /** The vulnerable manifest path */
  vulnerableManifestPath: Scalars['String']['output'];
  /** The vulnerable requirements */
  vulnerableRequirements?: Maybe<Scalars['String']['output']>;
};

/** The connection type for RepositoryVulnerabilityAlert. */
export type RepositoryVulnerabilityAlertConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryVulnerabilityAlertEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryVulnerabilityAlert>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The possible scopes of an alert's dependency. */
export type RepositoryVulnerabilityAlertDependencyScope =
  /** A dependency that is only used in development */
  | 'DEVELOPMENT'
  /** A dependency that is leveraged during application runtime */
  | 'RUNTIME';

/** An edge in a connection. */
export type RepositoryVulnerabilityAlertEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryVulnerabilityAlert>;
};

/** The possible states of an alert */
export type RepositoryVulnerabilityAlertState =
  /** An alert that has been automatically closed by Dependabot. */
  | 'AUTO_DISMISSED'
  /** An alert that has been manually closed by a user. */
  | 'DISMISSED'
  /** An alert that has been resolved by a code change. */
  | 'FIXED'
  /** An alert that is still open. */
  | 'OPEN';

/** Autogenerated input type of RequestReviews */
export type RequestReviewsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID']['input'];
  /** The Node IDs of the team to request. */
  teamIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Add users to the set rather than replace. */
  union?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node IDs of the user to request. */
  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of RequestReviews */
export type RequestReviewsPayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that is getting requests. */
  pullRequest?: Maybe<PullRequest>;
  /** The edge from the pull request to the requested reviewers. */
  requestedReviewersEdge?: Maybe<UserEdge>;
};

/** The possible states that can be requested when creating a check run. */
export type RequestableCheckStatusState =
  /** The check suite or run has been completed. */
  | 'COMPLETED'
  /** The check suite or run is in progress. */
  | 'IN_PROGRESS'
  /** The check suite or run is in pending state. */
  | 'PENDING'
  /** The check suite or run has been queued. */
  | 'QUEUED'
  /** The check suite or run is in waiting state. */
  | 'WAITING';

/** Types that can be requested reviewers. */
export type RequestedReviewer = Bot | Mannequin | Team | User;

/** The connection type for RequestedReviewer. */
export type RequestedReviewerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RequestedReviewerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RequestedReviewer>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type RequestedReviewerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RequestedReviewer>;
};

/** Represents a type that can be required by a pull request for merging. */
export type RequirableByPullRequest = {
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars['Boolean']['output'];
};


/** Represents a type that can be required by a pull request for merging. */
export type RequirableByPullRequestisRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule. */
export type RequiredDeploymentsParameters = {
  /** The environments that must be successfully deployed to before branches can be merged. */
  requiredDeploymentEnvironments: Array<Scalars['String']['output']>;
};

/** Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule. */
export type RequiredDeploymentsParametersInput = {
  /** The environments that must be successfully deployed to before branches can be merged. */
  requiredDeploymentEnvironments: Array<Scalars['String']['input']>;
};

/** Represents a required status check for a protected branch, but not any specific run of that check. */
export type RequiredStatusCheckDescription = {
  /** The App that must provide this status in order for it to be accepted. */
  app?: Maybe<App>;
  /** The name of this status. */
  context: Scalars['String']['output'];
};

/** Specifies the attributes for a new or updated required status check. */
export type RequiredStatusCheckInput = {
  /**
   * The ID of the App that must set the status in order for it to be accepted.
   * Omit this value to use whichever app has recently been setting this status, or
   * use "any" to allow any app to set the status.
   */
  appId?: InputMaybe<Scalars['ID']['input']>;
  /** Status check context that must pass for commits to be accepted to the matching branch. */
  context: Scalars['String']['input'];
};

/**
 * Choose which status checks must pass before the ref is updated. When enabled,
 * commits must first be pushed to another ref where the checks pass.
 */
export type RequiredStatusChecksParameters = {
  /** Status checks that are required. */
  requiredStatusChecks: Array<StatusCheckConfiguration>;
  /**
   * Whether pull requests targeting a matching branch must be tested with the
   * latest code. This setting will not take effect unless at least one status
   * check is enabled.
   */
  strictRequiredStatusChecksPolicy: Scalars['Boolean']['output'];
};

/**
 * Choose which status checks must pass before the ref is updated. When enabled,
 * commits must first be pushed to another ref where the checks pass.
 */
export type RequiredStatusChecksParametersInput = {
  /** Status checks that are required. */
  requiredStatusChecks: Array<StatusCheckConfigurationInput>;
  /**
   * Whether pull requests targeting a matching branch must be tested with the
   * latest code. This setting will not take effect unless at least one status
   * check is enabled.
   */
  strictRequiredStatusChecksPolicy: Scalars['Boolean']['input'];
};

/** Autogenerated input type of RerequestCheckSuite */
export type RerequestCheckSuiteInput = {
  /** The Node ID of the check suite. */
  checkSuiteId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of RerequestCheckSuite */
export type RerequestCheckSuitePayload = {
  /** The requested check suite. */
  checkSuite?: Maybe<CheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ResolveReviewThread */
export type ResolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the thread to resolve */
  threadId: Scalars['ID']['input'];
};

/** Autogenerated return type of ResolveReviewThread */
export type ResolveReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The thread to resolve. */
  thread?: Maybe<PullRequestReviewThread>;
};

/** Represents a private contribution a user made on GitHub. */
export type RestrictedContribution = Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  user: User;
};

/** Autogenerated input type of RetireSponsorsTier */
export type RetireSponsorsTierInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the published tier to retire. */
  tierId: Scalars['ID']['input'];
};

/** Autogenerated return type of RetireSponsorsTier */
export type RetireSponsorsTierPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The tier that was retired. */
  sponsorsTier?: Maybe<SponsorsTier>;
};

/** Autogenerated input type of RevertPullRequest */
export type RevertPullRequestInput = {
  /** The description of the revert pull request. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether the revert pull request should be a draft. */
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the pull request to revert. */
  pullRequestId: Scalars['ID']['input'];
  /** The title of the revert pull request. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of RevertPullRequest */
export type RevertPullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that was reverted. */
  pullRequest?: Maybe<PullRequest>;
  /** The new pull request that reverts the input pull request. */
  revertPullRequest?: Maybe<PullRequest>;
};

/** A user, team, or app who has the ability to dismiss a review on a protected branch. */
export type ReviewDismissalAllowance = Node & {
  /** The actor that can dismiss. */
  actor?: Maybe<ReviewDismissalAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** The Node ID of the ReviewDismissalAllowance object */
  id: Scalars['ID']['output'];
};

/** Types that can be an actor. */
export type ReviewDismissalAllowanceActor = App | Team | User;

/** The connection type for ReviewDismissalAllowance. */
export type ReviewDismissalAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReviewDismissalAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReviewDismissalAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ReviewDismissalAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ReviewDismissalAllowance>;
};

/** Represents a 'review_dismissed' event on a given issue or pull request. */
export type ReviewDismissedEvent = Node & UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** Identifies the optional message associated with the 'review_dismissed' event. */
  dismissalMessage?: Maybe<Scalars['String']['output']>;
  /** Identifies the optional message associated with the event, rendered to HTML. */
  dismissalMessageHTML?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the ReviewDismissedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the previous state of the review with the 'review_dismissed' event. */
  previousReviewState: PullRequestReviewState;
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the commit which caused the review to become stale. */
  pullRequestCommit?: Maybe<PullRequestCommit>;
  /** The HTTP path for this review dismissed event. */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the review associated with the 'review_dismissed' event. */
  review?: Maybe<PullRequestReview>;
  /** The HTTP URL for this review dismissed event. */
  url: Scalars['URI']['output'];
};

/** A request for a user to review a pull request. */
export type ReviewRequest = Node & {
  /** Whether this request was created for a code owner */
  asCodeOwner: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ReviewRequest object */
  id: Scalars['ID']['output'];
  /** Identifies the pull request associated with this review request. */
  pullRequest: PullRequest;
  /** The reviewer that is requested. */
  requestedReviewer?: Maybe<RequestedReviewer>;
};

/** The connection type for ReviewRequest. */
export type ReviewRequestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReviewRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReviewRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ReviewRequestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ReviewRequest>;
};

/** Represents an 'review_request_removed' event on a given pull request. */
export type ReviewRequestRemovedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ReviewRequestRemovedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the reviewer whose review request was removed. */
  requestedReviewer?: Maybe<RequestedReviewer>;
};

/** Represents an 'review_requested' event on a given pull request. */
export type ReviewRequestedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ReviewRequestedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the reviewer whose review was requested. */
  requestedReviewer?: Maybe<RequestedReviewer>;
};

/**
 * A hovercard context with a message describing the current code review state of the pull
 * request.
 */
export type ReviewStatusHovercardContext = HovercardContext & {
  /** A string describing this context */
  message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  octicon: Scalars['String']['output'];
  /** The current status of the pull request with respect to code review. */
  reviewDecision?: Maybe<PullRequestReviewDecision>;
};

/** Autogenerated input type of RevokeEnterpriseOrganizationsMigratorRole */
export type RevokeEnterpriseOrganizationsMigratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of the user to revoke the migrator role */
  login: Scalars['String']['input'];
};

/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */
export type RevokeEnterpriseOrganizationsMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organizations that had the migrator role revoked for the given user. */
  organizations?: Maybe<OrganizationConnection>;
};


/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */
export type RevokeEnterpriseOrganizationsMigratorRolePayloadorganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of RevokeMigratorRole */
export type RevokeMigratorRoleInput = {
  /** The user login or Team slug to revoke the migrator role from. */
  actor: Scalars['String']['input'];
  /** Specifies the type of the actor, can be either USER or TEAM. */
  actorType: ActorType;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that the user/team belongs to. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of RevokeMigratorRole */
export type RevokeMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Possible roles a user may have in relation to an organization. */
export type RoleInOrganization =
  /** A user who is a direct member of the organization. */
  | 'DIRECT_MEMBER'
  /** A user with full administrative access to the organization. */
  | 'OWNER'
  /** A user who is unaffiliated with the organization. */
  | 'UNAFFILIATED';

/** The level of enforcement for a rule or ruleset. */
export type RuleEnforcement =
  /** Rules will be enforced */
  | 'ACTIVE'
  /** Do not evaluate or enforce rules */
  | 'DISABLED'
  /**
   * Allow admins to test rules before enforcing them. Admins can view insights on
   * the Rule Insights page (`evaluate` is only available with GitHub Enterprise).
   */
  | 'EVALUATE';

/** Types which can be parameters for `RepositoryRule` objects. */
export type RuleParameters = BranchNamePatternParameters | CommitAuthorEmailPatternParameters | CommitMessagePatternParameters | CommitterEmailPatternParameters | PullRequestParameters | RequiredDeploymentsParameters | RequiredStatusChecksParameters | TagNamePatternParameters | UpdateParameters | WorkflowsParameters;

/** Specifies the parameters for a `RepositoryRule` object. Only one of the fields should be specified. */
export type RuleParametersInput = {
  /** Parameters used for the `branch_name_pattern` rule type */
  branchNamePattern?: InputMaybe<BranchNamePatternParametersInput>;
  /** Parameters used for the `commit_author_email_pattern` rule type */
  commitAuthorEmailPattern?: InputMaybe<CommitAuthorEmailPatternParametersInput>;
  /** Parameters used for the `commit_message_pattern` rule type */
  commitMessagePattern?: InputMaybe<CommitMessagePatternParametersInput>;
  /** Parameters used for the `committer_email_pattern` rule type */
  committerEmailPattern?: InputMaybe<CommitterEmailPatternParametersInput>;
  /** Parameters used for the `pull_request` rule type */
  pullRequest?: InputMaybe<PullRequestParametersInput>;
  /** Parameters used for the `required_deployments` rule type */
  requiredDeployments?: InputMaybe<RequiredDeploymentsParametersInput>;
  /** Parameters used for the `required_status_checks` rule type */
  requiredStatusChecks?: InputMaybe<RequiredStatusChecksParametersInput>;
  /** Parameters used for the `tag_name_pattern` rule type */
  tagNamePattern?: InputMaybe<TagNamePatternParametersInput>;
  /** Parameters used for the `update` rule type */
  update?: InputMaybe<UpdateParametersInput>;
  /** Parameters used for the `workflows` rule type */
  workflows?: InputMaybe<WorkflowsParametersInput>;
};

/** Types which can have `RepositoryRule` objects. */
export type RuleSource = Organization | Repository;

/** The possible digest algorithms used to sign SAML requests for an identity provider. */
export type SamlDigestAlgorithm =
  /** SHA1 */
  | 'SHA1'
  /** SHA256 */
  | 'SHA256'
  /** SHA384 */
  | 'SHA384'
  /** SHA512 */
  | 'SHA512';

/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */
export type SamlSignatureAlgorithm =
  /** RSA-SHA1 */
  | 'RSA_SHA1'
  /** RSA-SHA256 */
  | 'RSA_SHA256'
  /** RSA-SHA384 */
  | 'RSA_SHA384'
  /** RSA-SHA512 */
  | 'RSA_SHA512';

/** A Saved Reply is text a user can use to reply quickly. */
export type SavedReply = Node & {
  /** The body of the saved reply. */
  body: Scalars['String']['output'];
  /** The saved reply body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the SavedReply object */
  id: Scalars['ID']['output'];
  /** The title of the saved reply. */
  title: Scalars['String']['output'];
  /** The user that saved this reply. */
  user?: Maybe<Actor>;
};

/** The connection type for SavedReply. */
export type SavedReplyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SavedReplyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SavedReply>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SavedReplyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SavedReply>;
};

/** Ordering options for saved reply connections. */
export type SavedReplyOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order saved replies by. */
  field: SavedReplyOrderField;
};

/** Properties by which saved reply connections can be ordered. */
export type SavedReplyOrderField =
  /** Order saved reply by when they were updated. */
  | 'UPDATED_AT';

/** The results of a search. */
export type SearchResultItem = App | Discussion | Issue | MarketplaceListing | Organization | PullRequest | Repository | User;

/**
 * A list of results that matched against a search query. Regardless of the number
 * of matches, a maximum of 1,000 results will be available across all types,
 * potentially split across many pages.
 */
export type SearchResultItemConnection = {
  /**
   * The total number of pieces of code that matched the search query. Regardless
   * of the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  codeCount: Scalars['Int']['output'];
  /**
   * The total number of discussions that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  discussionCount: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SearchResultItemEdge>>>;
  /**
   * The total number of issues that matched the search query. Regardless of the
   * total number of matches, a maximum of 1,000 results will be available across all types.
   */
  issueCount: Scalars['Int']['output'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SearchResultItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /**
   * The total number of repositories that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  repositoryCount: Scalars['Int']['output'];
  /**
   * The total number of users that matched the search query. Regardless of the
   * total number of matches, a maximum of 1,000 results will be available across all types.
   */
  userCount: Scalars['Int']['output'];
  /**
   * The total number of wiki pages that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  wikiCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SearchResultItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SearchResultItem>;
  /** Text matches on the result found. */
  textMatches?: Maybe<Array<Maybe<TextMatch>>>;
};

/** Represents the individual results of a search. */
export type SearchType =
  /** Returns matching discussions in repositories. */
  | 'DISCUSSION'
  /** Returns results matching issues in repositories. */
  | 'ISSUE'
  /** Returns results matching repositories. */
  | 'REPOSITORY'
  /** Returns results matching users and organizations on GitHub. */
  | 'USER';

/** A GitHub Security Advisory */
export type SecurityAdvisory = Node & {
  /** The classification of the advisory */
  classification: SecurityAdvisoryClassification;
  /** The CVSS associated with this advisory */
  cvss: CVSS;
  /** CWEs associated with this Advisory */
  cwes: CWEConnection;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** This is a long plaintext description of the advisory */
  description: Scalars['String']['output'];
  /** The GitHub Security Advisory ID */
  ghsaId: Scalars['String']['output'];
  /** The Node ID of the SecurityAdvisory object */
  id: Scalars['ID']['output'];
  /** A list of identifiers for this advisory */
  identifiers: Array<SecurityAdvisoryIdentifier>;
  /** The permalink for the advisory's dependabot alerts page */
  notificationsPermalink?: Maybe<Scalars['URI']['output']>;
  /** The organization that originated the advisory */
  origin: Scalars['String']['output'];
  /** The permalink for the advisory */
  permalink?: Maybe<Scalars['URI']['output']>;
  /** When the advisory was published */
  publishedAt: Scalars['DateTime']['output'];
  /** A list of references for this advisory */
  references: Array<SecurityAdvisoryReference>;
  /** The severity of the advisory */
  severity: SecurityAdvisorySeverity;
  /** A short plaintext summary of the advisory */
  summary: Scalars['String']['output'];
  /** When the advisory was last updated */
  updatedAt: Scalars['DateTime']['output'];
  /** Vulnerabilities associated with this Advisory */
  vulnerabilities: SecurityVulnerabilityConnection;
  /** When the advisory was withdrawn, if it has been withdrawn */
  withdrawnAt?: Maybe<Scalars['DateTime']['output']>;
};


/** A GitHub Security Advisory */
export type SecurityAdvisorycwesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A GitHub Security Advisory */
export type SecurityAdvisoryvulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  classifications?: InputMaybe<Array<SecurityAdvisoryClassification>>;
  ecosystem?: InputMaybe<SecurityAdvisoryEcosystem>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SecurityVulnerabilityOrder>;
  package?: InputMaybe<Scalars['String']['input']>;
  severities?: InputMaybe<Array<SecurityAdvisorySeverity>>;
};

/** Classification of the advisory. */
export type SecurityAdvisoryClassification =
  /** Classification of general advisories. */
  | 'GENERAL'
  /** Classification of malware advisories. */
  | 'MALWARE';

/** The connection type for SecurityAdvisory. */
export type SecurityAdvisoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SecurityAdvisoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SecurityAdvisory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The possible ecosystems of a security vulnerability's package. */
export type SecurityAdvisoryEcosystem =
  /** GitHub Actions */
  | 'ACTIONS'
  /** PHP packages hosted at packagist.org */
  | 'COMPOSER'
  /** Erlang/Elixir packages hosted at hex.pm */
  | 'ERLANG'
  /** Go modules */
  | 'GO'
  /** Java artifacts hosted at the Maven central repository */
  | 'MAVEN'
  /** JavaScript packages hosted at npmjs.com */
  | 'NPM'
  /** .NET packages hosted at the NuGet Gallery */
  | 'NUGET'
  /** Python packages hosted at PyPI.org */
  | 'PIP'
  /** Dart packages hosted at pub.dev */
  | 'PUB'
  /** Ruby gems hosted at RubyGems.org */
  | 'RUBYGEMS'
  /** Rust crates */
  | 'RUST'
  /** Swift packages */
  | 'SWIFT';

/** An edge in a connection. */
export type SecurityAdvisoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SecurityAdvisory>;
};

/** A GitHub Security Advisory Identifier */
export type SecurityAdvisoryIdentifier = {
  /** The identifier type, e.g. GHSA, CVE */
  type: Scalars['String']['output'];
  /** The identifier */
  value: Scalars['String']['output'];
};

/** An advisory identifier to filter results on. */
export type SecurityAdvisoryIdentifierFilter = {
  /** The identifier type. */
  type: SecurityAdvisoryIdentifierType;
  /** The identifier string. Supports exact or partial matching. */
  value: Scalars['String']['input'];
};

/** Identifier formats available for advisories. */
export type SecurityAdvisoryIdentifierType =
  /** Common Vulnerabilities and Exposures Identifier. */
  | 'CVE'
  /** GitHub Security Advisory ID. */
  | 'GHSA';

/** Ordering options for security advisory connections */
export type SecurityAdvisoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order security advisories by. */
  field: SecurityAdvisoryOrderField;
};

/** Properties by which security advisory connections can be ordered. */
export type SecurityAdvisoryOrderField =
  /** Order advisories by publication time */
  | 'PUBLISHED_AT'
  /** Order advisories by update time */
  | 'UPDATED_AT';

/** An individual package */
export type SecurityAdvisoryPackage = {
  /** The ecosystem the package belongs to, e.g. RUBYGEMS, NPM */
  ecosystem: SecurityAdvisoryEcosystem;
  /** The package name */
  name: Scalars['String']['output'];
};

/** An individual package version */
export type SecurityAdvisoryPackageVersion = {
  /** The package name or version */
  identifier: Scalars['String']['output'];
};

/** A GitHub Security Advisory Reference */
export type SecurityAdvisoryReference = {
  /** A publicly accessible reference */
  url: Scalars['URI']['output'];
};

/** Severity of the vulnerability. */
export type SecurityAdvisorySeverity =
  /** Critical. */
  | 'CRITICAL'
  /** High. */
  | 'HIGH'
  /** Low. */
  | 'LOW'
  /** Moderate. */
  | 'MODERATE';

/** An individual vulnerability within an Advisory */
export type SecurityVulnerability = {
  /** The Advisory associated with this Vulnerability */
  advisory: SecurityAdvisory;
  /** The first version containing a fix for the vulnerability */
  firstPatchedVersion?: Maybe<SecurityAdvisoryPackageVersion>;
  /** A description of the vulnerable package */
  package: SecurityAdvisoryPackage;
  /** The severity of the vulnerability within this package */
  severity: SecurityAdvisorySeverity;
  /** When the vulnerability was last updated */
  updatedAt: Scalars['DateTime']['output'];
  /**
   * A string that describes the vulnerable package versions.
   * This string follows a basic syntax with a few forms.
   * + `= 0.2.0` denotes a single vulnerable version.
   * + `<= 1.0.8` denotes a version range up to and including the specified version
   * + `< 0.1.11` denotes a version range up to, but excluding, the specified version
   * + `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.
   * + `>= 0.0.1` denotes a version range with a known minimum, but no known maximum
   */
  vulnerableVersionRange: Scalars['String']['output'];
};

/** The connection type for SecurityVulnerability. */
export type SecurityVulnerabilityConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SecurityVulnerabilityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SecurityVulnerability>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SecurityVulnerabilityEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SecurityVulnerability>;
};

/** Ordering options for security vulnerability connections */
export type SecurityVulnerabilityOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order security vulnerabilities by. */
  field: SecurityVulnerabilityOrderField;
};

/** Properties by which security vulnerability connections can be ordered. */
export type SecurityVulnerabilityOrderField =
  /** Order vulnerability by update time */
  | 'UPDATED_AT';

/** Autogenerated input type of SetEnterpriseIdentityProvider */
export type SetEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod: SamlDigestAlgorithm;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID']['input'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate: Scalars['String']['input'];
  /** The Issuer Entity ID for the SAML identity provider */
  issuer?: InputMaybe<Scalars['String']['input']>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod: SamlSignatureAlgorithm;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl: Scalars['URI']['input'];
};

/** Autogenerated return type of SetEnterpriseIdentityProvider */
export type SetEnterpriseIdentityProviderPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The identity provider for the enterprise. */
  identityProvider?: Maybe<EnterpriseIdentityProvider>;
};

/** Autogenerated input type of SetOrganizationInteractionLimit */
export type SetOrganizationInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: RepositoryInteractionLimit;
  /** The ID of the organization to set a limit for. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of SetOrganizationInteractionLimit */
export type SetOrganizationInteractionLimitPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organization that the interaction limit was set for. */
  organization?: Maybe<Organization>;
};

/** Autogenerated input type of SetRepositoryInteractionLimit */
export type SetRepositoryInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: RepositoryInteractionLimit;
  /** The ID of the repository to set a limit for. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of SetRepositoryInteractionLimit */
export type SetRepositoryInteractionLimitPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository that the interaction limit was set for. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of SetUserInteractionLimit */
export type SetUserInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: RepositoryInteractionLimit;
  /** The ID of the user to set a limit for. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of SetUserInteractionLimit */
export type SetUserInteractionLimitPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The user that the interaction limit was set for. */
  user?: Maybe<User>;
};

/** Represents an S/MIME signature on a Commit or Tag. */
export type SmimeSignature = GitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean']['output'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** Social media profile associated with a user. */
export type SocialAccount = {
  /** Name of the social media account as it appears on the profile. */
  displayName: Scalars['String']['output'];
  /** Software or company that hosts the social media account. */
  provider: SocialAccountProvider;
  /** URL of the social media account. */
  url: Scalars['URI']['output'];
};

/** The connection type for SocialAccount. */
export type SocialAccountConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SocialAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SocialAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SocialAccountEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SocialAccount>;
};

/** Software or company that hosts social media accounts. */
export type SocialAccountProvider =
  /** Social media and networking website. */
  | 'FACEBOOK'
  /** Catch-all for social media providers that do not yet have specific handling. */
  | 'GENERIC'
  /** Fork of Mastodon with a greater focus on local posting. */
  | 'HOMETOWN'
  /** Social media website with a focus on photo and video sharing. */
  | 'INSTAGRAM'
  /** Professional networking website. */
  | 'LINKEDIN'
  /** Open-source federated microblogging service. */
  | 'MASTODON'
  /** JavaScript package registry. */
  | 'NPM'
  /** Social news aggregation and discussion website. */
  | 'REDDIT'
  /** Live-streaming service. */
  | 'TWITCH'
  /** Microblogging website. */
  | 'TWITTER'
  /** Online video platform. */
  | 'YOUTUBE';

/** Entities that can sponsor others via GitHub Sponsors */
export type Sponsor = Organization | User;

/** The connection type for Sponsor. */
export type SponsorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SponsorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Sponsor>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a user or organization who is sponsoring someone in GitHub Sponsors. */
export type SponsorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Sponsor>;
};

/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */
export type SponsorOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsor entities by. */
  field: SponsorOrderField;
};

/** Properties by which sponsor connections can be ordered. */
export type SponsorOrderField =
  /** Order sponsorable entities by login (username). */
  | 'LOGIN'
  /** Order sponsors by their relevance to the viewer. */
  | 'RELEVANCE';

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type Sponsorable = {
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars['Int']['output'];
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars['Boolean']['output'];
  /** Whether the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars['Boolean']['output'];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars['Boolean']['output'];
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']['output'];
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<SponsorsListing>;
  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
  sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;
  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
  sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: SponsorshipNewsletterConnection;
  /** The sponsorships where this user or organization is the maintainer receiving the funds. */
  sponsorshipsAsMaintainer: SponsorshipConnection;
  /** The sponsorships where this user or organization is the funder. */
  sponsorshipsAsSponsor: SponsorshipConnection;
  /**
   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
   * user themselves or by a user who can manage sponsorships for the requested organization.
   */
  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']['output']>;
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars['Boolean']['output'];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars['Boolean']['output'];
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorableisSponsoredByArgs = {
  accountLogin: Scalars['String']['input'];
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorablesponsoringArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorablesponsorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']['input']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorablesponsorsActivitiesArgs = {
  actions?: InputMaybe<Array<SponsorsActivityAction>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAsSponsor?: InputMaybe<Scalars['Boolean']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorsActivityOrder>;
  period?: InputMaybe<SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorablesponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorablesponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorablesponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorablesponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorablesponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  maintainerLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type SponsorabletotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars['DateTime']['input']>;
  sponsorableLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Entities that can be sponsored via GitHub Sponsors */
export type SponsorableItem = Organization | User;

/** The connection type for SponsorableItem. */
export type SponsorableItemConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SponsorableItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SponsorableItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SponsorableItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SponsorableItem>;
};

/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */
export type SponsorableOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsorable entities by. */
  field: SponsorableOrderField;
};

/** Properties by which sponsorable connections can be ordered. */
export type SponsorableOrderField =
  /** Order sponsorable entities by login (username). */
  | 'LOGIN';

/** An event related to sponsorship activity. */
export type SponsorsActivity = Node & {
  /** What action this activity indicates took place. */
  action: SponsorsActivityAction;
  /** The sponsor's current privacy level. */
  currentPrivacyLevel?: Maybe<SponsorshipPrivacy>;
  /** The Node ID of the SponsorsActivity object */
  id: Scalars['ID']['output'];
  /** The platform that was used to pay for the sponsorship. */
  paymentSource?: Maybe<SponsorshipPaymentSource>;
  /** The tier that the sponsorship used to use, for tier change events. */
  previousSponsorsTier?: Maybe<SponsorsTier>;
  /** The user or organization who triggered this activity and was/is sponsoring the sponsorable. */
  sponsor?: Maybe<Sponsor>;
  /** The user or organization that is being sponsored, the maintainer. */
  sponsorable: Sponsorable;
  /** The associated sponsorship tier. */
  sponsorsTier?: Maybe<SponsorsTier>;
  /** The timestamp of this event. */
  timestamp?: Maybe<Scalars['DateTime']['output']>;
  /** Was this sponsorship made alongside other sponsorships at the same time from the same sponsor? */
  viaBulkSponsorship: Scalars['Boolean']['output'];
};

/** The possible actions that GitHub Sponsors activities can represent. */
export type SponsorsActivityAction =
  /** The activity was cancelling a sponsorship. */
  | 'CANCELLED_SPONSORSHIP'
  /** The activity was starting a sponsorship. */
  | 'NEW_SPONSORSHIP'
  /** The activity was scheduling a downgrade or cancellation. */
  | 'PENDING_CHANGE'
  /** The activity was funds being refunded to the sponsor or GitHub. */
  | 'REFUND'
  /** The activity was disabling matching for a previously matched sponsorship. */
  | 'SPONSOR_MATCH_DISABLED'
  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */
  | 'TIER_CHANGE';

/** The connection type for SponsorsActivity. */
export type SponsorsActivityConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SponsorsActivityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SponsorsActivity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SponsorsActivityEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SponsorsActivity>;
};

/** Ordering options for GitHub Sponsors activity connections. */
export type SponsorsActivityOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order activity by. */
  field: SponsorsActivityOrderField;
};

/** Properties by which GitHub Sponsors activity connections can be ordered. */
export type SponsorsActivityOrderField =
  /** Order activities by when they happened. */
  | 'TIMESTAMP';

/** The possible time periods for which Sponsors activities can be requested. */
export type SponsorsActivityPeriod =
  /** Don't restrict the activity to any date range, include all activity. */
  | 'ALL'
  /** The previous calendar day. */
  | 'DAY'
  /** The previous thirty days. */
  | 'MONTH'
  /** The previous seven days. */
  | 'WEEK';

/** Represents countries or regions for billing and residence for a GitHub Sponsors profile. */
export type SponsorsCountryOrRegionCode =
  /** Andorra */
  | 'AD'
  /** United Arab Emirates */
  | 'AE'
  /** Afghanistan */
  | 'AF'
  /** Antigua and Barbuda */
  | 'AG'
  /** Anguilla */
  | 'AI'
  /** Albania */
  | 'AL'
  /** Armenia */
  | 'AM'
  /** Angola */
  | 'AO'
  /** Antarctica */
  | 'AQ'
  /** Argentina */
  | 'AR'
  /** American Samoa */
  | 'AS'
  /** Austria */
  | 'AT'
  /** Australia */
  | 'AU'
  /** Aruba */
  | 'AW'
  /** Åland */
  | 'AX'
  /** Azerbaijan */
  | 'AZ'
  /** Bosnia and Herzegovina */
  | 'BA'
  /** Barbados */
  | 'BB'
  /** Bangladesh */
  | 'BD'
  /** Belgium */
  | 'BE'
  /** Burkina Faso */
  | 'BF'
  /** Bulgaria */
  | 'BG'
  /** Bahrain */
  | 'BH'
  /** Burundi */
  | 'BI'
  /** Benin */
  | 'BJ'
  /** Saint Barthélemy */
  | 'BL'
  /** Bermuda */
  | 'BM'
  /** Brunei Darussalam */
  | 'BN'
  /** Bolivia */
  | 'BO'
  /** Bonaire, Sint Eustatius and Saba */
  | 'BQ'
  /** Brazil */
  | 'BR'
  /** Bahamas */
  | 'BS'
  /** Bhutan */
  | 'BT'
  /** Bouvet Island */
  | 'BV'
  /** Botswana */
  | 'BW'
  /** Belarus */
  | 'BY'
  /** Belize */
  | 'BZ'
  /** Canada */
  | 'CA'
  /** Cocos (Keeling) Islands */
  | 'CC'
  /** Congo (Kinshasa) */
  | 'CD'
  /** Central African Republic */
  | 'CF'
  /** Congo (Brazzaville) */
  | 'CG'
  /** Switzerland */
  | 'CH'
  /** Côte d'Ivoire */
  | 'CI'
  /** Cook Islands */
  | 'CK'
  /** Chile */
  | 'CL'
  /** Cameroon */
  | 'CM'
  /** China */
  | 'CN'
  /** Colombia */
  | 'CO'
  /** Costa Rica */
  | 'CR'
  /** Cape Verde */
  | 'CV'
  /** Curaçao */
  | 'CW'
  /** Christmas Island */
  | 'CX'
  /** Cyprus */
  | 'CY'
  /** Czech Republic */
  | 'CZ'
  /** Germany */
  | 'DE'
  /** Djibouti */
  | 'DJ'
  /** Denmark */
  | 'DK'
  /** Dominica */
  | 'DM'
  /** Dominican Republic */
  | 'DO'
  /** Algeria */
  | 'DZ'
  /** Ecuador */
  | 'EC'
  /** Estonia */
  | 'EE'
  /** Egypt */
  | 'EG'
  /** Western Sahara */
  | 'EH'
  /** Eritrea */
  | 'ER'
  /** Spain */
  | 'ES'
  /** Ethiopia */
  | 'ET'
  /** Finland */
  | 'FI'
  /** Fiji */
  | 'FJ'
  /** Falkland Islands */
  | 'FK'
  /** Micronesia */
  | 'FM'
  /** Faroe Islands */
  | 'FO'
  /** France */
  | 'FR'
  /** Gabon */
  | 'GA'
  /** United Kingdom */
  | 'GB'
  /** Grenada */
  | 'GD'
  /** Georgia */
  | 'GE'
  /** French Guiana */
  | 'GF'
  /** Guernsey */
  | 'GG'
  /** Ghana */
  | 'GH'
  /** Gibraltar */
  | 'GI'
  /** Greenland */
  | 'GL'
  /** Gambia */
  | 'GM'
  /** Guinea */
  | 'GN'
  /** Guadeloupe */
  | 'GP'
  /** Equatorial Guinea */
  | 'GQ'
  /** Greece */
  | 'GR'
  /** South Georgia and South Sandwich Islands */
  | 'GS'
  /** Guatemala */
  | 'GT'
  /** Guam */
  | 'GU'
  /** Guinea-Bissau */
  | 'GW'
  /** Guyana */
  | 'GY'
  /** Hong Kong */
  | 'HK'
  /** Heard and McDonald Islands */
  | 'HM'
  /** Honduras */
  | 'HN'
  /** Croatia */
  | 'HR'
  /** Haiti */
  | 'HT'
  /** Hungary */
  | 'HU'
  /** Indonesia */
  | 'ID'
  /** Ireland */
  | 'IE'
  /** Israel */
  | 'IL'
  /** Isle of Man */
  | 'IM'
  /** India */
  | 'IN'
  /** British Indian Ocean Territory */
  | 'IO'
  /** Iraq */
  | 'IQ'
  /** Iran */
  | 'IR'
  /** Iceland */
  | 'IS'
  /** Italy */
  | 'IT'
  /** Jersey */
  | 'JE'
  /** Jamaica */
  | 'JM'
  /** Jordan */
  | 'JO'
  /** Japan */
  | 'JP'
  /** Kenya */
  | 'KE'
  /** Kyrgyzstan */
  | 'KG'
  /** Cambodia */
  | 'KH'
  /** Kiribati */
  | 'KI'
  /** Comoros */
  | 'KM'
  /** Saint Kitts and Nevis */
  | 'KN'
  /** Korea, South */
  | 'KR'
  /** Kuwait */
  | 'KW'
  /** Cayman Islands */
  | 'KY'
  /** Kazakhstan */
  | 'KZ'
  /** Laos */
  | 'LA'
  /** Lebanon */
  | 'LB'
  /** Saint Lucia */
  | 'LC'
  /** Liechtenstein */
  | 'LI'
  /** Sri Lanka */
  | 'LK'
  /** Liberia */
  | 'LR'
  /** Lesotho */
  | 'LS'
  /** Lithuania */
  | 'LT'
  /** Luxembourg */
  | 'LU'
  /** Latvia */
  | 'LV'
  /** Libya */
  | 'LY'
  /** Morocco */
  | 'MA'
  /** Monaco */
  | 'MC'
  /** Moldova */
  | 'MD'
  /** Montenegro */
  | 'ME'
  /** Saint Martin (French part) */
  | 'MF'
  /** Madagascar */
  | 'MG'
  /** Marshall Islands */
  | 'MH'
  /** Macedonia */
  | 'MK'
  /** Mali */
  | 'ML'
  /** Myanmar */
  | 'MM'
  /** Mongolia */
  | 'MN'
  /** Macau */
  | 'MO'
  /** Northern Mariana Islands */
  | 'MP'
  /** Martinique */
  | 'MQ'
  /** Mauritania */
  | 'MR'
  /** Montserrat */
  | 'MS'
  /** Malta */
  | 'MT'
  /** Mauritius */
  | 'MU'
  /** Maldives */
  | 'MV'
  /** Malawi */
  | 'MW'
  /** Mexico */
  | 'MX'
  /** Malaysia */
  | 'MY'
  /** Mozambique */
  | 'MZ'
  /** Namibia */
  | 'NA'
  /** New Caledonia */
  | 'NC'
  /** Niger */
  | 'NE'
  /** Norfolk Island */
  | 'NF'
  /** Nigeria */
  | 'NG'
  /** Nicaragua */
  | 'NI'
  /** Netherlands */
  | 'NL'
  /** Norway */
  | 'NO'
  /** Nepal */
  | 'NP'
  /** Nauru */
  | 'NR'
  /** Niue */
  | 'NU'
  /** New Zealand */
  | 'NZ'
  /** Oman */
  | 'OM'
  /** Panama */
  | 'PA'
  /** Peru */
  | 'PE'
  /** French Polynesia */
  | 'PF'
  /** Papua New Guinea */
  | 'PG'
  /** Philippines */
  | 'PH'
  /** Pakistan */
  | 'PK'
  /** Poland */
  | 'PL'
  /** Saint Pierre and Miquelon */
  | 'PM'
  /** Pitcairn */
  | 'PN'
  /** Puerto Rico */
  | 'PR'
  /** Palestine */
  | 'PS'
  /** Portugal */
  | 'PT'
  /** Palau */
  | 'PW'
  /** Paraguay */
  | 'PY'
  /** Qatar */
  | 'QA'
  /** Reunion */
  | 'RE'
  /** Romania */
  | 'RO'
  /** Serbia */
  | 'RS'
  /** Russian Federation */
  | 'RU'
  /** Rwanda */
  | 'RW'
  /** Saudi Arabia */
  | 'SA'
  /** Solomon Islands */
  | 'SB'
  /** Seychelles */
  | 'SC'
  /** Sudan */
  | 'SD'
  /** Sweden */
  | 'SE'
  /** Singapore */
  | 'SG'
  /** Saint Helena */
  | 'SH'
  /** Slovenia */
  | 'SI'
  /** Svalbard and Jan Mayen Islands */
  | 'SJ'
  /** Slovakia */
  | 'SK'
  /** Sierra Leone */
  | 'SL'
  /** San Marino */
  | 'SM'
  /** Senegal */
  | 'SN'
  /** Somalia */
  | 'SO'
  /** Suriname */
  | 'SR'
  /** South Sudan */
  | 'SS'
  /** Sao Tome and Principe */
  | 'ST'
  /** El Salvador */
  | 'SV'
  /** Sint Maarten (Dutch part) */
  | 'SX'
  /** Swaziland */
  | 'SZ'
  /** Turks and Caicos Islands */
  | 'TC'
  /** Chad */
  | 'TD'
  /** French Southern Lands */
  | 'TF'
  /** Togo */
  | 'TG'
  /** Thailand */
  | 'TH'
  /** Tajikistan */
  | 'TJ'
  /** Tokelau */
  | 'TK'
  /** Timor-Leste */
  | 'TL'
  /** Turkmenistan */
  | 'TM'
  /** Tunisia */
  | 'TN'
  /** Tonga */
  | 'TO'
  /** Türkiye */
  | 'TR'
  /** Trinidad and Tobago */
  | 'TT'
  /** Tuvalu */
  | 'TV'
  /** Taiwan */
  | 'TW'
  /** Tanzania */
  | 'TZ'
  /** Ukraine */
  | 'UA'
  /** Uganda */
  | 'UG'
  /** United States Minor Outlying Islands */
  | 'UM'
  /** United States of America */
  | 'US'
  /** Uruguay */
  | 'UY'
  /** Uzbekistan */
  | 'UZ'
  /** Vatican City */
  | 'VA'
  /** Saint Vincent and the Grenadines */
  | 'VC'
  /** Venezuela */
  | 'VE'
  /** Virgin Islands, British */
  | 'VG'
  /** Virgin Islands, U.S. */
  | 'VI'
  /** Vietnam */
  | 'VN'
  /** Vanuatu */
  | 'VU'
  /** Wallis and Futuna Islands */
  | 'WF'
  /** Samoa */
  | 'WS'
  /** Yemen */
  | 'YE'
  /** Mayotte */
  | 'YT'
  /** South Africa */
  | 'ZA'
  /** Zambia */
  | 'ZM'
  /** Zimbabwe */
  | 'ZW';

/** A goal associated with a GitHub Sponsors listing, representing a target the sponsored maintainer would like to attain. */
export type SponsorsGoal = {
  /** A description of the goal from the maintainer. */
  description?: Maybe<Scalars['String']['output']>;
  /** What the objective of this goal is. */
  kind: SponsorsGoalKind;
  /** The percentage representing how complete this goal is, between 0-100. */
  percentComplete: Scalars['Int']['output'];
  /**
   * What the goal amount is. Represents an amount in USD for monthly sponsorship
   * amount goals. Represents a count of unique sponsors for total sponsors count goals.
   */
  targetValue: Scalars['Int']['output'];
  /** A brief summary of the kind and target value of this goal. */
  title: Scalars['String']['output'];
};

/** The different kinds of goals a GitHub Sponsors member can have. */
export type SponsorsGoalKind =
  /** The goal is about getting a certain amount in USD from sponsorships each month. */
  | 'MONTHLY_SPONSORSHIP_AMOUNT'
  /** The goal is about reaching a certain number of sponsors. */
  | 'TOTAL_SPONSORS_COUNT';

/** A GitHub Sponsors listing. */
export type SponsorsListing = Node & {
  /** The current goal the maintainer is trying to reach with GitHub Sponsors, if any. */
  activeGoal?: Maybe<SponsorsGoal>;
  /**
   * The Stripe Connect account currently in use for payouts for this Sponsors
   * listing, if any. Will only return a value when queried by the maintainer
   * themselves, or by an admin of the sponsorable organization.
   */
  activeStripeConnectAccount?: Maybe<StripeConnectAccount>;
  /**
   * The name of the country or region with the maintainer's bank account or fiscal
   * host. Will only return a value when queried by the maintainer themselves, or
   * by an admin of the sponsorable organization.
   */
  billingCountryOrRegion?: Maybe<Scalars['String']['output']>;
  /**
   * The email address used by GitHub to contact the sponsorable about their GitHub
   * Sponsors profile. Will only return a value when queried by the maintainer
   * themselves, or by an admin of the sponsorable organization.
   */
  contactEmailAddress?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The HTTP path for the Sponsors dashboard for this Sponsors listing. */
  dashboardResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for the Sponsors dashboard for this Sponsors listing. */
  dashboardUrl: Scalars['URI']['output'];
  /** The records featured on the GitHub Sponsors profile. */
  featuredItems: Array<SponsorsListingFeaturedItem>;
  /**
   * The fiscal host used for payments, if any. Will only return a value when
   * queried by the maintainer themselves, or by an admin of the sponsorable organization.
   */
  fiscalHost?: Maybe<Organization>;
  /** The full description of the listing. */
  fullDescription: Scalars['String']['output'];
  /** The full description of the listing rendered to HTML. */
  fullDescriptionHTML: Scalars['HTML']['output'];
  /** The Node ID of the SponsorsListing object */
  id: Scalars['ID']['output'];
  /** Whether this listing is publicly visible. */
  isPublic: Scalars['Boolean']['output'];
  /** The listing's full name. */
  name: Scalars['String']['output'];
  /** A future date on which this listing is eligible to receive a payout. */
  nextPayoutDate?: Maybe<Scalars['Date']['output']>;
  /**
   * The name of the country or region where the maintainer resides. Will only
   * return a value when queried by the maintainer themselves, or by an admin of
   * the sponsorable organization.
   */
  residenceCountryOrRegion?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this Sponsors listing. */
  resourcePath: Scalars['URI']['output'];
  /** The short description of the listing. */
  shortDescription: Scalars['String']['output'];
  /** The short name of the listing. */
  slug: Scalars['String']['output'];
  /** The entity this listing represents who can be sponsored on GitHub Sponsors. */
  sponsorable: Sponsorable;
  /** The tiers for this GitHub Sponsors profile. */
  tiers?: Maybe<SponsorsTierConnection>;
  /** The HTTP URL for this Sponsors listing. */
  url: Scalars['URI']['output'];
};


/** A GitHub Sponsors listing. */
export type SponsorsListingfeaturedItemsArgs = {
  featureableTypes?: InputMaybe<Array<SponsorsListingFeaturedItemFeatureableType>>;
};


/** A GitHub Sponsors listing. */
export type SponsorsListingtiersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnpublished?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorsTierOrder>;
};

/** A record that can be featured on a GitHub Sponsors profile. */
export type SponsorsListingFeatureableItem = Repository | User;

/** A record that is promoted on a GitHub Sponsors profile. */
export type SponsorsListingFeaturedItem = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /**
   * Will either be a description from the sponsorable maintainer about why they
   * featured this item, or the item's description itself, such as a user's bio
   * from their GitHub profile page.
   */
  description?: Maybe<Scalars['String']['output']>;
  /** The record that is featured on the GitHub Sponsors profile. */
  featureable: SponsorsListingFeatureableItem;
  /** The Node ID of the SponsorsListingFeaturedItem object */
  id: Scalars['ID']['output'];
  /**
   * The position of this featured item on the GitHub Sponsors profile with a lower
   * position indicating higher precedence. Starts at 1.
   */
  position: Scalars['Int']['output'];
  /** The GitHub Sponsors profile that features this record. */
  sponsorsListing: SponsorsListing;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The different kinds of records that can be featured on a GitHub Sponsors profile page. */
export type SponsorsListingFeaturedItemFeatureableType =
  /** A repository owned by the user or organization with the GitHub Sponsors profile. */
  | 'REPOSITORY'
  /** A user who belongs to the organization with the GitHub Sponsors profile. */
  | 'USER';

/** A GitHub Sponsors tier associated with a GitHub Sponsors listing. */
export type SponsorsTier = Node & {
  /** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
  adminInfo?: Maybe<SponsorsTierAdminInfo>;
  /**
   * Get a different tier for this tier's maintainer that is at the same frequency
   * as this tier but with an equal or lesser cost. Returns the published tier with
   * the monthly price closest to this tier's without going over.
   */
  closestLesserValueTier?: Maybe<SponsorsTier>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The description of the tier. */
  description: Scalars['String']['output'];
  /** The tier description rendered to HTML */
  descriptionHTML: Scalars['HTML']['output'];
  /** The Node ID of the SponsorsTier object */
  id: Scalars['ID']['output'];
  /**
   * Whether this tier was chosen at checkout time by the sponsor rather than
   * defined ahead of time by the maintainer who manages the Sponsors listing.
   */
  isCustomAmount: Scalars['Boolean']['output'];
  /** Whether this tier is only for use with one-time sponsorships. */
  isOneTime: Scalars['Boolean']['output'];
  /** How much this tier costs per month in cents. */
  monthlyPriceInCents: Scalars['Int']['output'];
  /** How much this tier costs per month in USD. */
  monthlyPriceInDollars: Scalars['Int']['output'];
  /** The name of the tier. */
  name: Scalars['String']['output'];
  /** The sponsors listing that this tier belongs to. */
  sponsorsListing: SponsorsListing;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type SponsorsTierAdminInfo = {
  /**
   * Indicates whether this tier is still a work in progress by the sponsorable and
   * not yet published to the associated GitHub Sponsors profile. Draft tiers
   * cannot be used for new sponsorships and will not be in use on existing
   * sponsorships. Draft tiers cannot be seen by anyone but the admins of the
   * GitHub Sponsors profile.
   */
  isDraft: Scalars['Boolean']['output'];
  /**
   * Indicates whether this tier is published to the associated GitHub Sponsors
   * profile. Published tiers are visible to anyone who can see the GitHub Sponsors
   * profile, and are available for use in sponsorships if the GitHub Sponsors
   * profile is publicly visible.
   */
  isPublished: Scalars['Boolean']['output'];
  /**
   * Indicates whether this tier has been retired from the associated GitHub
   * Sponsors profile. Retired tiers are no longer shown on the GitHub Sponsors
   * profile and cannot be chosen for new sponsorships. Existing sponsorships may
   * still use retired tiers if the sponsor selected the tier before it was retired.
   */
  isRetired: Scalars['Boolean']['output'];
  /** The sponsorships using this tier. */
  sponsorships: SponsorshipConnection;
};


/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type SponsorsTierAdminInfosponsorshipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};

/** The connection type for SponsorsTier. */
export type SponsorsTierConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SponsorsTierEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SponsorsTier>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SponsorsTierEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SponsorsTier>;
};

/** Ordering options for Sponsors tiers connections. */
export type SponsorsTierOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order tiers by. */
  field: SponsorsTierOrderField;
};

/** Properties by which Sponsors tiers connections can be ordered. */
export type SponsorsTierOrderField =
  /** Order tiers by creation time. */
  | 'CREATED_AT'
  /** Order tiers by their monthly price in cents */
  | 'MONTHLY_PRICE_IN_CENTS';

/** A sponsorship relationship between a sponsor and a maintainer */
export type Sponsorship = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the Sponsorship object */
  id: Scalars['ID']['output'];
  /**
   * Whether the sponsorship is active. False implies the sponsor is a past sponsor
   * of the maintainer, while true implies they are a current sponsor.
   */
  isActive: Scalars['Boolean']['output'];
  /** Whether this sponsorship represents a one-time payment versus a recurring sponsorship. */
  isOneTimePayment: Scalars['Boolean']['output'];
  /**
   * Whether the sponsor has chosen to receive sponsorship update emails sent from
   * the sponsorable. Only returns a non-null value when the viewer has permission to know this.
   */
  isSponsorOptedIntoEmail?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The entity that is being sponsored
   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.
   */
  maintainer: User;
  /** The platform that was most recently used to pay for the sponsorship. */
  paymentSource?: Maybe<SponsorshipPaymentSource>;
  /** The privacy level for this sponsorship. */
  privacyLevel: SponsorshipPrivacy;
  /**
   * The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.
   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.
   */
  sponsor?: Maybe<User>;
  /** The user or organization that is sponsoring, if you have permission to view them. */
  sponsorEntity?: Maybe<Sponsor>;
  /** The entity that is being sponsored */
  sponsorable: Sponsorable;
  /** The associated sponsorship tier */
  tier?: Maybe<SponsorsTier>;
  /** Identifies the date and time when the current tier was chosen for this sponsorship. */
  tierSelectedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** The connection type for Sponsorship. */
export type SponsorshipConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SponsorshipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Sponsorship>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /**
   * The total amount in cents of all recurring sponsorships in the connection
   * whose amount you can view. Does not include one-time sponsorships.
   */
  totalRecurringMonthlyPriceInCents: Scalars['Int']['output'];
  /**
   * The total amount in USD of all recurring sponsorships in the connection whose
   * amount you can view. Does not include one-time sponsorships.
   */
  totalRecurringMonthlyPriceInDollars: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SponsorshipEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Sponsorship>;
};

/** An update sent to sponsors of a user or organization on GitHub Sponsors. */
export type SponsorshipNewsletter = Node & {
  /** The author of the newsletter. */
  author?: Maybe<User>;
  /** The contents of the newsletter, the message the sponsorable wanted to give. */
  body: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the SponsorshipNewsletter object */
  id: Scalars['ID']['output'];
  /** Indicates if the newsletter has been made available to sponsors. */
  isPublished: Scalars['Boolean']['output'];
  /** The user or organization this newsletter is from. */
  sponsorable: Sponsorable;
  /** The subject of the newsletter, what it's about. */
  subject: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for SponsorshipNewsletter. */
export type SponsorshipNewsletterConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SponsorshipNewsletterEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SponsorshipNewsletter>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SponsorshipNewsletterEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SponsorshipNewsletter>;
};

/** Ordering options for sponsorship newsletter connections. */
export type SponsorshipNewsletterOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsorship newsletters by. */
  field: SponsorshipNewsletterOrderField;
};

/** Properties by which sponsorship update connections can be ordered. */
export type SponsorshipNewsletterOrderField =
  /** Order sponsorship newsletters by when they were created. */
  | 'CREATED_AT';

/** Ordering options for sponsorship connections. */
export type SponsorshipOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsorship by. */
  field: SponsorshipOrderField;
};

/** Properties by which sponsorship connections can be ordered. */
export type SponsorshipOrderField =
  /** Order sponsorship by creation time. */
  | 'CREATED_AT';

/** How payment was made for funding a GitHub Sponsors sponsorship. */
export type SponsorshipPaymentSource =
  /** Payment was made through GitHub. */
  | 'GITHUB'
  /** Payment was made through Patreon. */
  | 'PATREON';

/** The privacy of a sponsorship */
export type SponsorshipPrivacy =
  /** Private */
  | 'PRIVATE'
  /** Public */
  | 'PUBLIC';

/** The possible default commit messages for squash merges. */
export type SquashMergeCommitMessage =
  /** Default to a blank commit message. */
  | 'BLANK'
  /** Default to the branch's commit messages. */
  | 'COMMIT_MESSAGES'
  /** Default to the pull request's body. */
  | 'PR_BODY';

/** The possible default commit titles for squash merges. */
export type SquashMergeCommitTitle =
  /** Default to the commit's title (if only one commit) or the pull request's title (when more than one commit). */
  | 'COMMIT_OR_PR_TITLE'
  /** Default to the pull request's title. */
  | 'PR_TITLE';

/** Represents an SSH signature on a Commit or Tag. */
export type SshSignature = GitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean']['output'];
  /** Hex-encoded fingerprint of the key that signed this object. */
  keyFingerprint?: Maybe<Scalars['String']['output']>;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** Ways in which star connections can be ordered. */
export type StarOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field in which to order nodes by. */
  field: StarOrderField;
};

/** Properties by which star connections can be ordered. */
export type StarOrderField =
  /** Allows ordering a list of stars by when they were created. */
  | 'STARRED_AT';

/** The connection type for User. */
export type StargazerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<StargazerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a user that's starred a repository. */
export type StargazerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  node: User;
  /** Identifies when the item was starred. */
  starredAt: Scalars['DateTime']['output'];
};

/** Things that can be starred. */
export type Starrable = {
  /** The Node ID of the Starrable object */
  id: Scalars['ID']['output'];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int']['output'];
  /** A list of users who have starred this starrable. */
  stargazers: StargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean']['output'];
};


/** Things that can be starred. */
export type StarrablestargazersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<StarOrder>;
};

/** The connection type for Repository. */
export type StarredRepositoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<StarredRepositoryEdge>>>;
  /** Is the list of stars for this user truncated? This is true for users that have many stars. */
  isOverLimit: Scalars['Boolean']['output'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a starred repository. */
export type StarredRepositoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  node: Repository;
  /** Identifies when the item was starred. */
  starredAt: Scalars['DateTime']['output'];
};

/** Autogenerated input type of StartOrganizationMigration */
export type StartOrganizationMigrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The migration source access token. */
  sourceAccessToken: Scalars['String']['input'];
  /** The URL of the organization to migrate. */
  sourceOrgUrl: Scalars['URI']['input'];
  /** The ID of the enterprise the target organization belongs to. */
  targetEnterpriseId: Scalars['ID']['input'];
  /** The name of the target organization. */
  targetOrgName: Scalars['String']['input'];
};

/** Autogenerated return type of StartOrganizationMigration */
export type StartOrganizationMigrationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new organization migration. */
  orgMigration?: Maybe<OrganizationMigration>;
};

/** Autogenerated input type of StartRepositoryMigration */
export type StartRepositoryMigrationInput = {
  /** The migration source access token. */
  accessToken?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether to continue the migration on error. Defaults to `true`. */
  continueOnError?: InputMaybe<Scalars['Boolean']['input']>;
  /** The signed URL to access the user-uploaded git archive. */
  gitArchiveUrl?: InputMaybe<Scalars['String']['input']>;
  /** The GitHub personal access token of the user importing to the target repository. */
  githubPat?: InputMaybe<Scalars['String']['input']>;
  /** Whether to lock the source repository. */
  lockSource?: InputMaybe<Scalars['Boolean']['input']>;
  /** The signed URL to access the user-uploaded metadata archive. */
  metadataArchiveUrl?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that will own the imported repository. */
  ownerId: Scalars['ID']['input'];
  /** The name of the imported repository. */
  repositoryName: Scalars['String']['input'];
  /** Whether to skip migrating releases for the repository. */
  skipReleases?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the migration source. */
  sourceId: Scalars['ID']['input'];
  /** The URL of the source repository. */
  sourceRepositoryUrl?: InputMaybe<Scalars['URI']['input']>;
  /** The visibility of the imported repository. */
  targetRepoVisibility?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of StartRepositoryMigration */
export type StartRepositoryMigrationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new repository migration. */
  repositoryMigration?: Maybe<RepositoryMigration>;
};

/** Represents a commit status. */
export type Status = Node & {
  /** A list of status contexts and check runs for this commit. */
  combinedContexts: StatusCheckRollupContextConnection;
  /** The commit this status is attached to. */
  commit?: Maybe<Commit>;
  /** Looks up an individual status context by context name. */
  context?: Maybe<StatusContext>;
  /** The individual status contexts for this commit. */
  contexts: Array<StatusContext>;
  /** The Node ID of the Status object */
  id: Scalars['ID']['output'];
  /** The combined commit status. */
  state: StatusState;
};


/** Represents a commit status. */
export type StatuscombinedContextsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a commit status. */
export type StatuscontextArgs = {
  name: Scalars['String']['input'];
};

/** Required status check */
export type StatusCheckConfiguration = {
  /** The status check context name that must be present on the commit. */
  context: Scalars['String']['output'];
  /** The optional integration ID that this status check must originate from. */
  integrationId?: Maybe<Scalars['Int']['output']>;
};

/** Required status check */
export type StatusCheckConfigurationInput = {
  /** The status check context name that must be present on the commit. */
  context: Scalars['String']['input'];
  /** The optional integration ID that this status check must originate from. */
  integrationId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents the rollup for both the check runs and status for a commit. */
export type StatusCheckRollup = Node & {
  /** The commit the status and check runs are attached to. */
  commit?: Maybe<Commit>;
  /** A list of status contexts and check runs for this commit. */
  contexts: StatusCheckRollupContextConnection;
  /** The Node ID of the StatusCheckRollup object */
  id: Scalars['ID']['output'];
  /** The combined status for the commit. */
  state: StatusState;
};


/** Represents the rollup for both the check runs and status for a commit. */
export type StatusCheckRollupcontextsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Types that can be inside a StatusCheckRollup context. */
export type StatusCheckRollupContext = CheckRun | StatusContext;

/** The connection type for StatusCheckRollupContext. */
export type StatusCheckRollupContextConnection = {
  /** The number of check runs in this rollup. */
  checkRunCount: Scalars['Int']['output'];
  /** Counts of check runs by state. */
  checkRunCountsByState?: Maybe<Array<CheckRunStateCount>>;
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<StatusCheckRollupContextEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<StatusCheckRollupContext>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The number of status contexts in this rollup. */
  statusContextCount: Scalars['Int']['output'];
  /** Counts of status contexts by state. */
  statusContextCountsByState?: Maybe<Array<StatusContextStateCount>>;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type StatusCheckRollupContextEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<StatusCheckRollupContext>;
};

/** Represents an individual commit status context */
export type StatusContext = Node & RequirableByPullRequest & {
  /** The avatar of the OAuth application or the user that created the status */
  avatarUrl?: Maybe<Scalars['URI']['output']>;
  /** This commit this status context is attached to. */
  commit?: Maybe<Commit>;
  /** The name of this status context. */
  context: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created this status context. */
  creator?: Maybe<Actor>;
  /** The description for this status context. */
  description?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the StatusContext object */
  id: Scalars['ID']['output'];
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars['Boolean']['output'];
  /** The state of this status context. */
  state: StatusState;
  /** The URL for this status context. */
  targetUrl?: Maybe<Scalars['URI']['output']>;
};


/** Represents an individual commit status context */
export type StatusContextavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an individual commit status context */
export type StatusContextisRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents a count of the state of a status context. */
export type StatusContextStateCount = {
  /** The number of statuses with this state. */
  count: Scalars['Int']['output'];
  /** The state of a status context. */
  state: StatusState;
};

/** The possible commit status states. */
export type StatusState =
  /** Status is errored. */
  | 'ERROR'
  /** Status is expected. */
  | 'EXPECTED'
  /** Status is failing. */
  | 'FAILURE'
  /** Status is pending. */
  | 'PENDING'
  /** Status is successful. */
  | 'SUCCESS';

/** A Stripe Connect account for receiving sponsorship funds from GitHub Sponsors. */
export type StripeConnectAccount = {
  /** The account number used to identify this Stripe Connect account. */
  accountId: Scalars['String']['output'];
  /**
   * The name of the country or region of an external account, such as a bank
   * account, tied to the Stripe Connect account. Will only return a value when
   * queried by the maintainer of the associated GitHub Sponsors profile
   * themselves, or by an admin of the sponsorable organization.
   */
  billingCountryOrRegion?: Maybe<Scalars['String']['output']>;
  /**
   * The name of the country or region of the Stripe Connect account. Will only
   * return a value when queried by the maintainer of the associated GitHub
   * Sponsors profile themselves, or by an admin of the sponsorable organization.
   */
  countryOrRegion?: Maybe<Scalars['String']['output']>;
  /** Whether this Stripe Connect account is currently in use for the associated GitHub Sponsors profile. */
  isActive: Scalars['Boolean']['output'];
  /** The GitHub Sponsors profile associated with this Stripe Connect account. */
  sponsorsListing: SponsorsListing;
  /** The URL to access this Stripe Connect account on Stripe's website. */
  stripeDashboardUrl: Scalars['URI']['output'];
};

/** Autogenerated input type of SubmitPullRequestReview */
export type SubmitPullRequestReviewInput = {
  /** The text field to set on the Pull Request Review. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The event to send to the Pull Request Review. */
  event: PullRequestReviewEvent;
  /** The Pull Request ID to submit any pending reviews. */
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  /** The Pull Request Review ID to submit. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of SubmitPullRequestReview */
export type SubmitPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The submitted pull request review. */
  pullRequestReview?: Maybe<PullRequestReview>;
};

/** A pointer to a repository at a specific revision embedded inside another repository. */
export type Submodule = {
  /** The branch of the upstream submodule for tracking updates */
  branch?: Maybe<Scalars['String']['output']>;
  /** The git URL of the submodule repository */
  gitUrl: Scalars['URI']['output'];
  /** The name of the submodule in .gitmodules */
  name: Scalars['String']['output'];
  /** The name of the submodule in .gitmodules (Base64-encoded) */
  nameRaw: Scalars['Base64String']['output'];
  /** The path in the superproject that this submodule is located in */
  path: Scalars['String']['output'];
  /** The path in the superproject that this submodule is located in (Base64-encoded) */
  pathRaw: Scalars['Base64String']['output'];
  /** The commit revision of the subproject repository being tracked by the submodule */
  subprojectCommitOid?: Maybe<Scalars['GitObjectID']['output']>;
};

/** The connection type for Submodule. */
export type SubmoduleConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SubmoduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Submodule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SubmoduleEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Submodule>;
};

/** Entities that can be subscribed to for web and email notifications. */
export type Subscribable = {
  /** The Node ID of the Subscribable object */
  id: Scalars['ID']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<SubscriptionState>;
};

/** Entities that can be subscribed to for web and email notifications. */
export type SubscribableThread = {
  /** The Node ID of the SubscribableThread object */
  id: Scalars['ID']['output'];
  /** Identifies the viewer's thread subscription form action. */
  viewerThreadSubscriptionFormAction?: Maybe<ThreadSubscriptionFormAction>;
  /** Identifies the viewer's thread subscription status. */
  viewerThreadSubscriptionStatus?: Maybe<ThreadSubscriptionState>;
};

/** Represents a 'subscribed' event on a given `Subscribable`. */
export type SubscribedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the SubscribedEvent object */
  id: Scalars['ID']['output'];
  /** Object referenced by event. */
  subscribable: Subscribable;
};

/** The possible states of a subscription. */
export type SubscriptionState =
  /** The User is never notified. */
  | 'IGNORED'
  /** The User is notified of all conversations. */
  | 'SUBSCRIBED'
  /** The User is only notified when participating or @mentioned. */
  | 'UNSUBSCRIBED';

/** A suggestion to review a pull request based on a user's commit history and review comments. */
export type SuggestedReviewer = {
  /** Is this suggestion based on past commits? */
  isAuthor: Scalars['Boolean']['output'];
  /** Is this suggestion based on past review comments? */
  isCommenter: Scalars['Boolean']['output'];
  /** Identifies the user suggested to review the pull request. */
  reviewer: User;
};

/** Represents a Git tag. */
export type Tag = GitObject & Node & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String']['output'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI']['output'];
  /** The Node ID of the Tag object */
  id: Scalars['ID']['output'];
  /** The Git tag message. */
  message?: Maybe<Scalars['String']['output']>;
  /** The Git tag name. */
  name: Scalars['String']['output'];
  /** The Git object ID */
  oid: Scalars['GitObjectID']['output'];
  /** The Repository the Git object belongs to */
  repository: Repository;
  /** Details about the tag author. */
  tagger?: Maybe<GitActor>;
  /** The Git object the tag points to. */
  target: GitObject;
};

/** Parameters to be used for the tag_name_pattern rule */
export type TagNamePatternParameters = {
  /** How this rule will appear to users. */
  name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  operator: Scalars['String']['output'];
  /** The pattern to match with. */
  pattern: Scalars['String']['output'];
};

/** Parameters to be used for the tag_name_pattern rule */
export type TagNamePatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/** A team of users in an organization. */
export type Team = MemberStatusable & Node & Subscribable & {
  /** A list of teams that are ancestors of this team. */
  ancestors: TeamConnection;
  /** A URL pointing to the team's avatar. */
  avatarUrl?: Maybe<Scalars['URI']['output']>;
  /** List of child teams belonging to this team */
  childTeams: TeamConnection;
  /** The slug corresponding to the organization and team. */
  combinedSlug: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The description of the team. */
  description?: Maybe<Scalars['String']['output']>;
  /** Find a team discussion by its number. */
  discussion?: Maybe<TeamDiscussion>;
  /** A list of team discussions. */
  discussions: TeamDiscussionConnection;
  /** The HTTP path for team discussions */
  discussionsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for team discussions */
  discussionsUrl: Scalars['URI']['output'];
  /** The HTTP path for editing this team */
  editTeamResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for editing this team */
  editTeamUrl: Scalars['URI']['output'];
  /** The Node ID of the Team object */
  id: Scalars['ID']['output'];
  /** A list of pending invitations for users to this team */
  invitations?: Maybe<OrganizationInvitationConnection>;
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: UserStatusConnection;
  /** A list of users who are members of this team. */
  members: TeamMemberConnection;
  /** The HTTP path for the team' members */
  membersResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for the team' members */
  membersUrl: Scalars['URI']['output'];
  /** The name of the team. */
  name: Scalars['String']['output'];
  /** The HTTP path creating a new team */
  newTeamResourcePath: Scalars['URI']['output'];
  /** The HTTP URL creating a new team */
  newTeamUrl: Scalars['URI']['output'];
  /** The notification setting that the team has set. */
  notificationSetting: TeamNotificationSetting;
  /** The organization that owns this team. */
  organization: Organization;
  /** The parent team of the team. */
  parentTeam?: Maybe<Team>;
  /** The level of privacy the team has. */
  privacy: TeamPrivacy;
  /** Finds and returns the project according to the provided project number. */
  projectV2?: Maybe<ProjectV2>;
  /** List of projects this team has collaborator access to. */
  projectsV2: ProjectV2Connection;
  /** A list of repositories this team has access to. */
  repositories: TeamRepositoryConnection;
  /** The HTTP path for this team's repositories */
  repositoriesResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this team's repositories */
  repositoriesUrl: Scalars['URI']['output'];
  /** The HTTP path for this team */
  resourcePath: Scalars['URI']['output'];
  /** What algorithm is used for review assignment for this team */
  reviewRequestDelegationAlgorithm?: Maybe<TeamReviewAssignmentAlgorithm>;
  /** True if review assignment is enabled for this team */
  reviewRequestDelegationEnabled: Scalars['Boolean']['output'];
  /** How many team members are required for review assignment for this team */
  reviewRequestDelegationMemberCount?: Maybe<Scalars['Int']['output']>;
  /** When assigning team members via delegation, whether the entire team should be notified as well. */
  reviewRequestDelegationNotifyTeam: Scalars['Boolean']['output'];
  /** The slug corresponding to the team. */
  slug: Scalars['String']['output'];
  /** The HTTP path for this team's teams */
  teamsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this team's teams */
  teamsUrl: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this team */
  url: Scalars['URI']['output'];
  /** Team is adminable by the viewer. */
  viewerCanAdminister: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<SubscriptionState>;
};


/** A team of users in an organization. */
export type TeamancestorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A team of users in an organization. */
export type TeamavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** A team of users in an organization. */
export type TeamchildTeamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  immediateOnly?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TeamOrder>;
  userLogins?: InputMaybe<Array<Scalars['String']['input']>>;
};


/** A team of users in an organization. */
export type TeamdiscussionArgs = {
  number: Scalars['Int']['input'];
};


/** A team of users in an organization. */
export type TeamdiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  isPinned?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TeamDiscussionOrder>;
};


/** A team of users in an organization. */
export type TeaminvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A team of users in an organization. */
export type TeammemberStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserStatusOrder>;
};


/** A team of users in an organization. */
export type TeammembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  membership?: InputMaybe<TeamMembershipType>;
  orderBy?: InputMaybe<TeamMemberOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<TeamMemberRole>;
};


/** A team of users in an organization. */
export type TeamprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** A team of users in an organization. */
export type TeamprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<ProjectV2Filters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A team of users in an organization. */
export type TeamrepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TeamRepositoryOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
};

/** Audit log entry for a team.add_member event. */
export type TeamAddMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the TeamAddMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The team associated with the action */
  team?: Maybe<Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a team.add_repository event. */
export type TeamAddRepositoryAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the TeamAddRepositoryAuditEntry object */
  id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The team associated with the action */
  team?: Maybe<Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Metadata for an audit entry with action team.* */
export type TeamAuditEntryData = {
  /** The team associated with the action */
  team?: Maybe<Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a team.change_parent_team event. */
export type TeamChangeParentTeamAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the TeamChangeParentTeamAuditEntry object */
  id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The new parent team. */
  parentTeam?: Maybe<Team>;
  /** The name of the new parent team */
  parentTeamName?: Maybe<Scalars['String']['output']>;
  /** The name of the former parent team */
  parentTeamNameWas?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the parent team */
  parentTeamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the parent team */
  parentTeamUrl?: Maybe<Scalars['URI']['output']>;
  /** The former parent team. */
  parentTeamWas?: Maybe<Team>;
  /** The HTTP path for the previous parent team */
  parentTeamWasResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the previous parent team */
  parentTeamWasUrl?: Maybe<Scalars['URI']['output']>;
  /** The team associated with the action */
  team?: Maybe<Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The connection type for Team. */
export type TeamConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TeamEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Team>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A team discussion. */
export type TeamDiscussion = Comment & Deletable & Node & Reactable & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Actor>;
  /**
   * Author's association with the discussion's team.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  authorAssociation: CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /**
   * Identifies the discussion body hash.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  bodyVersion: Scalars['String']['output'];
  /**
   * A list of comments on this discussion.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  comments: TeamDiscussionCommentConnection;
  /**
   * The HTTP path for discussion comments
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  commentsResourcePath: Scalars['URI']['output'];
  /**
   * The HTTP URL for discussion comments
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  commentsUrl: Scalars['URI']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Actor>;
  /** The Node ID of the TeamDiscussion object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /**
   * Whether or not the discussion is pinned.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  isPinned: Scalars['Boolean']['output'];
  /**
   * Whether or not the discussion is only visible to team members and organization owners.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  isPrivate: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Identifies the discussion within its team.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  number: Scalars['Int']['output'];
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /**
   * The HTTP path for this discussion
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  resourcePath: Scalars['URI']['output'];
  /**
   * The team that defines the context of this discussion.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  team: Team;
  /**
   * The title of the discussion
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /**
   * The HTTP URL for this discussion
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /**
   * Whether or not the current viewer can pin this discussion.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  viewerCanPin: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<SubscriptionState>;
};


/** A team discussion. */
export type TeamDiscussioncommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fromComment?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TeamDiscussionCommentOrder>;
};


/** A team discussion. */
export type TeamDiscussionreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A team discussion. */
export type TeamDiscussionuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A comment on a team discussion. */
export type TeamDiscussionComment = Comment & Deletable & Node & Reactable & UniformResourceLocatable & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Actor>;
  /**
   * Author's association with the comment's team.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  authorAssociation: CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /**
   * The current version of the body content.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  bodyVersion: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /**
   * The discussion this comment is about.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  discussion: TeamDiscussion;
  /** The actor who edited the comment. */
  editor?: Maybe<Actor>;
  /** The Node ID of the TeamDiscussionComment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Identifies the comment number.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  number: Scalars['Int']['output'];
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /**
   * The HTTP path for this comment
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /**
   * The HTTP URL for this comment
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** A comment on a team discussion. */
export type TeamDiscussionCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A comment on a team discussion. */
export type TeamDiscussionCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for TeamDiscussionComment. */
export type TeamDiscussionCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TeamDiscussionCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TeamDiscussionComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type TeamDiscussionCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<TeamDiscussionComment>;
};

/** Ways in which team discussion comment connections can be ordered. */
export type TeamDiscussionCommentOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field by which to order nodes. */
  field: TeamDiscussionCommentOrderField;
};

/** Properties by which team discussion comment connections can be ordered. */
export type TeamDiscussionCommentOrderField =
  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */
  | 'NUMBER';

/** The connection type for TeamDiscussion. */
export type TeamDiscussionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TeamDiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TeamDiscussion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type TeamDiscussionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<TeamDiscussion>;
};

/** Ways in which team discussion connections can be ordered. */
export type TeamDiscussionOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field by which to order nodes. */
  field: TeamDiscussionOrderField;
};

/** Properties by which team discussion connections can be ordered. */
export type TeamDiscussionOrderField =
  /** Allows chronological ordering of team discussions. */
  | 'CREATED_AT';

/** An edge in a connection. */
export type TeamEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Team>;
};

/** The connection type for User. */
export type TeamMemberConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TeamMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a user who is a member of a team. */
export type TeamMemberEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The HTTP path to the organization's member access page. */
  memberAccessResourcePath: Scalars['URI']['output'];
  /** The HTTP URL to the organization's member access page. */
  memberAccessUrl: Scalars['URI']['output'];
  node: User;
  /** The role the member has on the team. */
  role: TeamMemberRole;
};

/** Ordering options for team member connections */
export type TeamMemberOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order team members by. */
  field: TeamMemberOrderField;
};

/** Properties by which team member connections can be ordered. */
export type TeamMemberOrderField =
  /** Order team members by creation time */
  | 'CREATED_AT'
  /** Order team members by login */
  | 'LOGIN';

/** The possible team member roles; either 'maintainer' or 'member'. */
export type TeamMemberRole =
  /** A team maintainer has permission to add and remove team members. */
  | 'MAINTAINER'
  /** A team member has no administrative permissions on the team. */
  | 'MEMBER';

/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
export type TeamMembershipType =
  /** Includes immediate and child team members for the team. */
  | 'ALL'
  /** Includes only child team members for the team. */
  | 'CHILD_TEAM'
  /** Includes only immediate members of the team. */
  | 'IMMEDIATE';

/** The possible team notification values. */
export type TeamNotificationSetting =
  /** No one will receive notifications. */
  | 'NOTIFICATIONS_DISABLED'
  /** Everyone will receive notifications when the team is @mentioned. */
  | 'NOTIFICATIONS_ENABLED';

/** Ways in which team connections can be ordered. */
export type TeamOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field in which to order nodes by. */
  field: TeamOrderField;
};

/** Properties by which team connections can be ordered. */
export type TeamOrderField =
  /** Allows ordering a list of teams by name. */
  | 'NAME';

/** The possible team privacy values. */
export type TeamPrivacy =
  /** A secret team can only be seen by its members. */
  | 'SECRET'
  /** A visible team can be seen and @mentioned by every member of the organization. */
  | 'VISIBLE';

/** Audit log entry for a team.remove_member event. */
export type TeamRemoveMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the TeamRemoveMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The team associated with the action */
  team?: Maybe<Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a team.remove_repository event. */
export type TeamRemoveRepositoryAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime']['output'];
  /** The Node ID of the TeamRemoveRepositoryAuditEntry object */
  id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The team associated with the action */
  team?: Maybe<Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The connection type for Repository. */
export type TeamRepositoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TeamRepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a team repository. */
export type TeamRepositoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  node: Repository;
  /** The permission level the team has on the repository */
  permission: RepositoryPermission;
};

/** Ordering options for team repository connections */
export type TeamRepositoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: TeamRepositoryOrderField;
};

/** Properties by which team repository connections can be ordered. */
export type TeamRepositoryOrderField =
  /** Order repositories by creation time */
  | 'CREATED_AT'
  /** Order repositories by name */
  | 'NAME'
  /** Order repositories by permission */
  | 'PERMISSION'
  /** Order repositories by push time */
  | 'PUSHED_AT'
  /** Order repositories by number of stargazers */
  | 'STARGAZERS'
  /** Order repositories by update time */
  | 'UPDATED_AT';

/** The possible team review assignment algorithms */
export type TeamReviewAssignmentAlgorithm =
  /** Balance review load across the entire team */
  | 'LOAD_BALANCE'
  /** Alternate reviews between each team member */
  | 'ROUND_ROBIN';

/** The role of a user on a team. */
export type TeamRole =
  /** User has admin rights on the team. */
  | 'ADMIN'
  /** User is a member of the team. */
  | 'MEMBER';

/** A text match within a search result. */
export type TextMatch = {
  /** The specific text fragment within the property matched on. */
  fragment: Scalars['String']['output'];
  /** Highlights within the matched fragment. */
  highlights: Array<TextMatchHighlight>;
  /** The property matched on. */
  property: Scalars['String']['output'];
};

/** Represents a single highlight in a search result match. */
export type TextMatchHighlight = {
  /** The indice in the fragment where the matched text begins. */
  beginIndice: Scalars['Int']['output'];
  /** The indice in the fragment where the matched text ends. */
  endIndice: Scalars['Int']['output'];
  /** The text matched. */
  text: Scalars['String']['output'];
};

/** The possible states of a thread subscription form action */
export type ThreadSubscriptionFormAction =
  /** The User cannot subscribe or unsubscribe to the thread */
  | 'NONE'
  /** The User can subscribe to the thread */
  | 'SUBSCRIBE'
  /** The User can unsubscribe to the thread */
  | 'UNSUBSCRIBE';

/** The possible states of a subscription. */
export type ThreadSubscriptionState =
  /** The subscription status is currently disabled. */
  | 'DISABLED'
  /** The User is never notified because they are ignoring the list */
  | 'IGNORING_LIST'
  /** The User is never notified because they are ignoring the thread */
  | 'IGNORING_THREAD'
  /** The User is not recieving notifications from this thread */
  | 'NONE'
  /** The User is notified becuase they are watching the list */
  | 'SUBSCRIBED_TO_LIST'
  /** The User is notified because they are subscribed to the thread */
  | 'SUBSCRIBED_TO_THREAD'
  /** The User is notified because they chose custom settings for this thread. */
  | 'SUBSCRIBED_TO_THREAD_EVENTS'
  /** The User is notified because they chose custom settings for this thread. */
  | 'SUBSCRIBED_TO_THREAD_TYPE'
  /** The subscription status is currently unavailable. */
  | 'UNAVAILABLE';

/** A topic aggregates entities that are related to a subject. */
export type Topic = Node & Starrable & {
  /** The Node ID of the Topic object */
  id: Scalars['ID']['output'];
  /** The topic's name. */
  name: Scalars['String']['output'];
  /**
   * A list of related topics, including aliases of this topic, sorted with the most relevant
   * first. Returns up to 10 Topics.
   */
  relatedTopics: Array<Topic>;
  /** A list of repositories. */
  repositories: RepositoryConnection;
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int']['output'];
  /** A list of users who have starred this starrable. */
  stargazers: StargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean']['output'];
};


/** A topic aggregates entities that are related to a subject. */
export type TopicrelatedTopicsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** A topic aggregates entities that are related to a subject. */
export type TopicrepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
  sponsorableOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A topic aggregates entities that are related to a subject. */
export type TopicstargazersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<StarOrder>;
};

/** Metadata for an audit entry with a topic. */
export type TopicAuditEntryData = {
  /** The name of the topic added to the repository */
  topic?: Maybe<Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']['output']>;
};

/** Reason that the suggested topic is declined. */
export type TopicSuggestionDeclineReason =
  /** The suggested topic is not relevant to the repository. */
  | 'NOT_RELEVANT'
  /** The viewer does not like the suggested topic. */
  | 'PERSONAL_PREFERENCE'
  /** The suggested topic is too general for the repository. */
  | 'TOO_GENERAL'
  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */
  | 'TOO_SPECIFIC';

/** The possible states of a tracked issue. */
export type TrackedIssueStates =
  /** The tracked issue is closed */
  | 'CLOSED'
  /** The tracked issue is open */
  | 'OPEN';

/** Autogenerated input type of TransferEnterpriseOrganization */
export type TransferEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise where the organization should be transferred. */
  destinationEnterpriseId: Scalars['ID']['input'];
  /** The ID of the organization to transfer. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of TransferEnterpriseOrganization */
export type TransferEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organization for which a transfer was initiated. */
  organization?: Maybe<Organization>;
};

/** Autogenerated input type of TransferIssue */
export type TransferIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether to create labels if they don't exist in the target repository (matched by name) */
  createLabelsIfMissing?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node ID of the issue to be transferred */
  issueId: Scalars['ID']['input'];
  /** The Node ID of the repository the issue should be transferred to */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of TransferIssue */
export type TransferIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was transferred */
  issue?: Maybe<Issue>;
};

/** Represents a 'transferred' event on a given issue or pull request. */
export type TransferredEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The repository this came from */
  fromRepository?: Maybe<Repository>;
  /** The Node ID of the TransferredEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the issue associated with the event. */
  issue: Issue;
};

/** Represents a Git tree. */
export type Tree = GitObject & Node & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String']['output'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI']['output'];
  /** A list of tree entries. */
  entries?: Maybe<Array<TreeEntry>>;
  /** The Node ID of the Tree object */
  id: Scalars['ID']['output'];
  /** The Git object ID */
  oid: Scalars['GitObjectID']['output'];
  /** The Repository the Git object belongs to */
  repository: Repository;
};

/** Represents a Git tree entry. */
export type TreeEntry = {
  /** The extension of the file */
  extension?: Maybe<Scalars['String']['output']>;
  /** Whether or not this tree entry is generated */
  isGenerated: Scalars['Boolean']['output'];
  /** The programming language this file is written in. */
  language?: Maybe<Language>;
  /** Number of lines in the file. */
  lineCount?: Maybe<Scalars['Int']['output']>;
  /** Entry file mode. */
  mode: Scalars['Int']['output'];
  /** Entry file name. */
  name: Scalars['String']['output'];
  /** Entry file name. (Base64-encoded) */
  nameRaw: Scalars['Base64String']['output'];
  /** Entry file object. */
  object?: Maybe<GitObject>;
  /** Entry file Git object ID. */
  oid: Scalars['GitObjectID']['output'];
  /** The full path of the file. */
  path?: Maybe<Scalars['String']['output']>;
  /** The full path of the file. (Base64-encoded) */
  pathRaw?: Maybe<Scalars['Base64String']['output']>;
  /** The Repository the tree entry belongs to */
  repository: Repository;
  /** Entry byte size */
  size: Scalars['Int']['output'];
  /** If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule */
  submodule?: Maybe<Submodule>;
  /** Entry file type. */
  type: Scalars['String']['output'];
};

/** Autogenerated input type of UnarchiveProjectV2Item */
export type UnarchiveProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the ProjectV2Item to unarchive. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project to archive the item from. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnarchiveProjectV2Item */
export type UnarchiveProjectV2ItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item unarchived from the project. */
  item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of UnarchiveRepository */
export type UnarchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to unarchive. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnarchiveRepository */
export type UnarchiveRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository that was unarchived. */
  repository?: Maybe<Repository>;
};

/** Represents an 'unassigned' event on any assignable object. */
export type UnassignedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the assignable associated with the event. */
  assignable: Assignable;
  /** Identifies the user or mannequin that was unassigned. */
  assignee?: Maybe<Assignee>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the UnassignedEvent object */
  id: Scalars['ID']['output'];
  /**
   * Identifies the subject (user) who was unassigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  user?: Maybe<User>;
};

/** Autogenerated input type of UnfollowOrganization */
export type UnfollowOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the organization to unfollow. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnfollowOrganization */
export type UnfollowOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organization that was unfollowed. */
  organization?: Maybe<Organization>;
};

/** Autogenerated input type of UnfollowUser */
export type UnfollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the user to unfollow. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnfollowUser */
export type UnfollowUserPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The user that was unfollowed. */
  user?: Maybe<User>;
};

/** Represents a type that can be retrieved by a URL. */
export type UniformResourceLocatable = {
  /** The HTML path to this resource. */
  resourcePath: Scalars['URI']['output'];
  /** The URL to this resource. */
  url: Scalars['URI']['output'];
};

/** Represents an unknown signature on a Commit or Tag. */
export type UnknownSignature = GitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean']['output'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** Represents an 'unlabeled' event on a given issue or pull request. */
export type UnlabeledEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the UnlabeledEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the label associated with the 'unlabeled' event. */
  label: Label;
  /** Identifies the `Labelable` associated with the event. */
  labelable: Labelable;
};

/** Autogenerated input type of UnlinkProjectV2FromRepository */
export type UnlinkProjectV2FromRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to unlink from the repository. */
  projectId: Scalars['ID']['input'];
  /** The ID of the repository to unlink from the project. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlinkProjectV2FromRepository */
export type UnlinkProjectV2FromRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository the project is no longer linked to. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of UnlinkProjectV2FromTeam */
export type UnlinkProjectV2FromTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to unlink from the team. */
  projectId: Scalars['ID']['input'];
  /** The ID of the team to unlink from the project. */
  teamId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlinkProjectV2FromTeam */
export type UnlinkProjectV2FromTeamPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The team the project is unlinked from */
  team?: Maybe<Team>;
};

/** Autogenerated input type of UnlinkRepositoryFromProject */
export type UnlinkRepositoryFromProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project linked to the Repository. */
  projectId: Scalars['ID']['input'];
  /** The ID of the Repository linked to the Project. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlinkRepositoryFromProject */
export type UnlinkRepositoryFromProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The linked Project. */
  project?: Maybe<Project>;
  /** The linked Repository. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of UnlockLockable */
export type UnlockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the item to be unlocked. */
  lockableId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlockLockable */
export type UnlockLockablePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was unlocked. */
  unlockedRecord?: Maybe<Lockable>;
};

/** Represents an 'unlocked' event on a given issue or pull request. */
export type UnlockedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the UnlockedEvent object */
  id: Scalars['ID']['output'];
  /** Object that was unlocked. */
  lockable: Lockable;
};

/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */
export type UnmarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion comment to unmark as an answer. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UnmarkDiscussionCommentAsAnswer */
export type UnmarkDiscussionCommentAsAnswerPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that includes the comment. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of UnmarkFileAsViewed */
export type UnmarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The path of the file to mark as unviewed */
  path: Scalars['String']['input'];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnmarkFileAsViewed */
export type UnmarkFileAsViewedPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request. */
  pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of UnmarkIssueAsDuplicate */
export type UnmarkIssueAsDuplicateInput = {
  /** ID of the issue or pull request currently considered canonical/authoritative/original. */
  canonicalId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue or pull request currently marked as a duplicate. */
  duplicateId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnmarkIssueAsDuplicate */
export type UnmarkIssueAsDuplicatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue or pull request that was marked as a duplicate. */
  duplicate?: Maybe<IssueOrPullRequest>;
};

/** Autogenerated input type of UnmarkProjectV2AsTemplate */
export type UnmarkProjectV2AsTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to unmark as a template. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnmarkProjectV2AsTemplate */
export type UnmarkProjectV2AsTemplatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The project. */
  projectV2?: Maybe<ProjectV2>;
};

/** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
export type UnmarkedAsDuplicateEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** The authoritative issue or pull request which has been duplicated by another. */
  canonical?: Maybe<IssueOrPullRequest>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The issue or pull request which has been marked as a duplicate of another. */
  duplicate?: Maybe<IssueOrPullRequest>;
  /** The Node ID of the UnmarkedAsDuplicateEvent object */
  id: Scalars['ID']['output'];
  /** Canonical and duplicate belong to different repositories. */
  isCrossRepository: Scalars['Boolean']['output'];
};

/** Autogenerated input type of UnminimizeComment */
export type UnminimizeCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnminimizeComment */
export type UnminimizeCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The comment that was unminimized. */
  unminimizedComment?: Maybe<Minimizable>;
};

/** Autogenerated input type of UnpinIssue */
export type UnpinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the issue to be unpinned */
  issueId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnpinIssue */
export type UnpinIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was unpinned */
  issue?: Maybe<Issue>;
};

/** Represents an 'unpinned' event on a given issue or pull request. */
export type UnpinnedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the UnpinnedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the issue associated with the event. */
  issue: Issue;
};

/** Autogenerated input type of UnresolveReviewThread */
export type UnresolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the thread to unresolve */
  threadId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnresolveReviewThread */
export type UnresolveReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The thread to resolve. */
  thread?: Maybe<PullRequestReviewThread>;
};

/** Autogenerated input type of UnsubscribeFromNotifications */
export type UnsubscribeFromNotificationsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The NotificationThread IDs of the objects to unsubscribe from. */
  ids: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of UnsubscribeFromNotifications */
export type UnsubscribeFromNotificationsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Represents an 'unsubscribed' event on a given `Subscribable`. */
export type UnsubscribedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the UnsubscribedEvent object */
  id: Scalars['ID']['output'];
  /** Object referenced by event. */
  subscribable: Subscribable;
};

/** Entities that can be updated. */
export type Updatable = {
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
};

/** Comments that can be updated. */
export type UpdatableComment = {
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;
};

/** Autogenerated input type of UpdateBranchProtectionRule */
export type UpdateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is branch creation a protected operation. */
  blocksCreations?: InputMaybe<Scalars['Boolean']['input']>;
  /** The global relay id of the branch protection rule to be updated. */
  branchProtectionRuleId: Scalars['ID']['input'];
  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */
  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */
  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Can admins override branch protection. */
  isAdminEnforced?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch?: InputMaybe<Scalars['Boolean']['input']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern?: InputMaybe<Scalars['String']['input']>;
  /** A list of User, Team, or App IDs allowed to push to matching branches. */
  pushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval?: InputMaybe<Scalars['Boolean']['input']>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']['input']>;
  /** The list of required deployment environments */
  requiredDeploymentEnvironments?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The list of required status checks */
  requiredStatusChecks?: InputMaybe<Array<RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are successful deployments required before merging. */
  requiresDeployments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of UpdateBranchProtectionRule */
export type UpdateBranchProtectionRulePayload = {
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateCheckRun */
export type UpdateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: InputMaybe<Array<CheckRunAction>>;
  /** The node of the check. */
  checkRunId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The time that the check run finished. */
  completedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The final conclusion of the check. */
  conclusion?: InputMaybe<CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: InputMaybe<Scalars['URI']['input']>;
  /** A reference for the run on the integrator's system. */
  externalId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the check. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Descriptive details about the run. */
  output?: InputMaybe<CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** The time that the check run began. */
  startedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The current status. */
  status?: InputMaybe<RequestableCheckStatusState>;
};

/** Autogenerated return type of UpdateCheckRun */
export type UpdateCheckRunPayload = {
  /** The updated check run. */
  checkRun?: Maybe<CheckRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateCheckSuitePreferences */
export type UpdateCheckSuitePreferencesInput = {
  /** The check suite preferences to modify. */
  autoTriggerPreferences: Array<CheckSuiteAutoTriggerPreference>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateCheckSuitePreferences */
export type UpdateCheckSuitePreferencesPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated repository. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of UpdateDiscussionComment */
export type UpdateDiscussionCommentInput = {
  /** The new contents of the comment body. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion comment to update. */
  commentId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateDiscussionComment */
export type UpdateDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The modified discussion comment. */
  comment?: Maybe<DiscussionComment>;
};

/** Autogenerated input type of UpdateDiscussion */
export type UpdateDiscussionInput = {
  /** The new contents of the discussion body. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of a discussion category within the same repository to change this discussion to. */
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion to update. */
  discussionId: Scalars['ID']['input'];
  /** The new discussion title. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateDiscussion */
export type UpdateDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The modified discussion. */
  discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of UpdateEnterpriseAdministratorRole */
export type UpdateEnterpriseAdministratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of a administrator whose role is being changed. */
  login: Scalars['String']['input'];
  /** The new role for the Enterprise administrator. */
  role: EnterpriseAdministratorRole;
};

/** Autogenerated return type of UpdateEnterpriseAdministratorRole */
export type UpdateEnterpriseAdministratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of changing the administrator's role. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the allow private repository forking setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the allow private repository forking policy on the enterprise. */
  policyValue?: InputMaybe<EnterpriseAllowPrivateRepositoryForkingPolicyValue>;
  /** The value for the allow private repository forking setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated allow private repository forking setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the allow private repository forking setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the base repository permission setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the base repository permission setting on the enterprise. */
  settingValue: EnterpriseDefaultRepositoryPermissionSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type UpdateEnterpriseDefaultRepositoryPermissionSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated base repository permission setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the base repository permission setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can change repository visibility setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can change repository visibility setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can change repository visibility setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can change repository visibility setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can create repositories setting. */
  enterpriseId: Scalars['ID']['input'];
  /** Allow members to create internal repositories. Defaults to current value. */
  membersCanCreateInternalRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  /** Allow members to create private repositories. Defaults to current value. */
  membersCanCreatePrivateRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  /** Allow members to create public repositories. Defaults to current value. */
  membersCanCreatePublicRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  /** When false, allow member organizations to set their own repository creation member privileges. */
  membersCanCreateRepositoriesPolicyEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Value for the members can create repositories setting on the enterprise. This
   * or the granular public/private/internal allowed fields (but not both) must be provided.
   */
  settingValue?: InputMaybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can create repositories setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can create repositories setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can delete issues setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can delete issues setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type UpdateEnterpriseMembersCanDeleteIssuesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can delete issues setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can delete issues setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can delete repositories setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can delete repositories setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can delete repositories setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can delete repositories setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can invite collaborators setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can invite collaborators setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can invite collaborators setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can invite collaborators setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type UpdateEnterpriseMembersCanMakePurchasesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can make purchases setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can make purchases setting on the enterprise. */
  settingValue: EnterpriseMembersCanMakePurchasesSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type UpdateEnterpriseMembersCanMakePurchasesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can make purchases setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can make purchases setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can update protected branches setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can update protected branches setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can update protected branches setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can update protected branches setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can view dependency insights setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can view dependency insights setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can view dependency insights setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can view dependency insights setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */
export type UpdateEnterpriseOrganizationProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the organization projects setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the organization projects setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseOrganizationProjectsSetting */
export type UpdateEnterpriseOrganizationProjectsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated organization projects setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the organization projects setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseOwnerOrganizationRole */
export type UpdateEnterpriseOwnerOrganizationRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the owner belongs to. */
  enterpriseId: Scalars['ID']['input'];
  /** The ID of the organization for membership change. */
  organizationId: Scalars['ID']['input'];
  /** The role to assume in the organization. */
  organizationRole: RoleInOrganization;
};

/** Autogenerated return type of UpdateEnterpriseOwnerOrganizationRole */
export type UpdateEnterpriseOwnerOrganizationRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of changing the owner's organization role. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseProfile */
export type UpdateEnterpriseProfileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The description of the enterprise. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The Enterprise ID to update. */
  enterpriseId: Scalars['ID']['input'];
  /** The location of the enterprise. */
  location?: InputMaybe<Scalars['String']['input']>;
  /** The name of the enterprise. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the enterprise's website. */
  websiteUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateEnterpriseProfile */
export type UpdateEnterpriseProfilePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated enterprise. */
  enterprise?: Maybe<Enterprise>;
};

/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */
export type UpdateEnterpriseRepositoryProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the repository projects setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the repository projects setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseRepositoryProjectsSetting */
export type UpdateEnterpriseRepositoryProjectsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated repository projects setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the repository projects setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */
export type UpdateEnterpriseTeamDiscussionsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the team discussions setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the team discussions setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTeamDiscussionsSetting */
export type UpdateEnterpriseTeamDiscussionsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated team discussions setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the team discussions setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the two factor authentication required setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the two factor authentication required setting on the enterprise. */
  settingValue: EnterpriseEnabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated two factor authentication required setting. */
  enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the two factor authentication required setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnvironment */
export type UpdateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The node ID of the environment. */
  environmentId: Scalars['ID']['input'];
  /** Whether deployments to this environment can be approved by the user who created the deployment. */
  preventSelfReview?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ids of users or teams that can approve deployments to this environment */
  reviewers?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The wait timer in minutes. */
  waitTimer?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateEnvironment */
export type UpdateEnvironmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated environment. */
  environment?: Maybe<Environment>;
};

/** Autogenerated input type of UpdateIpAllowListEnabledSetting */
export type UpdateIpAllowListEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner on which to set the IP allow list enabled setting. */
  ownerId: Scalars['ID']['input'];
  /** The value for the IP allow list enabled setting. */
  settingValue: IpAllowListEnabledSettingValue;
};

/** Autogenerated return type of UpdateIpAllowListEnabledSetting */
export type UpdateIpAllowListEnabledSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list owner on which the setting was updated. */
  owner?: Maybe<IpAllowListOwner>;
};

/** Autogenerated input type of UpdateIpAllowListEntry */
export type UpdateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the IP allow list entry to update. */
  ipAllowListEntryId: Scalars['ID']['input'];
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean']['input'];
  /** An optional name for the IP allow list entry. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateIpAllowListEntry */
export type UpdateIpAllowListEntryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list entry that was updated. */
  ipAllowListEntry?: Maybe<IpAllowListEntry>;
};

/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */
export type UpdateIpAllowListForInstalledAppsEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner. */
  ownerId: Scalars['ID']['input'];
  /** The value for the IP allow list configuration for installed GitHub Apps setting. */
  settingValue: IpAllowListForInstalledAppsEnabledSettingValue;
};

/** Autogenerated return type of UpdateIpAllowListForInstalledAppsEnabledSetting */
export type UpdateIpAllowListForInstalledAppsEnabledSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list owner on which the setting was updated. */
  owner?: Maybe<IpAllowListOwner>;
};

/** Autogenerated input type of UpdateIssueComment */
export type UpdateIssueCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the IssueComment to modify. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateIssueComment */
export type UpdateIssueCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated comment. */
  issueComment?: Maybe<IssueComment>;
};

/** Autogenerated input type of UpdateIssue */
export type UpdateIssueInput = {
  /** An array of Node IDs of users for this issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The body for the issue description. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Issue to modify. */
  id: Scalars['ID']['input'];
  /** An array of Node IDs of labels for this issue. */
  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: InputMaybe<Scalars['ID']['input']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The desired issue state. */
  state?: InputMaybe<IssueState>;
  /** The title for the issue. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateIssue */
export type UpdateIssuePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of UpdateLabel */
export type UpdateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */
  color?: InputMaybe<Scalars['String']['input']>;
  /** A brief description of the label, such as its purpose. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the label to be updated. */
  id: Scalars['ID']['input'];
  /** The updated name of the label. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateLabel */
export type UpdateLabelPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated label. */
  label?: Maybe<Label>;
};

/** Autogenerated input type of UpdateNotificationRestrictionSetting */
export type UpdateNotificationRestrictionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner on which to set the restrict notifications setting. */
  ownerId: Scalars['ID']['input'];
  /** The value for the restrict notifications setting. */
  settingValue: NotificationRestrictionSettingValue;
};

/** Autogenerated return type of UpdateNotificationRestrictionSetting */
export type UpdateNotificationRestrictionSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The owner on which the setting was updated. */
  owner?: Maybe<VerifiableDomainOwner>;
};

/** Autogenerated input type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */
export type UpdateOrganizationAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Enable forking of private repositories in the organization? */
  forkingEnabled: Scalars['Boolean']['input'];
  /** The ID of the organization on which to set the allow private repository forking setting. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */
export type UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of updating the allow private repository forking setting. */
  message?: Maybe<Scalars['String']['output']>;
  /** The organization with the updated allow private repository forking setting. */
  organization?: Maybe<Organization>;
};

/** Autogenerated input type of UpdateOrganizationWebCommitSignoffSetting */
export type UpdateOrganizationWebCommitSignoffSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization on which to set the web commit signoff setting. */
  organizationId: Scalars['ID']['input'];
  /** Enable signoff on web-based commits for repositories in the organization? */
  webCommitSignoffRequired: Scalars['Boolean']['input'];
};

/** Autogenerated return type of UpdateOrganizationWebCommitSignoffSetting */
export type UpdateOrganizationWebCommitSignoffSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of updating the web commit signoff setting. */
  message?: Maybe<Scalars['String']['output']>;
  /** The organization with the updated web commit signoff setting. */
  organization?: Maybe<Organization>;
};

/** Only allow users with bypass permission to update matching refs. */
export type UpdateParameters = {
  /** Branch can pull changes from its upstream repository */
  updateAllowsFetchAndMerge: Scalars['Boolean']['output'];
};

/** Only allow users with bypass permission to update matching refs. */
export type UpdateParametersInput = {
  /** Branch can pull changes from its upstream repository */
  updateAllowsFetchAndMerge: Scalars['Boolean']['input'];
};

/** Autogenerated input type of UpdatePatreonSponsorability */
export type UpdatePatreonSponsorabilityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Whether Patreon tiers should be shown on the GitHub Sponsors profile page,
   * allowing potential sponsors to make their payment through Patreon instead of GitHub.
   */
  enablePatreonSponsorships: Scalars['Boolean']['input'];
  /**
   * The username of the organization with the GitHub Sponsors profile, if any.
   * Defaults to the GitHub Sponsors profile for the authenticated user if omitted.
   */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdatePatreonSponsorability */
export type UpdatePatreonSponsorabilityPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The GitHub Sponsors profile. */
  sponsorsListing?: Maybe<SponsorsListing>;
};

/** Autogenerated input type of UpdateProjectCard */
export type UpdateProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not the ProjectCard should be archived */
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  /** The note of ProjectCard. */
  note?: InputMaybe<Scalars['String']['input']>;
  /** The ProjectCard ID to update. */
  projectCardId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProjectCard */
export type UpdateProjectCardPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated ProjectCard. */
  projectCard?: Maybe<ProjectCard>;
};

/** Autogenerated input type of UpdateProjectColumn */
export type UpdateProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of project column. */
  name: Scalars['String']['input'];
  /** The ProjectColumn ID to update. */
  projectColumnId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProjectColumn */
export type UpdateProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated project column. */
  projectColumn?: Maybe<ProjectColumn>;
};

/** Autogenerated input type of UpdateProject */
export type UpdateProjectInput = {
  /** The description of project. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of project. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The Project ID to update. */
  projectId: Scalars['ID']['input'];
  /** Whether the project is public or not. */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the project is open or closed. */
  state?: InputMaybe<ProjectState>;
};

/** Autogenerated return type of UpdateProject */
export type UpdateProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated project. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of UpdateProjectV2Collaborators */
export type UpdateProjectV2CollaboratorsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The collaborators to update. */
  collaborators: Array<ProjectV2Collaborator>;
  /** The ID of the project to update the collaborators for. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProjectV2Collaborators */
export type UpdateProjectV2CollaboratorsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The collaborators granted a role */
  collaborators?: Maybe<ProjectV2ActorConnection>;
};


/** Autogenerated return type of UpdateProjectV2Collaborators */
export type UpdateProjectV2CollaboratorsPayloadcollaboratorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UpdateProjectV2DraftIssue */
export type UpdateProjectV2DraftIssueInput = {
  /** The IDs of the assignees of the draft issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The body of the draft issue. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the draft issue to update. */
  draftIssueId: Scalars['ID']['input'];
  /** The title of the draft issue. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateProjectV2DraftIssue */
export type UpdateProjectV2DraftIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The draft issue updated in the project. */
  draftIssue?: Maybe<DraftIssue>;
};

/** Autogenerated input type of UpdateProjectV2 */
export type UpdateProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Set the project to closed or open. */
  closed?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the Project to update. */
  projectId: Scalars['ID']['input'];
  /** Set the project to public or private. */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  /** Set the readme description of the project. */
  readme?: InputMaybe<Scalars['String']['input']>;
  /** Set the short description of the project. */
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  /** Set the title of the project. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateProjectV2ItemFieldValue */
export type UpdateProjectV2ItemFieldValueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the field to be updated. */
  fieldId: Scalars['ID']['input'];
  /** The ID of the item to be updated. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project. */
  projectId: Scalars['ID']['input'];
  /** The value which will be set on the field. */
  value: ProjectV2FieldValue;
};

/** Autogenerated return type of UpdateProjectV2ItemFieldValue */
export type UpdateProjectV2ItemFieldValuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated item. */
  projectV2Item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of UpdateProjectV2ItemPosition */
export type UpdateProjectV2ItemPositionInput = {
  /** The ID of the item to position this item after. If omitted or set to null the item will be moved to top. */
  afterId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the item to be moved. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProjectV2ItemPosition */
export type UpdateProjectV2ItemPositionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The items in the new order */
  items?: Maybe<ProjectV2ItemConnection>;
};


/** Autogenerated return type of UpdateProjectV2ItemPosition */
export type UpdateProjectV2ItemPositionPayloaditemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateProjectV2 */
export type UpdateProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated Project. */
  projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of UpdatePullRequestBranch */
export type UpdatePullRequestBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The head ref oid for the upstream branch. */
  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID']['input'];
  /** The update branch method to use. If omitted, defaults to 'MERGE' */
  updateMethod?: InputMaybe<PullRequestBranchUpdateMethod>;
};

/** Autogenerated return type of UpdatePullRequestBranch */
export type UpdatePullRequestBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request. */
  pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of UpdatePullRequest */
export type UpdatePullRequestInput = {
  /** An array of Node IDs of users for this pull request. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository.
   */
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  /** The contents of the pull request. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An array of Node IDs of labels for this pull request. */
  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node ID of the milestone for this pull request. */
  milestoneId?: InputMaybe<Scalars['ID']['input']>;
  /** An array of Node IDs for projects associated with this pull request. */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID']['input'];
  /** The target state of the pull request. */
  state?: InputMaybe<PullRequestUpdateState>;
  /** The title of the pull request. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdatePullRequest */
export type UpdatePullRequestPayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request. */
  pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of UpdatePullRequestReviewComment */
export type UpdatePullRequestReviewCommentInput = {
  /** The text of the comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the comment to modify. */
  pullRequestReviewCommentId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdatePullRequestReviewComment */
export type UpdatePullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated comment. */
  pullRequestReviewComment?: Maybe<PullRequestReviewComment>;
};

/** Autogenerated input type of UpdatePullRequestReview */
export type UpdatePullRequestReviewInput = {
  /** The contents of the pull request review body. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdatePullRequestReview */
export type UpdatePullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request review. */
  pullRequestReview?: Maybe<PullRequestReview>;
};

/** Autogenerated input type of UpdateRef */
export type UpdateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Permit updates of branch Refs that are not fast-forwards? */
  force?: InputMaybe<Scalars['Boolean']['input']>;
  /** The GitObjectID that the Ref shall be updated to target. */
  oid: Scalars['GitObjectID']['input'];
  /** The Node ID of the Ref to be updated. */
  refId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateRef */
export type UpdateRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated Ref. */
  ref?: Maybe<Ref>;
};

/** Autogenerated input type of UpdateRefs */
export type UpdateRefsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A list of ref updates. */
  refUpdates: Array<RefUpdate>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateRefs */
export type UpdateRefsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateRepository */
export type UpdateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A new description for the repository. Pass an empty string to erase the existing description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if the repository should have the discussions feature enabled. */
  hasDiscussionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the project boards feature enabled. */
  hasProjectsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */
  homepageUrl?: InputMaybe<Scalars['URI']['input']>;
  /** The new name of the repository. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to update. */
  repositoryId: Scalars['ID']['input'];
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of UpdateRepository */
export type UpdateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated repository. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of UpdateRepositoryRuleset */
export type UpdateRepositoryRulesetInput = {
  /** A list of actors that are allowed to bypass rules in this ruleset. */
  bypassActors?: InputMaybe<Array<RepositoryRulesetBypassActorInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The list of conditions for this ruleset */
  conditions?: InputMaybe<RepositoryRuleConditionsInput>;
  /** The enforcement level for this ruleset */
  enforcement?: InputMaybe<RuleEnforcement>;
  /** The name of the ruleset. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The global relay id of the repository ruleset to be updated. */
  repositoryRulesetId: Scalars['ID']['input'];
  /** The list of rules for this ruleset */
  rules?: InputMaybe<Array<RepositoryRuleInput>>;
  /** The target of the ruleset. */
  target?: InputMaybe<RepositoryRulesetTarget>;
};

/** Autogenerated return type of UpdateRepositoryRuleset */
export type UpdateRepositoryRulesetPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created Ruleset. */
  ruleset?: Maybe<RepositoryRuleset>;
};

/** Autogenerated input type of UpdateRepositoryWebCommitSignoffSetting */
export type UpdateRepositoryWebCommitSignoffSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to update. */
  repositoryId: Scalars['ID']['input'];
  /** Indicates if the repository should require signoff on web-based commits. */
  webCommitSignoffRequired: Scalars['Boolean']['input'];
};

/** Autogenerated return type of UpdateRepositoryWebCommitSignoffSetting */
export type UpdateRepositoryWebCommitSignoffSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of updating the web commit signoff setting. */
  message?: Maybe<Scalars['String']['output']>;
  /** The updated repository. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of UpdateSponsorshipPreferences */
export type UpdateSponsorshipPreferencesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  privacyLevel?: InputMaybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateSponsorshipPreferences */
export type UpdateSponsorshipPreferencesPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The sponsorship that was updated. */
  sponsorship?: Maybe<Sponsorship>;
};

/** Autogenerated input type of UpdateSubscription */
export type UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The new state of the subscription. */
  state: SubscriptionState;
  /** The Node ID of the subscribable object to modify. */
  subscribableId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateSubscription */
export type UpdateSubscriptionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The input subscribable entity. */
  subscribable?: Maybe<Subscribable>;
};

/** Autogenerated input type of UpdateTeamDiscussionComment */
export type UpdateTeamDiscussionCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String']['input'];
  /** The current version of the body content. */
  bodyVersion?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to modify. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateTeamDiscussionComment */
export type UpdateTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated comment. */
  teamDiscussionComment?: Maybe<TeamDiscussionComment>;
};

/** Autogenerated input type of UpdateTeamDiscussion */
export type UpdateTeamDiscussionInput = {
  /** The updated text of the discussion. */
  body?: InputMaybe<Scalars['String']['input']>;
  /**
   * The current version of the body content. If provided, this update operation
   * will be rejected if the given version does not match the latest version on the server.
   */
  bodyVersion?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion to modify. */
  id: Scalars['ID']['input'];
  /** If provided, sets the pinned state of the updated discussion. */
  pinned?: InputMaybe<Scalars['Boolean']['input']>;
  /** The updated title of the discussion. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateTeamDiscussion */
export type UpdateTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated discussion. */
  teamDiscussion?: Maybe<TeamDiscussion>;
};

/** Autogenerated input type of UpdateTeamReviewAssignment */
export type UpdateTeamReviewAssignmentInput = {
  /** The algorithm to use for review assignment */
  algorithm?: InputMaybe<TeamReviewAssignmentAlgorithm>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Turn on or off review assignment */
  enabled: Scalars['Boolean']['input'];
  /** An array of team member IDs to exclude */
  excludedTeamMemberIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the team to update review assignments of */
  id: Scalars['ID']['input'];
  /** Notify the entire team of the PR if it is delegated */
  notifyTeam?: InputMaybe<Scalars['Boolean']['input']>;
  /** The number of team members to assign */
  teamMemberCount?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateTeamReviewAssignment */
export type UpdateTeamReviewAssignmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The team that was modified */
  team?: Maybe<Team>;
};

/** Autogenerated input type of UpdateTeamsRepository */
export type UpdateTeamsRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Permission that should be granted to the teams. */
  permission: RepositoryPermission;
  /** Repository ID being granted access to. */
  repositoryId: Scalars['ID']['input'];
  /** A list of teams being granted access. Limit: 10 */
  teamIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of UpdateTeamsRepository */
export type UpdateTeamsRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository that was updated. */
  repository?: Maybe<Repository>;
  /** The teams granted permission on the repository. */
  teams?: Maybe<Array<Team>>;
};

/** Autogenerated input type of UpdateTopics */
export type UpdateTopicsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** An array of topic names. */
  topicNames: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateTopics */
export type UpdateTopicsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Names of the provided topics that are not valid. */
  invalidTopicNames?: Maybe<Array<Scalars['String']['output']>>;
  /** The updated repository. */
  repository?: Maybe<Repository>;
};

/** Autogenerated input type of UpdateUserList */
export type UpdateUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A description of the list */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not the list is private */
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the list to update. */
  listId: Scalars['ID']['input'];
  /** The name of the list */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateUserList */
export type UpdateUserListPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The list that was just updated */
  list?: Maybe<UserList>;
};

/** Autogenerated input type of UpdateUserListsForItem */
export type UpdateUserListsForItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The item to add to the list */
  itemId: Scalars['ID']['input'];
  /** The lists to which this item should belong */
  listIds: Array<Scalars['ID']['input']>;
  /** The suggested lists to create and add this item to */
  suggestedListIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of UpdateUserListsForItem */
export type UpdateUserListsForItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was added */
  item?: Maybe<UserListItems>;
  /** The lists to which this item belongs */
  lists?: Maybe<Array<UserList>>;
  /** The user who owns the lists */
  user?: Maybe<User>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type User = Actor & Node & PackageOwner & ProfileOwner & ProjectOwner & ProjectV2Owner & ProjectV2Recent & RepositoryDiscussionAuthor & RepositoryDiscussionCommentAuthor & RepositoryOwner & Sponsorable & UniformResourceLocatable & {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean']['output'];
  /** A URL pointing to the user's public avatar. */
  avatarUrl: Scalars['URI']['output'];
  /** The user's public profile bio. */
  bio?: Maybe<Scalars['String']['output']>;
  /** The user's public profile bio as HTML. */
  bioHTML: Scalars['HTML']['output'];
  /** Could this user receive email notifications, if the organization had notification restrictions enabled? */
  canReceiveOrganizationEmailsWhenNotificationsRestricted: Scalars['Boolean']['output'];
  /** A list of commit comments made by this user. */
  commitComments: CommitCommentConnection;
  /** The user's public profile company. */
  company?: Maybe<Scalars['String']['output']>;
  /** The user's public profile company as HTML. */
  companyHTML: Scalars['HTML']['output'];
  /** The collection of contributions this user has made to different repositories. */
  contributionsCollection: ContributionsCollection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The user's publicly visible profile email. */
  email: Scalars['String']['output'];
  /** A list of enterprises that the user belongs to. */
  enterprises?: Maybe<EnterpriseConnection>;
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars['Int']['output'];
  /** A list of users the given user is followed by. */
  followers: FollowerConnection;
  /** A list of users the given user is following. */
  following: FollowingConnection;
  /** Find gist by repo name. */
  gist?: Maybe<Gist>;
  /** A list of gist comments made by this user. */
  gistComments: GistCommentConnection;
  /** A list of the Gists the user has created. */
  gists: GistConnection;
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars['Boolean']['output'];
  /** The hovercard information for this user in a given context */
  hovercard: Hovercard;
  /** The Node ID of the User object */
  id: Scalars['ID']['output'];
  /** The interaction ability settings for this user. */
  interactionAbility?: Maybe<RepositoryInteractionAbility>;
  /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */
  isBountyHunter: Scalars['Boolean']['output'];
  /** Whether or not this user is a participant in the GitHub Campus Experts Program. */
  isCampusExpert: Scalars['Boolean']['output'];
  /** Whether or not this user is a GitHub Developer Program member. */
  isDeveloperProgramMember: Scalars['Boolean']['output'];
  /** Whether or not this user is a GitHub employee. */
  isEmployee: Scalars['Boolean']['output'];
  /** Whether or not this user is following the viewer. Inverse of viewerIsFollowing */
  isFollowingViewer: Scalars['Boolean']['output'];
  /** Whether or not this user is a member of the GitHub Stars Program. */
  isGitHubStar: Scalars['Boolean']['output'];
  /** Whether or not the user has marked themselves as for hire. */
  isHireable: Scalars['Boolean']['output'];
  /** Whether or not this user is a site administrator. */
  isSiteAdmin: Scalars['Boolean']['output'];
  /** Whether the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars['Boolean']['output'];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars['Boolean']['output'];
  /** Whether or not this user is the viewing user. */
  isViewer: Scalars['Boolean']['output'];
  /** A list of issue comments made by this user. */
  issueComments: IssueCommentConnection;
  /** A list of issues associated with this user. */
  issues: IssueConnection;
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: ProfileItemShowcase;
  /** A user-curated list of repositories */
  lists: UserListConnection;
  /** The user's public profile location. */
  location?: Maybe<Scalars['String']['output']>;
  /** The username used to login. */
  login: Scalars['String']['output'];
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']['output'];
  /** The user's public profile name. */
  name?: Maybe<Scalars['String']['output']>;
  /** Find an organization by its login that the user belongs to. */
  organization?: Maybe<Organization>;
  /** Verified email addresses that match verified domains for a specified organization the user is a member of. */
  organizationVerifiedDomainEmails: Array<Scalars['String']['output']>;
  /** A list of organizations the user belongs to. */
  organizations: OrganizationConnection;
  /** A list of packages under the owner. */
  packages: PackageConnection;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int']['output'];
  /** Find project by number. */
  project?: Maybe<Project>;
  /** Find a project by number. */
  projectV2?: Maybe<ProjectV2>;
  /** A list of projects under the owner. */
  projects: ProjectConnection;
  /** The HTTP path listing user's projects */
  projectsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL listing user's projects */
  projectsUrl: Scalars['URI']['output'];
  /** A list of projects under the owner. */
  projectsV2: ProjectV2Connection;
  /** The user's profile pronouns */
  pronouns?: Maybe<Scalars['String']['output']>;
  /** A list of public keys associated with this user. */
  publicKeys: PublicKeyConnection;
  /** A list of pull requests associated with this user. */
  pullRequests: PullRequestConnection;
  /** Recent projects that this user has modified in the context of the owner. */
  recentProjects: ProjectV2Connection;
  /** A list of repositories that the user owns. */
  repositories: RepositoryConnection;
  /** A list of repositories that the user recently contributed to. */
  repositoriesContributedTo: RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<Repository>;
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: DiscussionCommentConnection;
  /** Discussions this user has started. */
  repositoryDiscussions: DiscussionConnection;
  /** The HTTP path for this user */
  resourcePath: Scalars['URI']['output'];
  /** Replies this user has saved */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** The user's social media accounts, ordered as they appear on the user's profile. */
  socialAccounts: SocialAccountConnection;
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<SponsorsListing>;
  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
  sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;
  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
  sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: SponsorshipNewsletterConnection;
  /** The sponsorships where this user or organization is the maintainer receiving the funds. */
  sponsorshipsAsMaintainer: SponsorshipConnection;
  /** The sponsorships where this user or organization is the funder. */
  sponsorshipsAsSponsor: SponsorshipConnection;
  /** Repositories the user has starred. */
  starredRepositories: StarredRepositoryConnection;
  /** The user's description of what they're currently doing. */
  status?: Maybe<UserStatus>;
  /** Suggested names for user lists */
  suggestedListNames: Array<UserListSuggestion>;
  /** Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created */
  topRepositories: RepositoryConnection;
  /**
   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
   * user themselves or by a user who can manage sponsorships for the requested organization.
   */
  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']['output']>;
  /** The user's Twitter username. */
  twitterUsername?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this user */
  url: Scalars['URI']['output'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean']['output'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean']['output'];
  /** Whether or not the viewer is able to follow the user. */
  viewerCanFollow: Scalars['Boolean']['output'];
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars['Boolean']['output'];
  /** Whether or not this user is followed by the viewer. Inverse of isFollowingViewer. */
  viewerIsFollowing: Scalars['Boolean']['output'];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars['Boolean']['output'];
  /** A list of repositories the given user is watching. */
  watching: RepositoryConnection;
  /** A URL pointing to the user's public website/blog. */
  websiteUrl?: Maybe<Scalars['URI']['output']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UseranyPinnableItemsArgs = {
  type?: InputMaybe<PinnableItemType>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UseravatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsercanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs = {
  login: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsercommitCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsercontributionsCollectionArgs = {
  from?: InputMaybe<Scalars['DateTime']['input']>;
  organizationID?: InputMaybe<Scalars['ID']['input']>;
  to?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserenterprisesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  membershipType?: InputMaybe<EnterpriseMembershipType>;
  orderBy?: InputMaybe<EnterpriseOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserfollowersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserfollowingArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsergistArgs = {
  name: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsergistCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsergistsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<GistOrder>;
  privacy?: InputMaybe<GistPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserhovercardArgs = {
  primarySubjectId?: InputMaybe<Scalars['ID']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserisSponsoredByArgs = {
  accountLogin: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserissueCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueCommentOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserissuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<IssueFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<IssueState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserlistsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserorganizationArgs = {
  login: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserorganizationVerifiedDomainEmailsArgs = {
  login: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserorganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserpackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<PackageOrder>;
  packageType?: InputMaybe<PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserpinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<PinnableItemType>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserpinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<PinnableItemType>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserprojectArgs = {
  number: Scalars['Int']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserprojectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<ProjectState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserpublicKeysArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserpullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<Array<PullRequestState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserrecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserrepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  isFork?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserrepositoriesContributedToArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  contributionTypes?: InputMaybe<Array<InputMaybe<RepositoryContributionType>>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssues?: InputMaybe<Scalars['Boolean']['input']>;
  includeUserRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  privacy?: InputMaybe<RepositoryPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserrepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserrepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']['input']>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserrepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  answered?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  states?: InputMaybe<Array<DiscussionState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsersavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SavedReplyOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsersocialAccountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsersponsoringArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsersponsorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsersponsorsActivitiesArgs = {
  actions?: InputMaybe<Array<SponsorsActivityAction>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAsSponsor?: InputMaybe<Scalars['Boolean']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorsActivityOrder>;
  period?: InputMaybe<SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsersponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsersponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsersponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsersponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsersponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  maintainerLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserstarredRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<StarOrder>;
  ownedByViewer?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsertopRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy: RepositoryOrder;
  since?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UsertotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars['DateTime']['input']>;
  sponsorableLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type UserwatchingArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
};

/** The possible durations that a user can be blocked for. */
export type UserBlockDuration =
  /** The user was blocked for 1 day */
  | 'ONE_DAY'
  /** The user was blocked for 30 days */
  | 'ONE_MONTH'
  /** The user was blocked for 7 days */
  | 'ONE_WEEK'
  /** The user was blocked permanently */
  | 'PERMANENT'
  /** The user was blocked for 3 days */
  | 'THREE_DAYS';

/** Represents a 'user_blocked' event on a given user. */
export type UserBlockedEvent = Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Actor>;
  /** Number of days that the user was blocked for. */
  blockDuration: UserBlockDuration;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the UserBlockedEvent object */
  id: Scalars['ID']['output'];
  /** The user who was blocked. */
  subject?: Maybe<User>;
};

/** The connection type for User. */
export type UserConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edit on user content */
export type UserContentEdit = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the date and time when the object was deleted. */
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The actor who deleted this content */
  deletedBy?: Maybe<Actor>;
  /** A summary of the changes for this edit */
  diff?: Maybe<Scalars['String']['output']>;
  /** When this content was edited */
  editedAt: Scalars['DateTime']['output'];
  /** The actor who edited this content */
  editor?: Maybe<Actor>;
  /** The Node ID of the UserContentEdit object */
  id: Scalars['ID']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** A list of edits to content. */
export type UserContentEditConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserContentEditEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserContentEdit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserContentEditEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserContentEdit>;
};

/** Represents a user. */
export type UserEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** Email attributes from External Identity */
export type UserEmailMetadata = {
  /** Boolean to identify primary emails */
  primary?: Maybe<Scalars['Boolean']['output']>;
  /** Type of email */
  type?: Maybe<Scalars['String']['output']>;
  /** Email id */
  value: Scalars['String']['output'];
};

/** A user-curated list of repositories */
export type UserList = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The description of this list */
  description?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the UserList object */
  id: Scalars['ID']['output'];
  /** Whether or not this list is private */
  isPrivate: Scalars['Boolean']['output'];
  /** The items associated with this list */
  items: UserListItemsConnection;
  /** The date and time at which this list was created or last had items added to it */
  lastAddedAt: Scalars['DateTime']['output'];
  /** The name of this list */
  name: Scalars['String']['output'];
  /** The slug of this list */
  slug: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The user to which this list belongs */
  user: User;
};


/** A user-curated list of repositories */
export type UserListitemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for UserList. */
export type UserListConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserListEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserList>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserListEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserList>;
};

/** Types that can be added to a user list. */
export type UserListItems = Repository;

/** The connection type for UserListItems. */
export type UserListItemsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserListItemsEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserListItems>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserListItemsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserListItems>;
};

/** Represents a suggested user list. */
export type UserListSuggestion = {
  /** The ID of the suggested user list */
  id?: Maybe<Scalars['ID']['output']>;
  /** The name of the suggested user list */
  name?: Maybe<Scalars['String']['output']>;
};

/** The user's description of what they're currently doing. */
export type UserStatus = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** An emoji summarizing the user's status. */
  emoji?: Maybe<Scalars['String']['output']>;
  /** The status emoji as HTML. */
  emojiHTML?: Maybe<Scalars['HTML']['output']>;
  /** If set, the status will not be shown after this date. */
  expiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** The Node ID of the UserStatus object */
  id: Scalars['ID']['output'];
  /** Whether this status indicates the user is not fully available on GitHub. */
  indicatesLimitedAvailability: Scalars['Boolean']['output'];
  /** A brief message describing what the user is doing. */
  message?: Maybe<Scalars['String']['output']>;
  /** The organization whose members can see this status. If null, this status is publicly visible. */
  organization?: Maybe<Organization>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The user who has this status. */
  user: User;
};

/** The connection type for UserStatus. */
export type UserStatusConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserStatusEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserStatus>;
};

/** Ordering options for user status connections. */
export type UserStatusOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order user statuses by. */
  field: UserStatusOrderField;
};

/** Properties by which user status connections can be ordered. */
export type UserStatusOrderField =
  /** Order user statuses by when they were updated. */
  | 'UPDATED_AT';

/** A domain that can be verified or approved for an organization or an enterprise. */
export type VerifiableDomain = Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The DNS host name that should be used for verification. */
  dnsHostName?: Maybe<Scalars['URI']['output']>;
  /** The unicode encoded domain. */
  domain: Scalars['URI']['output'];
  /** Whether a TXT record for verification with the expected host name was found. */
  hasFoundHostName: Scalars['Boolean']['output'];
  /** Whether a TXT record for verification with the expected verification token was found. */
  hasFoundVerificationToken: Scalars['Boolean']['output'];
  /** The Node ID of the VerifiableDomain object */
  id: Scalars['ID']['output'];
  /** Whether or not the domain is approved. */
  isApproved: Scalars['Boolean']['output'];
  /** Whether this domain is required to exist for an organization or enterprise policy to be enforced. */
  isRequiredForPolicyEnforcement: Scalars['Boolean']['output'];
  /** Whether or not the domain is verified. */
  isVerified: Scalars['Boolean']['output'];
  /** The owner of the domain. */
  owner: VerifiableDomainOwner;
  /** The punycode encoded domain. */
  punycodeEncodedDomain: Scalars['URI']['output'];
  /** The time that the current verification token will expire. */
  tokenExpirationTime?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The current verification token for the domain. */
  verificationToken?: Maybe<Scalars['String']['output']>;
};

/** The connection type for VerifiableDomain. */
export type VerifiableDomainConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VerifiableDomainEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VerifiableDomain>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type VerifiableDomainEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VerifiableDomain>;
};

/** Ordering options for verifiable domain connections. */
export type VerifiableDomainOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order verifiable domains by. */
  field: VerifiableDomainOrderField;
};

/** Properties by which verifiable domain connections can be ordered. */
export type VerifiableDomainOrderField =
  /** Order verifiable domains by their creation date. */
  | 'CREATED_AT'
  /** Order verifiable domains by the domain name. */
  | 'DOMAIN';

/** Types that can own a verifiable domain. */
export type VerifiableDomainOwner = Enterprise | Organization;

/** Autogenerated input type of VerifyVerifiableDomain */
export type VerifyVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to verify. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of VerifyVerifiableDomain */
export type VerifyVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The verifiable domain that was verified. */
  domain?: Maybe<VerifiableDomain>;
};

/** A hovercard context with a message describing how the viewer is related. */
export type ViewerHovercardContext = HovercardContext & {
  /** A string describing this context */
  message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  octicon: Scalars['String']['output'];
  /** Identifies the user who is related to this context. */
  viewer: User;
};

/** A subject that may be upvoted. */
export type Votable = {
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars['Int']['output'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars['Boolean']['output'];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars['Boolean']['output'];
};

/** A workflow contains meta information about an Actions workflow file. */
export type Workflow = Node & UniformResourceLocatable & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the Workflow object */
  id: Scalars['ID']['output'];
  /** The name of the workflow. */
  name: Scalars['String']['output'];
  /** The HTTP path for this workflow */
  resourcePath: Scalars['URI']['output'];
  /** The runs of the workflow. */
  runs: WorkflowRunConnection;
  /** The state of the workflow. */
  state: WorkflowState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this workflow */
  url: Scalars['URI']['output'];
};


/** A workflow contains meta information about an Actions workflow file. */
export type WorkflowrunsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<WorkflowRunOrder>;
};

/** A workflow that must run for this rule to pass */
export type WorkflowFileReference = {
  /** The path to the workflow file */
  path: Scalars['String']['output'];
  /** The ref (branch or tag) of the workflow file to use */
  ref?: Maybe<Scalars['String']['output']>;
  /** The ID of the repository where the workflow is defined */
  repositoryId: Scalars['Int']['output'];
  /** The commit SHA of the workflow file to use */
  sha?: Maybe<Scalars['String']['output']>;
};

/** A workflow that must run for this rule to pass */
export type WorkflowFileReferenceInput = {
  /** The path to the workflow file */
  path: Scalars['String']['input'];
  /** The ref (branch or tag) of the workflow file to use */
  ref?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository where the workflow is defined */
  repositoryId: Scalars['Int']['input'];
  /** The commit SHA of the workflow file to use */
  sha?: InputMaybe<Scalars['String']['input']>;
};

/** A workflow run. */
export type WorkflowRun = Node & UniformResourceLocatable & {
  /** The check suite this workflow run belongs to. */
  checkSuite: CheckSuite;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The log of deployment reviews */
  deploymentReviews: DeploymentReviewConnection;
  /** The event that triggered the workflow run */
  event: Scalars['String']['output'];
  /** The workflow file */
  file?: Maybe<WorkflowRunFile>;
  /** The Node ID of the WorkflowRun object */
  id: Scalars['ID']['output'];
  /** The pending deployment requests of all check runs in this workflow run */
  pendingDeploymentRequests: DeploymentRequestConnection;
  /** The HTTP path for this workflow run */
  resourcePath: Scalars['URI']['output'];
  /** A number that uniquely identifies this workflow run in its parent workflow. */
  runNumber: Scalars['Int']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this workflow run */
  url: Scalars['URI']['output'];
  /** The workflow executed in this workflow run. */
  workflow: Workflow;
};


/** A workflow run. */
export type WorkflowRundeploymentReviewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A workflow run. */
export type WorkflowRunpendingDeploymentRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for WorkflowRun. */
export type WorkflowRunConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkflowRunEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkflowRun>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type WorkflowRunEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkflowRun>;
};

/** An executed workflow file for a workflow run. */
export type WorkflowRunFile = Node & UniformResourceLocatable & {
  /** The Node ID of the WorkflowRunFile object */
  id: Scalars['ID']['output'];
  /** The path of the workflow file relative to its repository. */
  path: Scalars['String']['output'];
  /** The direct link to the file in the repository which stores the workflow file. */
  repositoryFileUrl: Scalars['URI']['output'];
  /** The repository name and owner which stores the workflow file. */
  repositoryName: Scalars['URI']['output'];
  /** The HTTP path for this workflow run file */
  resourcePath: Scalars['URI']['output'];
  /** The parent workflow run execution for this file. */
  run: WorkflowRun;
  /** The HTTP URL for this workflow run file */
  url: Scalars['URI']['output'];
  /** If the viewer has permissions to push to the repository which stores the workflow. */
  viewerCanPushRepository: Scalars['Boolean']['output'];
  /** If the viewer has permissions to read the repository which stores the workflow. */
  viewerCanReadRepository: Scalars['Boolean']['output'];
};

/** Ways in which lists of workflow runs can be ordered upon return. */
export type WorkflowRunOrder = {
  /** The direction in which to order workflow runs by the specified field. */
  direction: OrderDirection;
  /** The field by which to order workflows. */
  field: WorkflowRunOrderField;
};

/** Properties by which workflow run connections can be ordered. */
export type WorkflowRunOrderField =
  /** Order workflow runs by most recently created */
  | 'CREATED_AT';

/** The possible states for a workflow. */
export type WorkflowState =
  /** The workflow is active. */
  | 'ACTIVE'
  /** The workflow was deleted from the git repository. */
  | 'DELETED'
  /** The workflow was disabled by default on a fork. */
  | 'DISABLED_FORK'
  /** The workflow was disabled for inactivity in the repository. */
  | 'DISABLED_INACTIVITY'
  /** The workflow was disabled manually. */
  | 'DISABLED_MANUALLY';

/** Require all changes made to a targeted branch to pass the specified workflows before they can be merged. */
export type WorkflowsParameters = {
  /** Workflows that must pass for this rule to pass. */
  workflows: Array<WorkflowFileReference>;
};

/** Require all changes made to a targeted branch to pass the specified workflows before they can be merged. */
export type WorkflowsParametersInput = {
  /** Workflows that must pass for this rule to pass. */
  workflows: Array<WorkflowFileReferenceInput>;
};

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
  selectionSet: string | ((fieldNode: FieldNode) => SelectionSetNode);
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping of union types */
export type ResolversUnionTypes<RefType extends Record<string, unknown>> = ResolversObject<{
  Assignee: ( Bot ) | ( Mannequin ) | ( Organization ) | ( User );
  AuditEntryActor: ( Bot ) | ( Organization ) | ( User );
  BranchActorAllowanceActor: ( App ) | ( Team ) | ( User );
  BypassActor: ( App ) | ( Team );
  Claimable: ( Mannequin ) | ( User );
  Closer: ( Commit ) | ( PullRequest );
  CreatedIssueOrRestrictedContribution: ( CreatedIssueContribution ) | ( RestrictedContribution );
  CreatedPullRequestOrRestrictedContribution: ( CreatedPullRequestContribution ) | ( RestrictedContribution );
  CreatedRepositoryOrRestrictedContribution: ( CreatedRepositoryContribution ) | ( RestrictedContribution );
  DeploymentReviewer: ( Team ) | ( User );
  EnterpriseMember: ( EnterpriseUserAccount ) | ( User );
  IpAllowListOwner: ( App ) | ( Enterprise ) | ( Organization );
  IssueOrPullRequest: ( Issue ) | ( PullRequest );
  IssueTimelineItem: ( Omit<AssignedEvent, 'assignee'> & { assignee?: Maybe<RefType['Assignee']> } ) | ( Omit<ClosedEvent, 'closer'> & { closer?: Maybe<RefType['Closer']> } ) | ( Commit ) | ( Omit<CrossReferencedEvent, 'source' | 'target'> & { source: RefType['ReferencedSubject'], target: RefType['ReferencedSubject'] } ) | ( Omit<DemilestonedEvent, 'subject'> & { subject: RefType['MilestoneItem'] } ) | ( IssueComment ) | ( LabeledEvent ) | ( LockedEvent ) | ( Omit<MilestonedEvent, 'subject'> & { subject: RefType['MilestoneItem'] } ) | ( Omit<ReferencedEvent, 'subject'> & { subject: RefType['ReferencedSubject'] } ) | ( Omit<RenamedTitleEvent, 'subject'> & { subject: RefType['RenamedTitleSubject'] } ) | ( ReopenedEvent ) | ( SubscribedEvent ) | ( TransferredEvent ) | ( Omit<UnassignedEvent, 'assignee'> & { assignee?: Maybe<RefType['Assignee']> } ) | ( UnlabeledEvent ) | ( UnlockedEvent ) | ( UnsubscribedEvent ) | ( UserBlockedEvent );
  IssueTimelineItems: ( AddedToProjectEvent ) | ( Omit<AssignedEvent, 'assignee'> & { assignee?: Maybe<RefType['Assignee']> } ) | ( Omit<ClosedEvent, 'closer'> & { closer?: Maybe<RefType['Closer']> } ) | ( CommentDeletedEvent ) | ( Omit<ConnectedEvent, 'source' | 'subject'> & { source: RefType['ReferencedSubject'], subject: RefType['ReferencedSubject'] } ) | ( ConvertedNoteToIssueEvent ) | ( ConvertedToDiscussionEvent ) | ( Omit<CrossReferencedEvent, 'source' | 'target'> & { source: RefType['ReferencedSubject'], target: RefType['ReferencedSubject'] } ) | ( Omit<DemilestonedEvent, 'subject'> & { subject: RefType['MilestoneItem'] } ) | ( Omit<DisconnectedEvent, 'source' | 'subject'> & { source: RefType['ReferencedSubject'], subject: RefType['ReferencedSubject'] } ) | ( IssueComment ) | ( LabeledEvent ) | ( LockedEvent ) | ( Omit<MarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<RefType['IssueOrPullRequest']>, duplicate?: Maybe<RefType['IssueOrPullRequest']> } ) | ( MentionedEvent ) | ( Omit<MilestonedEvent, 'subject'> & { subject: RefType['MilestoneItem'] } ) | ( MovedColumnsInProjectEvent ) | ( PinnedEvent ) | ( Omit<ReferencedEvent, 'subject'> & { subject: RefType['ReferencedSubject'] } ) | ( RemovedFromProjectEvent ) | ( Omit<RenamedTitleEvent, 'subject'> & { subject: RefType['RenamedTitleSubject'] } ) | ( ReopenedEvent ) | ( SubscribedEvent ) | ( TransferredEvent ) | ( Omit<UnassignedEvent, 'assignee'> & { assignee?: Maybe<RefType['Assignee']> } ) | ( UnlabeledEvent ) | ( UnlockedEvent ) | ( Omit<UnmarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<RefType['IssueOrPullRequest']>, duplicate?: Maybe<RefType['IssueOrPullRequest']> } ) | ( UnpinnedEvent ) | ( UnsubscribedEvent ) | ( UserBlockedEvent );
  MilestoneItem: ( Issue ) | ( PullRequest );
  OrgRestoreMemberAuditEntryMembership: ( OrgRestoreMemberMembershipOrganizationAuditEntryData ) | ( OrgRestoreMemberMembershipRepositoryAuditEntryData ) | ( OrgRestoreMemberMembershipTeamAuditEntryData );
  OrganizationAuditEntry: ( Omit<MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<RefType['AuditEntryActor']>, restoredMemberships?: Maybe<Array<RefType['OrgRestoreMemberAuditEntryMembership']>> } ) | ( Omit<OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } );
  OrganizationOrUser: ( Organization ) | ( User );
  PermissionGranter: ( Organization ) | ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } ) | ( Team );
  PinnableItem: ( Gist ) | ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } );
  ProjectCardItem: ( Issue ) | ( PullRequest );
  ProjectV2Actor: ( Team ) | ( User );
  ProjectV2FieldConfiguration: ( ProjectV2Field ) | ( ProjectV2IterationField ) | ( ProjectV2SingleSelectField );
  ProjectV2ItemContent: ( DraftIssue ) | ( Issue ) | ( PullRequest );
  ProjectV2ItemFieldValue: ( Omit<ProjectV2ItemFieldDateValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldIterationValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldLabelValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldMilestoneValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldNumberValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldPullRequestValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldRepositoryValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldReviewerValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldSingleSelectValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldTextValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldUserValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } );
  PullRequestTimelineItem: ( Omit<AssignedEvent, 'assignee'> & { assignee?: Maybe<RefType['Assignee']> } ) | ( BaseRefDeletedEvent ) | ( BaseRefForcePushedEvent ) | ( Omit<ClosedEvent, 'closer'> & { closer?: Maybe<RefType['Closer']> } ) | ( Commit ) | ( CommitCommentThread ) | ( Omit<CrossReferencedEvent, 'source' | 'target'> & { source: RefType['ReferencedSubject'], target: RefType['ReferencedSubject'] } ) | ( Omit<DemilestonedEvent, 'subject'> & { subject: RefType['MilestoneItem'] } ) | ( DeployedEvent ) | ( DeploymentEnvironmentChangedEvent ) | ( HeadRefDeletedEvent ) | ( HeadRefForcePushedEvent ) | ( HeadRefRestoredEvent ) | ( IssueComment ) | ( LabeledEvent ) | ( LockedEvent ) | ( MergedEvent ) | ( Omit<MilestonedEvent, 'subject'> & { subject: RefType['MilestoneItem'] } ) | ( PullRequestReview ) | ( PullRequestReviewComment ) | ( PullRequestReviewThread ) | ( Omit<ReferencedEvent, 'subject'> & { subject: RefType['ReferencedSubject'] } ) | ( Omit<RenamedTitleEvent, 'subject'> & { subject: RefType['RenamedTitleSubject'] } ) | ( ReopenedEvent ) | ( ReviewDismissedEvent ) | ( Omit<ReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['RequestedReviewer']> } ) | ( Omit<ReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['RequestedReviewer']> } ) | ( SubscribedEvent ) | ( Omit<UnassignedEvent, 'assignee'> & { assignee?: Maybe<RefType['Assignee']> } ) | ( UnlabeledEvent ) | ( UnlockedEvent ) | ( UnsubscribedEvent ) | ( UserBlockedEvent );
  PullRequestTimelineItems: ( AddedToMergeQueueEvent ) | ( AddedToProjectEvent ) | ( Omit<AssignedEvent, 'assignee'> & { assignee?: Maybe<RefType['Assignee']> } ) | ( AutoMergeDisabledEvent ) | ( AutoMergeEnabledEvent ) | ( AutoRebaseEnabledEvent ) | ( AutoSquashEnabledEvent ) | ( AutomaticBaseChangeFailedEvent ) | ( AutomaticBaseChangeSucceededEvent ) | ( BaseRefChangedEvent ) | ( BaseRefDeletedEvent ) | ( BaseRefForcePushedEvent ) | ( Omit<ClosedEvent, 'closer'> & { closer?: Maybe<RefType['Closer']> } ) | ( CommentDeletedEvent ) | ( Omit<ConnectedEvent, 'source' | 'subject'> & { source: RefType['ReferencedSubject'], subject: RefType['ReferencedSubject'] } ) | ( ConvertToDraftEvent ) | ( ConvertedNoteToIssueEvent ) | ( ConvertedToDiscussionEvent ) | ( Omit<CrossReferencedEvent, 'source' | 'target'> & { source: RefType['ReferencedSubject'], target: RefType['ReferencedSubject'] } ) | ( Omit<DemilestonedEvent, 'subject'> & { subject: RefType['MilestoneItem'] } ) | ( DeployedEvent ) | ( DeploymentEnvironmentChangedEvent ) | ( Omit<DisconnectedEvent, 'source' | 'subject'> & { source: RefType['ReferencedSubject'], subject: RefType['ReferencedSubject'] } ) | ( HeadRefDeletedEvent ) | ( HeadRefForcePushedEvent ) | ( HeadRefRestoredEvent ) | ( IssueComment ) | ( LabeledEvent ) | ( LockedEvent ) | ( Omit<MarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<RefType['IssueOrPullRequest']>, duplicate?: Maybe<RefType['IssueOrPullRequest']> } ) | ( MentionedEvent ) | ( MergedEvent ) | ( Omit<MilestonedEvent, 'subject'> & { subject: RefType['MilestoneItem'] } ) | ( MovedColumnsInProjectEvent ) | ( PinnedEvent ) | ( PullRequestCommit ) | ( PullRequestCommitCommentThread ) | ( PullRequestReview ) | ( PullRequestReviewThread ) | ( PullRequestRevisionMarker ) | ( ReadyForReviewEvent ) | ( Omit<ReferencedEvent, 'subject'> & { subject: RefType['ReferencedSubject'] } ) | ( RemovedFromMergeQueueEvent ) | ( RemovedFromProjectEvent ) | ( Omit<RenamedTitleEvent, 'subject'> & { subject: RefType['RenamedTitleSubject'] } ) | ( ReopenedEvent ) | ( ReviewDismissedEvent ) | ( Omit<ReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['RequestedReviewer']> } ) | ( Omit<ReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['RequestedReviewer']> } ) | ( SubscribedEvent ) | ( TransferredEvent ) | ( Omit<UnassignedEvent, 'assignee'> & { assignee?: Maybe<RefType['Assignee']> } ) | ( UnlabeledEvent ) | ( UnlockedEvent ) | ( Omit<UnmarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<RefType['IssueOrPullRequest']>, duplicate?: Maybe<RefType['IssueOrPullRequest']> } ) | ( UnpinnedEvent ) | ( UnsubscribedEvent ) | ( UserBlockedEvent );
  PushAllowanceActor: ( App ) | ( Team ) | ( User );
  Reactor: ( Bot ) | ( Mannequin ) | ( Organization ) | ( User );
  ReferencedSubject: ( Issue ) | ( PullRequest );
  RenamedTitleSubject: ( Issue ) | ( PullRequest );
  RequestedReviewer: ( Bot ) | ( Mannequin ) | ( Team ) | ( User );
  ReviewDismissalAllowanceActor: ( App ) | ( Team ) | ( User );
  RuleParameters: ( BranchNamePatternParameters ) | ( CommitAuthorEmailPatternParameters ) | ( CommitMessagePatternParameters ) | ( CommitterEmailPatternParameters ) | ( PullRequestParameters ) | ( RequiredDeploymentsParameters ) | ( RequiredStatusChecksParameters ) | ( TagNamePatternParameters ) | ( UpdateParameters ) | ( WorkflowsParameters );
  RuleSource: ( Organization ) | ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } );
  SearchResultItem: ( App ) | ( Discussion ) | ( Issue ) | ( MarketplaceListing ) | ( Organization ) | ( PullRequest ) | ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } ) | ( User );
  Sponsor: ( Organization ) | ( User );
  SponsorableItem: ( Organization ) | ( User );
  SponsorsListingFeatureableItem: ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } ) | ( User );
  StatusCheckRollupContext: ( CheckRun ) | ( StatusContext );
  UserListItems: ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } );
  VerifiableDomainOwner: ( Enterprise ) | ( Organization );
}>;

/** Mapping of interface types */
export type ResolversInterfaceTypes<RefType extends Record<string, unknown>> = ResolversObject<{
  Actor: ( Bot ) | ( EnterpriseUserAccount ) | ( Mannequin ) | ( Organization ) | ( User );
  AnnouncementBanner: ( Enterprise ) | ( Organization );
  Assignable: ( Issue ) | ( PullRequest );
  AuditEntry: ( Omit<MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<RefType['AuditEntryActor']>, restoredMemberships?: Maybe<Array<RefType['OrgRestoreMemberAuditEntryMembership']>> } ) | ( Omit<OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } );
  Closable: ( Discussion ) | ( Issue ) | ( Milestone ) | ( Project ) | ( Omit<ProjectV2, 'field'> & { field?: Maybe<RefType['ProjectV2FieldConfiguration']> } ) | ( PullRequest );
  Comment: ( CommitComment ) | ( Discussion ) | ( DiscussionComment ) | ( GistComment ) | ( Issue ) | ( IssueComment ) | ( PullRequest ) | ( PullRequestReview ) | ( PullRequestReviewComment ) | ( TeamDiscussion ) | ( TeamDiscussionComment );
  Contribution: ( CreatedCommitContribution ) | ( CreatedIssueContribution ) | ( CreatedPullRequestContribution ) | ( CreatedPullRequestReviewContribution ) | ( CreatedRepositoryContribution ) | ( JoinedGitHubContribution ) | ( RestrictedContribution );
  Deletable: ( CommitComment ) | ( Discussion ) | ( DiscussionComment ) | ( GistComment ) | ( Issue ) | ( IssueComment ) | ( PullRequestReview ) | ( PullRequestReviewComment ) | ( TeamDiscussion ) | ( TeamDiscussionComment );
  EnterpriseAuditEntryData: ( Omit<MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } );
  GitObject: ( Blob ) | ( Commit ) | ( Tag ) | ( Tree );
  GitSignature: ( GpgSignature ) | ( SmimeSignature ) | ( SshSignature ) | ( UnknownSignature );
  HovercardContext: ( GenericHovercardContext ) | ( OrganizationTeamsHovercardContext ) | ( OrganizationsHovercardContext ) | ( ReviewStatusHovercardContext ) | ( ViewerHovercardContext );
  Labelable: ( Discussion ) | ( Issue ) | ( PullRequest );
  Lockable: ( Discussion ) | ( Issue ) | ( PullRequest );
  MemberStatusable: ( Organization ) | ( Team );
  Migration: ( RepositoryMigration );
  Minimizable: ( CommitComment ) | ( DiscussionComment ) | ( GistComment ) | ( IssueComment ) | ( PullRequestReview ) | ( PullRequestReviewComment );
  Node: ( AddedToMergeQueueEvent ) | ( AddedToProjectEvent ) | ( App ) | ( Omit<AssignedEvent, 'assignee'> & { assignee?: Maybe<RefType['Assignee']> } ) | ( AutoMergeDisabledEvent ) | ( AutoMergeEnabledEvent ) | ( AutoRebaseEnabledEvent ) | ( AutoSquashEnabledEvent ) | ( AutomaticBaseChangeFailedEvent ) | ( AutomaticBaseChangeSucceededEvent ) | ( BaseRefChangedEvent ) | ( BaseRefDeletedEvent ) | ( BaseRefForcePushedEvent ) | ( Blob ) | ( Bot ) | ( BranchProtectionRule ) | ( Omit<BypassForcePushAllowance, 'actor'> & { actor?: Maybe<RefType['BranchActorAllowanceActor']> } ) | ( Omit<BypassPullRequestAllowance, 'actor'> & { actor?: Maybe<RefType['BranchActorAllowanceActor']> } ) | ( CWE ) | ( CheckRun ) | ( CheckSuite ) | ( Omit<ClosedEvent, 'closer'> & { closer?: Maybe<RefType['Closer']> } ) | ( CodeOfConduct ) | ( CommentDeletedEvent ) | ( Commit ) | ( CommitComment ) | ( CommitCommentThread ) | ( Comparison ) | ( Omit<ConnectedEvent, 'source' | 'subject'> & { source: RefType['ReferencedSubject'], subject: RefType['ReferencedSubject'] } ) | ( ConvertToDraftEvent ) | ( ConvertedNoteToIssueEvent ) | ( ConvertedToDiscussionEvent ) | ( Omit<CrossReferencedEvent, 'source' | 'target'> & { source: RefType['ReferencedSubject'], target: RefType['ReferencedSubject'] } ) | ( Omit<DemilestonedEvent, 'subject'> & { subject: RefType['MilestoneItem'] } ) | ( DependencyGraphManifest ) | ( DeployKey ) | ( DeployedEvent ) | ( Deployment ) | ( DeploymentEnvironmentChangedEvent ) | ( DeploymentReview ) | ( DeploymentStatus ) | ( Omit<DisconnectedEvent, 'source' | 'subject'> & { source: RefType['ReferencedSubject'], subject: RefType['ReferencedSubject'] } ) | ( Discussion ) | ( DiscussionCategory ) | ( DiscussionComment ) | ( DiscussionPoll ) | ( DiscussionPollOption ) | ( DraftIssue ) | ( Enterprise ) | ( EnterpriseAdministratorInvitation ) | ( EnterpriseIdentityProvider ) | ( EnterpriseRepositoryInfo ) | ( EnterpriseServerInstallation ) | ( EnterpriseServerUserAccount ) | ( EnterpriseServerUserAccountEmail ) | ( EnterpriseServerUserAccountsUpload ) | ( EnterpriseUserAccount ) | ( Environment ) | ( ExternalIdentity ) | ( Gist ) | ( GistComment ) | ( HeadRefDeletedEvent ) | ( HeadRefForcePushedEvent ) | ( HeadRefRestoredEvent ) | ( Omit<IpAllowListEntry, 'owner'> & { owner: RefType['IpAllowListOwner'] } ) | ( Issue ) | ( IssueComment ) | ( Label ) | ( LabeledEvent ) | ( Language ) | ( License ) | ( LinkedBranch ) | ( LockedEvent ) | ( Mannequin ) | ( Omit<MarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<RefType['IssueOrPullRequest']>, duplicate?: Maybe<RefType['IssueOrPullRequest']> } ) | ( MarketplaceCategory ) | ( MarketplaceListing ) | ( MemberFeatureRequestNotification ) | ( Omit<MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( MentionedEvent ) | ( MergeQueue ) | ( MergeQueueEntry ) | ( MergedEvent ) | ( MigrationSource ) | ( Milestone ) | ( Omit<MilestonedEvent, 'subject'> & { subject: RefType['MilestoneItem'] } ) | ( MovedColumnsInProjectEvent ) | ( OIDCProvider ) | ( Omit<OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<RefType['AuditEntryActor']>, restoredMemberships?: Maybe<Array<RefType['OrgRestoreMemberAuditEntryMembership']>> } ) | ( Omit<OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Organization ) | ( OrganizationIdentityProvider ) | ( OrganizationInvitation ) | ( OrganizationMigration ) | ( Package ) | ( PackageFile ) | ( PackageTag ) | ( PackageVersion ) | ( PinnedDiscussion ) | ( PinnedEvent ) | ( PinnedIssue ) | ( Omit<PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Project ) | ( Omit<ProjectCard, 'content'> & { content?: Maybe<RefType['ProjectCardItem']> } ) | ( ProjectColumn ) | ( Omit<ProjectV2, 'field'> & { field?: Maybe<RefType['ProjectV2FieldConfiguration']> } ) | ( ProjectV2Field ) | ( Omit<ProjectV2Item, 'content' | 'fieldValueByName'> & { content?: Maybe<RefType['ProjectV2ItemContent']>, fieldValueByName?: Maybe<RefType['ProjectV2ItemFieldValue']> } ) | ( Omit<ProjectV2ItemFieldDateValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldIterationValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldNumberValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldSingleSelectValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldTextValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( ProjectV2IterationField ) | ( ProjectV2SingleSelectField ) | ( ProjectV2View ) | ( ProjectV2Workflow ) | ( PublicKey ) | ( PullRequest ) | ( PullRequestCommit ) | ( PullRequestCommitCommentThread ) | ( PullRequestReview ) | ( PullRequestReviewComment ) | ( PullRequestReviewThread ) | ( PullRequestThread ) | ( Push ) | ( Omit<PushAllowance, 'actor'> & { actor?: Maybe<RefType['PushAllowanceActor']> } ) | ( Reaction ) | ( ReadyForReviewEvent ) | ( Ref ) | ( Omit<ReferencedEvent, 'subject'> & { subject: RefType['ReferencedSubject'] } ) | ( Release ) | ( ReleaseAsset ) | ( RemovedFromMergeQueueEvent ) | ( RemovedFromProjectEvent ) | ( Omit<RenamedTitleEvent, 'subject'> & { subject: RefType['RenamedTitleSubject'] } ) | ( ReopenedEvent ) | ( Omit<RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } ) | ( RepositoryInvitation ) | ( RepositoryMigration ) | ( Omit<RepositoryRule, 'parameters'> & { parameters?: Maybe<RefType['RuleParameters']> } ) | ( Omit<RepositoryRuleset, 'source'> & { source: RefType['RuleSource'] } ) | ( Omit<RepositoryRulesetBypassActor, 'actor'> & { actor?: Maybe<RefType['BypassActor']> } ) | ( RepositoryTopic ) | ( Omit<RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( RepositoryVulnerabilityAlert ) | ( Omit<ReviewDismissalAllowance, 'actor'> & { actor?: Maybe<RefType['ReviewDismissalAllowanceActor']> } ) | ( ReviewDismissedEvent ) | ( Omit<ReviewRequest, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['RequestedReviewer']> } ) | ( Omit<ReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['RequestedReviewer']> } ) | ( Omit<ReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['RequestedReviewer']> } ) | ( SavedReply ) | ( SecurityAdvisory ) | ( Omit<SponsorsActivity, 'sponsor'> & { sponsor?: Maybe<RefType['Sponsor']> } ) | ( SponsorsListing ) | ( Omit<SponsorsListingFeaturedItem, 'featureable'> & { featureable: RefType['SponsorsListingFeatureableItem'] } ) | ( SponsorsTier ) | ( Omit<Sponsorship, 'sponsorEntity'> & { sponsorEntity?: Maybe<RefType['Sponsor']> } ) | ( SponsorshipNewsletter ) | ( Status ) | ( StatusCheckRollup ) | ( StatusContext ) | ( SubscribedEvent ) | ( Tag ) | ( Team ) | ( Omit<TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( TeamDiscussion ) | ( TeamDiscussionComment ) | ( Omit<TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Topic ) | ( TransferredEvent ) | ( Tree ) | ( Omit<UnassignedEvent, 'assignee'> & { assignee?: Maybe<RefType['Assignee']> } ) | ( UnlabeledEvent ) | ( UnlockedEvent ) | ( Omit<UnmarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<RefType['IssueOrPullRequest']>, duplicate?: Maybe<RefType['IssueOrPullRequest']> } ) | ( UnpinnedEvent ) | ( UnsubscribedEvent ) | ( User ) | ( UserBlockedEvent ) | ( UserContentEdit ) | ( UserList ) | ( UserStatus ) | ( Omit<VerifiableDomain, 'owner'> & { owner: RefType['VerifiableDomainOwner'] } ) | ( Workflow ) | ( WorkflowRun ) | ( WorkflowRunFile );
  OauthApplicationAuditEntryData: ( Omit<OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } );
  OrganizationAuditEntryData: ( Omit<MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<RefType['AuditEntryActor']>, restoredMemberships?: Maybe<Array<RefType['OrgRestoreMemberAuditEntryMembership']>> } ) | ( OrgRestoreMemberMembershipOrganizationAuditEntryData ) | ( Omit<OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } );
  PackageOwner: ( Organization ) | ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } ) | ( User );
  ProfileOwner: ( Organization ) | ( User );
  ProjectOwner: ( Organization ) | ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } ) | ( User );
  ProjectV2FieldCommon: ( ProjectV2Field ) | ( ProjectV2IterationField ) | ( ProjectV2SingleSelectField );
  ProjectV2ItemFieldValueCommon: ( Omit<ProjectV2ItemFieldDateValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldIterationValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldNumberValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldSingleSelectValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } ) | ( Omit<ProjectV2ItemFieldTextValue, 'field'> & { field: RefType['ProjectV2FieldConfiguration'] } );
  ProjectV2Owner: ( Issue ) | ( Organization ) | ( PullRequest ) | ( User );
  ProjectV2Recent: ( Organization ) | ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } ) | ( User );
  Reactable: ( CommitComment ) | ( Discussion ) | ( DiscussionComment ) | ( Issue ) | ( IssueComment ) | ( PullRequest ) | ( PullRequestReview ) | ( PullRequestReviewComment ) | ( Release ) | ( TeamDiscussion ) | ( TeamDiscussionComment );
  RepositoryAuditEntryData: ( OrgRestoreMemberMembershipRepositoryAuditEntryData ) | ( Omit<PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } );
  RepositoryDiscussionAuthor: ( Organization ) | ( User );
  RepositoryDiscussionCommentAuthor: ( Organization ) | ( User );
  RepositoryInfo: ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } );
  RepositoryNode: ( CommitComment ) | ( CommitCommentThread ) | ( DependabotUpdate ) | ( Discussion ) | ( DiscussionCategory ) | ( Issue ) | ( IssueComment ) | ( PinnedDiscussion ) | ( PullRequest ) | ( PullRequestCommitCommentThread ) | ( PullRequestReview ) | ( PullRequestReviewComment ) | ( RepositoryVulnerabilityAlert );
  RepositoryOwner: ( Organization ) | ( User );
  RequirableByPullRequest: ( CheckRun ) | ( StatusContext );
  Sponsorable: ( Organization ) | ( User );
  Starrable: ( Gist ) | ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } ) | ( Topic );
  Subscribable: ( Commit ) | ( Discussion ) | ( Issue ) | ( PullRequest ) | ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } ) | ( Team ) | ( TeamDiscussion );
  SubscribableThread: ( Issue );
  TeamAuditEntryData: ( OrgRestoreMemberMembershipTeamAuditEntryData ) | ( Omit<TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } );
  TopicAuditEntryData: ( Omit<RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } ) | ( Omit<RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['AuditEntryActor']> } );
  UniformResourceLocatable: ( Bot ) | ( CheckRun ) | ( Omit<ClosedEvent, 'closer'> & { closer?: Maybe<RefType['Closer']> } ) | ( Commit ) | ( ConvertToDraftEvent ) | ( Omit<CrossReferencedEvent, 'source' | 'target'> & { source: RefType['ReferencedSubject'], target: RefType['ReferencedSubject'] } ) | ( Gist ) | ( Issue ) | ( Mannequin ) | ( MergedEvent ) | ( Milestone ) | ( Organization ) | ( PullRequest ) | ( PullRequestCommit ) | ( ReadyForReviewEvent ) | ( Release ) | ( Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['IssueOrPullRequest']> } ) | ( RepositoryTopic ) | ( ReviewDismissedEvent ) | ( TeamDiscussion ) | ( TeamDiscussionComment ) | ( User ) | ( Workflow ) | ( WorkflowRun ) | ( WorkflowRunFile );
  Updatable: ( CommitComment ) | ( Discussion ) | ( DiscussionComment ) | ( GistComment ) | ( Issue ) | ( IssueComment ) | ( Project ) | ( Omit<ProjectV2, 'field'> & { field?: Maybe<RefType['ProjectV2FieldConfiguration']> } ) | ( PullRequest ) | ( PullRequestReview ) | ( PullRequestReviewComment ) | ( TeamDiscussion ) | ( TeamDiscussionComment );
  UpdatableComment: ( CommitComment ) | ( DiscussionComment ) | ( GistComment ) | ( Issue ) | ( IssueComment ) | ( PullRequest ) | ( PullRequestReview ) | ( PullRequestReviewComment ) | ( TeamDiscussion ) | ( TeamDiscussionComment );
  Votable: ( Discussion ) | ( DiscussionComment );
}>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  AbortQueuedMigrationsInput: AbortQueuedMigrationsInput;
  String: ResolverTypeWrapper<Scalars['String']['output']>;
  ID: ResolverTypeWrapper<Scalars['ID']['output']>;
  AbortQueuedMigrationsPayload: ResolverTypeWrapper<AbortQueuedMigrationsPayload>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
  AbortRepositoryMigrationInput: AbortRepositoryMigrationInput;
  AbortRepositoryMigrationPayload: ResolverTypeWrapper<AbortRepositoryMigrationPayload>;
  AcceptEnterpriseAdministratorInvitationInput: AcceptEnterpriseAdministratorInvitationInput;
  AcceptEnterpriseAdministratorInvitationPayload: ResolverTypeWrapper<AcceptEnterpriseAdministratorInvitationPayload>;
  AcceptTopicSuggestionInput: AcceptTopicSuggestionInput;
  AcceptTopicSuggestionPayload: ResolverTypeWrapper<AcceptTopicSuggestionPayload>;
  Actor: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Actor']>;
  Int: ResolverTypeWrapper<Scalars['Int']['output']>;
  ActorLocation: ResolverTypeWrapper<ActorLocation>;
  ActorType: ActorType;
  AddAssigneesToAssignableInput: AddAssigneesToAssignableInput;
  AddAssigneesToAssignablePayload: ResolverTypeWrapper<AddAssigneesToAssignablePayload>;
  AddCommentInput: AddCommentInput;
  AddCommentPayload: ResolverTypeWrapper<AddCommentPayload>;
  AddDiscussionCommentInput: AddDiscussionCommentInput;
  AddDiscussionCommentPayload: ResolverTypeWrapper<AddDiscussionCommentPayload>;
  AddDiscussionPollVoteInput: AddDiscussionPollVoteInput;
  AddDiscussionPollVotePayload: ResolverTypeWrapper<AddDiscussionPollVotePayload>;
  AddEnterpriseOrganizationMemberInput: AddEnterpriseOrganizationMemberInput;
  AddEnterpriseOrganizationMemberPayload: ResolverTypeWrapper<AddEnterpriseOrganizationMemberPayload>;
  AddEnterpriseSupportEntitlementInput: AddEnterpriseSupportEntitlementInput;
  AddEnterpriseSupportEntitlementPayload: ResolverTypeWrapper<AddEnterpriseSupportEntitlementPayload>;
  AddLabelsToLabelableInput: AddLabelsToLabelableInput;
  AddLabelsToLabelablePayload: ResolverTypeWrapper<AddLabelsToLabelablePayload>;
  AddProjectCardInput: AddProjectCardInput;
  AddProjectCardPayload: ResolverTypeWrapper<AddProjectCardPayload>;
  AddProjectColumnInput: AddProjectColumnInput;
  AddProjectColumnPayload: ResolverTypeWrapper<AddProjectColumnPayload>;
  AddProjectV2DraftIssueInput: AddProjectV2DraftIssueInput;
  AddProjectV2DraftIssuePayload: ResolverTypeWrapper<AddProjectV2DraftIssuePayload>;
  AddProjectV2ItemByIdInput: AddProjectV2ItemByIdInput;
  AddProjectV2ItemByIdPayload: ResolverTypeWrapper<AddProjectV2ItemByIdPayload>;
  AddPullRequestReviewCommentInput: AddPullRequestReviewCommentInput;
  AddPullRequestReviewCommentPayload: ResolverTypeWrapper<AddPullRequestReviewCommentPayload>;
  AddPullRequestReviewInput: AddPullRequestReviewInput;
  AddPullRequestReviewPayload: ResolverTypeWrapper<AddPullRequestReviewPayload>;
  AddPullRequestReviewThreadInput: AddPullRequestReviewThreadInput;
  AddPullRequestReviewThreadPayload: ResolverTypeWrapper<AddPullRequestReviewThreadPayload>;
  AddPullRequestReviewThreadReplyInput: AddPullRequestReviewThreadReplyInput;
  AddPullRequestReviewThreadReplyPayload: ResolverTypeWrapper<AddPullRequestReviewThreadReplyPayload>;
  AddReactionInput: AddReactionInput;
  AddReactionPayload: ResolverTypeWrapper<AddReactionPayload>;
  AddStarInput: AddStarInput;
  AddStarPayload: ResolverTypeWrapper<AddStarPayload>;
  AddUpvoteInput: AddUpvoteInput;
  AddUpvotePayload: ResolverTypeWrapper<AddUpvotePayload>;
  AddVerifiableDomainInput: AddVerifiableDomainInput;
  AddVerifiableDomainPayload: ResolverTypeWrapper<AddVerifiableDomainPayload>;
  AddedToMergeQueueEvent: ResolverTypeWrapper<AddedToMergeQueueEvent>;
  AddedToProjectEvent: ResolverTypeWrapper<AddedToProjectEvent>;
  AnnouncementBanner: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['AnnouncementBanner']>;
  App: ResolverTypeWrapper<App>;
  ApproveDeploymentsInput: ApproveDeploymentsInput;
  ApproveDeploymentsPayload: ResolverTypeWrapper<ApproveDeploymentsPayload>;
  ApproveVerifiableDomainInput: ApproveVerifiableDomainInput;
  ApproveVerifiableDomainPayload: ResolverTypeWrapper<ApproveVerifiableDomainPayload>;
  ArchiveProjectV2ItemInput: ArchiveProjectV2ItemInput;
  ArchiveProjectV2ItemPayload: ResolverTypeWrapper<ArchiveProjectV2ItemPayload>;
  ArchiveRepositoryInput: ArchiveRepositoryInput;
  ArchiveRepositoryPayload: ResolverTypeWrapper<ArchiveRepositoryPayload>;
  Assignable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Assignable']>;
  AssignedEvent: ResolverTypeWrapper<Omit<AssignedEvent, 'assignee'> & { assignee?: Maybe<ResolversTypes['Assignee']> }>;
  Assignee: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Assignee']>;
  AuditEntry: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['AuditEntry']>;
  AuditEntryActor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['AuditEntryActor']>;
  AuditLogOrder: AuditLogOrder;
  AuditLogOrderField: AuditLogOrderField;
  AutoMergeDisabledEvent: ResolverTypeWrapper<AutoMergeDisabledEvent>;
  AutoMergeEnabledEvent: ResolverTypeWrapper<AutoMergeEnabledEvent>;
  AutoMergeRequest: ResolverTypeWrapper<AutoMergeRequest>;
  AutoRebaseEnabledEvent: ResolverTypeWrapper<AutoRebaseEnabledEvent>;
  AutoSquashEnabledEvent: ResolverTypeWrapper<AutoSquashEnabledEvent>;
  AutomaticBaseChangeFailedEvent: ResolverTypeWrapper<AutomaticBaseChangeFailedEvent>;
  AutomaticBaseChangeSucceededEvent: ResolverTypeWrapper<AutomaticBaseChangeSucceededEvent>;
  Base64String: ResolverTypeWrapper<Scalars['Base64String']['output']>;
  BaseRefChangedEvent: ResolverTypeWrapper<BaseRefChangedEvent>;
  BaseRefDeletedEvent: ResolverTypeWrapper<BaseRefDeletedEvent>;
  BaseRefForcePushedEvent: ResolverTypeWrapper<BaseRefForcePushedEvent>;
  BigInt: ResolverTypeWrapper<Scalars['BigInt']['output']>;
  Blame: ResolverTypeWrapper<Blame>;
  BlameRange: ResolverTypeWrapper<BlameRange>;
  Blob: ResolverTypeWrapper<Blob>;
  Bot: ResolverTypeWrapper<Bot>;
  BranchActorAllowanceActor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['BranchActorAllowanceActor']>;
  BranchNamePatternParameters: ResolverTypeWrapper<BranchNamePatternParameters>;
  BranchNamePatternParametersInput: BranchNamePatternParametersInput;
  BranchProtectionRule: ResolverTypeWrapper<BranchProtectionRule>;
  BranchProtectionRuleConflict: ResolverTypeWrapper<BranchProtectionRuleConflict>;
  BranchProtectionRuleConflictConnection: ResolverTypeWrapper<BranchProtectionRuleConflictConnection>;
  BranchProtectionRuleConflictEdge: ResolverTypeWrapper<BranchProtectionRuleConflictEdge>;
  BranchProtectionRuleConnection: ResolverTypeWrapper<BranchProtectionRuleConnection>;
  BranchProtectionRuleEdge: ResolverTypeWrapper<BranchProtectionRuleEdge>;
  BulkSponsorship: BulkSponsorship;
  BypassActor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['BypassActor']>;
  BypassForcePushAllowance: ResolverTypeWrapper<Omit<BypassForcePushAllowance, 'actor'> & { actor?: Maybe<ResolversTypes['BranchActorAllowanceActor']> }>;
  BypassForcePushAllowanceConnection: ResolverTypeWrapper<BypassForcePushAllowanceConnection>;
  BypassForcePushAllowanceEdge: ResolverTypeWrapper<BypassForcePushAllowanceEdge>;
  BypassPullRequestAllowance: ResolverTypeWrapper<Omit<BypassPullRequestAllowance, 'actor'> & { actor?: Maybe<ResolversTypes['BranchActorAllowanceActor']> }>;
  BypassPullRequestAllowanceConnection: ResolverTypeWrapper<BypassPullRequestAllowanceConnection>;
  BypassPullRequestAllowanceEdge: ResolverTypeWrapper<BypassPullRequestAllowanceEdge>;
  CVSS: ResolverTypeWrapper<CVSS>;
  Float: ResolverTypeWrapper<Scalars['Float']['output']>;
  CWE: ResolverTypeWrapper<CWE>;
  CWEConnection: ResolverTypeWrapper<CWEConnection>;
  CWEEdge: ResolverTypeWrapper<CWEEdge>;
  CancelEnterpriseAdminInvitationInput: CancelEnterpriseAdminInvitationInput;
  CancelEnterpriseAdminInvitationPayload: ResolverTypeWrapper<CancelEnterpriseAdminInvitationPayload>;
  CancelSponsorshipInput: CancelSponsorshipInput;
  CancelSponsorshipPayload: ResolverTypeWrapper<CancelSponsorshipPayload>;
  ChangeUserStatusInput: ChangeUserStatusInput;
  ChangeUserStatusPayload: ResolverTypeWrapper<ChangeUserStatusPayload>;
  CheckAnnotation: ResolverTypeWrapper<CheckAnnotation>;
  CheckAnnotationConnection: ResolverTypeWrapper<CheckAnnotationConnection>;
  CheckAnnotationData: CheckAnnotationData;
  CheckAnnotationEdge: ResolverTypeWrapper<CheckAnnotationEdge>;
  CheckAnnotationLevel: CheckAnnotationLevel;
  CheckAnnotationPosition: ResolverTypeWrapper<CheckAnnotationPosition>;
  CheckAnnotationRange: CheckAnnotationRange;
  CheckAnnotationSpan: ResolverTypeWrapper<CheckAnnotationSpan>;
  CheckConclusionState: CheckConclusionState;
  CheckRun: ResolverTypeWrapper<CheckRun>;
  CheckRunAction: CheckRunAction;
  CheckRunConnection: ResolverTypeWrapper<CheckRunConnection>;
  CheckRunEdge: ResolverTypeWrapper<CheckRunEdge>;
  CheckRunFilter: CheckRunFilter;
  CheckRunOutput: CheckRunOutput;
  CheckRunOutputImage: CheckRunOutputImage;
  CheckRunState: CheckRunState;
  CheckRunStateCount: ResolverTypeWrapper<CheckRunStateCount>;
  CheckRunType: CheckRunType;
  CheckStatusState: CheckStatusState;
  CheckStep: ResolverTypeWrapper<CheckStep>;
  CheckStepConnection: ResolverTypeWrapper<CheckStepConnection>;
  CheckStepEdge: ResolverTypeWrapper<CheckStepEdge>;
  CheckSuite: ResolverTypeWrapper<CheckSuite>;
  CheckSuiteAutoTriggerPreference: CheckSuiteAutoTriggerPreference;
  CheckSuiteConnection: ResolverTypeWrapper<CheckSuiteConnection>;
  CheckSuiteEdge: ResolverTypeWrapper<CheckSuiteEdge>;
  CheckSuiteFilter: CheckSuiteFilter;
  Claimable: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Claimable']>;
  ClearLabelsFromLabelableInput: ClearLabelsFromLabelableInput;
  ClearLabelsFromLabelablePayload: ResolverTypeWrapper<ClearLabelsFromLabelablePayload>;
  ClearProjectV2ItemFieldValueInput: ClearProjectV2ItemFieldValueInput;
  ClearProjectV2ItemFieldValuePayload: ResolverTypeWrapper<ClearProjectV2ItemFieldValuePayload>;
  CloneProjectInput: CloneProjectInput;
  CloneProjectPayload: ResolverTypeWrapper<CloneProjectPayload>;
  CloneTemplateRepositoryInput: CloneTemplateRepositoryInput;
  CloneTemplateRepositoryPayload: ResolverTypeWrapper<CloneTemplateRepositoryPayload>;
  Closable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Closable']>;
  CloseDiscussionInput: CloseDiscussionInput;
  CloseDiscussionPayload: ResolverTypeWrapper<CloseDiscussionPayload>;
  CloseIssueInput: CloseIssueInput;
  CloseIssuePayload: ResolverTypeWrapper<CloseIssuePayload>;
  ClosePullRequestInput: ClosePullRequestInput;
  ClosePullRequestPayload: ResolverTypeWrapper<ClosePullRequestPayload>;
  ClosedEvent: ResolverTypeWrapper<Omit<ClosedEvent, 'closer'> & { closer?: Maybe<ResolversTypes['Closer']> }>;
  Closer: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Closer']>;
  CodeOfConduct: ResolverTypeWrapper<CodeOfConduct>;
  CollaboratorAffiliation: CollaboratorAffiliation;
  Comment: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Comment']>;
  CommentAuthorAssociation: CommentAuthorAssociation;
  CommentCannotUpdateReason: CommentCannotUpdateReason;
  CommentDeletedEvent: ResolverTypeWrapper<CommentDeletedEvent>;
  Commit: ResolverTypeWrapper<Commit>;
  CommitAuthor: CommitAuthor;
  CommitAuthorEmailPatternParameters: ResolverTypeWrapper<CommitAuthorEmailPatternParameters>;
  CommitAuthorEmailPatternParametersInput: CommitAuthorEmailPatternParametersInput;
  CommitComment: ResolverTypeWrapper<CommitComment>;
  CommitCommentConnection: ResolverTypeWrapper<CommitCommentConnection>;
  CommitCommentEdge: ResolverTypeWrapper<CommitCommentEdge>;
  CommitCommentThread: ResolverTypeWrapper<CommitCommentThread>;
  CommitConnection: ResolverTypeWrapper<CommitConnection>;
  CommitContributionOrder: CommitContributionOrder;
  CommitContributionOrderField: CommitContributionOrderField;
  CommitContributionsByRepository: ResolverTypeWrapper<CommitContributionsByRepository>;
  CommitEdge: ResolverTypeWrapper<CommitEdge>;
  CommitHistoryConnection: ResolverTypeWrapper<CommitHistoryConnection>;
  CommitMessage: CommitMessage;
  CommitMessagePatternParameters: ResolverTypeWrapper<CommitMessagePatternParameters>;
  CommitMessagePatternParametersInput: CommitMessagePatternParametersInput;
  CommittableBranch: CommittableBranch;
  CommitterEmailPatternParameters: ResolverTypeWrapper<CommitterEmailPatternParameters>;
  CommitterEmailPatternParametersInput: CommitterEmailPatternParametersInput;
  Comparison: ResolverTypeWrapper<Comparison>;
  ComparisonCommitConnection: ResolverTypeWrapper<ComparisonCommitConnection>;
  ComparisonStatus: ComparisonStatus;
  ConnectedEvent: ResolverTypeWrapper<Omit<ConnectedEvent, 'source' | 'subject'> & { source: ResolversTypes['ReferencedSubject'], subject: ResolversTypes['ReferencedSubject'] }>;
  ContributingGuidelines: ResolverTypeWrapper<ContributingGuidelines>;
  Contribution: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Contribution']>;
  ContributionCalendar: ResolverTypeWrapper<ContributionCalendar>;
  ContributionCalendarDay: ResolverTypeWrapper<ContributionCalendarDay>;
  ContributionCalendarMonth: ResolverTypeWrapper<ContributionCalendarMonth>;
  ContributionCalendarWeek: ResolverTypeWrapper<ContributionCalendarWeek>;
  ContributionLevel: ContributionLevel;
  ContributionOrder: ContributionOrder;
  ContributionsCollection: ResolverTypeWrapper<Omit<ContributionsCollection, 'firstIssueContribution' | 'firstPullRequestContribution' | 'firstRepositoryContribution'> & { firstIssueContribution?: Maybe<ResolversTypes['CreatedIssueOrRestrictedContribution']>, firstPullRequestContribution?: Maybe<ResolversTypes['CreatedPullRequestOrRestrictedContribution']>, firstRepositoryContribution?: Maybe<ResolversTypes['CreatedRepositoryOrRestrictedContribution']> }>;
  ConvertProjectCardNoteToIssueInput: ConvertProjectCardNoteToIssueInput;
  ConvertProjectCardNoteToIssuePayload: ResolverTypeWrapper<ConvertProjectCardNoteToIssuePayload>;
  ConvertPullRequestToDraftInput: ConvertPullRequestToDraftInput;
  ConvertPullRequestToDraftPayload: ResolverTypeWrapper<ConvertPullRequestToDraftPayload>;
  ConvertToDraftEvent: ResolverTypeWrapper<ConvertToDraftEvent>;
  ConvertedNoteToIssueEvent: ResolverTypeWrapper<ConvertedNoteToIssueEvent>;
  ConvertedToDiscussionEvent: ResolverTypeWrapper<ConvertedToDiscussionEvent>;
  CopyProjectV2Input: CopyProjectV2Input;
  CopyProjectV2Payload: ResolverTypeWrapper<CopyProjectV2Payload>;
  CreateAttributionInvitationInput: CreateAttributionInvitationInput;
  CreateAttributionInvitationPayload: ResolverTypeWrapper<Omit<CreateAttributionInvitationPayload, 'source' | 'target'> & { source?: Maybe<ResolversTypes['Claimable']>, target?: Maybe<ResolversTypes['Claimable']> }>;
  CreateBranchProtectionRuleInput: CreateBranchProtectionRuleInput;
  CreateBranchProtectionRulePayload: ResolverTypeWrapper<CreateBranchProtectionRulePayload>;
  CreateCheckRunInput: CreateCheckRunInput;
  CreateCheckRunPayload: ResolverTypeWrapper<CreateCheckRunPayload>;
  CreateCheckSuiteInput: CreateCheckSuiteInput;
  CreateCheckSuitePayload: ResolverTypeWrapper<CreateCheckSuitePayload>;
  CreateCommitOnBranchInput: CreateCommitOnBranchInput;
  CreateCommitOnBranchPayload: ResolverTypeWrapper<CreateCommitOnBranchPayload>;
  CreateDeploymentInput: CreateDeploymentInput;
  CreateDeploymentPayload: ResolverTypeWrapper<CreateDeploymentPayload>;
  CreateDeploymentStatusInput: CreateDeploymentStatusInput;
  CreateDeploymentStatusPayload: ResolverTypeWrapper<CreateDeploymentStatusPayload>;
  CreateDiscussionInput: CreateDiscussionInput;
  CreateDiscussionPayload: ResolverTypeWrapper<CreateDiscussionPayload>;
  CreateEnterpriseOrganizationInput: CreateEnterpriseOrganizationInput;
  CreateEnterpriseOrganizationPayload: ResolverTypeWrapper<CreateEnterpriseOrganizationPayload>;
  CreateEnvironmentInput: CreateEnvironmentInput;
  CreateEnvironmentPayload: ResolverTypeWrapper<CreateEnvironmentPayload>;
  CreateIpAllowListEntryInput: CreateIpAllowListEntryInput;
  CreateIpAllowListEntryPayload: ResolverTypeWrapper<CreateIpAllowListEntryPayload>;
  CreateIssueInput: CreateIssueInput;
  CreateIssuePayload: ResolverTypeWrapper<CreateIssuePayload>;
  CreateLabelInput: CreateLabelInput;
  CreateLabelPayload: ResolverTypeWrapper<CreateLabelPayload>;
  CreateLinkedBranchInput: CreateLinkedBranchInput;
  CreateLinkedBranchPayload: ResolverTypeWrapper<CreateLinkedBranchPayload>;
  CreateMigrationSourceInput: CreateMigrationSourceInput;
  CreateMigrationSourcePayload: ResolverTypeWrapper<CreateMigrationSourcePayload>;
  CreateProjectInput: CreateProjectInput;
  CreateProjectPayload: ResolverTypeWrapper<CreateProjectPayload>;
  CreateProjectV2FieldInput: CreateProjectV2FieldInput;
  CreateProjectV2FieldPayload: ResolverTypeWrapper<Omit<CreateProjectV2FieldPayload, 'projectV2Field'> & { projectV2Field?: Maybe<ResolversTypes['ProjectV2FieldConfiguration']> }>;
  CreateProjectV2Input: CreateProjectV2Input;
  CreateProjectV2Payload: ResolverTypeWrapper<CreateProjectV2Payload>;
  CreatePullRequestInput: CreatePullRequestInput;
  CreatePullRequestPayload: ResolverTypeWrapper<CreatePullRequestPayload>;
  CreateRefInput: CreateRefInput;
  CreateRefPayload: ResolverTypeWrapper<CreateRefPayload>;
  CreateRepositoryInput: CreateRepositoryInput;
  CreateRepositoryPayload: ResolverTypeWrapper<CreateRepositoryPayload>;
  CreateRepositoryRulesetInput: CreateRepositoryRulesetInput;
  CreateRepositoryRulesetPayload: ResolverTypeWrapper<CreateRepositoryRulesetPayload>;
  CreateSponsorsListingInput: CreateSponsorsListingInput;
  CreateSponsorsListingPayload: ResolverTypeWrapper<CreateSponsorsListingPayload>;
  CreateSponsorsTierInput: CreateSponsorsTierInput;
  CreateSponsorsTierPayload: ResolverTypeWrapper<CreateSponsorsTierPayload>;
  CreateSponsorshipInput: CreateSponsorshipInput;
  CreateSponsorshipPayload: ResolverTypeWrapper<CreateSponsorshipPayload>;
  CreateSponsorshipsInput: CreateSponsorshipsInput;
  CreateSponsorshipsPayload: ResolverTypeWrapper<CreateSponsorshipsPayload>;
  CreateTeamDiscussionCommentInput: CreateTeamDiscussionCommentInput;
  CreateTeamDiscussionCommentPayload: ResolverTypeWrapper<CreateTeamDiscussionCommentPayload>;
  CreateTeamDiscussionInput: CreateTeamDiscussionInput;
  CreateTeamDiscussionPayload: ResolverTypeWrapper<CreateTeamDiscussionPayload>;
  CreateUserListInput: CreateUserListInput;
  CreateUserListPayload: ResolverTypeWrapper<CreateUserListPayload>;
  CreatedCommitContribution: ResolverTypeWrapper<CreatedCommitContribution>;
  CreatedCommitContributionConnection: ResolverTypeWrapper<CreatedCommitContributionConnection>;
  CreatedCommitContributionEdge: ResolverTypeWrapper<CreatedCommitContributionEdge>;
  CreatedIssueContribution: ResolverTypeWrapper<CreatedIssueContribution>;
  CreatedIssueContributionConnection: ResolverTypeWrapper<CreatedIssueContributionConnection>;
  CreatedIssueContributionEdge: ResolverTypeWrapper<CreatedIssueContributionEdge>;
  CreatedIssueOrRestrictedContribution: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CreatedIssueOrRestrictedContribution']>;
  CreatedPullRequestContribution: ResolverTypeWrapper<CreatedPullRequestContribution>;
  CreatedPullRequestContributionConnection: ResolverTypeWrapper<CreatedPullRequestContributionConnection>;
  CreatedPullRequestContributionEdge: ResolverTypeWrapper<CreatedPullRequestContributionEdge>;
  CreatedPullRequestOrRestrictedContribution: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CreatedPullRequestOrRestrictedContribution']>;
  CreatedPullRequestReviewContribution: ResolverTypeWrapper<CreatedPullRequestReviewContribution>;
  CreatedPullRequestReviewContributionConnection: ResolverTypeWrapper<CreatedPullRequestReviewContributionConnection>;
  CreatedPullRequestReviewContributionEdge: ResolverTypeWrapper<CreatedPullRequestReviewContributionEdge>;
  CreatedRepositoryContribution: ResolverTypeWrapper<CreatedRepositoryContribution>;
  CreatedRepositoryContributionConnection: ResolverTypeWrapper<CreatedRepositoryContributionConnection>;
  CreatedRepositoryContributionEdge: ResolverTypeWrapper<CreatedRepositoryContributionEdge>;
  CreatedRepositoryOrRestrictedContribution: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CreatedRepositoryOrRestrictedContribution']>;
  CrossReferencedEvent: ResolverTypeWrapper<Omit<CrossReferencedEvent, 'source' | 'target'> & { source: ResolversTypes['ReferencedSubject'], target: ResolversTypes['ReferencedSubject'] }>;
  Date: ResolverTypeWrapper<Scalars['Date']['output']>;
  DateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;
  DeclineTopicSuggestionInput: DeclineTopicSuggestionInput;
  DeclineTopicSuggestionPayload: ResolverTypeWrapper<DeclineTopicSuggestionPayload>;
  DefaultRepositoryPermissionField: DefaultRepositoryPermissionField;
  Deletable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Deletable']>;
  DeleteBranchProtectionRuleInput: DeleteBranchProtectionRuleInput;
  DeleteBranchProtectionRulePayload: ResolverTypeWrapper<DeleteBranchProtectionRulePayload>;
  DeleteDeploymentInput: DeleteDeploymentInput;
  DeleteDeploymentPayload: ResolverTypeWrapper<DeleteDeploymentPayload>;
  DeleteDiscussionCommentInput: DeleteDiscussionCommentInput;
  DeleteDiscussionCommentPayload: ResolverTypeWrapper<DeleteDiscussionCommentPayload>;
  DeleteDiscussionInput: DeleteDiscussionInput;
  DeleteDiscussionPayload: ResolverTypeWrapper<DeleteDiscussionPayload>;
  DeleteEnvironmentInput: DeleteEnvironmentInput;
  DeleteEnvironmentPayload: ResolverTypeWrapper<DeleteEnvironmentPayload>;
  DeleteIpAllowListEntryInput: DeleteIpAllowListEntryInput;
  DeleteIpAllowListEntryPayload: ResolverTypeWrapper<DeleteIpAllowListEntryPayload>;
  DeleteIssueCommentInput: DeleteIssueCommentInput;
  DeleteIssueCommentPayload: ResolverTypeWrapper<DeleteIssueCommentPayload>;
  DeleteIssueInput: DeleteIssueInput;
  DeleteIssuePayload: ResolverTypeWrapper<DeleteIssuePayload>;
  DeleteLabelInput: DeleteLabelInput;
  DeleteLabelPayload: ResolverTypeWrapper<DeleteLabelPayload>;
  DeleteLinkedBranchInput: DeleteLinkedBranchInput;
  DeleteLinkedBranchPayload: ResolverTypeWrapper<DeleteLinkedBranchPayload>;
  DeletePackageVersionInput: DeletePackageVersionInput;
  DeletePackageVersionPayload: ResolverTypeWrapper<DeletePackageVersionPayload>;
  DeleteProjectCardInput: DeleteProjectCardInput;
  DeleteProjectCardPayload: ResolverTypeWrapper<DeleteProjectCardPayload>;
  DeleteProjectColumnInput: DeleteProjectColumnInput;
  DeleteProjectColumnPayload: ResolverTypeWrapper<DeleteProjectColumnPayload>;
  DeleteProjectInput: DeleteProjectInput;
  DeleteProjectPayload: ResolverTypeWrapper<DeleteProjectPayload>;
  DeleteProjectV2FieldInput: DeleteProjectV2FieldInput;
  DeleteProjectV2FieldPayload: ResolverTypeWrapper<Omit<DeleteProjectV2FieldPayload, 'projectV2Field'> & { projectV2Field?: Maybe<ResolversTypes['ProjectV2FieldConfiguration']> }>;
  DeleteProjectV2Input: DeleteProjectV2Input;
  DeleteProjectV2ItemInput: DeleteProjectV2ItemInput;
  DeleteProjectV2ItemPayload: ResolverTypeWrapper<DeleteProjectV2ItemPayload>;
  DeleteProjectV2Payload: ResolverTypeWrapper<DeleteProjectV2Payload>;
  DeleteProjectV2WorkflowInput: DeleteProjectV2WorkflowInput;
  DeleteProjectV2WorkflowPayload: ResolverTypeWrapper<DeleteProjectV2WorkflowPayload>;
  DeletePullRequestReviewCommentInput: DeletePullRequestReviewCommentInput;
  DeletePullRequestReviewCommentPayload: ResolverTypeWrapper<DeletePullRequestReviewCommentPayload>;
  DeletePullRequestReviewInput: DeletePullRequestReviewInput;
  DeletePullRequestReviewPayload: ResolverTypeWrapper<DeletePullRequestReviewPayload>;
  DeleteRefInput: DeleteRefInput;
  DeleteRefPayload: ResolverTypeWrapper<DeleteRefPayload>;
  DeleteRepositoryRulesetInput: DeleteRepositoryRulesetInput;
  DeleteRepositoryRulesetPayload: ResolverTypeWrapper<DeleteRepositoryRulesetPayload>;
  DeleteTeamDiscussionCommentInput: DeleteTeamDiscussionCommentInput;
  DeleteTeamDiscussionCommentPayload: ResolverTypeWrapper<DeleteTeamDiscussionCommentPayload>;
  DeleteTeamDiscussionInput: DeleteTeamDiscussionInput;
  DeleteTeamDiscussionPayload: ResolverTypeWrapper<DeleteTeamDiscussionPayload>;
  DeleteUserListInput: DeleteUserListInput;
  DeleteUserListPayload: ResolverTypeWrapper<DeleteUserListPayload>;
  DeleteVerifiableDomainInput: DeleteVerifiableDomainInput;
  DeleteVerifiableDomainPayload: ResolverTypeWrapper<Omit<DeleteVerifiableDomainPayload, 'owner'> & { owner?: Maybe<ResolversTypes['VerifiableDomainOwner']> }>;
  DemilestonedEvent: ResolverTypeWrapper<Omit<DemilestonedEvent, 'subject'> & { subject: ResolversTypes['MilestoneItem'] }>;
  DependabotUpdate: ResolverTypeWrapper<DependabotUpdate>;
  DependabotUpdateError: ResolverTypeWrapper<DependabotUpdateError>;
  DependencyGraphDependency: ResolverTypeWrapper<DependencyGraphDependency>;
  DependencyGraphDependencyConnection: ResolverTypeWrapper<DependencyGraphDependencyConnection>;
  DependencyGraphDependencyEdge: ResolverTypeWrapper<DependencyGraphDependencyEdge>;
  DependencyGraphEcosystem: DependencyGraphEcosystem;
  DependencyGraphManifest: ResolverTypeWrapper<DependencyGraphManifest>;
  DependencyGraphManifestConnection: ResolverTypeWrapper<DependencyGraphManifestConnection>;
  DependencyGraphManifestEdge: ResolverTypeWrapper<DependencyGraphManifestEdge>;
  DeployKey: ResolverTypeWrapper<DeployKey>;
  DeployKeyConnection: ResolverTypeWrapper<DeployKeyConnection>;
  DeployKeyEdge: ResolverTypeWrapper<DeployKeyEdge>;
  DeployedEvent: ResolverTypeWrapper<DeployedEvent>;
  Deployment: ResolverTypeWrapper<Deployment>;
  DeploymentConnection: ResolverTypeWrapper<DeploymentConnection>;
  DeploymentEdge: ResolverTypeWrapper<DeploymentEdge>;
  DeploymentEnvironmentChangedEvent: ResolverTypeWrapper<DeploymentEnvironmentChangedEvent>;
  DeploymentOrder: DeploymentOrder;
  DeploymentOrderField: DeploymentOrderField;
  DeploymentProtectionRule: ResolverTypeWrapper<DeploymentProtectionRule>;
  DeploymentProtectionRuleConnection: ResolverTypeWrapper<DeploymentProtectionRuleConnection>;
  DeploymentProtectionRuleEdge: ResolverTypeWrapper<DeploymentProtectionRuleEdge>;
  DeploymentProtectionRuleType: DeploymentProtectionRuleType;
  DeploymentRequest: ResolverTypeWrapper<DeploymentRequest>;
  DeploymentRequestConnection: ResolverTypeWrapper<DeploymentRequestConnection>;
  DeploymentRequestEdge: ResolverTypeWrapper<DeploymentRequestEdge>;
  DeploymentReview: ResolverTypeWrapper<DeploymentReview>;
  DeploymentReviewConnection: ResolverTypeWrapper<DeploymentReviewConnection>;
  DeploymentReviewEdge: ResolverTypeWrapper<DeploymentReviewEdge>;
  DeploymentReviewState: DeploymentReviewState;
  DeploymentReviewer: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['DeploymentReviewer']>;
  DeploymentReviewerConnection: ResolverTypeWrapper<Omit<DeploymentReviewerConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['DeploymentReviewer']>>> }>;
  DeploymentReviewerEdge: ResolverTypeWrapper<Omit<DeploymentReviewerEdge, 'node'> & { node?: Maybe<ResolversTypes['DeploymentReviewer']> }>;
  DeploymentState: DeploymentState;
  DeploymentStatus: ResolverTypeWrapper<DeploymentStatus>;
  DeploymentStatusConnection: ResolverTypeWrapper<DeploymentStatusConnection>;
  DeploymentStatusEdge: ResolverTypeWrapper<DeploymentStatusEdge>;
  DeploymentStatusState: DeploymentStatusState;
  DequeuePullRequestInput: DequeuePullRequestInput;
  DequeuePullRequestPayload: ResolverTypeWrapper<DequeuePullRequestPayload>;
  DiffSide: DiffSide;
  DisablePullRequestAutoMergeInput: DisablePullRequestAutoMergeInput;
  DisablePullRequestAutoMergePayload: ResolverTypeWrapper<DisablePullRequestAutoMergePayload>;
  DisconnectedEvent: ResolverTypeWrapper<Omit<DisconnectedEvent, 'source' | 'subject'> & { source: ResolversTypes['ReferencedSubject'], subject: ResolversTypes['ReferencedSubject'] }>;
  Discussion: ResolverTypeWrapper<Discussion>;
  DiscussionCategory: ResolverTypeWrapper<DiscussionCategory>;
  DiscussionCategoryConnection: ResolverTypeWrapper<DiscussionCategoryConnection>;
  DiscussionCategoryEdge: ResolverTypeWrapper<DiscussionCategoryEdge>;
  DiscussionCloseReason: DiscussionCloseReason;
  DiscussionComment: ResolverTypeWrapper<DiscussionComment>;
  DiscussionCommentConnection: ResolverTypeWrapper<DiscussionCommentConnection>;
  DiscussionCommentEdge: ResolverTypeWrapper<DiscussionCommentEdge>;
  DiscussionConnection: ResolverTypeWrapper<DiscussionConnection>;
  DiscussionEdge: ResolverTypeWrapper<DiscussionEdge>;
  DiscussionOrder: DiscussionOrder;
  DiscussionOrderField: DiscussionOrderField;
  DiscussionPoll: ResolverTypeWrapper<DiscussionPoll>;
  DiscussionPollOption: ResolverTypeWrapper<DiscussionPollOption>;
  DiscussionPollOptionConnection: ResolverTypeWrapper<DiscussionPollOptionConnection>;
  DiscussionPollOptionEdge: ResolverTypeWrapper<DiscussionPollOptionEdge>;
  DiscussionPollOptionOrder: DiscussionPollOptionOrder;
  DiscussionPollOptionOrderField: DiscussionPollOptionOrderField;
  DiscussionState: DiscussionState;
  DiscussionStateReason: DiscussionStateReason;
  DismissPullRequestReviewInput: DismissPullRequestReviewInput;
  DismissPullRequestReviewPayload: ResolverTypeWrapper<DismissPullRequestReviewPayload>;
  DismissReason: DismissReason;
  DismissRepositoryVulnerabilityAlertInput: DismissRepositoryVulnerabilityAlertInput;
  DismissRepositoryVulnerabilityAlertPayload: ResolverTypeWrapper<DismissRepositoryVulnerabilityAlertPayload>;
  DraftIssue: ResolverTypeWrapper<DraftIssue>;
  DraftPullRequestReviewComment: DraftPullRequestReviewComment;
  DraftPullRequestReviewThread: DraftPullRequestReviewThread;
  EnablePullRequestAutoMergeInput: EnablePullRequestAutoMergeInput;
  EnablePullRequestAutoMergePayload: ResolverTypeWrapper<EnablePullRequestAutoMergePayload>;
  EnqueuePullRequestInput: EnqueuePullRequestInput;
  EnqueuePullRequestPayload: ResolverTypeWrapper<EnqueuePullRequestPayload>;
  Enterprise: ResolverTypeWrapper<Enterprise>;
  EnterpriseAdministratorConnection: ResolverTypeWrapper<EnterpriseAdministratorConnection>;
  EnterpriseAdministratorEdge: ResolverTypeWrapper<EnterpriseAdministratorEdge>;
  EnterpriseAdministratorInvitation: ResolverTypeWrapper<EnterpriseAdministratorInvitation>;
  EnterpriseAdministratorInvitationConnection: ResolverTypeWrapper<EnterpriseAdministratorInvitationConnection>;
  EnterpriseAdministratorInvitationEdge: ResolverTypeWrapper<EnterpriseAdministratorInvitationEdge>;
  EnterpriseAdministratorInvitationOrder: EnterpriseAdministratorInvitationOrder;
  EnterpriseAdministratorInvitationOrderField: EnterpriseAdministratorInvitationOrderField;
  EnterpriseAdministratorRole: EnterpriseAdministratorRole;
  EnterpriseAllowPrivateRepositoryForkingPolicyValue: EnterpriseAllowPrivateRepositoryForkingPolicyValue;
  EnterpriseAuditEntryData: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['EnterpriseAuditEntryData']>;
  EnterpriseBillingInfo: ResolverTypeWrapper<EnterpriseBillingInfo>;
  EnterpriseConnection: ResolverTypeWrapper<EnterpriseConnection>;
  EnterpriseDefaultRepositoryPermissionSettingValue: EnterpriseDefaultRepositoryPermissionSettingValue;
  EnterpriseEdge: ResolverTypeWrapper<EnterpriseEdge>;
  EnterpriseEnabledDisabledSettingValue: EnterpriseEnabledDisabledSettingValue;
  EnterpriseEnabledSettingValue: EnterpriseEnabledSettingValue;
  EnterpriseFailedInvitationConnection: ResolverTypeWrapper<EnterpriseFailedInvitationConnection>;
  EnterpriseFailedInvitationEdge: ResolverTypeWrapper<EnterpriseFailedInvitationEdge>;
  EnterpriseIdentityProvider: ResolverTypeWrapper<EnterpriseIdentityProvider>;
  EnterpriseMember: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['EnterpriseMember']>;
  EnterpriseMemberConnection: ResolverTypeWrapper<Omit<EnterpriseMemberConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['EnterpriseMember']>>> }>;
  EnterpriseMemberEdge: ResolverTypeWrapper<Omit<EnterpriseMemberEdge, 'node'> & { node?: Maybe<ResolversTypes['EnterpriseMember']> }>;
  EnterpriseMemberOrder: EnterpriseMemberOrder;
  EnterpriseMemberOrderField: EnterpriseMemberOrderField;
  EnterpriseMembersCanCreateRepositoriesSettingValue: EnterpriseMembersCanCreateRepositoriesSettingValue;
  EnterpriseMembersCanMakePurchasesSettingValue: EnterpriseMembersCanMakePurchasesSettingValue;
  EnterpriseMembershipType: EnterpriseMembershipType;
  EnterpriseOrder: EnterpriseOrder;
  EnterpriseOrderField: EnterpriseOrderField;
  EnterpriseOrganizationMembershipConnection: ResolverTypeWrapper<EnterpriseOrganizationMembershipConnection>;
  EnterpriseOrganizationMembershipEdge: ResolverTypeWrapper<EnterpriseOrganizationMembershipEdge>;
  EnterpriseOutsideCollaboratorConnection: ResolverTypeWrapper<EnterpriseOutsideCollaboratorConnection>;
  EnterpriseOutsideCollaboratorEdge: ResolverTypeWrapper<EnterpriseOutsideCollaboratorEdge>;
  EnterpriseOwnerInfo: ResolverTypeWrapper<EnterpriseOwnerInfo>;
  EnterprisePendingMemberInvitationConnection: ResolverTypeWrapper<EnterprisePendingMemberInvitationConnection>;
  EnterprisePendingMemberInvitationEdge: ResolverTypeWrapper<EnterprisePendingMemberInvitationEdge>;
  EnterpriseRepositoryInfo: ResolverTypeWrapper<EnterpriseRepositoryInfo>;
  EnterpriseRepositoryInfoConnection: ResolverTypeWrapper<EnterpriseRepositoryInfoConnection>;
  EnterpriseRepositoryInfoEdge: ResolverTypeWrapper<EnterpriseRepositoryInfoEdge>;
  EnterpriseServerInstallation: ResolverTypeWrapper<EnterpriseServerInstallation>;
  EnterpriseServerInstallationConnection: ResolverTypeWrapper<EnterpriseServerInstallationConnection>;
  EnterpriseServerInstallationEdge: ResolverTypeWrapper<EnterpriseServerInstallationEdge>;
  EnterpriseServerInstallationMembershipConnection: ResolverTypeWrapper<EnterpriseServerInstallationMembershipConnection>;
  EnterpriseServerInstallationMembershipEdge: ResolverTypeWrapper<EnterpriseServerInstallationMembershipEdge>;
  EnterpriseServerInstallationOrder: EnterpriseServerInstallationOrder;
  EnterpriseServerInstallationOrderField: EnterpriseServerInstallationOrderField;
  EnterpriseServerUserAccount: ResolverTypeWrapper<EnterpriseServerUserAccount>;
  EnterpriseServerUserAccountConnection: ResolverTypeWrapper<EnterpriseServerUserAccountConnection>;
  EnterpriseServerUserAccountEdge: ResolverTypeWrapper<EnterpriseServerUserAccountEdge>;
  EnterpriseServerUserAccountEmail: ResolverTypeWrapper<EnterpriseServerUserAccountEmail>;
  EnterpriseServerUserAccountEmailConnection: ResolverTypeWrapper<EnterpriseServerUserAccountEmailConnection>;
  EnterpriseServerUserAccountEmailEdge: ResolverTypeWrapper<EnterpriseServerUserAccountEmailEdge>;
  EnterpriseServerUserAccountEmailOrder: EnterpriseServerUserAccountEmailOrder;
  EnterpriseServerUserAccountEmailOrderField: EnterpriseServerUserAccountEmailOrderField;
  EnterpriseServerUserAccountOrder: EnterpriseServerUserAccountOrder;
  EnterpriseServerUserAccountOrderField: EnterpriseServerUserAccountOrderField;
  EnterpriseServerUserAccountsUpload: ResolverTypeWrapper<EnterpriseServerUserAccountsUpload>;
  EnterpriseServerUserAccountsUploadConnection: ResolverTypeWrapper<EnterpriseServerUserAccountsUploadConnection>;
  EnterpriseServerUserAccountsUploadEdge: ResolverTypeWrapper<EnterpriseServerUserAccountsUploadEdge>;
  EnterpriseServerUserAccountsUploadOrder: EnterpriseServerUserAccountsUploadOrder;
  EnterpriseServerUserAccountsUploadOrderField: EnterpriseServerUserAccountsUploadOrderField;
  EnterpriseServerUserAccountsUploadSyncState: EnterpriseServerUserAccountsUploadSyncState;
  EnterpriseUserAccount: ResolverTypeWrapper<EnterpriseUserAccount>;
  EnterpriseUserAccountMembershipRole: EnterpriseUserAccountMembershipRole;
  EnterpriseUserDeployment: EnterpriseUserDeployment;
  Environment: ResolverTypeWrapper<Environment>;
  EnvironmentConnection: ResolverTypeWrapper<EnvironmentConnection>;
  EnvironmentEdge: ResolverTypeWrapper<EnvironmentEdge>;
  EnvironmentOrderField: EnvironmentOrderField;
  Environments: Environments;
  ExternalIdentity: ResolverTypeWrapper<ExternalIdentity>;
  ExternalIdentityAttribute: ResolverTypeWrapper<ExternalIdentityAttribute>;
  ExternalIdentityConnection: ResolverTypeWrapper<ExternalIdentityConnection>;
  ExternalIdentityEdge: ResolverTypeWrapper<ExternalIdentityEdge>;
  ExternalIdentitySamlAttributes: ResolverTypeWrapper<ExternalIdentitySamlAttributes>;
  ExternalIdentityScimAttributes: ResolverTypeWrapper<ExternalIdentityScimAttributes>;
  FileAddition: FileAddition;
  FileChanges: FileChanges;
  FileDeletion: FileDeletion;
  FileViewedState: FileViewedState;
  FollowOrganizationInput: FollowOrganizationInput;
  FollowOrganizationPayload: ResolverTypeWrapper<FollowOrganizationPayload>;
  FollowUserInput: FollowUserInput;
  FollowUserPayload: ResolverTypeWrapper<FollowUserPayload>;
  FollowerConnection: ResolverTypeWrapper<FollowerConnection>;
  FollowingConnection: ResolverTypeWrapper<FollowingConnection>;
  FundingLink: ResolverTypeWrapper<FundingLink>;
  FundingPlatform: FundingPlatform;
  GenericHovercardContext: ResolverTypeWrapper<GenericHovercardContext>;
  Gist: ResolverTypeWrapper<Gist>;
  GistComment: ResolverTypeWrapper<GistComment>;
  GistCommentConnection: ResolverTypeWrapper<GistCommentConnection>;
  GistCommentEdge: ResolverTypeWrapper<GistCommentEdge>;
  GistConnection: ResolverTypeWrapper<GistConnection>;
  GistEdge: ResolverTypeWrapper<GistEdge>;
  GistFile: ResolverTypeWrapper<GistFile>;
  GistOrder: GistOrder;
  GistOrderField: GistOrderField;
  GistPrivacy: GistPrivacy;
  GitActor: ResolverTypeWrapper<GitActor>;
  GitActorConnection: ResolverTypeWrapper<GitActorConnection>;
  GitActorEdge: ResolverTypeWrapper<GitActorEdge>;
  GitHubMetadata: ResolverTypeWrapper<GitHubMetadata>;
  GitObject: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['GitObject']>;
  GitObjectID: ResolverTypeWrapper<Scalars['GitObjectID']['output']>;
  GitRefname: ResolverTypeWrapper<Scalars['GitRefname']['output']>;
  GitSSHRemote: ResolverTypeWrapper<Scalars['GitSSHRemote']['output']>;
  GitSignature: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['GitSignature']>;
  GitSignatureState: GitSignatureState;
  GitTimestamp: ResolverTypeWrapper<Scalars['GitTimestamp']['output']>;
  GpgSignature: ResolverTypeWrapper<GpgSignature>;
  GrantEnterpriseOrganizationsMigratorRoleInput: GrantEnterpriseOrganizationsMigratorRoleInput;
  GrantEnterpriseOrganizationsMigratorRolePayload: ResolverTypeWrapper<GrantEnterpriseOrganizationsMigratorRolePayload>;
  GrantMigratorRoleInput: GrantMigratorRoleInput;
  GrantMigratorRolePayload: ResolverTypeWrapper<GrantMigratorRolePayload>;
  HTML: ResolverTypeWrapper<Scalars['HTML']['output']>;
  HeadRefDeletedEvent: ResolverTypeWrapper<HeadRefDeletedEvent>;
  HeadRefForcePushedEvent: ResolverTypeWrapper<HeadRefForcePushedEvent>;
  HeadRefRestoredEvent: ResolverTypeWrapper<HeadRefRestoredEvent>;
  Hovercard: ResolverTypeWrapper<Hovercard>;
  HovercardContext: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['HovercardContext']>;
  IdentityProviderConfigurationState: IdentityProviderConfigurationState;
  ImportProjectInput: ImportProjectInput;
  ImportProjectPayload: ResolverTypeWrapper<ImportProjectPayload>;
  InviteEnterpriseAdminInput: InviteEnterpriseAdminInput;
  InviteEnterpriseAdminPayload: ResolverTypeWrapper<InviteEnterpriseAdminPayload>;
  IpAllowListEnabledSettingValue: IpAllowListEnabledSettingValue;
  IpAllowListEntry: ResolverTypeWrapper<Omit<IpAllowListEntry, 'owner'> & { owner: ResolversTypes['IpAllowListOwner'] }>;
  IpAllowListEntryConnection: ResolverTypeWrapper<IpAllowListEntryConnection>;
  IpAllowListEntryEdge: ResolverTypeWrapper<IpAllowListEntryEdge>;
  IpAllowListEntryOrder: IpAllowListEntryOrder;
  IpAllowListEntryOrderField: IpAllowListEntryOrderField;
  IpAllowListForInstalledAppsEnabledSettingValue: IpAllowListForInstalledAppsEnabledSettingValue;
  IpAllowListOwner: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['IpAllowListOwner']>;
  Issue: ResolverTypeWrapper<Issue>;
  IssueClosedStateReason: IssueClosedStateReason;
  IssueComment: ResolverTypeWrapper<IssueComment>;
  IssueCommentConnection: ResolverTypeWrapper<IssueCommentConnection>;
  IssueCommentEdge: ResolverTypeWrapper<IssueCommentEdge>;
  IssueCommentOrder: IssueCommentOrder;
  IssueCommentOrderField: IssueCommentOrderField;
  IssueConnection: ResolverTypeWrapper<IssueConnection>;
  IssueContributionsByRepository: ResolverTypeWrapper<IssueContributionsByRepository>;
  IssueEdge: ResolverTypeWrapper<IssueEdge>;
  IssueFilters: IssueFilters;
  IssueOrPullRequest: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['IssueOrPullRequest']>;
  IssueOrder: IssueOrder;
  IssueOrderField: IssueOrderField;
  IssueState: IssueState;
  IssueStateReason: IssueStateReason;
  IssueTemplate: ResolverTypeWrapper<IssueTemplate>;
  IssueTimelineConnection: ResolverTypeWrapper<Omit<IssueTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['IssueTimelineItem']>>> }>;
  IssueTimelineItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['IssueTimelineItem']>;
  IssueTimelineItemEdge: ResolverTypeWrapper<Omit<IssueTimelineItemEdge, 'node'> & { node?: Maybe<ResolversTypes['IssueTimelineItem']> }>;
  IssueTimelineItems: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['IssueTimelineItems']>;
  IssueTimelineItemsConnection: ResolverTypeWrapper<Omit<IssueTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['IssueTimelineItems']>>> }>;
  IssueTimelineItemsEdge: ResolverTypeWrapper<Omit<IssueTimelineItemsEdge, 'node'> & { node?: Maybe<ResolversTypes['IssueTimelineItems']> }>;
  IssueTimelineItemsItemType: IssueTimelineItemsItemType;
  JoinedGitHubContribution: ResolverTypeWrapper<JoinedGitHubContribution>;
  Label: ResolverTypeWrapper<Label>;
  LabelConnection: ResolverTypeWrapper<LabelConnection>;
  LabelEdge: ResolverTypeWrapper<LabelEdge>;
  LabelOrder: LabelOrder;
  LabelOrderField: LabelOrderField;
  Labelable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Labelable']>;
  LabeledEvent: ResolverTypeWrapper<LabeledEvent>;
  Language: ResolverTypeWrapper<Language>;
  LanguageConnection: ResolverTypeWrapper<LanguageConnection>;
  LanguageEdge: ResolverTypeWrapper<LanguageEdge>;
  LanguageOrder: LanguageOrder;
  LanguageOrderField: LanguageOrderField;
  License: ResolverTypeWrapper<License>;
  LicenseRule: ResolverTypeWrapper<LicenseRule>;
  LinkProjectV2ToRepositoryInput: LinkProjectV2ToRepositoryInput;
  LinkProjectV2ToRepositoryPayload: ResolverTypeWrapper<LinkProjectV2ToRepositoryPayload>;
  LinkProjectV2ToTeamInput: LinkProjectV2ToTeamInput;
  LinkProjectV2ToTeamPayload: ResolverTypeWrapper<LinkProjectV2ToTeamPayload>;
  LinkRepositoryToProjectInput: LinkRepositoryToProjectInput;
  LinkRepositoryToProjectPayload: ResolverTypeWrapper<LinkRepositoryToProjectPayload>;
  LinkedBranch: ResolverTypeWrapper<LinkedBranch>;
  LinkedBranchConnection: ResolverTypeWrapper<LinkedBranchConnection>;
  LinkedBranchEdge: ResolverTypeWrapper<LinkedBranchEdge>;
  LockLockableInput: LockLockableInput;
  LockLockablePayload: ResolverTypeWrapper<LockLockablePayload>;
  LockReason: LockReason;
  Lockable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Lockable']>;
  LockedEvent: ResolverTypeWrapper<LockedEvent>;
  Mannequin: ResolverTypeWrapper<Mannequin>;
  MannequinConnection: ResolverTypeWrapper<MannequinConnection>;
  MannequinEdge: ResolverTypeWrapper<MannequinEdge>;
  MannequinOrder: MannequinOrder;
  MannequinOrderField: MannequinOrderField;
  MarkDiscussionCommentAsAnswerInput: MarkDiscussionCommentAsAnswerInput;
  MarkDiscussionCommentAsAnswerPayload: ResolverTypeWrapper<MarkDiscussionCommentAsAnswerPayload>;
  MarkFileAsViewedInput: MarkFileAsViewedInput;
  MarkFileAsViewedPayload: ResolverTypeWrapper<MarkFileAsViewedPayload>;
  MarkProjectV2AsTemplateInput: MarkProjectV2AsTemplateInput;
  MarkProjectV2AsTemplatePayload: ResolverTypeWrapper<MarkProjectV2AsTemplatePayload>;
  MarkPullRequestReadyForReviewInput: MarkPullRequestReadyForReviewInput;
  MarkPullRequestReadyForReviewPayload: ResolverTypeWrapper<MarkPullRequestReadyForReviewPayload>;
  MarkedAsDuplicateEvent: ResolverTypeWrapper<Omit<MarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<ResolversTypes['IssueOrPullRequest']>, duplicate?: Maybe<ResolversTypes['IssueOrPullRequest']> }>;
  MarketplaceCategory: ResolverTypeWrapper<MarketplaceCategory>;
  MarketplaceListing: ResolverTypeWrapper<MarketplaceListing>;
  MarketplaceListingConnection: ResolverTypeWrapper<MarketplaceListingConnection>;
  MarketplaceListingEdge: ResolverTypeWrapper<MarketplaceListingEdge>;
  MemberFeatureRequestNotification: ResolverTypeWrapper<MemberFeatureRequestNotification>;
  MemberStatusable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['MemberStatusable']>;
  MembersCanDeleteReposClearAuditEntry: ResolverTypeWrapper<Omit<MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  MembersCanDeleteReposDisableAuditEntry: ResolverTypeWrapper<Omit<MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  MembersCanDeleteReposEnableAuditEntry: ResolverTypeWrapper<Omit<MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  MentionedEvent: ResolverTypeWrapper<MentionedEvent>;
  MergeBranchInput: MergeBranchInput;
  MergeBranchPayload: ResolverTypeWrapper<MergeBranchPayload>;
  MergeCommitMessage: MergeCommitMessage;
  MergeCommitTitle: MergeCommitTitle;
  MergePullRequestInput: MergePullRequestInput;
  MergePullRequestPayload: ResolverTypeWrapper<MergePullRequestPayload>;
  MergeQueue: ResolverTypeWrapper<MergeQueue>;
  MergeQueueConfiguration: ResolverTypeWrapper<MergeQueueConfiguration>;
  MergeQueueEntry: ResolverTypeWrapper<MergeQueueEntry>;
  MergeQueueEntryConnection: ResolverTypeWrapper<MergeQueueEntryConnection>;
  MergeQueueEntryEdge: ResolverTypeWrapper<MergeQueueEntryEdge>;
  MergeQueueEntryState: MergeQueueEntryState;
  MergeQueueMergingStrategy: MergeQueueMergingStrategy;
  MergeStateStatus: MergeStateStatus;
  MergeableState: MergeableState;
  MergedEvent: ResolverTypeWrapper<MergedEvent>;
  Migration: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Migration']>;
  MigrationSource: ResolverTypeWrapper<MigrationSource>;
  MigrationSourceType: MigrationSourceType;
  MigrationState: MigrationState;
  Milestone: ResolverTypeWrapper<Milestone>;
  MilestoneConnection: ResolverTypeWrapper<MilestoneConnection>;
  MilestoneEdge: ResolverTypeWrapper<MilestoneEdge>;
  MilestoneItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['MilestoneItem']>;
  MilestoneOrder: MilestoneOrder;
  MilestoneOrderField: MilestoneOrderField;
  MilestoneState: MilestoneState;
  MilestonedEvent: ResolverTypeWrapper<Omit<MilestonedEvent, 'subject'> & { subject: ResolversTypes['MilestoneItem'] }>;
  Minimizable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Minimizable']>;
  MinimizeCommentInput: MinimizeCommentInput;
  MinimizeCommentPayload: ResolverTypeWrapper<MinimizeCommentPayload>;
  MoveProjectCardInput: MoveProjectCardInput;
  MoveProjectCardPayload: ResolverTypeWrapper<MoveProjectCardPayload>;
  MoveProjectColumnInput: MoveProjectColumnInput;
  MoveProjectColumnPayload: ResolverTypeWrapper<MoveProjectColumnPayload>;
  MovedColumnsInProjectEvent: ResolverTypeWrapper<MovedColumnsInProjectEvent>;
  Mutation: ResolverTypeWrapper<{}>;
  Node: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Node']>;
  NotificationRestrictionSettingValue: NotificationRestrictionSettingValue;
  OIDCProvider: ResolverTypeWrapper<OIDCProvider>;
  OIDCProviderType: OIDCProviderType;
  OauthApplicationAuditEntryData: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['OauthApplicationAuditEntryData']>;
  OauthApplicationCreateAuditEntry: ResolverTypeWrapper<Omit<OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OauthApplicationCreateAuditEntryState: OauthApplicationCreateAuditEntryState;
  OperationType: OperationType;
  OrderDirection: OrderDirection;
  OrgAddBillingManagerAuditEntry: ResolverTypeWrapper<Omit<OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgAddMemberAuditEntry: ResolverTypeWrapper<Omit<OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgAddMemberAuditEntryPermission: OrgAddMemberAuditEntryPermission;
  OrgBlockUserAuditEntry: ResolverTypeWrapper<Omit<OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgConfigDisableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgConfigEnableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgCreateAuditEntry: ResolverTypeWrapper<Omit<OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgCreateAuditEntryBillingPlan: OrgCreateAuditEntryBillingPlan;
  OrgDisableOauthAppRestrictionsAuditEntry: ResolverTypeWrapper<Omit<OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgDisableSamlAuditEntry: ResolverTypeWrapper<Omit<OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgDisableTwoFactorRequirementAuditEntry: ResolverTypeWrapper<Omit<OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgEnableOauthAppRestrictionsAuditEntry: ResolverTypeWrapper<Omit<OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgEnableSamlAuditEntry: ResolverTypeWrapper<Omit<OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgEnableTwoFactorRequirementAuditEntry: ResolverTypeWrapper<Omit<OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgEnterpriseOwnerOrder: OrgEnterpriseOwnerOrder;
  OrgEnterpriseOwnerOrderField: OrgEnterpriseOwnerOrderField;
  OrgInviteMemberAuditEntry: ResolverTypeWrapper<Omit<OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgInviteToBusinessAuditEntry: ResolverTypeWrapper<Omit<OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgOauthAppAccessApprovedAuditEntry: ResolverTypeWrapper<Omit<OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgOauthAppAccessBlockedAuditEntry: ResolverTypeWrapper<Omit<OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgOauthAppAccessDeniedAuditEntry: ResolverTypeWrapper<Omit<OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgOauthAppAccessRequestedAuditEntry: ResolverTypeWrapper<Omit<OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgOauthAppAccessUnblockedAuditEntry: ResolverTypeWrapper<Omit<OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgRemoveBillingManagerAuditEntry: ResolverTypeWrapper<Omit<OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgRemoveBillingManagerAuditEntryReason: OrgRemoveBillingManagerAuditEntryReason;
  OrgRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgRemoveMemberAuditEntryMembershipType: OrgRemoveMemberAuditEntryMembershipType;
  OrgRemoveMemberAuditEntryReason: OrgRemoveMemberAuditEntryReason;
  OrgRemoveOutsideCollaboratorAuditEntry: ResolverTypeWrapper<Omit<OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgRemoveOutsideCollaboratorAuditEntryMembershipType: OrgRemoveOutsideCollaboratorAuditEntryMembershipType;
  OrgRemoveOutsideCollaboratorAuditEntryReason: OrgRemoveOutsideCollaboratorAuditEntryReason;
  OrgRestoreMemberAuditEntry: ResolverTypeWrapper<Omit<OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']>, restoredMemberships?: Maybe<Array<ResolversTypes['OrgRestoreMemberAuditEntryMembership']>> }>;
  OrgRestoreMemberAuditEntryMembership: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OrgRestoreMemberAuditEntryMembership']>;
  OrgRestoreMemberMembershipOrganizationAuditEntryData: ResolverTypeWrapper<OrgRestoreMemberMembershipOrganizationAuditEntryData>;
  OrgRestoreMemberMembershipRepositoryAuditEntryData: ResolverTypeWrapper<OrgRestoreMemberMembershipRepositoryAuditEntryData>;
  OrgRestoreMemberMembershipTeamAuditEntryData: ResolverTypeWrapper<OrgRestoreMemberMembershipTeamAuditEntryData>;
  OrgUnblockUserAuditEntry: ResolverTypeWrapper<Omit<OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgUpdateDefaultRepositoryPermissionAuditEntry: ResolverTypeWrapper<Omit<OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgUpdateDefaultRepositoryPermissionAuditEntryPermission: OrgUpdateDefaultRepositoryPermissionAuditEntryPermission;
  OrgUpdateMemberAuditEntry: ResolverTypeWrapper<Omit<OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgUpdateMemberAuditEntryPermission: OrgUpdateMemberAuditEntryPermission;
  OrgUpdateMemberRepositoryCreationPermissionAuditEntry: ResolverTypeWrapper<Omit<OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility: OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility;
  OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: ResolverTypeWrapper<Omit<OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  Organization: ResolverTypeWrapper<Organization>;
  OrganizationAuditEntry: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OrganizationAuditEntry']>;
  OrganizationAuditEntryConnection: ResolverTypeWrapper<Omit<OrganizationAuditEntryConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['OrganizationAuditEntry']>>> }>;
  OrganizationAuditEntryData: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['OrganizationAuditEntryData']>;
  OrganizationAuditEntryEdge: ResolverTypeWrapper<Omit<OrganizationAuditEntryEdge, 'node'> & { node?: Maybe<ResolversTypes['OrganizationAuditEntry']> }>;
  OrganizationConnection: ResolverTypeWrapper<OrganizationConnection>;
  OrganizationEdge: ResolverTypeWrapper<OrganizationEdge>;
  OrganizationEnterpriseOwnerConnection: ResolverTypeWrapper<OrganizationEnterpriseOwnerConnection>;
  OrganizationEnterpriseOwnerEdge: ResolverTypeWrapper<OrganizationEnterpriseOwnerEdge>;
  OrganizationIdentityProvider: ResolverTypeWrapper<OrganizationIdentityProvider>;
  OrganizationInvitation: ResolverTypeWrapper<OrganizationInvitation>;
  OrganizationInvitationConnection: ResolverTypeWrapper<OrganizationInvitationConnection>;
  OrganizationInvitationEdge: ResolverTypeWrapper<OrganizationInvitationEdge>;
  OrganizationInvitationRole: OrganizationInvitationRole;
  OrganizationInvitationSource: OrganizationInvitationSource;
  OrganizationInvitationType: OrganizationInvitationType;
  OrganizationMemberConnection: ResolverTypeWrapper<OrganizationMemberConnection>;
  OrganizationMemberEdge: ResolverTypeWrapper<OrganizationMemberEdge>;
  OrganizationMemberRole: OrganizationMemberRole;
  OrganizationMembersCanCreateRepositoriesSettingValue: OrganizationMembersCanCreateRepositoriesSettingValue;
  OrganizationMigration: ResolverTypeWrapper<OrganizationMigration>;
  OrganizationMigrationState: OrganizationMigrationState;
  OrganizationOrUser: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OrganizationOrUser']>;
  OrganizationOrder: OrganizationOrder;
  OrganizationOrderField: OrganizationOrderField;
  OrganizationTeamsHovercardContext: ResolverTypeWrapper<OrganizationTeamsHovercardContext>;
  OrganizationsHovercardContext: ResolverTypeWrapper<OrganizationsHovercardContext>;
  Package: ResolverTypeWrapper<Package>;
  PackageConnection: ResolverTypeWrapper<PackageConnection>;
  PackageEdge: ResolverTypeWrapper<PackageEdge>;
  PackageFile: ResolverTypeWrapper<PackageFile>;
  PackageFileConnection: ResolverTypeWrapper<PackageFileConnection>;
  PackageFileEdge: ResolverTypeWrapper<PackageFileEdge>;
  PackageFileOrder: PackageFileOrder;
  PackageFileOrderField: PackageFileOrderField;
  PackageOrder: PackageOrder;
  PackageOrderField: PackageOrderField;
  PackageOwner: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['PackageOwner']>;
  PackageStatistics: ResolverTypeWrapper<PackageStatistics>;
  PackageTag: ResolverTypeWrapper<PackageTag>;
  PackageType: PackageType;
  PackageVersion: ResolverTypeWrapper<PackageVersion>;
  PackageVersionConnection: ResolverTypeWrapper<PackageVersionConnection>;
  PackageVersionEdge: ResolverTypeWrapper<PackageVersionEdge>;
  PackageVersionOrder: PackageVersionOrder;
  PackageVersionOrderField: PackageVersionOrderField;
  PackageVersionStatistics: ResolverTypeWrapper<PackageVersionStatistics>;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  PatchStatus: PatchStatus;
  PermissionGranter: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PermissionGranter']>;
  PermissionSource: ResolverTypeWrapper<Omit<PermissionSource, 'source'> & { source: ResolversTypes['PermissionGranter'] }>;
  PinIssueInput: PinIssueInput;
  PinIssuePayload: ResolverTypeWrapper<PinIssuePayload>;
  PinnableItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PinnableItem']>;
  PinnableItemConnection: ResolverTypeWrapper<Omit<PinnableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['PinnableItem']>>> }>;
  PinnableItemEdge: ResolverTypeWrapper<Omit<PinnableItemEdge, 'node'> & { node?: Maybe<ResolversTypes['PinnableItem']> }>;
  PinnableItemType: PinnableItemType;
  PinnedDiscussion: ResolverTypeWrapper<PinnedDiscussion>;
  PinnedDiscussionConnection: ResolverTypeWrapper<PinnedDiscussionConnection>;
  PinnedDiscussionEdge: ResolverTypeWrapper<PinnedDiscussionEdge>;
  PinnedDiscussionGradient: PinnedDiscussionGradient;
  PinnedDiscussionPattern: PinnedDiscussionPattern;
  PinnedEvent: ResolverTypeWrapper<PinnedEvent>;
  PinnedIssue: ResolverTypeWrapper<PinnedIssue>;
  PinnedIssueConnection: ResolverTypeWrapper<PinnedIssueConnection>;
  PinnedIssueEdge: ResolverTypeWrapper<PinnedIssueEdge>;
  PreciseDateTime: ResolverTypeWrapper<Scalars['PreciseDateTime']['output']>;
  PrivateRepositoryForkingDisableAuditEntry: ResolverTypeWrapper<Omit<PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  PrivateRepositoryForkingEnableAuditEntry: ResolverTypeWrapper<Omit<PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  ProfileItemShowcase: ResolverTypeWrapper<ProfileItemShowcase>;
  ProfileOwner: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ProfileOwner']>;
  Project: ResolverTypeWrapper<Project>;
  ProjectCard: ResolverTypeWrapper<Omit<ProjectCard, 'content'> & { content?: Maybe<ResolversTypes['ProjectCardItem']> }>;
  ProjectCardArchivedState: ProjectCardArchivedState;
  ProjectCardConnection: ResolverTypeWrapper<ProjectCardConnection>;
  ProjectCardEdge: ResolverTypeWrapper<ProjectCardEdge>;
  ProjectCardImport: ProjectCardImport;
  ProjectCardItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProjectCardItem']>;
  ProjectCardState: ProjectCardState;
  ProjectColumn: ResolverTypeWrapper<ProjectColumn>;
  ProjectColumnConnection: ResolverTypeWrapper<ProjectColumnConnection>;
  ProjectColumnEdge: ResolverTypeWrapper<ProjectColumnEdge>;
  ProjectColumnImport: ProjectColumnImport;
  ProjectColumnPurpose: ProjectColumnPurpose;
  ProjectConnection: ResolverTypeWrapper<ProjectConnection>;
  ProjectEdge: ResolverTypeWrapper<ProjectEdge>;
  ProjectOrder: ProjectOrder;
  ProjectOrderField: ProjectOrderField;
  ProjectOwner: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ProjectOwner']>;
  ProjectProgress: ResolverTypeWrapper<ProjectProgress>;
  ProjectState: ProjectState;
  ProjectTemplate: ProjectTemplate;
  ProjectV2: ResolverTypeWrapper<Omit<ProjectV2, 'field'> & { field?: Maybe<ResolversTypes['ProjectV2FieldConfiguration']> }>;
  ProjectV2Actor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProjectV2Actor']>;
  ProjectV2ActorConnection: ResolverTypeWrapper<Omit<ProjectV2ActorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['ProjectV2Actor']>>> }>;
  ProjectV2ActorEdge: ResolverTypeWrapper<Omit<ProjectV2ActorEdge, 'node'> & { node?: Maybe<ResolversTypes['ProjectV2Actor']> }>;
  ProjectV2Collaborator: ProjectV2Collaborator;
  ProjectV2Connection: ResolverTypeWrapper<ProjectV2Connection>;
  ProjectV2CustomFieldType: ProjectV2CustomFieldType;
  ProjectV2Edge: ResolverTypeWrapper<ProjectV2Edge>;
  ProjectV2Field: ResolverTypeWrapper<ProjectV2Field>;
  ProjectV2FieldCommon: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ProjectV2FieldCommon']>;
  ProjectV2FieldConfiguration: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProjectV2FieldConfiguration']>;
  ProjectV2FieldConfigurationConnection: ResolverTypeWrapper<Omit<ProjectV2FieldConfigurationConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['ProjectV2FieldConfiguration']>>> }>;
  ProjectV2FieldConfigurationEdge: ResolverTypeWrapper<Omit<ProjectV2FieldConfigurationEdge, 'node'> & { node?: Maybe<ResolversTypes['ProjectV2FieldConfiguration']> }>;
  ProjectV2FieldConnection: ResolverTypeWrapper<ProjectV2FieldConnection>;
  ProjectV2FieldEdge: ResolverTypeWrapper<ProjectV2FieldEdge>;
  ProjectV2FieldOrder: ProjectV2FieldOrder;
  ProjectV2FieldOrderField: ProjectV2FieldOrderField;
  ProjectV2FieldType: ProjectV2FieldType;
  ProjectV2FieldValue: ProjectV2FieldValue;
  ProjectV2Filters: ProjectV2Filters;
  ProjectV2Item: ResolverTypeWrapper<Omit<ProjectV2Item, 'content' | 'fieldValueByName'> & { content?: Maybe<ResolversTypes['ProjectV2ItemContent']>, fieldValueByName?: Maybe<ResolversTypes['ProjectV2ItemFieldValue']> }>;
  ProjectV2ItemConnection: ResolverTypeWrapper<ProjectV2ItemConnection>;
  ProjectV2ItemContent: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProjectV2ItemContent']>;
  ProjectV2ItemEdge: ResolverTypeWrapper<ProjectV2ItemEdge>;
  ProjectV2ItemFieldDateValue: ResolverTypeWrapper<Omit<ProjectV2ItemFieldDateValue, 'field'> & { field: ResolversTypes['ProjectV2FieldConfiguration'] }>;
  ProjectV2ItemFieldIterationValue: ResolverTypeWrapper<Omit<ProjectV2ItemFieldIterationValue, 'field'> & { field: ResolversTypes['ProjectV2FieldConfiguration'] }>;
  ProjectV2ItemFieldLabelValue: ResolverTypeWrapper<Omit<ProjectV2ItemFieldLabelValue, 'field'> & { field: ResolversTypes['ProjectV2FieldConfiguration'] }>;
  ProjectV2ItemFieldMilestoneValue: ResolverTypeWrapper<Omit<ProjectV2ItemFieldMilestoneValue, 'field'> & { field: ResolversTypes['ProjectV2FieldConfiguration'] }>;
  ProjectV2ItemFieldNumberValue: ResolverTypeWrapper<Omit<ProjectV2ItemFieldNumberValue, 'field'> & { field: ResolversTypes['ProjectV2FieldConfiguration'] }>;
  ProjectV2ItemFieldPullRequestValue: ResolverTypeWrapper<Omit<ProjectV2ItemFieldPullRequestValue, 'field'> & { field: ResolversTypes['ProjectV2FieldConfiguration'] }>;
  ProjectV2ItemFieldRepositoryValue: ResolverTypeWrapper<Omit<ProjectV2ItemFieldRepositoryValue, 'field'> & { field: ResolversTypes['ProjectV2FieldConfiguration'] }>;
  ProjectV2ItemFieldReviewerValue: ResolverTypeWrapper<Omit<ProjectV2ItemFieldReviewerValue, 'field'> & { field: ResolversTypes['ProjectV2FieldConfiguration'] }>;
  ProjectV2ItemFieldSingleSelectValue: ResolverTypeWrapper<Omit<ProjectV2ItemFieldSingleSelectValue, 'field'> & { field: ResolversTypes['ProjectV2FieldConfiguration'] }>;
  ProjectV2ItemFieldTextValue: ResolverTypeWrapper<Omit<ProjectV2ItemFieldTextValue, 'field'> & { field: ResolversTypes['ProjectV2FieldConfiguration'] }>;
  ProjectV2ItemFieldUserValue: ResolverTypeWrapper<Omit<ProjectV2ItemFieldUserValue, 'field'> & { field: ResolversTypes['ProjectV2FieldConfiguration'] }>;
  ProjectV2ItemFieldValue: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ProjectV2ItemFieldValue']>;
  ProjectV2ItemFieldValueCommon: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ProjectV2ItemFieldValueCommon']>;
  ProjectV2ItemFieldValueConnection: ResolverTypeWrapper<Omit<ProjectV2ItemFieldValueConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['ProjectV2ItemFieldValue']>>> }>;
  ProjectV2ItemFieldValueEdge: ResolverTypeWrapper<Omit<ProjectV2ItemFieldValueEdge, 'node'> & { node?: Maybe<ResolversTypes['ProjectV2ItemFieldValue']> }>;
  ProjectV2ItemFieldValueOrder: ProjectV2ItemFieldValueOrder;
  ProjectV2ItemFieldValueOrderField: ProjectV2ItemFieldValueOrderField;
  ProjectV2ItemOrder: ProjectV2ItemOrder;
  ProjectV2ItemOrderField: ProjectV2ItemOrderField;
  ProjectV2ItemType: ProjectV2ItemType;
  ProjectV2IterationField: ResolverTypeWrapper<ProjectV2IterationField>;
  ProjectV2IterationFieldConfiguration: ResolverTypeWrapper<ProjectV2IterationFieldConfiguration>;
  ProjectV2IterationFieldIteration: ResolverTypeWrapper<ProjectV2IterationFieldIteration>;
  ProjectV2Order: ProjectV2Order;
  ProjectV2OrderField: ProjectV2OrderField;
  ProjectV2Owner: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ProjectV2Owner']>;
  ProjectV2Recent: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ProjectV2Recent']>;
  ProjectV2Roles: ProjectV2Roles;
  ProjectV2SingleSelectField: ResolverTypeWrapper<ProjectV2SingleSelectField>;
  ProjectV2SingleSelectFieldOption: ResolverTypeWrapper<ProjectV2SingleSelectFieldOption>;
  ProjectV2SingleSelectFieldOptionColor: ProjectV2SingleSelectFieldOptionColor;
  ProjectV2SingleSelectFieldOptionInput: ProjectV2SingleSelectFieldOptionInput;
  ProjectV2SortBy: ResolverTypeWrapper<ProjectV2SortBy>;
  ProjectV2SortByConnection: ResolverTypeWrapper<ProjectV2SortByConnection>;
  ProjectV2SortByEdge: ResolverTypeWrapper<ProjectV2SortByEdge>;
  ProjectV2SortByField: ResolverTypeWrapper<Omit<ProjectV2SortByField, 'field'> & { field: ResolversTypes['ProjectV2FieldConfiguration'] }>;
  ProjectV2SortByFieldConnection: ResolverTypeWrapper<ProjectV2SortByFieldConnection>;
  ProjectV2SortByFieldEdge: ResolverTypeWrapper<ProjectV2SortByFieldEdge>;
  ProjectV2State: ProjectV2State;
  ProjectV2View: ResolverTypeWrapper<ProjectV2View>;
  ProjectV2ViewConnection: ResolverTypeWrapper<ProjectV2ViewConnection>;
  ProjectV2ViewEdge: ResolverTypeWrapper<ProjectV2ViewEdge>;
  ProjectV2ViewLayout: ProjectV2ViewLayout;
  ProjectV2ViewOrder: ProjectV2ViewOrder;
  ProjectV2ViewOrderField: ProjectV2ViewOrderField;
  ProjectV2Workflow: ResolverTypeWrapper<ProjectV2Workflow>;
  ProjectV2WorkflowConnection: ResolverTypeWrapper<ProjectV2WorkflowConnection>;
  ProjectV2WorkflowEdge: ResolverTypeWrapper<ProjectV2WorkflowEdge>;
  ProjectV2WorkflowOrder: ProjectV2WorkflowOrder;
  ProjectV2WorkflowsOrderField: ProjectV2WorkflowsOrderField;
  PublicKey: ResolverTypeWrapper<PublicKey>;
  PublicKeyConnection: ResolverTypeWrapper<PublicKeyConnection>;
  PublicKeyEdge: ResolverTypeWrapper<PublicKeyEdge>;
  PublishSponsorsTierInput: PublishSponsorsTierInput;
  PublishSponsorsTierPayload: ResolverTypeWrapper<PublishSponsorsTierPayload>;
  PullRequest: ResolverTypeWrapper<PullRequest>;
  PullRequestBranchUpdateMethod: PullRequestBranchUpdateMethod;
  PullRequestChangedFile: ResolverTypeWrapper<PullRequestChangedFile>;
  PullRequestChangedFileConnection: ResolverTypeWrapper<PullRequestChangedFileConnection>;
  PullRequestChangedFileEdge: ResolverTypeWrapper<PullRequestChangedFileEdge>;
  PullRequestCommit: ResolverTypeWrapper<PullRequestCommit>;
  PullRequestCommitCommentThread: ResolverTypeWrapper<PullRequestCommitCommentThread>;
  PullRequestCommitConnection: ResolverTypeWrapper<PullRequestCommitConnection>;
  PullRequestCommitEdge: ResolverTypeWrapper<PullRequestCommitEdge>;
  PullRequestConnection: ResolverTypeWrapper<PullRequestConnection>;
  PullRequestContributionsByRepository: ResolverTypeWrapper<PullRequestContributionsByRepository>;
  PullRequestEdge: ResolverTypeWrapper<PullRequestEdge>;
  PullRequestMergeMethod: PullRequestMergeMethod;
  PullRequestOrder: PullRequestOrder;
  PullRequestOrderField: PullRequestOrderField;
  PullRequestParameters: ResolverTypeWrapper<PullRequestParameters>;
  PullRequestParametersInput: PullRequestParametersInput;
  PullRequestReview: ResolverTypeWrapper<PullRequestReview>;
  PullRequestReviewComment: ResolverTypeWrapper<PullRequestReviewComment>;
  PullRequestReviewCommentConnection: ResolverTypeWrapper<PullRequestReviewCommentConnection>;
  PullRequestReviewCommentEdge: ResolverTypeWrapper<PullRequestReviewCommentEdge>;
  PullRequestReviewCommentState: PullRequestReviewCommentState;
  PullRequestReviewConnection: ResolverTypeWrapper<PullRequestReviewConnection>;
  PullRequestReviewContributionsByRepository: ResolverTypeWrapper<PullRequestReviewContributionsByRepository>;
  PullRequestReviewDecision: PullRequestReviewDecision;
  PullRequestReviewEdge: ResolverTypeWrapper<PullRequestReviewEdge>;
  PullRequestReviewEvent: PullRequestReviewEvent;
  PullRequestReviewState: PullRequestReviewState;
  PullRequestReviewThread: ResolverTypeWrapper<PullRequestReviewThread>;
  PullRequestReviewThreadConnection: ResolverTypeWrapper<PullRequestReviewThreadConnection>;
  PullRequestReviewThreadEdge: ResolverTypeWrapper<PullRequestReviewThreadEdge>;
  PullRequestReviewThreadSubjectType: PullRequestReviewThreadSubjectType;
  PullRequestRevisionMarker: ResolverTypeWrapper<PullRequestRevisionMarker>;
  PullRequestState: PullRequestState;
  PullRequestTemplate: ResolverTypeWrapper<PullRequestTemplate>;
  PullRequestThread: ResolverTypeWrapper<PullRequestThread>;
  PullRequestTimelineConnection: ResolverTypeWrapper<Omit<PullRequestTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['PullRequestTimelineItem']>>> }>;
  PullRequestTimelineItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PullRequestTimelineItem']>;
  PullRequestTimelineItemEdge: ResolverTypeWrapper<Omit<PullRequestTimelineItemEdge, 'node'> & { node?: Maybe<ResolversTypes['PullRequestTimelineItem']> }>;
  PullRequestTimelineItems: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PullRequestTimelineItems']>;
  PullRequestTimelineItemsConnection: ResolverTypeWrapper<Omit<PullRequestTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['PullRequestTimelineItems']>>> }>;
  PullRequestTimelineItemsEdge: ResolverTypeWrapper<Omit<PullRequestTimelineItemsEdge, 'node'> & { node?: Maybe<ResolversTypes['PullRequestTimelineItems']> }>;
  PullRequestTimelineItemsItemType: PullRequestTimelineItemsItemType;
  PullRequestUpdateState: PullRequestUpdateState;
  Push: ResolverTypeWrapper<Push>;
  PushAllowance: ResolverTypeWrapper<Omit<PushAllowance, 'actor'> & { actor?: Maybe<ResolversTypes['PushAllowanceActor']> }>;
  PushAllowanceActor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['PushAllowanceActor']>;
  PushAllowanceConnection: ResolverTypeWrapper<PushAllowanceConnection>;
  PushAllowanceEdge: ResolverTypeWrapper<PushAllowanceEdge>;
  Query: ResolverTypeWrapper<{}>;
  RateLimit: ResolverTypeWrapper<RateLimit>;
  Reactable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Reactable']>;
  ReactingUserConnection: ResolverTypeWrapper<ReactingUserConnection>;
  ReactingUserEdge: ResolverTypeWrapper<ReactingUserEdge>;
  Reaction: ResolverTypeWrapper<Reaction>;
  ReactionConnection: ResolverTypeWrapper<ReactionConnection>;
  ReactionContent: ReactionContent;
  ReactionEdge: ResolverTypeWrapper<ReactionEdge>;
  ReactionGroup: ResolverTypeWrapper<ReactionGroup>;
  ReactionOrder: ReactionOrder;
  ReactionOrderField: ReactionOrderField;
  Reactor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Reactor']>;
  ReactorConnection: ResolverTypeWrapper<Omit<ReactorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Reactor']>>> }>;
  ReactorEdge: ResolverTypeWrapper<Omit<ReactorEdge, 'node'> & { node: ResolversTypes['Reactor'] }>;
  ReadyForReviewEvent: ResolverTypeWrapper<ReadyForReviewEvent>;
  Ref: ResolverTypeWrapper<Ref>;
  RefConnection: ResolverTypeWrapper<RefConnection>;
  RefEdge: ResolverTypeWrapper<RefEdge>;
  RefNameConditionTarget: ResolverTypeWrapper<RefNameConditionTarget>;
  RefNameConditionTargetInput: RefNameConditionTargetInput;
  RefOrder: RefOrder;
  RefOrderField: RefOrderField;
  RefUpdate: RefUpdate;
  RefUpdateRule: ResolverTypeWrapper<RefUpdateRule>;
  ReferencedEvent: ResolverTypeWrapper<Omit<ReferencedEvent, 'subject'> & { subject: ResolversTypes['ReferencedSubject'] }>;
  ReferencedSubject: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ReferencedSubject']>;
  RegenerateEnterpriseIdentityProviderRecoveryCodesInput: RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
  RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: ResolverTypeWrapper<RegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;
  RegenerateVerifiableDomainTokenInput: RegenerateVerifiableDomainTokenInput;
  RegenerateVerifiableDomainTokenPayload: ResolverTypeWrapper<RegenerateVerifiableDomainTokenPayload>;
  RejectDeploymentsInput: RejectDeploymentsInput;
  RejectDeploymentsPayload: ResolverTypeWrapper<RejectDeploymentsPayload>;
  Release: ResolverTypeWrapper<Release>;
  ReleaseAsset: ResolverTypeWrapper<ReleaseAsset>;
  ReleaseAssetConnection: ResolverTypeWrapper<ReleaseAssetConnection>;
  ReleaseAssetEdge: ResolverTypeWrapper<ReleaseAssetEdge>;
  ReleaseConnection: ResolverTypeWrapper<ReleaseConnection>;
  ReleaseEdge: ResolverTypeWrapper<ReleaseEdge>;
  ReleaseOrder: ReleaseOrder;
  ReleaseOrderField: ReleaseOrderField;
  RemoveAssigneesFromAssignableInput: RemoveAssigneesFromAssignableInput;
  RemoveAssigneesFromAssignablePayload: ResolverTypeWrapper<RemoveAssigneesFromAssignablePayload>;
  RemoveEnterpriseAdminInput: RemoveEnterpriseAdminInput;
  RemoveEnterpriseAdminPayload: ResolverTypeWrapper<RemoveEnterpriseAdminPayload>;
  RemoveEnterpriseIdentityProviderInput: RemoveEnterpriseIdentityProviderInput;
  RemoveEnterpriseIdentityProviderPayload: ResolverTypeWrapper<RemoveEnterpriseIdentityProviderPayload>;
  RemoveEnterpriseMemberInput: RemoveEnterpriseMemberInput;
  RemoveEnterpriseMemberPayload: ResolverTypeWrapper<RemoveEnterpriseMemberPayload>;
  RemoveEnterpriseOrganizationInput: RemoveEnterpriseOrganizationInput;
  RemoveEnterpriseOrganizationPayload: ResolverTypeWrapper<RemoveEnterpriseOrganizationPayload>;
  RemoveEnterpriseSupportEntitlementInput: RemoveEnterpriseSupportEntitlementInput;
  RemoveEnterpriseSupportEntitlementPayload: ResolverTypeWrapper<RemoveEnterpriseSupportEntitlementPayload>;
  RemoveLabelsFromLabelableInput: RemoveLabelsFromLabelableInput;
  RemoveLabelsFromLabelablePayload: ResolverTypeWrapper<RemoveLabelsFromLabelablePayload>;
  RemoveOutsideCollaboratorInput: RemoveOutsideCollaboratorInput;
  RemoveOutsideCollaboratorPayload: ResolverTypeWrapper<RemoveOutsideCollaboratorPayload>;
  RemoveReactionInput: RemoveReactionInput;
  RemoveReactionPayload: ResolverTypeWrapper<RemoveReactionPayload>;
  RemoveStarInput: RemoveStarInput;
  RemoveStarPayload: ResolverTypeWrapper<RemoveStarPayload>;
  RemoveUpvoteInput: RemoveUpvoteInput;
  RemoveUpvotePayload: ResolverTypeWrapper<RemoveUpvotePayload>;
  RemovedFromMergeQueueEvent: ResolverTypeWrapper<RemovedFromMergeQueueEvent>;
  RemovedFromProjectEvent: ResolverTypeWrapper<RemovedFromProjectEvent>;
  RenamedTitleEvent: ResolverTypeWrapper<Omit<RenamedTitleEvent, 'subject'> & { subject: ResolversTypes['RenamedTitleSubject'] }>;
  RenamedTitleSubject: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RenamedTitleSubject']>;
  ReopenDiscussionInput: ReopenDiscussionInput;
  ReopenDiscussionPayload: ResolverTypeWrapper<ReopenDiscussionPayload>;
  ReopenIssueInput: ReopenIssueInput;
  ReopenIssuePayload: ResolverTypeWrapper<ReopenIssuePayload>;
  ReopenPullRequestInput: ReopenPullRequestInput;
  ReopenPullRequestPayload: ResolverTypeWrapper<ReopenPullRequestPayload>;
  ReopenedEvent: ResolverTypeWrapper<ReopenedEvent>;
  RepoAccessAuditEntry: ResolverTypeWrapper<Omit<RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoAccessAuditEntryVisibility: RepoAccessAuditEntryVisibility;
  RepoAddMemberAuditEntry: ResolverTypeWrapper<Omit<RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoAddMemberAuditEntryVisibility: RepoAddMemberAuditEntryVisibility;
  RepoAddTopicAuditEntry: ResolverTypeWrapper<Omit<RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoArchivedAuditEntry: ResolverTypeWrapper<Omit<RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoArchivedAuditEntryVisibility: RepoArchivedAuditEntryVisibility;
  RepoChangeMergeSettingAuditEntry: ResolverTypeWrapper<Omit<RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoChangeMergeSettingAuditEntryMergeType: RepoChangeMergeSettingAuditEntryMergeType;
  RepoConfigDisableAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoConfigDisableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoConfigDisableContributorsOnlyAuditEntry: ResolverTypeWrapper<Omit<RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoConfigDisableSockpuppetDisallowedAuditEntry: ResolverTypeWrapper<Omit<RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoConfigEnableAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoConfigEnableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoConfigEnableContributorsOnlyAuditEntry: ResolverTypeWrapper<Omit<RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoConfigEnableSockpuppetDisallowedAuditEntry: ResolverTypeWrapper<Omit<RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoConfigLockAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoConfigUnlockAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoCreateAuditEntry: ResolverTypeWrapper<Omit<RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoCreateAuditEntryVisibility: RepoCreateAuditEntryVisibility;
  RepoDestroyAuditEntry: ResolverTypeWrapper<Omit<RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoDestroyAuditEntryVisibility: RepoDestroyAuditEntryVisibility;
  RepoRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepoRemoveMemberAuditEntryVisibility: RepoRemoveMemberAuditEntryVisibility;
  RepoRemoveTopicAuditEntry: ResolverTypeWrapper<Omit<RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  ReportedContentClassifiers: ReportedContentClassifiers;
  Repository: ResolverTypeWrapper<Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<ResolversTypes['IssueOrPullRequest']> }>;
  RepositoryAffiliation: RepositoryAffiliation;
  RepositoryAuditEntryData: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['RepositoryAuditEntryData']>;
  RepositoryCodeowners: ResolverTypeWrapper<RepositoryCodeowners>;
  RepositoryCodeownersError: ResolverTypeWrapper<RepositoryCodeownersError>;
  RepositoryCollaboratorConnection: ResolverTypeWrapper<RepositoryCollaboratorConnection>;
  RepositoryCollaboratorEdge: ResolverTypeWrapper<RepositoryCollaboratorEdge>;
  RepositoryConnection: ResolverTypeWrapper<RepositoryConnection>;
  RepositoryContactLink: ResolverTypeWrapper<RepositoryContactLink>;
  RepositoryContributionType: RepositoryContributionType;
  RepositoryDiscussionAuthor: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['RepositoryDiscussionAuthor']>;
  RepositoryDiscussionCommentAuthor: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['RepositoryDiscussionCommentAuthor']>;
  RepositoryEdge: ResolverTypeWrapper<RepositoryEdge>;
  RepositoryIdConditionTarget: ResolverTypeWrapper<RepositoryIdConditionTarget>;
  RepositoryIdConditionTargetInput: RepositoryIdConditionTargetInput;
  RepositoryInfo: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['RepositoryInfo']>;
  RepositoryInteractionAbility: ResolverTypeWrapper<RepositoryInteractionAbility>;
  RepositoryInteractionLimit: RepositoryInteractionLimit;
  RepositoryInteractionLimitExpiry: RepositoryInteractionLimitExpiry;
  RepositoryInteractionLimitOrigin: RepositoryInteractionLimitOrigin;
  RepositoryInvitation: ResolverTypeWrapper<RepositoryInvitation>;
  RepositoryInvitationConnection: ResolverTypeWrapper<RepositoryInvitationConnection>;
  RepositoryInvitationEdge: ResolverTypeWrapper<RepositoryInvitationEdge>;
  RepositoryInvitationOrder: RepositoryInvitationOrder;
  RepositoryInvitationOrderField: RepositoryInvitationOrderField;
  RepositoryLockReason: RepositoryLockReason;
  RepositoryMigration: ResolverTypeWrapper<RepositoryMigration>;
  RepositoryMigrationConnection: ResolverTypeWrapper<RepositoryMigrationConnection>;
  RepositoryMigrationEdge: ResolverTypeWrapper<RepositoryMigrationEdge>;
  RepositoryMigrationOrder: RepositoryMigrationOrder;
  RepositoryMigrationOrderDirection: RepositoryMigrationOrderDirection;
  RepositoryMigrationOrderField: RepositoryMigrationOrderField;
  RepositoryNameConditionTarget: ResolverTypeWrapper<RepositoryNameConditionTarget>;
  RepositoryNameConditionTargetInput: RepositoryNameConditionTargetInput;
  RepositoryNode: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['RepositoryNode']>;
  RepositoryOrder: RepositoryOrder;
  RepositoryOrderField: RepositoryOrderField;
  RepositoryOwner: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['RepositoryOwner']>;
  RepositoryPermission: RepositoryPermission;
  RepositoryPrivacy: RepositoryPrivacy;
  RepositoryRule: ResolverTypeWrapper<Omit<RepositoryRule, 'parameters'> & { parameters?: Maybe<ResolversTypes['RuleParameters']> }>;
  RepositoryRuleConditions: ResolverTypeWrapper<RepositoryRuleConditions>;
  RepositoryRuleConditionsInput: RepositoryRuleConditionsInput;
  RepositoryRuleConnection: ResolverTypeWrapper<RepositoryRuleConnection>;
  RepositoryRuleEdge: ResolverTypeWrapper<RepositoryRuleEdge>;
  RepositoryRuleInput: RepositoryRuleInput;
  RepositoryRuleType: RepositoryRuleType;
  RepositoryRuleset: ResolverTypeWrapper<Omit<RepositoryRuleset, 'source'> & { source: ResolversTypes['RuleSource'] }>;
  RepositoryRulesetBypassActor: ResolverTypeWrapper<Omit<RepositoryRulesetBypassActor, 'actor'> & { actor?: Maybe<ResolversTypes['BypassActor']> }>;
  RepositoryRulesetBypassActorBypassMode: RepositoryRulesetBypassActorBypassMode;
  RepositoryRulesetBypassActorConnection: ResolverTypeWrapper<RepositoryRulesetBypassActorConnection>;
  RepositoryRulesetBypassActorEdge: ResolverTypeWrapper<RepositoryRulesetBypassActorEdge>;
  RepositoryRulesetBypassActorInput: RepositoryRulesetBypassActorInput;
  RepositoryRulesetConnection: ResolverTypeWrapper<RepositoryRulesetConnection>;
  RepositoryRulesetEdge: ResolverTypeWrapper<RepositoryRulesetEdge>;
  RepositoryRulesetTarget: RepositoryRulesetTarget;
  RepositoryTopic: ResolverTypeWrapper<RepositoryTopic>;
  RepositoryTopicConnection: ResolverTypeWrapper<RepositoryTopicConnection>;
  RepositoryTopicEdge: ResolverTypeWrapper<RepositoryTopicEdge>;
  RepositoryVisibility: RepositoryVisibility;
  RepositoryVisibilityChangeDisableAuditEntry: ResolverTypeWrapper<Omit<RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepositoryVisibilityChangeEnableAuditEntry: ResolverTypeWrapper<Omit<RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  RepositoryVulnerabilityAlert: ResolverTypeWrapper<RepositoryVulnerabilityAlert>;
  RepositoryVulnerabilityAlertConnection: ResolverTypeWrapper<RepositoryVulnerabilityAlertConnection>;
  RepositoryVulnerabilityAlertDependencyScope: RepositoryVulnerabilityAlertDependencyScope;
  RepositoryVulnerabilityAlertEdge: ResolverTypeWrapper<RepositoryVulnerabilityAlertEdge>;
  RepositoryVulnerabilityAlertState: RepositoryVulnerabilityAlertState;
  RequestReviewsInput: RequestReviewsInput;
  RequestReviewsPayload: ResolverTypeWrapper<RequestReviewsPayload>;
  RequestableCheckStatusState: RequestableCheckStatusState;
  RequestedReviewer: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RequestedReviewer']>;
  RequestedReviewerConnection: ResolverTypeWrapper<Omit<RequestedReviewerConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['RequestedReviewer']>>> }>;
  RequestedReviewerEdge: ResolverTypeWrapper<Omit<RequestedReviewerEdge, 'node'> & { node?: Maybe<ResolversTypes['RequestedReviewer']> }>;
  RequirableByPullRequest: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['RequirableByPullRequest']>;
  RequiredDeploymentsParameters: ResolverTypeWrapper<RequiredDeploymentsParameters>;
  RequiredDeploymentsParametersInput: RequiredDeploymentsParametersInput;
  RequiredStatusCheckDescription: ResolverTypeWrapper<RequiredStatusCheckDescription>;
  RequiredStatusCheckInput: RequiredStatusCheckInput;
  RequiredStatusChecksParameters: ResolverTypeWrapper<RequiredStatusChecksParameters>;
  RequiredStatusChecksParametersInput: RequiredStatusChecksParametersInput;
  RerequestCheckSuiteInput: RerequestCheckSuiteInput;
  RerequestCheckSuitePayload: ResolverTypeWrapper<RerequestCheckSuitePayload>;
  ResolveReviewThreadInput: ResolveReviewThreadInput;
  ResolveReviewThreadPayload: ResolverTypeWrapper<ResolveReviewThreadPayload>;
  RestrictedContribution: ResolverTypeWrapper<RestrictedContribution>;
  RetireSponsorsTierInput: RetireSponsorsTierInput;
  RetireSponsorsTierPayload: ResolverTypeWrapper<RetireSponsorsTierPayload>;
  RevertPullRequestInput: RevertPullRequestInput;
  RevertPullRequestPayload: ResolverTypeWrapper<RevertPullRequestPayload>;
  ReviewDismissalAllowance: ResolverTypeWrapper<Omit<ReviewDismissalAllowance, 'actor'> & { actor?: Maybe<ResolversTypes['ReviewDismissalAllowanceActor']> }>;
  ReviewDismissalAllowanceActor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ReviewDismissalAllowanceActor']>;
  ReviewDismissalAllowanceConnection: ResolverTypeWrapper<ReviewDismissalAllowanceConnection>;
  ReviewDismissalAllowanceEdge: ResolverTypeWrapper<ReviewDismissalAllowanceEdge>;
  ReviewDismissedEvent: ResolverTypeWrapper<ReviewDismissedEvent>;
  ReviewRequest: ResolverTypeWrapper<Omit<ReviewRequest, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversTypes['RequestedReviewer']> }>;
  ReviewRequestConnection: ResolverTypeWrapper<ReviewRequestConnection>;
  ReviewRequestEdge: ResolverTypeWrapper<ReviewRequestEdge>;
  ReviewRequestRemovedEvent: ResolverTypeWrapper<Omit<ReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversTypes['RequestedReviewer']> }>;
  ReviewRequestedEvent: ResolverTypeWrapper<Omit<ReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversTypes['RequestedReviewer']> }>;
  ReviewStatusHovercardContext: ResolverTypeWrapper<ReviewStatusHovercardContext>;
  RevokeEnterpriseOrganizationsMigratorRoleInput: RevokeEnterpriseOrganizationsMigratorRoleInput;
  RevokeEnterpriseOrganizationsMigratorRolePayload: ResolverTypeWrapper<RevokeEnterpriseOrganizationsMigratorRolePayload>;
  RevokeMigratorRoleInput: RevokeMigratorRoleInput;
  RevokeMigratorRolePayload: ResolverTypeWrapper<RevokeMigratorRolePayload>;
  RoleInOrganization: RoleInOrganization;
  RuleEnforcement: RuleEnforcement;
  RuleParameters: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RuleParameters']>;
  RuleParametersInput: RuleParametersInput;
  RuleSource: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RuleSource']>;
  SamlDigestAlgorithm: SamlDigestAlgorithm;
  SamlSignatureAlgorithm: SamlSignatureAlgorithm;
  SavedReply: ResolverTypeWrapper<SavedReply>;
  SavedReplyConnection: ResolverTypeWrapper<SavedReplyConnection>;
  SavedReplyEdge: ResolverTypeWrapper<SavedReplyEdge>;
  SavedReplyOrder: SavedReplyOrder;
  SavedReplyOrderField: SavedReplyOrderField;
  SearchResultItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SearchResultItem']>;
  SearchResultItemConnection: ResolverTypeWrapper<Omit<SearchResultItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['SearchResultItem']>>> }>;
  SearchResultItemEdge: ResolverTypeWrapper<Omit<SearchResultItemEdge, 'node'> & { node?: Maybe<ResolversTypes['SearchResultItem']> }>;
  SearchType: SearchType;
  SecurityAdvisory: ResolverTypeWrapper<SecurityAdvisory>;
  SecurityAdvisoryClassification: SecurityAdvisoryClassification;
  SecurityAdvisoryConnection: ResolverTypeWrapper<SecurityAdvisoryConnection>;
  SecurityAdvisoryEcosystem: SecurityAdvisoryEcosystem;
  SecurityAdvisoryEdge: ResolverTypeWrapper<SecurityAdvisoryEdge>;
  SecurityAdvisoryIdentifier: ResolverTypeWrapper<SecurityAdvisoryIdentifier>;
  SecurityAdvisoryIdentifierFilter: SecurityAdvisoryIdentifierFilter;
  SecurityAdvisoryIdentifierType: SecurityAdvisoryIdentifierType;
  SecurityAdvisoryOrder: SecurityAdvisoryOrder;
  SecurityAdvisoryOrderField: SecurityAdvisoryOrderField;
  SecurityAdvisoryPackage: ResolverTypeWrapper<SecurityAdvisoryPackage>;
  SecurityAdvisoryPackageVersion: ResolverTypeWrapper<SecurityAdvisoryPackageVersion>;
  SecurityAdvisoryReference: ResolverTypeWrapper<SecurityAdvisoryReference>;
  SecurityAdvisorySeverity: SecurityAdvisorySeverity;
  SecurityVulnerability: ResolverTypeWrapper<SecurityVulnerability>;
  SecurityVulnerabilityConnection: ResolverTypeWrapper<SecurityVulnerabilityConnection>;
  SecurityVulnerabilityEdge: ResolverTypeWrapper<SecurityVulnerabilityEdge>;
  SecurityVulnerabilityOrder: SecurityVulnerabilityOrder;
  SecurityVulnerabilityOrderField: SecurityVulnerabilityOrderField;
  SetEnterpriseIdentityProviderInput: SetEnterpriseIdentityProviderInput;
  SetEnterpriseIdentityProviderPayload: ResolverTypeWrapper<SetEnterpriseIdentityProviderPayload>;
  SetOrganizationInteractionLimitInput: SetOrganizationInteractionLimitInput;
  SetOrganizationInteractionLimitPayload: ResolverTypeWrapper<SetOrganizationInteractionLimitPayload>;
  SetRepositoryInteractionLimitInput: SetRepositoryInteractionLimitInput;
  SetRepositoryInteractionLimitPayload: ResolverTypeWrapper<SetRepositoryInteractionLimitPayload>;
  SetUserInteractionLimitInput: SetUserInteractionLimitInput;
  SetUserInteractionLimitPayload: ResolverTypeWrapper<SetUserInteractionLimitPayload>;
  SmimeSignature: ResolverTypeWrapper<SmimeSignature>;
  SocialAccount: ResolverTypeWrapper<SocialAccount>;
  SocialAccountConnection: ResolverTypeWrapper<SocialAccountConnection>;
  SocialAccountEdge: ResolverTypeWrapper<SocialAccountEdge>;
  SocialAccountProvider: SocialAccountProvider;
  Sponsor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Sponsor']>;
  SponsorConnection: ResolverTypeWrapper<Omit<SponsorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Sponsor']>>> }>;
  SponsorEdge: ResolverTypeWrapper<Omit<SponsorEdge, 'node'> & { node?: Maybe<ResolversTypes['Sponsor']> }>;
  SponsorOrder: SponsorOrder;
  SponsorOrderField: SponsorOrderField;
  Sponsorable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Sponsorable']>;
  SponsorableItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SponsorableItem']>;
  SponsorableItemConnection: ResolverTypeWrapper<Omit<SponsorableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['SponsorableItem']>>> }>;
  SponsorableItemEdge: ResolverTypeWrapper<Omit<SponsorableItemEdge, 'node'> & { node?: Maybe<ResolversTypes['SponsorableItem']> }>;
  SponsorableOrder: SponsorableOrder;
  SponsorableOrderField: SponsorableOrderField;
  SponsorsActivity: ResolverTypeWrapper<Omit<SponsorsActivity, 'sponsor'> & { sponsor?: Maybe<ResolversTypes['Sponsor']> }>;
  SponsorsActivityAction: SponsorsActivityAction;
  SponsorsActivityConnection: ResolverTypeWrapper<SponsorsActivityConnection>;
  SponsorsActivityEdge: ResolverTypeWrapper<SponsorsActivityEdge>;
  SponsorsActivityOrder: SponsorsActivityOrder;
  SponsorsActivityOrderField: SponsorsActivityOrderField;
  SponsorsActivityPeriod: SponsorsActivityPeriod;
  SponsorsCountryOrRegionCode: SponsorsCountryOrRegionCode;
  SponsorsGoal: ResolverTypeWrapper<SponsorsGoal>;
  SponsorsGoalKind: SponsorsGoalKind;
  SponsorsListing: ResolverTypeWrapper<SponsorsListing>;
  SponsorsListingFeatureableItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SponsorsListingFeatureableItem']>;
  SponsorsListingFeaturedItem: ResolverTypeWrapper<Omit<SponsorsListingFeaturedItem, 'featureable'> & { featureable: ResolversTypes['SponsorsListingFeatureableItem'] }>;
  SponsorsListingFeaturedItemFeatureableType: SponsorsListingFeaturedItemFeatureableType;
  SponsorsTier: ResolverTypeWrapper<SponsorsTier>;
  SponsorsTierAdminInfo: ResolverTypeWrapper<SponsorsTierAdminInfo>;
  SponsorsTierConnection: ResolverTypeWrapper<SponsorsTierConnection>;
  SponsorsTierEdge: ResolverTypeWrapper<SponsorsTierEdge>;
  SponsorsTierOrder: SponsorsTierOrder;
  SponsorsTierOrderField: SponsorsTierOrderField;
  Sponsorship: ResolverTypeWrapper<Omit<Sponsorship, 'sponsorEntity'> & { sponsorEntity?: Maybe<ResolversTypes['Sponsor']> }>;
  SponsorshipConnection: ResolverTypeWrapper<SponsorshipConnection>;
  SponsorshipEdge: ResolverTypeWrapper<SponsorshipEdge>;
  SponsorshipNewsletter: ResolverTypeWrapper<SponsorshipNewsletter>;
  SponsorshipNewsletterConnection: ResolverTypeWrapper<SponsorshipNewsletterConnection>;
  SponsorshipNewsletterEdge: ResolverTypeWrapper<SponsorshipNewsletterEdge>;
  SponsorshipNewsletterOrder: SponsorshipNewsletterOrder;
  SponsorshipNewsletterOrderField: SponsorshipNewsletterOrderField;
  SponsorshipOrder: SponsorshipOrder;
  SponsorshipOrderField: SponsorshipOrderField;
  SponsorshipPaymentSource: SponsorshipPaymentSource;
  SponsorshipPrivacy: SponsorshipPrivacy;
  SquashMergeCommitMessage: SquashMergeCommitMessage;
  SquashMergeCommitTitle: SquashMergeCommitTitle;
  SshSignature: ResolverTypeWrapper<SshSignature>;
  StarOrder: StarOrder;
  StarOrderField: StarOrderField;
  StargazerConnection: ResolverTypeWrapper<StargazerConnection>;
  StargazerEdge: ResolverTypeWrapper<StargazerEdge>;
  Starrable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Starrable']>;
  StarredRepositoryConnection: ResolverTypeWrapper<StarredRepositoryConnection>;
  StarredRepositoryEdge: ResolverTypeWrapper<StarredRepositoryEdge>;
  StartOrganizationMigrationInput: StartOrganizationMigrationInput;
  StartOrganizationMigrationPayload: ResolverTypeWrapper<StartOrganizationMigrationPayload>;
  StartRepositoryMigrationInput: StartRepositoryMigrationInput;
  StartRepositoryMigrationPayload: ResolverTypeWrapper<StartRepositoryMigrationPayload>;
  Status: ResolverTypeWrapper<Status>;
  StatusCheckConfiguration: ResolverTypeWrapper<StatusCheckConfiguration>;
  StatusCheckConfigurationInput: StatusCheckConfigurationInput;
  StatusCheckRollup: ResolverTypeWrapper<StatusCheckRollup>;
  StatusCheckRollupContext: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StatusCheckRollupContext']>;
  StatusCheckRollupContextConnection: ResolverTypeWrapper<Omit<StatusCheckRollupContextConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['StatusCheckRollupContext']>>> }>;
  StatusCheckRollupContextEdge: ResolverTypeWrapper<Omit<StatusCheckRollupContextEdge, 'node'> & { node?: Maybe<ResolversTypes['StatusCheckRollupContext']> }>;
  StatusContext: ResolverTypeWrapper<StatusContext>;
  StatusContextStateCount: ResolverTypeWrapper<StatusContextStateCount>;
  StatusState: StatusState;
  StripeConnectAccount: ResolverTypeWrapper<StripeConnectAccount>;
  SubmitPullRequestReviewInput: SubmitPullRequestReviewInput;
  SubmitPullRequestReviewPayload: ResolverTypeWrapper<SubmitPullRequestReviewPayload>;
  Submodule: ResolverTypeWrapper<Submodule>;
  SubmoduleConnection: ResolverTypeWrapper<SubmoduleConnection>;
  SubmoduleEdge: ResolverTypeWrapper<SubmoduleEdge>;
  Subscribable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Subscribable']>;
  SubscribableThread: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['SubscribableThread']>;
  SubscribedEvent: ResolverTypeWrapper<SubscribedEvent>;
  SubscriptionState: SubscriptionState;
  SuggestedReviewer: ResolverTypeWrapper<SuggestedReviewer>;
  Tag: ResolverTypeWrapper<Tag>;
  TagNamePatternParameters: ResolverTypeWrapper<TagNamePatternParameters>;
  TagNamePatternParametersInput: TagNamePatternParametersInput;
  Team: ResolverTypeWrapper<Team>;
  TeamAddMemberAuditEntry: ResolverTypeWrapper<Omit<TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  TeamAddRepositoryAuditEntry: ResolverTypeWrapper<Omit<TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  TeamAuditEntryData: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['TeamAuditEntryData']>;
  TeamChangeParentTeamAuditEntry: ResolverTypeWrapper<Omit<TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  TeamConnection: ResolverTypeWrapper<TeamConnection>;
  TeamDiscussion: ResolverTypeWrapper<TeamDiscussion>;
  TeamDiscussionComment: ResolverTypeWrapper<TeamDiscussionComment>;
  TeamDiscussionCommentConnection: ResolverTypeWrapper<TeamDiscussionCommentConnection>;
  TeamDiscussionCommentEdge: ResolverTypeWrapper<TeamDiscussionCommentEdge>;
  TeamDiscussionCommentOrder: TeamDiscussionCommentOrder;
  TeamDiscussionCommentOrderField: TeamDiscussionCommentOrderField;
  TeamDiscussionConnection: ResolverTypeWrapper<TeamDiscussionConnection>;
  TeamDiscussionEdge: ResolverTypeWrapper<TeamDiscussionEdge>;
  TeamDiscussionOrder: TeamDiscussionOrder;
  TeamDiscussionOrderField: TeamDiscussionOrderField;
  TeamEdge: ResolverTypeWrapper<TeamEdge>;
  TeamMemberConnection: ResolverTypeWrapper<TeamMemberConnection>;
  TeamMemberEdge: ResolverTypeWrapper<TeamMemberEdge>;
  TeamMemberOrder: TeamMemberOrder;
  TeamMemberOrderField: TeamMemberOrderField;
  TeamMemberRole: TeamMemberRole;
  TeamMembershipType: TeamMembershipType;
  TeamNotificationSetting: TeamNotificationSetting;
  TeamOrder: TeamOrder;
  TeamOrderField: TeamOrderField;
  TeamPrivacy: TeamPrivacy;
  TeamRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  TeamRemoveRepositoryAuditEntry: ResolverTypeWrapper<Omit<TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['AuditEntryActor']> }>;
  TeamRepositoryConnection: ResolverTypeWrapper<TeamRepositoryConnection>;
  TeamRepositoryEdge: ResolverTypeWrapper<TeamRepositoryEdge>;
  TeamRepositoryOrder: TeamRepositoryOrder;
  TeamRepositoryOrderField: TeamRepositoryOrderField;
  TeamReviewAssignmentAlgorithm: TeamReviewAssignmentAlgorithm;
  TeamRole: TeamRole;
  TextMatch: ResolverTypeWrapper<TextMatch>;
  TextMatchHighlight: ResolverTypeWrapper<TextMatchHighlight>;
  ThreadSubscriptionFormAction: ThreadSubscriptionFormAction;
  ThreadSubscriptionState: ThreadSubscriptionState;
  Topic: ResolverTypeWrapper<Topic>;
  TopicAuditEntryData: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['TopicAuditEntryData']>;
  TopicSuggestionDeclineReason: TopicSuggestionDeclineReason;
  TrackedIssueStates: TrackedIssueStates;
  TransferEnterpriseOrganizationInput: TransferEnterpriseOrganizationInput;
  TransferEnterpriseOrganizationPayload: ResolverTypeWrapper<TransferEnterpriseOrganizationPayload>;
  TransferIssueInput: TransferIssueInput;
  TransferIssuePayload: ResolverTypeWrapper<TransferIssuePayload>;
  TransferredEvent: ResolverTypeWrapper<TransferredEvent>;
  Tree: ResolverTypeWrapper<Tree>;
  TreeEntry: ResolverTypeWrapper<TreeEntry>;
  URI: ResolverTypeWrapper<Scalars['URI']['output']>;
  UnarchiveProjectV2ItemInput: UnarchiveProjectV2ItemInput;
  UnarchiveProjectV2ItemPayload: ResolverTypeWrapper<UnarchiveProjectV2ItemPayload>;
  UnarchiveRepositoryInput: UnarchiveRepositoryInput;
  UnarchiveRepositoryPayload: ResolverTypeWrapper<UnarchiveRepositoryPayload>;
  UnassignedEvent: ResolverTypeWrapper<Omit<UnassignedEvent, 'assignee'> & { assignee?: Maybe<ResolversTypes['Assignee']> }>;
  UnfollowOrganizationInput: UnfollowOrganizationInput;
  UnfollowOrganizationPayload: ResolverTypeWrapper<UnfollowOrganizationPayload>;
  UnfollowUserInput: UnfollowUserInput;
  UnfollowUserPayload: ResolverTypeWrapper<UnfollowUserPayload>;
  UniformResourceLocatable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['UniformResourceLocatable']>;
  UnknownSignature: ResolverTypeWrapper<UnknownSignature>;
  UnlabeledEvent: ResolverTypeWrapper<UnlabeledEvent>;
  UnlinkProjectV2FromRepositoryInput: UnlinkProjectV2FromRepositoryInput;
  UnlinkProjectV2FromRepositoryPayload: ResolverTypeWrapper<UnlinkProjectV2FromRepositoryPayload>;
  UnlinkProjectV2FromTeamInput: UnlinkProjectV2FromTeamInput;
  UnlinkProjectV2FromTeamPayload: ResolverTypeWrapper<UnlinkProjectV2FromTeamPayload>;
  UnlinkRepositoryFromProjectInput: UnlinkRepositoryFromProjectInput;
  UnlinkRepositoryFromProjectPayload: ResolverTypeWrapper<UnlinkRepositoryFromProjectPayload>;
  UnlockLockableInput: UnlockLockableInput;
  UnlockLockablePayload: ResolverTypeWrapper<UnlockLockablePayload>;
  UnlockedEvent: ResolverTypeWrapper<UnlockedEvent>;
  UnmarkDiscussionCommentAsAnswerInput: UnmarkDiscussionCommentAsAnswerInput;
  UnmarkDiscussionCommentAsAnswerPayload: ResolverTypeWrapper<UnmarkDiscussionCommentAsAnswerPayload>;
  UnmarkFileAsViewedInput: UnmarkFileAsViewedInput;
  UnmarkFileAsViewedPayload: ResolverTypeWrapper<UnmarkFileAsViewedPayload>;
  UnmarkIssueAsDuplicateInput: UnmarkIssueAsDuplicateInput;
  UnmarkIssueAsDuplicatePayload: ResolverTypeWrapper<Omit<UnmarkIssueAsDuplicatePayload, 'duplicate'> & { duplicate?: Maybe<ResolversTypes['IssueOrPullRequest']> }>;
  UnmarkProjectV2AsTemplateInput: UnmarkProjectV2AsTemplateInput;
  UnmarkProjectV2AsTemplatePayload: ResolverTypeWrapper<UnmarkProjectV2AsTemplatePayload>;
  UnmarkedAsDuplicateEvent: ResolverTypeWrapper<Omit<UnmarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<ResolversTypes['IssueOrPullRequest']>, duplicate?: Maybe<ResolversTypes['IssueOrPullRequest']> }>;
  UnminimizeCommentInput: UnminimizeCommentInput;
  UnminimizeCommentPayload: ResolverTypeWrapper<UnminimizeCommentPayload>;
  UnpinIssueInput: UnpinIssueInput;
  UnpinIssuePayload: ResolverTypeWrapper<UnpinIssuePayload>;
  UnpinnedEvent: ResolverTypeWrapper<UnpinnedEvent>;
  UnresolveReviewThreadInput: UnresolveReviewThreadInput;
  UnresolveReviewThreadPayload: ResolverTypeWrapper<UnresolveReviewThreadPayload>;
  UnsubscribeFromNotificationsInput: UnsubscribeFromNotificationsInput;
  UnsubscribeFromNotificationsPayload: ResolverTypeWrapper<UnsubscribeFromNotificationsPayload>;
  UnsubscribedEvent: ResolverTypeWrapper<UnsubscribedEvent>;
  Updatable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Updatable']>;
  UpdatableComment: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['UpdatableComment']>;
  UpdateBranchProtectionRuleInput: UpdateBranchProtectionRuleInput;
  UpdateBranchProtectionRulePayload: ResolverTypeWrapper<UpdateBranchProtectionRulePayload>;
  UpdateCheckRunInput: UpdateCheckRunInput;
  UpdateCheckRunPayload: ResolverTypeWrapper<UpdateCheckRunPayload>;
  UpdateCheckSuitePreferencesInput: UpdateCheckSuitePreferencesInput;
  UpdateCheckSuitePreferencesPayload: ResolverTypeWrapper<UpdateCheckSuitePreferencesPayload>;
  UpdateDiscussionCommentInput: UpdateDiscussionCommentInput;
  UpdateDiscussionCommentPayload: ResolverTypeWrapper<UpdateDiscussionCommentPayload>;
  UpdateDiscussionInput: UpdateDiscussionInput;
  UpdateDiscussionPayload: ResolverTypeWrapper<UpdateDiscussionPayload>;
  UpdateEnterpriseAdministratorRoleInput: UpdateEnterpriseAdministratorRoleInput;
  UpdateEnterpriseAdministratorRolePayload: ResolverTypeWrapper<UpdateEnterpriseAdministratorRolePayload>;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: ResolverTypeWrapper<UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;
  UpdateEnterpriseDefaultRepositoryPermissionSettingInput: UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
  UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: ResolverTypeWrapper<UpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: ResolverTypeWrapper<UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingInput: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: ResolverTypeWrapper<UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;
  UpdateEnterpriseMembersCanDeleteIssuesSettingInput: UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
  UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: ResolverTypeWrapper<UpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: ResolverTypeWrapper<UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: ResolverTypeWrapper<UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;
  UpdateEnterpriseMembersCanMakePurchasesSettingInput: UpdateEnterpriseMembersCanMakePurchasesSettingInput;
  UpdateEnterpriseMembersCanMakePurchasesSettingPayload: ResolverTypeWrapper<UpdateEnterpriseMembersCanMakePurchasesSettingPayload>;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: ResolverTypeWrapper<UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: ResolverTypeWrapper<UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;
  UpdateEnterpriseOrganizationProjectsSettingInput: UpdateEnterpriseOrganizationProjectsSettingInput;
  UpdateEnterpriseOrganizationProjectsSettingPayload: ResolverTypeWrapper<UpdateEnterpriseOrganizationProjectsSettingPayload>;
  UpdateEnterpriseOwnerOrganizationRoleInput: UpdateEnterpriseOwnerOrganizationRoleInput;
  UpdateEnterpriseOwnerOrganizationRolePayload: ResolverTypeWrapper<UpdateEnterpriseOwnerOrganizationRolePayload>;
  UpdateEnterpriseProfileInput: UpdateEnterpriseProfileInput;
  UpdateEnterpriseProfilePayload: ResolverTypeWrapper<UpdateEnterpriseProfilePayload>;
  UpdateEnterpriseRepositoryProjectsSettingInput: UpdateEnterpriseRepositoryProjectsSettingInput;
  UpdateEnterpriseRepositoryProjectsSettingPayload: ResolverTypeWrapper<UpdateEnterpriseRepositoryProjectsSettingPayload>;
  UpdateEnterpriseTeamDiscussionsSettingInput: UpdateEnterpriseTeamDiscussionsSettingInput;
  UpdateEnterpriseTeamDiscussionsSettingPayload: ResolverTypeWrapper<UpdateEnterpriseTeamDiscussionsSettingPayload>;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: ResolverTypeWrapper<UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;
  UpdateEnvironmentInput: UpdateEnvironmentInput;
  UpdateEnvironmentPayload: ResolverTypeWrapper<UpdateEnvironmentPayload>;
  UpdateIpAllowListEnabledSettingInput: UpdateIpAllowListEnabledSettingInput;
  UpdateIpAllowListEnabledSettingPayload: ResolverTypeWrapper<Omit<UpdateIpAllowListEnabledSettingPayload, 'owner'> & { owner?: Maybe<ResolversTypes['IpAllowListOwner']> }>;
  UpdateIpAllowListEntryInput: UpdateIpAllowListEntryInput;
  UpdateIpAllowListEntryPayload: ResolverTypeWrapper<UpdateIpAllowListEntryPayload>;
  UpdateIpAllowListForInstalledAppsEnabledSettingInput: UpdateIpAllowListForInstalledAppsEnabledSettingInput;
  UpdateIpAllowListForInstalledAppsEnabledSettingPayload: ResolverTypeWrapper<Omit<UpdateIpAllowListForInstalledAppsEnabledSettingPayload, 'owner'> & { owner?: Maybe<ResolversTypes['IpAllowListOwner']> }>;
  UpdateIssueCommentInput: UpdateIssueCommentInput;
  UpdateIssueCommentPayload: ResolverTypeWrapper<UpdateIssueCommentPayload>;
  UpdateIssueInput: UpdateIssueInput;
  UpdateIssuePayload: ResolverTypeWrapper<UpdateIssuePayload>;
  UpdateLabelInput: UpdateLabelInput;
  UpdateLabelPayload: ResolverTypeWrapper<UpdateLabelPayload>;
  UpdateNotificationRestrictionSettingInput: UpdateNotificationRestrictionSettingInput;
  UpdateNotificationRestrictionSettingPayload: ResolverTypeWrapper<Omit<UpdateNotificationRestrictionSettingPayload, 'owner'> & { owner?: Maybe<ResolversTypes['VerifiableDomainOwner']> }>;
  UpdateOrganizationAllowPrivateRepositoryForkingSettingInput: UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
  UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload: ResolverTypeWrapper<UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload>;
  UpdateOrganizationWebCommitSignoffSettingInput: UpdateOrganizationWebCommitSignoffSettingInput;
  UpdateOrganizationWebCommitSignoffSettingPayload: ResolverTypeWrapper<UpdateOrganizationWebCommitSignoffSettingPayload>;
  UpdateParameters: ResolverTypeWrapper<UpdateParameters>;
  UpdateParametersInput: UpdateParametersInput;
  UpdatePatreonSponsorabilityInput: UpdatePatreonSponsorabilityInput;
  UpdatePatreonSponsorabilityPayload: ResolverTypeWrapper<UpdatePatreonSponsorabilityPayload>;
  UpdateProjectCardInput: UpdateProjectCardInput;
  UpdateProjectCardPayload: ResolverTypeWrapper<UpdateProjectCardPayload>;
  UpdateProjectColumnInput: UpdateProjectColumnInput;
  UpdateProjectColumnPayload: ResolverTypeWrapper<UpdateProjectColumnPayload>;
  UpdateProjectInput: UpdateProjectInput;
  UpdateProjectPayload: ResolverTypeWrapper<UpdateProjectPayload>;
  UpdateProjectV2CollaboratorsInput: UpdateProjectV2CollaboratorsInput;
  UpdateProjectV2CollaboratorsPayload: ResolverTypeWrapper<UpdateProjectV2CollaboratorsPayload>;
  UpdateProjectV2DraftIssueInput: UpdateProjectV2DraftIssueInput;
  UpdateProjectV2DraftIssuePayload: ResolverTypeWrapper<UpdateProjectV2DraftIssuePayload>;
  UpdateProjectV2Input: UpdateProjectV2Input;
  UpdateProjectV2ItemFieldValueInput: UpdateProjectV2ItemFieldValueInput;
  UpdateProjectV2ItemFieldValuePayload: ResolverTypeWrapper<UpdateProjectV2ItemFieldValuePayload>;
  UpdateProjectV2ItemPositionInput: UpdateProjectV2ItemPositionInput;
  UpdateProjectV2ItemPositionPayload: ResolverTypeWrapper<UpdateProjectV2ItemPositionPayload>;
  UpdateProjectV2Payload: ResolverTypeWrapper<UpdateProjectV2Payload>;
  UpdatePullRequestBranchInput: UpdatePullRequestBranchInput;
  UpdatePullRequestBranchPayload: ResolverTypeWrapper<UpdatePullRequestBranchPayload>;
  UpdatePullRequestInput: UpdatePullRequestInput;
  UpdatePullRequestPayload: ResolverTypeWrapper<UpdatePullRequestPayload>;
  UpdatePullRequestReviewCommentInput: UpdatePullRequestReviewCommentInput;
  UpdatePullRequestReviewCommentPayload: ResolverTypeWrapper<UpdatePullRequestReviewCommentPayload>;
  UpdatePullRequestReviewInput: UpdatePullRequestReviewInput;
  UpdatePullRequestReviewPayload: ResolverTypeWrapper<UpdatePullRequestReviewPayload>;
  UpdateRefInput: UpdateRefInput;
  UpdateRefPayload: ResolverTypeWrapper<UpdateRefPayload>;
  UpdateRefsInput: UpdateRefsInput;
  UpdateRefsPayload: ResolverTypeWrapper<UpdateRefsPayload>;
  UpdateRepositoryInput: UpdateRepositoryInput;
  UpdateRepositoryPayload: ResolverTypeWrapper<UpdateRepositoryPayload>;
  UpdateRepositoryRulesetInput: UpdateRepositoryRulesetInput;
  UpdateRepositoryRulesetPayload: ResolverTypeWrapper<UpdateRepositoryRulesetPayload>;
  UpdateRepositoryWebCommitSignoffSettingInput: UpdateRepositoryWebCommitSignoffSettingInput;
  UpdateRepositoryWebCommitSignoffSettingPayload: ResolverTypeWrapper<UpdateRepositoryWebCommitSignoffSettingPayload>;
  UpdateSponsorshipPreferencesInput: UpdateSponsorshipPreferencesInput;
  UpdateSponsorshipPreferencesPayload: ResolverTypeWrapper<UpdateSponsorshipPreferencesPayload>;
  UpdateSubscriptionInput: UpdateSubscriptionInput;
  UpdateSubscriptionPayload: ResolverTypeWrapper<UpdateSubscriptionPayload>;
  UpdateTeamDiscussionCommentInput: UpdateTeamDiscussionCommentInput;
  UpdateTeamDiscussionCommentPayload: ResolverTypeWrapper<UpdateTeamDiscussionCommentPayload>;
  UpdateTeamDiscussionInput: UpdateTeamDiscussionInput;
  UpdateTeamDiscussionPayload: ResolverTypeWrapper<UpdateTeamDiscussionPayload>;
  UpdateTeamReviewAssignmentInput: UpdateTeamReviewAssignmentInput;
  UpdateTeamReviewAssignmentPayload: ResolverTypeWrapper<UpdateTeamReviewAssignmentPayload>;
  UpdateTeamsRepositoryInput: UpdateTeamsRepositoryInput;
  UpdateTeamsRepositoryPayload: ResolverTypeWrapper<UpdateTeamsRepositoryPayload>;
  UpdateTopicsInput: UpdateTopicsInput;
  UpdateTopicsPayload: ResolverTypeWrapper<UpdateTopicsPayload>;
  UpdateUserListInput: UpdateUserListInput;
  UpdateUserListPayload: ResolverTypeWrapper<UpdateUserListPayload>;
  UpdateUserListsForItemInput: UpdateUserListsForItemInput;
  UpdateUserListsForItemPayload: ResolverTypeWrapper<Omit<UpdateUserListsForItemPayload, 'item'> & { item?: Maybe<ResolversTypes['UserListItems']> }>;
  User: ResolverTypeWrapper<User>;
  UserBlockDuration: UserBlockDuration;
  UserBlockedEvent: ResolverTypeWrapper<UserBlockedEvent>;
  UserConnection: ResolverTypeWrapper<UserConnection>;
  UserContentEdit: ResolverTypeWrapper<UserContentEdit>;
  UserContentEditConnection: ResolverTypeWrapper<UserContentEditConnection>;
  UserContentEditEdge: ResolverTypeWrapper<UserContentEditEdge>;
  UserEdge: ResolverTypeWrapper<UserEdge>;
  UserEmailMetadata: ResolverTypeWrapper<UserEmailMetadata>;
  UserList: ResolverTypeWrapper<UserList>;
  UserListConnection: ResolverTypeWrapper<UserListConnection>;
  UserListEdge: ResolverTypeWrapper<UserListEdge>;
  UserListItems: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['UserListItems']>;
  UserListItemsConnection: ResolverTypeWrapper<Omit<UserListItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['UserListItems']>>> }>;
  UserListItemsEdge: ResolverTypeWrapper<Omit<UserListItemsEdge, 'node'> & { node?: Maybe<ResolversTypes['UserListItems']> }>;
  UserListSuggestion: ResolverTypeWrapper<UserListSuggestion>;
  UserStatus: ResolverTypeWrapper<UserStatus>;
  UserStatusConnection: ResolverTypeWrapper<UserStatusConnection>;
  UserStatusEdge: ResolverTypeWrapper<UserStatusEdge>;
  UserStatusOrder: UserStatusOrder;
  UserStatusOrderField: UserStatusOrderField;
  VerifiableDomain: ResolverTypeWrapper<Omit<VerifiableDomain, 'owner'> & { owner: ResolversTypes['VerifiableDomainOwner'] }>;
  VerifiableDomainConnection: ResolverTypeWrapper<VerifiableDomainConnection>;
  VerifiableDomainEdge: ResolverTypeWrapper<VerifiableDomainEdge>;
  VerifiableDomainOrder: VerifiableDomainOrder;
  VerifiableDomainOrderField: VerifiableDomainOrderField;
  VerifiableDomainOwner: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['VerifiableDomainOwner']>;
  VerifyVerifiableDomainInput: VerifyVerifiableDomainInput;
  VerifyVerifiableDomainPayload: ResolverTypeWrapper<VerifyVerifiableDomainPayload>;
  ViewerHovercardContext: ResolverTypeWrapper<ViewerHovercardContext>;
  Votable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Votable']>;
  Workflow: ResolverTypeWrapper<Workflow>;
  WorkflowFileReference: ResolverTypeWrapper<WorkflowFileReference>;
  WorkflowFileReferenceInput: WorkflowFileReferenceInput;
  WorkflowRun: ResolverTypeWrapper<WorkflowRun>;
  WorkflowRunConnection: ResolverTypeWrapper<WorkflowRunConnection>;
  WorkflowRunEdge: ResolverTypeWrapper<WorkflowRunEdge>;
  WorkflowRunFile: ResolverTypeWrapper<WorkflowRunFile>;
  WorkflowRunOrder: WorkflowRunOrder;
  WorkflowRunOrderField: WorkflowRunOrderField;
  WorkflowState: WorkflowState;
  WorkflowsParameters: ResolverTypeWrapper<WorkflowsParameters>;
  WorkflowsParametersInput: WorkflowsParametersInput;
  X509Certificate: ResolverTypeWrapper<Scalars['X509Certificate']['output']>;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  AbortQueuedMigrationsInput: AbortQueuedMigrationsInput;
  String: Scalars['String']['output'];
  ID: Scalars['ID']['output'];
  AbortQueuedMigrationsPayload: AbortQueuedMigrationsPayload;
  Boolean: Scalars['Boolean']['output'];
  AbortRepositoryMigrationInput: AbortRepositoryMigrationInput;
  AbortRepositoryMigrationPayload: AbortRepositoryMigrationPayload;
  AcceptEnterpriseAdministratorInvitationInput: AcceptEnterpriseAdministratorInvitationInput;
  AcceptEnterpriseAdministratorInvitationPayload: AcceptEnterpriseAdministratorInvitationPayload;
  AcceptTopicSuggestionInput: AcceptTopicSuggestionInput;
  AcceptTopicSuggestionPayload: AcceptTopicSuggestionPayload;
  Actor: ResolversInterfaceTypes<ResolversParentTypes>['Actor'];
  Int: Scalars['Int']['output'];
  ActorLocation: ActorLocation;
  AddAssigneesToAssignableInput: AddAssigneesToAssignableInput;
  AddAssigneesToAssignablePayload: AddAssigneesToAssignablePayload;
  AddCommentInput: AddCommentInput;
  AddCommentPayload: AddCommentPayload;
  AddDiscussionCommentInput: AddDiscussionCommentInput;
  AddDiscussionCommentPayload: AddDiscussionCommentPayload;
  AddDiscussionPollVoteInput: AddDiscussionPollVoteInput;
  AddDiscussionPollVotePayload: AddDiscussionPollVotePayload;
  AddEnterpriseOrganizationMemberInput: AddEnterpriseOrganizationMemberInput;
  AddEnterpriseOrganizationMemberPayload: AddEnterpriseOrganizationMemberPayload;
  AddEnterpriseSupportEntitlementInput: AddEnterpriseSupportEntitlementInput;
  AddEnterpriseSupportEntitlementPayload: AddEnterpriseSupportEntitlementPayload;
  AddLabelsToLabelableInput: AddLabelsToLabelableInput;
  AddLabelsToLabelablePayload: AddLabelsToLabelablePayload;
  AddProjectCardInput: AddProjectCardInput;
  AddProjectCardPayload: AddProjectCardPayload;
  AddProjectColumnInput: AddProjectColumnInput;
  AddProjectColumnPayload: AddProjectColumnPayload;
  AddProjectV2DraftIssueInput: AddProjectV2DraftIssueInput;
  AddProjectV2DraftIssuePayload: AddProjectV2DraftIssuePayload;
  AddProjectV2ItemByIdInput: AddProjectV2ItemByIdInput;
  AddProjectV2ItemByIdPayload: AddProjectV2ItemByIdPayload;
  AddPullRequestReviewCommentInput: AddPullRequestReviewCommentInput;
  AddPullRequestReviewCommentPayload: AddPullRequestReviewCommentPayload;
  AddPullRequestReviewInput: AddPullRequestReviewInput;
  AddPullRequestReviewPayload: AddPullRequestReviewPayload;
  AddPullRequestReviewThreadInput: AddPullRequestReviewThreadInput;
  AddPullRequestReviewThreadPayload: AddPullRequestReviewThreadPayload;
  AddPullRequestReviewThreadReplyInput: AddPullRequestReviewThreadReplyInput;
  AddPullRequestReviewThreadReplyPayload: AddPullRequestReviewThreadReplyPayload;
  AddReactionInput: AddReactionInput;
  AddReactionPayload: AddReactionPayload;
  AddStarInput: AddStarInput;
  AddStarPayload: AddStarPayload;
  AddUpvoteInput: AddUpvoteInput;
  AddUpvotePayload: AddUpvotePayload;
  AddVerifiableDomainInput: AddVerifiableDomainInput;
  AddVerifiableDomainPayload: AddVerifiableDomainPayload;
  AddedToMergeQueueEvent: AddedToMergeQueueEvent;
  AddedToProjectEvent: AddedToProjectEvent;
  AnnouncementBanner: ResolversInterfaceTypes<ResolversParentTypes>['AnnouncementBanner'];
  App: App;
  ApproveDeploymentsInput: ApproveDeploymentsInput;
  ApproveDeploymentsPayload: ApproveDeploymentsPayload;
  ApproveVerifiableDomainInput: ApproveVerifiableDomainInput;
  ApproveVerifiableDomainPayload: ApproveVerifiableDomainPayload;
  ArchiveProjectV2ItemInput: ArchiveProjectV2ItemInput;
  ArchiveProjectV2ItemPayload: ArchiveProjectV2ItemPayload;
  ArchiveRepositoryInput: ArchiveRepositoryInput;
  ArchiveRepositoryPayload: ArchiveRepositoryPayload;
  Assignable: ResolversInterfaceTypes<ResolversParentTypes>['Assignable'];
  AssignedEvent: Omit<AssignedEvent, 'assignee'> & { assignee?: Maybe<ResolversParentTypes['Assignee']> };
  Assignee: ResolversUnionTypes<ResolversParentTypes>['Assignee'];
  AuditEntry: ResolversInterfaceTypes<ResolversParentTypes>['AuditEntry'];
  AuditEntryActor: ResolversUnionTypes<ResolversParentTypes>['AuditEntryActor'];
  AuditLogOrder: AuditLogOrder;
  AutoMergeDisabledEvent: AutoMergeDisabledEvent;
  AutoMergeEnabledEvent: AutoMergeEnabledEvent;
  AutoMergeRequest: AutoMergeRequest;
  AutoRebaseEnabledEvent: AutoRebaseEnabledEvent;
  AutoSquashEnabledEvent: AutoSquashEnabledEvent;
  AutomaticBaseChangeFailedEvent: AutomaticBaseChangeFailedEvent;
  AutomaticBaseChangeSucceededEvent: AutomaticBaseChangeSucceededEvent;
  Base64String: Scalars['Base64String']['output'];
  BaseRefChangedEvent: BaseRefChangedEvent;
  BaseRefDeletedEvent: BaseRefDeletedEvent;
  BaseRefForcePushedEvent: BaseRefForcePushedEvent;
  BigInt: Scalars['BigInt']['output'];
  Blame: Blame;
  BlameRange: BlameRange;
  Blob: Blob;
  Bot: Bot;
  BranchActorAllowanceActor: ResolversUnionTypes<ResolversParentTypes>['BranchActorAllowanceActor'];
  BranchNamePatternParameters: BranchNamePatternParameters;
  BranchNamePatternParametersInput: BranchNamePatternParametersInput;
  BranchProtectionRule: BranchProtectionRule;
  BranchProtectionRuleConflict: BranchProtectionRuleConflict;
  BranchProtectionRuleConflictConnection: BranchProtectionRuleConflictConnection;
  BranchProtectionRuleConflictEdge: BranchProtectionRuleConflictEdge;
  BranchProtectionRuleConnection: BranchProtectionRuleConnection;
  BranchProtectionRuleEdge: BranchProtectionRuleEdge;
  BulkSponsorship: BulkSponsorship;
  BypassActor: ResolversUnionTypes<ResolversParentTypes>['BypassActor'];
  BypassForcePushAllowance: Omit<BypassForcePushAllowance, 'actor'> & { actor?: Maybe<ResolversParentTypes['BranchActorAllowanceActor']> };
  BypassForcePushAllowanceConnection: BypassForcePushAllowanceConnection;
  BypassForcePushAllowanceEdge: BypassForcePushAllowanceEdge;
  BypassPullRequestAllowance: Omit<BypassPullRequestAllowance, 'actor'> & { actor?: Maybe<ResolversParentTypes['BranchActorAllowanceActor']> };
  BypassPullRequestAllowanceConnection: BypassPullRequestAllowanceConnection;
  BypassPullRequestAllowanceEdge: BypassPullRequestAllowanceEdge;
  CVSS: CVSS;
  Float: Scalars['Float']['output'];
  CWE: CWE;
  CWEConnection: CWEConnection;
  CWEEdge: CWEEdge;
  CancelEnterpriseAdminInvitationInput: CancelEnterpriseAdminInvitationInput;
  CancelEnterpriseAdminInvitationPayload: CancelEnterpriseAdminInvitationPayload;
  CancelSponsorshipInput: CancelSponsorshipInput;
  CancelSponsorshipPayload: CancelSponsorshipPayload;
  ChangeUserStatusInput: ChangeUserStatusInput;
  ChangeUserStatusPayload: ChangeUserStatusPayload;
  CheckAnnotation: CheckAnnotation;
  CheckAnnotationConnection: CheckAnnotationConnection;
  CheckAnnotationData: CheckAnnotationData;
  CheckAnnotationEdge: CheckAnnotationEdge;
  CheckAnnotationPosition: CheckAnnotationPosition;
  CheckAnnotationRange: CheckAnnotationRange;
  CheckAnnotationSpan: CheckAnnotationSpan;
  CheckRun: CheckRun;
  CheckRunAction: CheckRunAction;
  CheckRunConnection: CheckRunConnection;
  CheckRunEdge: CheckRunEdge;
  CheckRunFilter: CheckRunFilter;
  CheckRunOutput: CheckRunOutput;
  CheckRunOutputImage: CheckRunOutputImage;
  CheckRunStateCount: CheckRunStateCount;
  CheckStep: CheckStep;
  CheckStepConnection: CheckStepConnection;
  CheckStepEdge: CheckStepEdge;
  CheckSuite: CheckSuite;
  CheckSuiteAutoTriggerPreference: CheckSuiteAutoTriggerPreference;
  CheckSuiteConnection: CheckSuiteConnection;
  CheckSuiteEdge: CheckSuiteEdge;
  CheckSuiteFilter: CheckSuiteFilter;
  Claimable: ResolversUnionTypes<ResolversParentTypes>['Claimable'];
  ClearLabelsFromLabelableInput: ClearLabelsFromLabelableInput;
  ClearLabelsFromLabelablePayload: ClearLabelsFromLabelablePayload;
  ClearProjectV2ItemFieldValueInput: ClearProjectV2ItemFieldValueInput;
  ClearProjectV2ItemFieldValuePayload: ClearProjectV2ItemFieldValuePayload;
  CloneProjectInput: CloneProjectInput;
  CloneProjectPayload: CloneProjectPayload;
  CloneTemplateRepositoryInput: CloneTemplateRepositoryInput;
  CloneTemplateRepositoryPayload: CloneTemplateRepositoryPayload;
  Closable: ResolversInterfaceTypes<ResolversParentTypes>['Closable'];
  CloseDiscussionInput: CloseDiscussionInput;
  CloseDiscussionPayload: CloseDiscussionPayload;
  CloseIssueInput: CloseIssueInput;
  CloseIssuePayload: CloseIssuePayload;
  ClosePullRequestInput: ClosePullRequestInput;
  ClosePullRequestPayload: ClosePullRequestPayload;
  ClosedEvent: Omit<ClosedEvent, 'closer'> & { closer?: Maybe<ResolversParentTypes['Closer']> };
  Closer: ResolversUnionTypes<ResolversParentTypes>['Closer'];
  CodeOfConduct: CodeOfConduct;
  Comment: ResolversInterfaceTypes<ResolversParentTypes>['Comment'];
  CommentDeletedEvent: CommentDeletedEvent;
  Commit: Commit;
  CommitAuthor: CommitAuthor;
  CommitAuthorEmailPatternParameters: CommitAuthorEmailPatternParameters;
  CommitAuthorEmailPatternParametersInput: CommitAuthorEmailPatternParametersInput;
  CommitComment: CommitComment;
  CommitCommentConnection: CommitCommentConnection;
  CommitCommentEdge: CommitCommentEdge;
  CommitCommentThread: CommitCommentThread;
  CommitConnection: CommitConnection;
  CommitContributionOrder: CommitContributionOrder;
  CommitContributionsByRepository: CommitContributionsByRepository;
  CommitEdge: CommitEdge;
  CommitHistoryConnection: CommitHistoryConnection;
  CommitMessage: CommitMessage;
  CommitMessagePatternParameters: CommitMessagePatternParameters;
  CommitMessagePatternParametersInput: CommitMessagePatternParametersInput;
  CommittableBranch: CommittableBranch;
  CommitterEmailPatternParameters: CommitterEmailPatternParameters;
  CommitterEmailPatternParametersInput: CommitterEmailPatternParametersInput;
  Comparison: Comparison;
  ComparisonCommitConnection: ComparisonCommitConnection;
  ConnectedEvent: Omit<ConnectedEvent, 'source' | 'subject'> & { source: ResolversParentTypes['ReferencedSubject'], subject: ResolversParentTypes['ReferencedSubject'] };
  ContributingGuidelines: ContributingGuidelines;
  Contribution: ResolversInterfaceTypes<ResolversParentTypes>['Contribution'];
  ContributionCalendar: ContributionCalendar;
  ContributionCalendarDay: ContributionCalendarDay;
  ContributionCalendarMonth: ContributionCalendarMonth;
  ContributionCalendarWeek: ContributionCalendarWeek;
  ContributionOrder: ContributionOrder;
  ContributionsCollection: Omit<ContributionsCollection, 'firstIssueContribution' | 'firstPullRequestContribution' | 'firstRepositoryContribution'> & { firstIssueContribution?: Maybe<ResolversParentTypes['CreatedIssueOrRestrictedContribution']>, firstPullRequestContribution?: Maybe<ResolversParentTypes['CreatedPullRequestOrRestrictedContribution']>, firstRepositoryContribution?: Maybe<ResolversParentTypes['CreatedRepositoryOrRestrictedContribution']> };
  ConvertProjectCardNoteToIssueInput: ConvertProjectCardNoteToIssueInput;
  ConvertProjectCardNoteToIssuePayload: ConvertProjectCardNoteToIssuePayload;
  ConvertPullRequestToDraftInput: ConvertPullRequestToDraftInput;
  ConvertPullRequestToDraftPayload: ConvertPullRequestToDraftPayload;
  ConvertToDraftEvent: ConvertToDraftEvent;
  ConvertedNoteToIssueEvent: ConvertedNoteToIssueEvent;
  ConvertedToDiscussionEvent: ConvertedToDiscussionEvent;
  CopyProjectV2Input: CopyProjectV2Input;
  CopyProjectV2Payload: CopyProjectV2Payload;
  CreateAttributionInvitationInput: CreateAttributionInvitationInput;
  CreateAttributionInvitationPayload: Omit<CreateAttributionInvitationPayload, 'source' | 'target'> & { source?: Maybe<ResolversParentTypes['Claimable']>, target?: Maybe<ResolversParentTypes['Claimable']> };
  CreateBranchProtectionRuleInput: CreateBranchProtectionRuleInput;
  CreateBranchProtectionRulePayload: CreateBranchProtectionRulePayload;
  CreateCheckRunInput: CreateCheckRunInput;
  CreateCheckRunPayload: CreateCheckRunPayload;
  CreateCheckSuiteInput: CreateCheckSuiteInput;
  CreateCheckSuitePayload: CreateCheckSuitePayload;
  CreateCommitOnBranchInput: CreateCommitOnBranchInput;
  CreateCommitOnBranchPayload: CreateCommitOnBranchPayload;
  CreateDeploymentInput: CreateDeploymentInput;
  CreateDeploymentPayload: CreateDeploymentPayload;
  CreateDeploymentStatusInput: CreateDeploymentStatusInput;
  CreateDeploymentStatusPayload: CreateDeploymentStatusPayload;
  CreateDiscussionInput: CreateDiscussionInput;
  CreateDiscussionPayload: CreateDiscussionPayload;
  CreateEnterpriseOrganizationInput: CreateEnterpriseOrganizationInput;
  CreateEnterpriseOrganizationPayload: CreateEnterpriseOrganizationPayload;
  CreateEnvironmentInput: CreateEnvironmentInput;
  CreateEnvironmentPayload: CreateEnvironmentPayload;
  CreateIpAllowListEntryInput: CreateIpAllowListEntryInput;
  CreateIpAllowListEntryPayload: CreateIpAllowListEntryPayload;
  CreateIssueInput: CreateIssueInput;
  CreateIssuePayload: CreateIssuePayload;
  CreateLabelInput: CreateLabelInput;
  CreateLabelPayload: CreateLabelPayload;
  CreateLinkedBranchInput: CreateLinkedBranchInput;
  CreateLinkedBranchPayload: CreateLinkedBranchPayload;
  CreateMigrationSourceInput: CreateMigrationSourceInput;
  CreateMigrationSourcePayload: CreateMigrationSourcePayload;
  CreateProjectInput: CreateProjectInput;
  CreateProjectPayload: CreateProjectPayload;
  CreateProjectV2FieldInput: CreateProjectV2FieldInput;
  CreateProjectV2FieldPayload: Omit<CreateProjectV2FieldPayload, 'projectV2Field'> & { projectV2Field?: Maybe<ResolversParentTypes['ProjectV2FieldConfiguration']> };
  CreateProjectV2Input: CreateProjectV2Input;
  CreateProjectV2Payload: CreateProjectV2Payload;
  CreatePullRequestInput: CreatePullRequestInput;
  CreatePullRequestPayload: CreatePullRequestPayload;
  CreateRefInput: CreateRefInput;
  CreateRefPayload: CreateRefPayload;
  CreateRepositoryInput: CreateRepositoryInput;
  CreateRepositoryPayload: CreateRepositoryPayload;
  CreateRepositoryRulesetInput: CreateRepositoryRulesetInput;
  CreateRepositoryRulesetPayload: CreateRepositoryRulesetPayload;
  CreateSponsorsListingInput: CreateSponsorsListingInput;
  CreateSponsorsListingPayload: CreateSponsorsListingPayload;
  CreateSponsorsTierInput: CreateSponsorsTierInput;
  CreateSponsorsTierPayload: CreateSponsorsTierPayload;
  CreateSponsorshipInput: CreateSponsorshipInput;
  CreateSponsorshipPayload: CreateSponsorshipPayload;
  CreateSponsorshipsInput: CreateSponsorshipsInput;
  CreateSponsorshipsPayload: CreateSponsorshipsPayload;
  CreateTeamDiscussionCommentInput: CreateTeamDiscussionCommentInput;
  CreateTeamDiscussionCommentPayload: CreateTeamDiscussionCommentPayload;
  CreateTeamDiscussionInput: CreateTeamDiscussionInput;
  CreateTeamDiscussionPayload: CreateTeamDiscussionPayload;
  CreateUserListInput: CreateUserListInput;
  CreateUserListPayload: CreateUserListPayload;
  CreatedCommitContribution: CreatedCommitContribution;
  CreatedCommitContributionConnection: CreatedCommitContributionConnection;
  CreatedCommitContributionEdge: CreatedCommitContributionEdge;
  CreatedIssueContribution: CreatedIssueContribution;
  CreatedIssueContributionConnection: CreatedIssueContributionConnection;
  CreatedIssueContributionEdge: CreatedIssueContributionEdge;
  CreatedIssueOrRestrictedContribution: ResolversUnionTypes<ResolversParentTypes>['CreatedIssueOrRestrictedContribution'];
  CreatedPullRequestContribution: CreatedPullRequestContribution;
  CreatedPullRequestContributionConnection: CreatedPullRequestContributionConnection;
  CreatedPullRequestContributionEdge: CreatedPullRequestContributionEdge;
  CreatedPullRequestOrRestrictedContribution: ResolversUnionTypes<ResolversParentTypes>['CreatedPullRequestOrRestrictedContribution'];
  CreatedPullRequestReviewContribution: CreatedPullRequestReviewContribution;
  CreatedPullRequestReviewContributionConnection: CreatedPullRequestReviewContributionConnection;
  CreatedPullRequestReviewContributionEdge: CreatedPullRequestReviewContributionEdge;
  CreatedRepositoryContribution: CreatedRepositoryContribution;
  CreatedRepositoryContributionConnection: CreatedRepositoryContributionConnection;
  CreatedRepositoryContributionEdge: CreatedRepositoryContributionEdge;
  CreatedRepositoryOrRestrictedContribution: ResolversUnionTypes<ResolversParentTypes>['CreatedRepositoryOrRestrictedContribution'];
  CrossReferencedEvent: Omit<CrossReferencedEvent, 'source' | 'target'> & { source: ResolversParentTypes['ReferencedSubject'], target: ResolversParentTypes['ReferencedSubject'] };
  Date: Scalars['Date']['output'];
  DateTime: Scalars['DateTime']['output'];
  DeclineTopicSuggestionInput: DeclineTopicSuggestionInput;
  DeclineTopicSuggestionPayload: DeclineTopicSuggestionPayload;
  Deletable: ResolversInterfaceTypes<ResolversParentTypes>['Deletable'];
  DeleteBranchProtectionRuleInput: DeleteBranchProtectionRuleInput;
  DeleteBranchProtectionRulePayload: DeleteBranchProtectionRulePayload;
  DeleteDeploymentInput: DeleteDeploymentInput;
  DeleteDeploymentPayload: DeleteDeploymentPayload;
  DeleteDiscussionCommentInput: DeleteDiscussionCommentInput;
  DeleteDiscussionCommentPayload: DeleteDiscussionCommentPayload;
  DeleteDiscussionInput: DeleteDiscussionInput;
  DeleteDiscussionPayload: DeleteDiscussionPayload;
  DeleteEnvironmentInput: DeleteEnvironmentInput;
  DeleteEnvironmentPayload: DeleteEnvironmentPayload;
  DeleteIpAllowListEntryInput: DeleteIpAllowListEntryInput;
  DeleteIpAllowListEntryPayload: DeleteIpAllowListEntryPayload;
  DeleteIssueCommentInput: DeleteIssueCommentInput;
  DeleteIssueCommentPayload: DeleteIssueCommentPayload;
  DeleteIssueInput: DeleteIssueInput;
  DeleteIssuePayload: DeleteIssuePayload;
  DeleteLabelInput: DeleteLabelInput;
  DeleteLabelPayload: DeleteLabelPayload;
  DeleteLinkedBranchInput: DeleteLinkedBranchInput;
  DeleteLinkedBranchPayload: DeleteLinkedBranchPayload;
  DeletePackageVersionInput: DeletePackageVersionInput;
  DeletePackageVersionPayload: DeletePackageVersionPayload;
  DeleteProjectCardInput: DeleteProjectCardInput;
  DeleteProjectCardPayload: DeleteProjectCardPayload;
  DeleteProjectColumnInput: DeleteProjectColumnInput;
  DeleteProjectColumnPayload: DeleteProjectColumnPayload;
  DeleteProjectInput: DeleteProjectInput;
  DeleteProjectPayload: DeleteProjectPayload;
  DeleteProjectV2FieldInput: DeleteProjectV2FieldInput;
  DeleteProjectV2FieldPayload: Omit<DeleteProjectV2FieldPayload, 'projectV2Field'> & { projectV2Field?: Maybe<ResolversParentTypes['ProjectV2FieldConfiguration']> };
  DeleteProjectV2Input: DeleteProjectV2Input;
  DeleteProjectV2ItemInput: DeleteProjectV2ItemInput;
  DeleteProjectV2ItemPayload: DeleteProjectV2ItemPayload;
  DeleteProjectV2Payload: DeleteProjectV2Payload;
  DeleteProjectV2WorkflowInput: DeleteProjectV2WorkflowInput;
  DeleteProjectV2WorkflowPayload: DeleteProjectV2WorkflowPayload;
  DeletePullRequestReviewCommentInput: DeletePullRequestReviewCommentInput;
  DeletePullRequestReviewCommentPayload: DeletePullRequestReviewCommentPayload;
  DeletePullRequestReviewInput: DeletePullRequestReviewInput;
  DeletePullRequestReviewPayload: DeletePullRequestReviewPayload;
  DeleteRefInput: DeleteRefInput;
  DeleteRefPayload: DeleteRefPayload;
  DeleteRepositoryRulesetInput: DeleteRepositoryRulesetInput;
  DeleteRepositoryRulesetPayload: DeleteRepositoryRulesetPayload;
  DeleteTeamDiscussionCommentInput: DeleteTeamDiscussionCommentInput;
  DeleteTeamDiscussionCommentPayload: DeleteTeamDiscussionCommentPayload;
  DeleteTeamDiscussionInput: DeleteTeamDiscussionInput;
  DeleteTeamDiscussionPayload: DeleteTeamDiscussionPayload;
  DeleteUserListInput: DeleteUserListInput;
  DeleteUserListPayload: DeleteUserListPayload;
  DeleteVerifiableDomainInput: DeleteVerifiableDomainInput;
  DeleteVerifiableDomainPayload: Omit<DeleteVerifiableDomainPayload, 'owner'> & { owner?: Maybe<ResolversParentTypes['VerifiableDomainOwner']> };
  DemilestonedEvent: Omit<DemilestonedEvent, 'subject'> & { subject: ResolversParentTypes['MilestoneItem'] };
  DependabotUpdate: DependabotUpdate;
  DependabotUpdateError: DependabotUpdateError;
  DependencyGraphDependency: DependencyGraphDependency;
  DependencyGraphDependencyConnection: DependencyGraphDependencyConnection;
  DependencyGraphDependencyEdge: DependencyGraphDependencyEdge;
  DependencyGraphManifest: DependencyGraphManifest;
  DependencyGraphManifestConnection: DependencyGraphManifestConnection;
  DependencyGraphManifestEdge: DependencyGraphManifestEdge;
  DeployKey: DeployKey;
  DeployKeyConnection: DeployKeyConnection;
  DeployKeyEdge: DeployKeyEdge;
  DeployedEvent: DeployedEvent;
  Deployment: Deployment;
  DeploymentConnection: DeploymentConnection;
  DeploymentEdge: DeploymentEdge;
  DeploymentEnvironmentChangedEvent: DeploymentEnvironmentChangedEvent;
  DeploymentOrder: DeploymentOrder;
  DeploymentProtectionRule: DeploymentProtectionRule;
  DeploymentProtectionRuleConnection: DeploymentProtectionRuleConnection;
  DeploymentProtectionRuleEdge: DeploymentProtectionRuleEdge;
  DeploymentRequest: DeploymentRequest;
  DeploymentRequestConnection: DeploymentRequestConnection;
  DeploymentRequestEdge: DeploymentRequestEdge;
  DeploymentReview: DeploymentReview;
  DeploymentReviewConnection: DeploymentReviewConnection;
  DeploymentReviewEdge: DeploymentReviewEdge;
  DeploymentReviewer: ResolversUnionTypes<ResolversParentTypes>['DeploymentReviewer'];
  DeploymentReviewerConnection: Omit<DeploymentReviewerConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['DeploymentReviewer']>>> };
  DeploymentReviewerEdge: Omit<DeploymentReviewerEdge, 'node'> & { node?: Maybe<ResolversParentTypes['DeploymentReviewer']> };
  DeploymentStatus: DeploymentStatus;
  DeploymentStatusConnection: DeploymentStatusConnection;
  DeploymentStatusEdge: DeploymentStatusEdge;
  DequeuePullRequestInput: DequeuePullRequestInput;
  DequeuePullRequestPayload: DequeuePullRequestPayload;
  DisablePullRequestAutoMergeInput: DisablePullRequestAutoMergeInput;
  DisablePullRequestAutoMergePayload: DisablePullRequestAutoMergePayload;
  DisconnectedEvent: Omit<DisconnectedEvent, 'source' | 'subject'> & { source: ResolversParentTypes['ReferencedSubject'], subject: ResolversParentTypes['ReferencedSubject'] };
  Discussion: Discussion;
  DiscussionCategory: DiscussionCategory;
  DiscussionCategoryConnection: DiscussionCategoryConnection;
  DiscussionCategoryEdge: DiscussionCategoryEdge;
  DiscussionComment: DiscussionComment;
  DiscussionCommentConnection: DiscussionCommentConnection;
  DiscussionCommentEdge: DiscussionCommentEdge;
  DiscussionConnection: DiscussionConnection;
  DiscussionEdge: DiscussionEdge;
  DiscussionOrder: DiscussionOrder;
  DiscussionPoll: DiscussionPoll;
  DiscussionPollOption: DiscussionPollOption;
  DiscussionPollOptionConnection: DiscussionPollOptionConnection;
  DiscussionPollOptionEdge: DiscussionPollOptionEdge;
  DiscussionPollOptionOrder: DiscussionPollOptionOrder;
  DismissPullRequestReviewInput: DismissPullRequestReviewInput;
  DismissPullRequestReviewPayload: DismissPullRequestReviewPayload;
  DismissRepositoryVulnerabilityAlertInput: DismissRepositoryVulnerabilityAlertInput;
  DismissRepositoryVulnerabilityAlertPayload: DismissRepositoryVulnerabilityAlertPayload;
  DraftIssue: DraftIssue;
  DraftPullRequestReviewComment: DraftPullRequestReviewComment;
  DraftPullRequestReviewThread: DraftPullRequestReviewThread;
  EnablePullRequestAutoMergeInput: EnablePullRequestAutoMergeInput;
  EnablePullRequestAutoMergePayload: EnablePullRequestAutoMergePayload;
  EnqueuePullRequestInput: EnqueuePullRequestInput;
  EnqueuePullRequestPayload: EnqueuePullRequestPayload;
  Enterprise: Enterprise;
  EnterpriseAdministratorConnection: EnterpriseAdministratorConnection;
  EnterpriseAdministratorEdge: EnterpriseAdministratorEdge;
  EnterpriseAdministratorInvitation: EnterpriseAdministratorInvitation;
  EnterpriseAdministratorInvitationConnection: EnterpriseAdministratorInvitationConnection;
  EnterpriseAdministratorInvitationEdge: EnterpriseAdministratorInvitationEdge;
  EnterpriseAdministratorInvitationOrder: EnterpriseAdministratorInvitationOrder;
  EnterpriseAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>['EnterpriseAuditEntryData'];
  EnterpriseBillingInfo: EnterpriseBillingInfo;
  EnterpriseConnection: EnterpriseConnection;
  EnterpriseEdge: EnterpriseEdge;
  EnterpriseFailedInvitationConnection: EnterpriseFailedInvitationConnection;
  EnterpriseFailedInvitationEdge: EnterpriseFailedInvitationEdge;
  EnterpriseIdentityProvider: EnterpriseIdentityProvider;
  EnterpriseMember: ResolversUnionTypes<ResolversParentTypes>['EnterpriseMember'];
  EnterpriseMemberConnection: Omit<EnterpriseMemberConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['EnterpriseMember']>>> };
  EnterpriseMemberEdge: Omit<EnterpriseMemberEdge, 'node'> & { node?: Maybe<ResolversParentTypes['EnterpriseMember']> };
  EnterpriseMemberOrder: EnterpriseMemberOrder;
  EnterpriseOrder: EnterpriseOrder;
  EnterpriseOrganizationMembershipConnection: EnterpriseOrganizationMembershipConnection;
  EnterpriseOrganizationMembershipEdge: EnterpriseOrganizationMembershipEdge;
  EnterpriseOutsideCollaboratorConnection: EnterpriseOutsideCollaboratorConnection;
  EnterpriseOutsideCollaboratorEdge: EnterpriseOutsideCollaboratorEdge;
  EnterpriseOwnerInfo: EnterpriseOwnerInfo;
  EnterprisePendingMemberInvitationConnection: EnterprisePendingMemberInvitationConnection;
  EnterprisePendingMemberInvitationEdge: EnterprisePendingMemberInvitationEdge;
  EnterpriseRepositoryInfo: EnterpriseRepositoryInfo;
  EnterpriseRepositoryInfoConnection: EnterpriseRepositoryInfoConnection;
  EnterpriseRepositoryInfoEdge: EnterpriseRepositoryInfoEdge;
  EnterpriseServerInstallation: EnterpriseServerInstallation;
  EnterpriseServerInstallationConnection: EnterpriseServerInstallationConnection;
  EnterpriseServerInstallationEdge: EnterpriseServerInstallationEdge;
  EnterpriseServerInstallationMembershipConnection: EnterpriseServerInstallationMembershipConnection;
  EnterpriseServerInstallationMembershipEdge: EnterpriseServerInstallationMembershipEdge;
  EnterpriseServerInstallationOrder: EnterpriseServerInstallationOrder;
  EnterpriseServerUserAccount: EnterpriseServerUserAccount;
  EnterpriseServerUserAccountConnection: EnterpriseServerUserAccountConnection;
  EnterpriseServerUserAccountEdge: EnterpriseServerUserAccountEdge;
  EnterpriseServerUserAccountEmail: EnterpriseServerUserAccountEmail;
  EnterpriseServerUserAccountEmailConnection: EnterpriseServerUserAccountEmailConnection;
  EnterpriseServerUserAccountEmailEdge: EnterpriseServerUserAccountEmailEdge;
  EnterpriseServerUserAccountEmailOrder: EnterpriseServerUserAccountEmailOrder;
  EnterpriseServerUserAccountOrder: EnterpriseServerUserAccountOrder;
  EnterpriseServerUserAccountsUpload: EnterpriseServerUserAccountsUpload;
  EnterpriseServerUserAccountsUploadConnection: EnterpriseServerUserAccountsUploadConnection;
  EnterpriseServerUserAccountsUploadEdge: EnterpriseServerUserAccountsUploadEdge;
  EnterpriseServerUserAccountsUploadOrder: EnterpriseServerUserAccountsUploadOrder;
  EnterpriseUserAccount: EnterpriseUserAccount;
  Environment: Environment;
  EnvironmentConnection: EnvironmentConnection;
  EnvironmentEdge: EnvironmentEdge;
  Environments: Environments;
  ExternalIdentity: ExternalIdentity;
  ExternalIdentityAttribute: ExternalIdentityAttribute;
  ExternalIdentityConnection: ExternalIdentityConnection;
  ExternalIdentityEdge: ExternalIdentityEdge;
  ExternalIdentitySamlAttributes: ExternalIdentitySamlAttributes;
  ExternalIdentityScimAttributes: ExternalIdentityScimAttributes;
  FileAddition: FileAddition;
  FileChanges: FileChanges;
  FileDeletion: FileDeletion;
  FollowOrganizationInput: FollowOrganizationInput;
  FollowOrganizationPayload: FollowOrganizationPayload;
  FollowUserInput: FollowUserInput;
  FollowUserPayload: FollowUserPayload;
  FollowerConnection: FollowerConnection;
  FollowingConnection: FollowingConnection;
  FundingLink: FundingLink;
  GenericHovercardContext: GenericHovercardContext;
  Gist: Gist;
  GistComment: GistComment;
  GistCommentConnection: GistCommentConnection;
  GistCommentEdge: GistCommentEdge;
  GistConnection: GistConnection;
  GistEdge: GistEdge;
  GistFile: GistFile;
  GistOrder: GistOrder;
  GitActor: GitActor;
  GitActorConnection: GitActorConnection;
  GitActorEdge: GitActorEdge;
  GitHubMetadata: GitHubMetadata;
  GitObject: ResolversInterfaceTypes<ResolversParentTypes>['GitObject'];
  GitObjectID: Scalars['GitObjectID']['output'];
  GitRefname: Scalars['GitRefname']['output'];
  GitSSHRemote: Scalars['GitSSHRemote']['output'];
  GitSignature: ResolversInterfaceTypes<ResolversParentTypes>['GitSignature'];
  GitTimestamp: Scalars['GitTimestamp']['output'];
  GpgSignature: GpgSignature;
  GrantEnterpriseOrganizationsMigratorRoleInput: GrantEnterpriseOrganizationsMigratorRoleInput;
  GrantEnterpriseOrganizationsMigratorRolePayload: GrantEnterpriseOrganizationsMigratorRolePayload;
  GrantMigratorRoleInput: GrantMigratorRoleInput;
  GrantMigratorRolePayload: GrantMigratorRolePayload;
  HTML: Scalars['HTML']['output'];
  HeadRefDeletedEvent: HeadRefDeletedEvent;
  HeadRefForcePushedEvent: HeadRefForcePushedEvent;
  HeadRefRestoredEvent: HeadRefRestoredEvent;
  Hovercard: Hovercard;
  HovercardContext: ResolversInterfaceTypes<ResolversParentTypes>['HovercardContext'];
  ImportProjectInput: ImportProjectInput;
  ImportProjectPayload: ImportProjectPayload;
  InviteEnterpriseAdminInput: InviteEnterpriseAdminInput;
  InviteEnterpriseAdminPayload: InviteEnterpriseAdminPayload;
  IpAllowListEntry: Omit<IpAllowListEntry, 'owner'> & { owner: ResolversParentTypes['IpAllowListOwner'] };
  IpAllowListEntryConnection: IpAllowListEntryConnection;
  IpAllowListEntryEdge: IpAllowListEntryEdge;
  IpAllowListEntryOrder: IpAllowListEntryOrder;
  IpAllowListOwner: ResolversUnionTypes<ResolversParentTypes>['IpAllowListOwner'];
  Issue: Issue;
  IssueComment: IssueComment;
  IssueCommentConnection: IssueCommentConnection;
  IssueCommentEdge: IssueCommentEdge;
  IssueCommentOrder: IssueCommentOrder;
  IssueConnection: IssueConnection;
  IssueContributionsByRepository: IssueContributionsByRepository;
  IssueEdge: IssueEdge;
  IssueFilters: IssueFilters;
  IssueOrPullRequest: ResolversUnionTypes<ResolversParentTypes>['IssueOrPullRequest'];
  IssueOrder: IssueOrder;
  IssueTemplate: IssueTemplate;
  IssueTimelineConnection: Omit<IssueTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['IssueTimelineItem']>>> };
  IssueTimelineItem: ResolversUnionTypes<ResolversParentTypes>['IssueTimelineItem'];
  IssueTimelineItemEdge: Omit<IssueTimelineItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['IssueTimelineItem']> };
  IssueTimelineItems: ResolversUnionTypes<ResolversParentTypes>['IssueTimelineItems'];
  IssueTimelineItemsConnection: Omit<IssueTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['IssueTimelineItems']>>> };
  IssueTimelineItemsEdge: Omit<IssueTimelineItemsEdge, 'node'> & { node?: Maybe<ResolversParentTypes['IssueTimelineItems']> };
  JoinedGitHubContribution: JoinedGitHubContribution;
  Label: Label;
  LabelConnection: LabelConnection;
  LabelEdge: LabelEdge;
  LabelOrder: LabelOrder;
  Labelable: ResolversInterfaceTypes<ResolversParentTypes>['Labelable'];
  LabeledEvent: LabeledEvent;
  Language: Language;
  LanguageConnection: LanguageConnection;
  LanguageEdge: LanguageEdge;
  LanguageOrder: LanguageOrder;
  License: License;
  LicenseRule: LicenseRule;
  LinkProjectV2ToRepositoryInput: LinkProjectV2ToRepositoryInput;
  LinkProjectV2ToRepositoryPayload: LinkProjectV2ToRepositoryPayload;
  LinkProjectV2ToTeamInput: LinkProjectV2ToTeamInput;
  LinkProjectV2ToTeamPayload: LinkProjectV2ToTeamPayload;
  LinkRepositoryToProjectInput: LinkRepositoryToProjectInput;
  LinkRepositoryToProjectPayload: LinkRepositoryToProjectPayload;
  LinkedBranch: LinkedBranch;
  LinkedBranchConnection: LinkedBranchConnection;
  LinkedBranchEdge: LinkedBranchEdge;
  LockLockableInput: LockLockableInput;
  LockLockablePayload: LockLockablePayload;
  Lockable: ResolversInterfaceTypes<ResolversParentTypes>['Lockable'];
  LockedEvent: LockedEvent;
  Mannequin: Mannequin;
  MannequinConnection: MannequinConnection;
  MannequinEdge: MannequinEdge;
  MannequinOrder: MannequinOrder;
  MarkDiscussionCommentAsAnswerInput: MarkDiscussionCommentAsAnswerInput;
  MarkDiscussionCommentAsAnswerPayload: MarkDiscussionCommentAsAnswerPayload;
  MarkFileAsViewedInput: MarkFileAsViewedInput;
  MarkFileAsViewedPayload: MarkFileAsViewedPayload;
  MarkProjectV2AsTemplateInput: MarkProjectV2AsTemplateInput;
  MarkProjectV2AsTemplatePayload: MarkProjectV2AsTemplatePayload;
  MarkPullRequestReadyForReviewInput: MarkPullRequestReadyForReviewInput;
  MarkPullRequestReadyForReviewPayload: MarkPullRequestReadyForReviewPayload;
  MarkedAsDuplicateEvent: Omit<MarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<ResolversParentTypes['IssueOrPullRequest']>, duplicate?: Maybe<ResolversParentTypes['IssueOrPullRequest']> };
  MarketplaceCategory: MarketplaceCategory;
  MarketplaceListing: MarketplaceListing;
  MarketplaceListingConnection: MarketplaceListingConnection;
  MarketplaceListingEdge: MarketplaceListingEdge;
  MemberFeatureRequestNotification: MemberFeatureRequestNotification;
  MemberStatusable: ResolversInterfaceTypes<ResolversParentTypes>['MemberStatusable'];
  MembersCanDeleteReposClearAuditEntry: Omit<MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  MembersCanDeleteReposDisableAuditEntry: Omit<MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  MembersCanDeleteReposEnableAuditEntry: Omit<MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  MentionedEvent: MentionedEvent;
  MergeBranchInput: MergeBranchInput;
  MergeBranchPayload: MergeBranchPayload;
  MergePullRequestInput: MergePullRequestInput;
  MergePullRequestPayload: MergePullRequestPayload;
  MergeQueue: MergeQueue;
  MergeQueueConfiguration: MergeQueueConfiguration;
  MergeQueueEntry: MergeQueueEntry;
  MergeQueueEntryConnection: MergeQueueEntryConnection;
  MergeQueueEntryEdge: MergeQueueEntryEdge;
  MergedEvent: MergedEvent;
  Migration: ResolversInterfaceTypes<ResolversParentTypes>['Migration'];
  MigrationSource: MigrationSource;
  Milestone: Milestone;
  MilestoneConnection: MilestoneConnection;
  MilestoneEdge: MilestoneEdge;
  MilestoneItem: ResolversUnionTypes<ResolversParentTypes>['MilestoneItem'];
  MilestoneOrder: MilestoneOrder;
  MilestonedEvent: Omit<MilestonedEvent, 'subject'> & { subject: ResolversParentTypes['MilestoneItem'] };
  Minimizable: ResolversInterfaceTypes<ResolversParentTypes>['Minimizable'];
  MinimizeCommentInput: MinimizeCommentInput;
  MinimizeCommentPayload: MinimizeCommentPayload;
  MoveProjectCardInput: MoveProjectCardInput;
  MoveProjectCardPayload: MoveProjectCardPayload;
  MoveProjectColumnInput: MoveProjectColumnInput;
  MoveProjectColumnPayload: MoveProjectColumnPayload;
  MovedColumnsInProjectEvent: MovedColumnsInProjectEvent;
  Mutation: {};
  Node: ResolversInterfaceTypes<ResolversParentTypes>['Node'];
  OIDCProvider: OIDCProvider;
  OauthApplicationAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>['OauthApplicationAuditEntryData'];
  OauthApplicationCreateAuditEntry: Omit<OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgAddBillingManagerAuditEntry: Omit<OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgAddMemberAuditEntry: Omit<OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgBlockUserAuditEntry: Omit<OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgConfigDisableCollaboratorsOnlyAuditEntry: Omit<OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgConfigEnableCollaboratorsOnlyAuditEntry: Omit<OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgCreateAuditEntry: Omit<OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgDisableOauthAppRestrictionsAuditEntry: Omit<OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgDisableSamlAuditEntry: Omit<OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgDisableTwoFactorRequirementAuditEntry: Omit<OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgEnableOauthAppRestrictionsAuditEntry: Omit<OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgEnableSamlAuditEntry: Omit<OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgEnableTwoFactorRequirementAuditEntry: Omit<OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgEnterpriseOwnerOrder: OrgEnterpriseOwnerOrder;
  OrgInviteMemberAuditEntry: Omit<OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgInviteToBusinessAuditEntry: Omit<OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgOauthAppAccessApprovedAuditEntry: Omit<OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgOauthAppAccessBlockedAuditEntry: Omit<OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgOauthAppAccessDeniedAuditEntry: Omit<OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgOauthAppAccessRequestedAuditEntry: Omit<OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgOauthAppAccessUnblockedAuditEntry: Omit<OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgRemoveBillingManagerAuditEntry: Omit<OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgRemoveMemberAuditEntry: Omit<OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgRemoveOutsideCollaboratorAuditEntry: Omit<OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgRestoreMemberAuditEntry: Omit<OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']>, restoredMemberships?: Maybe<Array<ResolversParentTypes['OrgRestoreMemberAuditEntryMembership']>> };
  OrgRestoreMemberAuditEntryMembership: ResolversUnionTypes<ResolversParentTypes>['OrgRestoreMemberAuditEntryMembership'];
  OrgRestoreMemberMembershipOrganizationAuditEntryData: OrgRestoreMemberMembershipOrganizationAuditEntryData;
  OrgRestoreMemberMembershipRepositoryAuditEntryData: OrgRestoreMemberMembershipRepositoryAuditEntryData;
  OrgRestoreMemberMembershipTeamAuditEntryData: OrgRestoreMemberMembershipTeamAuditEntryData;
  OrgUnblockUserAuditEntry: Omit<OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgUpdateDefaultRepositoryPermissionAuditEntry: Omit<OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgUpdateMemberAuditEntry: Omit<OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgUpdateMemberRepositoryCreationPermissionAuditEntry: Omit<OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: Omit<OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  Organization: Organization;
  OrganizationAuditEntry: ResolversUnionTypes<ResolversParentTypes>['OrganizationAuditEntry'];
  OrganizationAuditEntryConnection: Omit<OrganizationAuditEntryConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['OrganizationAuditEntry']>>> };
  OrganizationAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>['OrganizationAuditEntryData'];
  OrganizationAuditEntryEdge: Omit<OrganizationAuditEntryEdge, 'node'> & { node?: Maybe<ResolversParentTypes['OrganizationAuditEntry']> };
  OrganizationConnection: OrganizationConnection;
  OrganizationEdge: OrganizationEdge;
  OrganizationEnterpriseOwnerConnection: OrganizationEnterpriseOwnerConnection;
  OrganizationEnterpriseOwnerEdge: OrganizationEnterpriseOwnerEdge;
  OrganizationIdentityProvider: OrganizationIdentityProvider;
  OrganizationInvitation: OrganizationInvitation;
  OrganizationInvitationConnection: OrganizationInvitationConnection;
  OrganizationInvitationEdge: OrganizationInvitationEdge;
  OrganizationMemberConnection: OrganizationMemberConnection;
  OrganizationMemberEdge: OrganizationMemberEdge;
  OrganizationMigration: OrganizationMigration;
  OrganizationOrUser: ResolversUnionTypes<ResolversParentTypes>['OrganizationOrUser'];
  OrganizationOrder: OrganizationOrder;
  OrganizationTeamsHovercardContext: OrganizationTeamsHovercardContext;
  OrganizationsHovercardContext: OrganizationsHovercardContext;
  Package: Package;
  PackageConnection: PackageConnection;
  PackageEdge: PackageEdge;
  PackageFile: PackageFile;
  PackageFileConnection: PackageFileConnection;
  PackageFileEdge: PackageFileEdge;
  PackageFileOrder: PackageFileOrder;
  PackageOrder: PackageOrder;
  PackageOwner: ResolversInterfaceTypes<ResolversParentTypes>['PackageOwner'];
  PackageStatistics: PackageStatistics;
  PackageTag: PackageTag;
  PackageVersion: PackageVersion;
  PackageVersionConnection: PackageVersionConnection;
  PackageVersionEdge: PackageVersionEdge;
  PackageVersionOrder: PackageVersionOrder;
  PackageVersionStatistics: PackageVersionStatistics;
  PageInfo: PageInfo;
  PermissionGranter: ResolversUnionTypes<ResolversParentTypes>['PermissionGranter'];
  PermissionSource: Omit<PermissionSource, 'source'> & { source: ResolversParentTypes['PermissionGranter'] };
  PinIssueInput: PinIssueInput;
  PinIssuePayload: PinIssuePayload;
  PinnableItem: ResolversUnionTypes<ResolversParentTypes>['PinnableItem'];
  PinnableItemConnection: Omit<PinnableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['PinnableItem']>>> };
  PinnableItemEdge: Omit<PinnableItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['PinnableItem']> };
  PinnedDiscussion: PinnedDiscussion;
  PinnedDiscussionConnection: PinnedDiscussionConnection;
  PinnedDiscussionEdge: PinnedDiscussionEdge;
  PinnedEvent: PinnedEvent;
  PinnedIssue: PinnedIssue;
  PinnedIssueConnection: PinnedIssueConnection;
  PinnedIssueEdge: PinnedIssueEdge;
  PreciseDateTime: Scalars['PreciseDateTime']['output'];
  PrivateRepositoryForkingDisableAuditEntry: Omit<PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  PrivateRepositoryForkingEnableAuditEntry: Omit<PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  ProfileItemShowcase: ProfileItemShowcase;
  ProfileOwner: ResolversInterfaceTypes<ResolversParentTypes>['ProfileOwner'];
  Project: Project;
  ProjectCard: Omit<ProjectCard, 'content'> & { content?: Maybe<ResolversParentTypes['ProjectCardItem']> };
  ProjectCardConnection: ProjectCardConnection;
  ProjectCardEdge: ProjectCardEdge;
  ProjectCardImport: ProjectCardImport;
  ProjectCardItem: ResolversUnionTypes<ResolversParentTypes>['ProjectCardItem'];
  ProjectColumn: ProjectColumn;
  ProjectColumnConnection: ProjectColumnConnection;
  ProjectColumnEdge: ProjectColumnEdge;
  ProjectColumnImport: ProjectColumnImport;
  ProjectConnection: ProjectConnection;
  ProjectEdge: ProjectEdge;
  ProjectOrder: ProjectOrder;
  ProjectOwner: ResolversInterfaceTypes<ResolversParentTypes>['ProjectOwner'];
  ProjectProgress: ProjectProgress;
  ProjectV2: Omit<ProjectV2, 'field'> & { field?: Maybe<ResolversParentTypes['ProjectV2FieldConfiguration']> };
  ProjectV2Actor: ResolversUnionTypes<ResolversParentTypes>['ProjectV2Actor'];
  ProjectV2ActorConnection: Omit<ProjectV2ActorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['ProjectV2Actor']>>> };
  ProjectV2ActorEdge: Omit<ProjectV2ActorEdge, 'node'> & { node?: Maybe<ResolversParentTypes['ProjectV2Actor']> };
  ProjectV2Collaborator: ProjectV2Collaborator;
  ProjectV2Connection: ProjectV2Connection;
  ProjectV2Edge: ProjectV2Edge;
  ProjectV2Field: ProjectV2Field;
  ProjectV2FieldCommon: ResolversInterfaceTypes<ResolversParentTypes>['ProjectV2FieldCommon'];
  ProjectV2FieldConfiguration: ResolversUnionTypes<ResolversParentTypes>['ProjectV2FieldConfiguration'];
  ProjectV2FieldConfigurationConnection: Omit<ProjectV2FieldConfigurationConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['ProjectV2FieldConfiguration']>>> };
  ProjectV2FieldConfigurationEdge: Omit<ProjectV2FieldConfigurationEdge, 'node'> & { node?: Maybe<ResolversParentTypes['ProjectV2FieldConfiguration']> };
  ProjectV2FieldConnection: ProjectV2FieldConnection;
  ProjectV2FieldEdge: ProjectV2FieldEdge;
  ProjectV2FieldOrder: ProjectV2FieldOrder;
  ProjectV2FieldValue: ProjectV2FieldValue;
  ProjectV2Filters: ProjectV2Filters;
  ProjectV2Item: Omit<ProjectV2Item, 'content' | 'fieldValueByName'> & { content?: Maybe<ResolversParentTypes['ProjectV2ItemContent']>, fieldValueByName?: Maybe<ResolversParentTypes['ProjectV2ItemFieldValue']> };
  ProjectV2ItemConnection: ProjectV2ItemConnection;
  ProjectV2ItemContent: ResolversUnionTypes<ResolversParentTypes>['ProjectV2ItemContent'];
  ProjectV2ItemEdge: ProjectV2ItemEdge;
  ProjectV2ItemFieldDateValue: Omit<ProjectV2ItemFieldDateValue, 'field'> & { field: ResolversParentTypes['ProjectV2FieldConfiguration'] };
  ProjectV2ItemFieldIterationValue: Omit<ProjectV2ItemFieldIterationValue, 'field'> & { field: ResolversParentTypes['ProjectV2FieldConfiguration'] };
  ProjectV2ItemFieldLabelValue: Omit<ProjectV2ItemFieldLabelValue, 'field'> & { field: ResolversParentTypes['ProjectV2FieldConfiguration'] };
  ProjectV2ItemFieldMilestoneValue: Omit<ProjectV2ItemFieldMilestoneValue, 'field'> & { field: ResolversParentTypes['ProjectV2FieldConfiguration'] };
  ProjectV2ItemFieldNumberValue: Omit<ProjectV2ItemFieldNumberValue, 'field'> & { field: ResolversParentTypes['ProjectV2FieldConfiguration'] };
  ProjectV2ItemFieldPullRequestValue: Omit<ProjectV2ItemFieldPullRequestValue, 'field'> & { field: ResolversParentTypes['ProjectV2FieldConfiguration'] };
  ProjectV2ItemFieldRepositoryValue: Omit<ProjectV2ItemFieldRepositoryValue, 'field'> & { field: ResolversParentTypes['ProjectV2FieldConfiguration'] };
  ProjectV2ItemFieldReviewerValue: Omit<ProjectV2ItemFieldReviewerValue, 'field'> & { field: ResolversParentTypes['ProjectV2FieldConfiguration'] };
  ProjectV2ItemFieldSingleSelectValue: Omit<ProjectV2ItemFieldSingleSelectValue, 'field'> & { field: ResolversParentTypes['ProjectV2FieldConfiguration'] };
  ProjectV2ItemFieldTextValue: Omit<ProjectV2ItemFieldTextValue, 'field'> & { field: ResolversParentTypes['ProjectV2FieldConfiguration'] };
  ProjectV2ItemFieldUserValue: Omit<ProjectV2ItemFieldUserValue, 'field'> & { field: ResolversParentTypes['ProjectV2FieldConfiguration'] };
  ProjectV2ItemFieldValue: ResolversUnionTypes<ResolversParentTypes>['ProjectV2ItemFieldValue'];
  ProjectV2ItemFieldValueCommon: ResolversInterfaceTypes<ResolversParentTypes>['ProjectV2ItemFieldValueCommon'];
  ProjectV2ItemFieldValueConnection: Omit<ProjectV2ItemFieldValueConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['ProjectV2ItemFieldValue']>>> };
  ProjectV2ItemFieldValueEdge: Omit<ProjectV2ItemFieldValueEdge, 'node'> & { node?: Maybe<ResolversParentTypes['ProjectV2ItemFieldValue']> };
  ProjectV2ItemFieldValueOrder: ProjectV2ItemFieldValueOrder;
  ProjectV2ItemOrder: ProjectV2ItemOrder;
  ProjectV2IterationField: ProjectV2IterationField;
  ProjectV2IterationFieldConfiguration: ProjectV2IterationFieldConfiguration;
  ProjectV2IterationFieldIteration: ProjectV2IterationFieldIteration;
  ProjectV2Order: ProjectV2Order;
  ProjectV2Owner: ResolversInterfaceTypes<ResolversParentTypes>['ProjectV2Owner'];
  ProjectV2Recent: ResolversInterfaceTypes<ResolversParentTypes>['ProjectV2Recent'];
  ProjectV2SingleSelectField: ProjectV2SingleSelectField;
  ProjectV2SingleSelectFieldOption: ProjectV2SingleSelectFieldOption;
  ProjectV2SingleSelectFieldOptionInput: ProjectV2SingleSelectFieldOptionInput;
  ProjectV2SortBy: ProjectV2SortBy;
  ProjectV2SortByConnection: ProjectV2SortByConnection;
  ProjectV2SortByEdge: ProjectV2SortByEdge;
  ProjectV2SortByField: Omit<ProjectV2SortByField, 'field'> & { field: ResolversParentTypes['ProjectV2FieldConfiguration'] };
  ProjectV2SortByFieldConnection: ProjectV2SortByFieldConnection;
  ProjectV2SortByFieldEdge: ProjectV2SortByFieldEdge;
  ProjectV2View: ProjectV2View;
  ProjectV2ViewConnection: ProjectV2ViewConnection;
  ProjectV2ViewEdge: ProjectV2ViewEdge;
  ProjectV2ViewOrder: ProjectV2ViewOrder;
  ProjectV2Workflow: ProjectV2Workflow;
  ProjectV2WorkflowConnection: ProjectV2WorkflowConnection;
  ProjectV2WorkflowEdge: ProjectV2WorkflowEdge;
  ProjectV2WorkflowOrder: ProjectV2WorkflowOrder;
  PublicKey: PublicKey;
  PublicKeyConnection: PublicKeyConnection;
  PublicKeyEdge: PublicKeyEdge;
  PublishSponsorsTierInput: PublishSponsorsTierInput;
  PublishSponsorsTierPayload: PublishSponsorsTierPayload;
  PullRequest: PullRequest;
  PullRequestChangedFile: PullRequestChangedFile;
  PullRequestChangedFileConnection: PullRequestChangedFileConnection;
  PullRequestChangedFileEdge: PullRequestChangedFileEdge;
  PullRequestCommit: PullRequestCommit;
  PullRequestCommitCommentThread: PullRequestCommitCommentThread;
  PullRequestCommitConnection: PullRequestCommitConnection;
  PullRequestCommitEdge: PullRequestCommitEdge;
  PullRequestConnection: PullRequestConnection;
  PullRequestContributionsByRepository: PullRequestContributionsByRepository;
  PullRequestEdge: PullRequestEdge;
  PullRequestOrder: PullRequestOrder;
  PullRequestParameters: PullRequestParameters;
  PullRequestParametersInput: PullRequestParametersInput;
  PullRequestReview: PullRequestReview;
  PullRequestReviewComment: PullRequestReviewComment;
  PullRequestReviewCommentConnection: PullRequestReviewCommentConnection;
  PullRequestReviewCommentEdge: PullRequestReviewCommentEdge;
  PullRequestReviewConnection: PullRequestReviewConnection;
  PullRequestReviewContributionsByRepository: PullRequestReviewContributionsByRepository;
  PullRequestReviewEdge: PullRequestReviewEdge;
  PullRequestReviewThread: PullRequestReviewThread;
  PullRequestReviewThreadConnection: PullRequestReviewThreadConnection;
  PullRequestReviewThreadEdge: PullRequestReviewThreadEdge;
  PullRequestRevisionMarker: PullRequestRevisionMarker;
  PullRequestTemplate: PullRequestTemplate;
  PullRequestThread: PullRequestThread;
  PullRequestTimelineConnection: Omit<PullRequestTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['PullRequestTimelineItem']>>> };
  PullRequestTimelineItem: ResolversUnionTypes<ResolversParentTypes>['PullRequestTimelineItem'];
  PullRequestTimelineItemEdge: Omit<PullRequestTimelineItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['PullRequestTimelineItem']> };
  PullRequestTimelineItems: ResolversUnionTypes<ResolversParentTypes>['PullRequestTimelineItems'];
  PullRequestTimelineItemsConnection: Omit<PullRequestTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['PullRequestTimelineItems']>>> };
  PullRequestTimelineItemsEdge: Omit<PullRequestTimelineItemsEdge, 'node'> & { node?: Maybe<ResolversParentTypes['PullRequestTimelineItems']> };
  Push: Push;
  PushAllowance: Omit<PushAllowance, 'actor'> & { actor?: Maybe<ResolversParentTypes['PushAllowanceActor']> };
  PushAllowanceActor: ResolversUnionTypes<ResolversParentTypes>['PushAllowanceActor'];
  PushAllowanceConnection: PushAllowanceConnection;
  PushAllowanceEdge: PushAllowanceEdge;
  Query: {};
  RateLimit: RateLimit;
  Reactable: ResolversInterfaceTypes<ResolversParentTypes>['Reactable'];
  ReactingUserConnection: ReactingUserConnection;
  ReactingUserEdge: ReactingUserEdge;
  Reaction: Reaction;
  ReactionConnection: ReactionConnection;
  ReactionEdge: ReactionEdge;
  ReactionGroup: ReactionGroup;
  ReactionOrder: ReactionOrder;
  Reactor: ResolversUnionTypes<ResolversParentTypes>['Reactor'];
  ReactorConnection: Omit<ReactorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Reactor']>>> };
  ReactorEdge: Omit<ReactorEdge, 'node'> & { node: ResolversParentTypes['Reactor'] };
  ReadyForReviewEvent: ReadyForReviewEvent;
  Ref: Ref;
  RefConnection: RefConnection;
  RefEdge: RefEdge;
  RefNameConditionTarget: RefNameConditionTarget;
  RefNameConditionTargetInput: RefNameConditionTargetInput;
  RefOrder: RefOrder;
  RefUpdate: RefUpdate;
  RefUpdateRule: RefUpdateRule;
  ReferencedEvent: Omit<ReferencedEvent, 'subject'> & { subject: ResolversParentTypes['ReferencedSubject'] };
  ReferencedSubject: ResolversUnionTypes<ResolversParentTypes>['ReferencedSubject'];
  RegenerateEnterpriseIdentityProviderRecoveryCodesInput: RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
  RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: RegenerateEnterpriseIdentityProviderRecoveryCodesPayload;
  RegenerateVerifiableDomainTokenInput: RegenerateVerifiableDomainTokenInput;
  RegenerateVerifiableDomainTokenPayload: RegenerateVerifiableDomainTokenPayload;
  RejectDeploymentsInput: RejectDeploymentsInput;
  RejectDeploymentsPayload: RejectDeploymentsPayload;
  Release: Release;
  ReleaseAsset: ReleaseAsset;
  ReleaseAssetConnection: ReleaseAssetConnection;
  ReleaseAssetEdge: ReleaseAssetEdge;
  ReleaseConnection: ReleaseConnection;
  ReleaseEdge: ReleaseEdge;
  ReleaseOrder: ReleaseOrder;
  RemoveAssigneesFromAssignableInput: RemoveAssigneesFromAssignableInput;
  RemoveAssigneesFromAssignablePayload: RemoveAssigneesFromAssignablePayload;
  RemoveEnterpriseAdminInput: RemoveEnterpriseAdminInput;
  RemoveEnterpriseAdminPayload: RemoveEnterpriseAdminPayload;
  RemoveEnterpriseIdentityProviderInput: RemoveEnterpriseIdentityProviderInput;
  RemoveEnterpriseIdentityProviderPayload: RemoveEnterpriseIdentityProviderPayload;
  RemoveEnterpriseMemberInput: RemoveEnterpriseMemberInput;
  RemoveEnterpriseMemberPayload: RemoveEnterpriseMemberPayload;
  RemoveEnterpriseOrganizationInput: RemoveEnterpriseOrganizationInput;
  RemoveEnterpriseOrganizationPayload: RemoveEnterpriseOrganizationPayload;
  RemoveEnterpriseSupportEntitlementInput: RemoveEnterpriseSupportEntitlementInput;
  RemoveEnterpriseSupportEntitlementPayload: RemoveEnterpriseSupportEntitlementPayload;
  RemoveLabelsFromLabelableInput: RemoveLabelsFromLabelableInput;
  RemoveLabelsFromLabelablePayload: RemoveLabelsFromLabelablePayload;
  RemoveOutsideCollaboratorInput: RemoveOutsideCollaboratorInput;
  RemoveOutsideCollaboratorPayload: RemoveOutsideCollaboratorPayload;
  RemoveReactionInput: RemoveReactionInput;
  RemoveReactionPayload: RemoveReactionPayload;
  RemoveStarInput: RemoveStarInput;
  RemoveStarPayload: RemoveStarPayload;
  RemoveUpvoteInput: RemoveUpvoteInput;
  RemoveUpvotePayload: RemoveUpvotePayload;
  RemovedFromMergeQueueEvent: RemovedFromMergeQueueEvent;
  RemovedFromProjectEvent: RemovedFromProjectEvent;
  RenamedTitleEvent: Omit<RenamedTitleEvent, 'subject'> & { subject: ResolversParentTypes['RenamedTitleSubject'] };
  RenamedTitleSubject: ResolversUnionTypes<ResolversParentTypes>['RenamedTitleSubject'];
  ReopenDiscussionInput: ReopenDiscussionInput;
  ReopenDiscussionPayload: ReopenDiscussionPayload;
  ReopenIssueInput: ReopenIssueInput;
  ReopenIssuePayload: ReopenIssuePayload;
  ReopenPullRequestInput: ReopenPullRequestInput;
  ReopenPullRequestPayload: ReopenPullRequestPayload;
  ReopenedEvent: ReopenedEvent;
  RepoAccessAuditEntry: Omit<RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoAddMemberAuditEntry: Omit<RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoAddTopicAuditEntry: Omit<RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoArchivedAuditEntry: Omit<RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoChangeMergeSettingAuditEntry: Omit<RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoConfigDisableAnonymousGitAccessAuditEntry: Omit<RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoConfigDisableCollaboratorsOnlyAuditEntry: Omit<RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoConfigDisableContributorsOnlyAuditEntry: Omit<RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoConfigDisableSockpuppetDisallowedAuditEntry: Omit<RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoConfigEnableAnonymousGitAccessAuditEntry: Omit<RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoConfigEnableCollaboratorsOnlyAuditEntry: Omit<RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoConfigEnableContributorsOnlyAuditEntry: Omit<RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoConfigEnableSockpuppetDisallowedAuditEntry: Omit<RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoConfigLockAnonymousGitAccessAuditEntry: Omit<RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoConfigUnlockAnonymousGitAccessAuditEntry: Omit<RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoCreateAuditEntry: Omit<RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoDestroyAuditEntry: Omit<RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoRemoveMemberAuditEntry: Omit<RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepoRemoveTopicAuditEntry: Omit<RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  Repository: Omit<Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<ResolversParentTypes['IssueOrPullRequest']> };
  RepositoryAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>['RepositoryAuditEntryData'];
  RepositoryCodeowners: RepositoryCodeowners;
  RepositoryCodeownersError: RepositoryCodeownersError;
  RepositoryCollaboratorConnection: RepositoryCollaboratorConnection;
  RepositoryCollaboratorEdge: RepositoryCollaboratorEdge;
  RepositoryConnection: RepositoryConnection;
  RepositoryContactLink: RepositoryContactLink;
  RepositoryDiscussionAuthor: ResolversInterfaceTypes<ResolversParentTypes>['RepositoryDiscussionAuthor'];
  RepositoryDiscussionCommentAuthor: ResolversInterfaceTypes<ResolversParentTypes>['RepositoryDiscussionCommentAuthor'];
  RepositoryEdge: RepositoryEdge;
  RepositoryIdConditionTarget: RepositoryIdConditionTarget;
  RepositoryIdConditionTargetInput: RepositoryIdConditionTargetInput;
  RepositoryInfo: ResolversInterfaceTypes<ResolversParentTypes>['RepositoryInfo'];
  RepositoryInteractionAbility: RepositoryInteractionAbility;
  RepositoryInvitation: RepositoryInvitation;
  RepositoryInvitationConnection: RepositoryInvitationConnection;
  RepositoryInvitationEdge: RepositoryInvitationEdge;
  RepositoryInvitationOrder: RepositoryInvitationOrder;
  RepositoryMigration: RepositoryMigration;
  RepositoryMigrationConnection: RepositoryMigrationConnection;
  RepositoryMigrationEdge: RepositoryMigrationEdge;
  RepositoryMigrationOrder: RepositoryMigrationOrder;
  RepositoryNameConditionTarget: RepositoryNameConditionTarget;
  RepositoryNameConditionTargetInput: RepositoryNameConditionTargetInput;
  RepositoryNode: ResolversInterfaceTypes<ResolversParentTypes>['RepositoryNode'];
  RepositoryOrder: RepositoryOrder;
  RepositoryOwner: ResolversInterfaceTypes<ResolversParentTypes>['RepositoryOwner'];
  RepositoryRule: Omit<RepositoryRule, 'parameters'> & { parameters?: Maybe<ResolversParentTypes['RuleParameters']> };
  RepositoryRuleConditions: RepositoryRuleConditions;
  RepositoryRuleConditionsInput: RepositoryRuleConditionsInput;
  RepositoryRuleConnection: RepositoryRuleConnection;
  RepositoryRuleEdge: RepositoryRuleEdge;
  RepositoryRuleInput: RepositoryRuleInput;
  RepositoryRuleset: Omit<RepositoryRuleset, 'source'> & { source: ResolversParentTypes['RuleSource'] };
  RepositoryRulesetBypassActor: Omit<RepositoryRulesetBypassActor, 'actor'> & { actor?: Maybe<ResolversParentTypes['BypassActor']> };
  RepositoryRulesetBypassActorConnection: RepositoryRulesetBypassActorConnection;
  RepositoryRulesetBypassActorEdge: RepositoryRulesetBypassActorEdge;
  RepositoryRulesetBypassActorInput: RepositoryRulesetBypassActorInput;
  RepositoryRulesetConnection: RepositoryRulesetConnection;
  RepositoryRulesetEdge: RepositoryRulesetEdge;
  RepositoryTopic: RepositoryTopic;
  RepositoryTopicConnection: RepositoryTopicConnection;
  RepositoryTopicEdge: RepositoryTopicEdge;
  RepositoryVisibilityChangeDisableAuditEntry: Omit<RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepositoryVisibilityChangeEnableAuditEntry: Omit<RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  RepositoryVulnerabilityAlert: RepositoryVulnerabilityAlert;
  RepositoryVulnerabilityAlertConnection: RepositoryVulnerabilityAlertConnection;
  RepositoryVulnerabilityAlertEdge: RepositoryVulnerabilityAlertEdge;
  RequestReviewsInput: RequestReviewsInput;
  RequestReviewsPayload: RequestReviewsPayload;
  RequestedReviewer: ResolversUnionTypes<ResolversParentTypes>['RequestedReviewer'];
  RequestedReviewerConnection: Omit<RequestedReviewerConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['RequestedReviewer']>>> };
  RequestedReviewerEdge: Omit<RequestedReviewerEdge, 'node'> & { node?: Maybe<ResolversParentTypes['RequestedReviewer']> };
  RequirableByPullRequest: ResolversInterfaceTypes<ResolversParentTypes>['RequirableByPullRequest'];
  RequiredDeploymentsParameters: RequiredDeploymentsParameters;
  RequiredDeploymentsParametersInput: RequiredDeploymentsParametersInput;
  RequiredStatusCheckDescription: RequiredStatusCheckDescription;
  RequiredStatusCheckInput: RequiredStatusCheckInput;
  RequiredStatusChecksParameters: RequiredStatusChecksParameters;
  RequiredStatusChecksParametersInput: RequiredStatusChecksParametersInput;
  RerequestCheckSuiteInput: RerequestCheckSuiteInput;
  RerequestCheckSuitePayload: RerequestCheckSuitePayload;
  ResolveReviewThreadInput: ResolveReviewThreadInput;
  ResolveReviewThreadPayload: ResolveReviewThreadPayload;
  RestrictedContribution: RestrictedContribution;
  RetireSponsorsTierInput: RetireSponsorsTierInput;
  RetireSponsorsTierPayload: RetireSponsorsTierPayload;
  RevertPullRequestInput: RevertPullRequestInput;
  RevertPullRequestPayload: RevertPullRequestPayload;
  ReviewDismissalAllowance: Omit<ReviewDismissalAllowance, 'actor'> & { actor?: Maybe<ResolversParentTypes['ReviewDismissalAllowanceActor']> };
  ReviewDismissalAllowanceActor: ResolversUnionTypes<ResolversParentTypes>['ReviewDismissalAllowanceActor'];
  ReviewDismissalAllowanceConnection: ReviewDismissalAllowanceConnection;
  ReviewDismissalAllowanceEdge: ReviewDismissalAllowanceEdge;
  ReviewDismissedEvent: ReviewDismissedEvent;
  ReviewRequest: Omit<ReviewRequest, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversParentTypes['RequestedReviewer']> };
  ReviewRequestConnection: ReviewRequestConnection;
  ReviewRequestEdge: ReviewRequestEdge;
  ReviewRequestRemovedEvent: Omit<ReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversParentTypes['RequestedReviewer']> };
  ReviewRequestedEvent: Omit<ReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversParentTypes['RequestedReviewer']> };
  ReviewStatusHovercardContext: ReviewStatusHovercardContext;
  RevokeEnterpriseOrganizationsMigratorRoleInput: RevokeEnterpriseOrganizationsMigratorRoleInput;
  RevokeEnterpriseOrganizationsMigratorRolePayload: RevokeEnterpriseOrganizationsMigratorRolePayload;
  RevokeMigratorRoleInput: RevokeMigratorRoleInput;
  RevokeMigratorRolePayload: RevokeMigratorRolePayload;
  RuleParameters: ResolversUnionTypes<ResolversParentTypes>['RuleParameters'];
  RuleParametersInput: RuleParametersInput;
  RuleSource: ResolversUnionTypes<ResolversParentTypes>['RuleSource'];
  SavedReply: SavedReply;
  SavedReplyConnection: SavedReplyConnection;
  SavedReplyEdge: SavedReplyEdge;
  SavedReplyOrder: SavedReplyOrder;
  SearchResultItem: ResolversUnionTypes<ResolversParentTypes>['SearchResultItem'];
  SearchResultItemConnection: Omit<SearchResultItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['SearchResultItem']>>> };
  SearchResultItemEdge: Omit<SearchResultItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['SearchResultItem']> };
  SecurityAdvisory: SecurityAdvisory;
  SecurityAdvisoryConnection: SecurityAdvisoryConnection;
  SecurityAdvisoryEdge: SecurityAdvisoryEdge;
  SecurityAdvisoryIdentifier: SecurityAdvisoryIdentifier;
  SecurityAdvisoryIdentifierFilter: SecurityAdvisoryIdentifierFilter;
  SecurityAdvisoryOrder: SecurityAdvisoryOrder;
  SecurityAdvisoryPackage: SecurityAdvisoryPackage;
  SecurityAdvisoryPackageVersion: SecurityAdvisoryPackageVersion;
  SecurityAdvisoryReference: SecurityAdvisoryReference;
  SecurityVulnerability: SecurityVulnerability;
  SecurityVulnerabilityConnection: SecurityVulnerabilityConnection;
  SecurityVulnerabilityEdge: SecurityVulnerabilityEdge;
  SecurityVulnerabilityOrder: SecurityVulnerabilityOrder;
  SetEnterpriseIdentityProviderInput: SetEnterpriseIdentityProviderInput;
  SetEnterpriseIdentityProviderPayload: SetEnterpriseIdentityProviderPayload;
  SetOrganizationInteractionLimitInput: SetOrganizationInteractionLimitInput;
  SetOrganizationInteractionLimitPayload: SetOrganizationInteractionLimitPayload;
  SetRepositoryInteractionLimitInput: SetRepositoryInteractionLimitInput;
  SetRepositoryInteractionLimitPayload: SetRepositoryInteractionLimitPayload;
  SetUserInteractionLimitInput: SetUserInteractionLimitInput;
  SetUserInteractionLimitPayload: SetUserInteractionLimitPayload;
  SmimeSignature: SmimeSignature;
  SocialAccount: SocialAccount;
  SocialAccountConnection: SocialAccountConnection;
  SocialAccountEdge: SocialAccountEdge;
  Sponsor: ResolversUnionTypes<ResolversParentTypes>['Sponsor'];
  SponsorConnection: Omit<SponsorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Sponsor']>>> };
  SponsorEdge: Omit<SponsorEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Sponsor']> };
  SponsorOrder: SponsorOrder;
  Sponsorable: ResolversInterfaceTypes<ResolversParentTypes>['Sponsorable'];
  SponsorableItem: ResolversUnionTypes<ResolversParentTypes>['SponsorableItem'];
  SponsorableItemConnection: Omit<SponsorableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['SponsorableItem']>>> };
  SponsorableItemEdge: Omit<SponsorableItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['SponsorableItem']> };
  SponsorableOrder: SponsorableOrder;
  SponsorsActivity: Omit<SponsorsActivity, 'sponsor'> & { sponsor?: Maybe<ResolversParentTypes['Sponsor']> };
  SponsorsActivityConnection: SponsorsActivityConnection;
  SponsorsActivityEdge: SponsorsActivityEdge;
  SponsorsActivityOrder: SponsorsActivityOrder;
  SponsorsGoal: SponsorsGoal;
  SponsorsListing: SponsorsListing;
  SponsorsListingFeatureableItem: ResolversUnionTypes<ResolversParentTypes>['SponsorsListingFeatureableItem'];
  SponsorsListingFeaturedItem: Omit<SponsorsListingFeaturedItem, 'featureable'> & { featureable: ResolversParentTypes['SponsorsListingFeatureableItem'] };
  SponsorsTier: SponsorsTier;
  SponsorsTierAdminInfo: SponsorsTierAdminInfo;
  SponsorsTierConnection: SponsorsTierConnection;
  SponsorsTierEdge: SponsorsTierEdge;
  SponsorsTierOrder: SponsorsTierOrder;
  Sponsorship: Omit<Sponsorship, 'sponsorEntity'> & { sponsorEntity?: Maybe<ResolversParentTypes['Sponsor']> };
  SponsorshipConnection: SponsorshipConnection;
  SponsorshipEdge: SponsorshipEdge;
  SponsorshipNewsletter: SponsorshipNewsletter;
  SponsorshipNewsletterConnection: SponsorshipNewsletterConnection;
  SponsorshipNewsletterEdge: SponsorshipNewsletterEdge;
  SponsorshipNewsletterOrder: SponsorshipNewsletterOrder;
  SponsorshipOrder: SponsorshipOrder;
  SshSignature: SshSignature;
  StarOrder: StarOrder;
  StargazerConnection: StargazerConnection;
  StargazerEdge: StargazerEdge;
  Starrable: ResolversInterfaceTypes<ResolversParentTypes>['Starrable'];
  StarredRepositoryConnection: StarredRepositoryConnection;
  StarredRepositoryEdge: StarredRepositoryEdge;
  StartOrganizationMigrationInput: StartOrganizationMigrationInput;
  StartOrganizationMigrationPayload: StartOrganizationMigrationPayload;
  StartRepositoryMigrationInput: StartRepositoryMigrationInput;
  StartRepositoryMigrationPayload: StartRepositoryMigrationPayload;
  Status: Status;
  StatusCheckConfiguration: StatusCheckConfiguration;
  StatusCheckConfigurationInput: StatusCheckConfigurationInput;
  StatusCheckRollup: StatusCheckRollup;
  StatusCheckRollupContext: ResolversUnionTypes<ResolversParentTypes>['StatusCheckRollupContext'];
  StatusCheckRollupContextConnection: Omit<StatusCheckRollupContextConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['StatusCheckRollupContext']>>> };
  StatusCheckRollupContextEdge: Omit<StatusCheckRollupContextEdge, 'node'> & { node?: Maybe<ResolversParentTypes['StatusCheckRollupContext']> };
  StatusContext: StatusContext;
  StatusContextStateCount: StatusContextStateCount;
  StripeConnectAccount: StripeConnectAccount;
  SubmitPullRequestReviewInput: SubmitPullRequestReviewInput;
  SubmitPullRequestReviewPayload: SubmitPullRequestReviewPayload;
  Submodule: Submodule;
  SubmoduleConnection: SubmoduleConnection;
  SubmoduleEdge: SubmoduleEdge;
  Subscribable: ResolversInterfaceTypes<ResolversParentTypes>['Subscribable'];
  SubscribableThread: ResolversInterfaceTypes<ResolversParentTypes>['SubscribableThread'];
  SubscribedEvent: SubscribedEvent;
  SuggestedReviewer: SuggestedReviewer;
  Tag: Tag;
  TagNamePatternParameters: TagNamePatternParameters;
  TagNamePatternParametersInput: TagNamePatternParametersInput;
  Team: Team;
  TeamAddMemberAuditEntry: Omit<TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  TeamAddRepositoryAuditEntry: Omit<TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  TeamAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>['TeamAuditEntryData'];
  TeamChangeParentTeamAuditEntry: Omit<TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  TeamConnection: TeamConnection;
  TeamDiscussion: TeamDiscussion;
  TeamDiscussionComment: TeamDiscussionComment;
  TeamDiscussionCommentConnection: TeamDiscussionCommentConnection;
  TeamDiscussionCommentEdge: TeamDiscussionCommentEdge;
  TeamDiscussionCommentOrder: TeamDiscussionCommentOrder;
  TeamDiscussionConnection: TeamDiscussionConnection;
  TeamDiscussionEdge: TeamDiscussionEdge;
  TeamDiscussionOrder: TeamDiscussionOrder;
  TeamEdge: TeamEdge;
  TeamMemberConnection: TeamMemberConnection;
  TeamMemberEdge: TeamMemberEdge;
  TeamMemberOrder: TeamMemberOrder;
  TeamOrder: TeamOrder;
  TeamRemoveMemberAuditEntry: Omit<TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  TeamRemoveRepositoryAuditEntry: Omit<TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['AuditEntryActor']> };
  TeamRepositoryConnection: TeamRepositoryConnection;
  TeamRepositoryEdge: TeamRepositoryEdge;
  TeamRepositoryOrder: TeamRepositoryOrder;
  TextMatch: TextMatch;
  TextMatchHighlight: TextMatchHighlight;
  Topic: Topic;
  TopicAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>['TopicAuditEntryData'];
  TransferEnterpriseOrganizationInput: TransferEnterpriseOrganizationInput;
  TransferEnterpriseOrganizationPayload: TransferEnterpriseOrganizationPayload;
  TransferIssueInput: TransferIssueInput;
  TransferIssuePayload: TransferIssuePayload;
  TransferredEvent: TransferredEvent;
  Tree: Tree;
  TreeEntry: TreeEntry;
  URI: Scalars['URI']['output'];
  UnarchiveProjectV2ItemInput: UnarchiveProjectV2ItemInput;
  UnarchiveProjectV2ItemPayload: UnarchiveProjectV2ItemPayload;
  UnarchiveRepositoryInput: UnarchiveRepositoryInput;
  UnarchiveRepositoryPayload: UnarchiveRepositoryPayload;
  UnassignedEvent: Omit<UnassignedEvent, 'assignee'> & { assignee?: Maybe<ResolversParentTypes['Assignee']> };
  UnfollowOrganizationInput: UnfollowOrganizationInput;
  UnfollowOrganizationPayload: UnfollowOrganizationPayload;
  UnfollowUserInput: UnfollowUserInput;
  UnfollowUserPayload: UnfollowUserPayload;
  UniformResourceLocatable: ResolversInterfaceTypes<ResolversParentTypes>['UniformResourceLocatable'];
  UnknownSignature: UnknownSignature;
  UnlabeledEvent: UnlabeledEvent;
  UnlinkProjectV2FromRepositoryInput: UnlinkProjectV2FromRepositoryInput;
  UnlinkProjectV2FromRepositoryPayload: UnlinkProjectV2FromRepositoryPayload;
  UnlinkProjectV2FromTeamInput: UnlinkProjectV2FromTeamInput;
  UnlinkProjectV2FromTeamPayload: UnlinkProjectV2FromTeamPayload;
  UnlinkRepositoryFromProjectInput: UnlinkRepositoryFromProjectInput;
  UnlinkRepositoryFromProjectPayload: UnlinkRepositoryFromProjectPayload;
  UnlockLockableInput: UnlockLockableInput;
  UnlockLockablePayload: UnlockLockablePayload;
  UnlockedEvent: UnlockedEvent;
  UnmarkDiscussionCommentAsAnswerInput: UnmarkDiscussionCommentAsAnswerInput;
  UnmarkDiscussionCommentAsAnswerPayload: UnmarkDiscussionCommentAsAnswerPayload;
  UnmarkFileAsViewedInput: UnmarkFileAsViewedInput;
  UnmarkFileAsViewedPayload: UnmarkFileAsViewedPayload;
  UnmarkIssueAsDuplicateInput: UnmarkIssueAsDuplicateInput;
  UnmarkIssueAsDuplicatePayload: Omit<UnmarkIssueAsDuplicatePayload, 'duplicate'> & { duplicate?: Maybe<ResolversParentTypes['IssueOrPullRequest']> };
  UnmarkProjectV2AsTemplateInput: UnmarkProjectV2AsTemplateInput;
  UnmarkProjectV2AsTemplatePayload: UnmarkProjectV2AsTemplatePayload;
  UnmarkedAsDuplicateEvent: Omit<UnmarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<ResolversParentTypes['IssueOrPullRequest']>, duplicate?: Maybe<ResolversParentTypes['IssueOrPullRequest']> };
  UnminimizeCommentInput: UnminimizeCommentInput;
  UnminimizeCommentPayload: UnminimizeCommentPayload;
  UnpinIssueInput: UnpinIssueInput;
  UnpinIssuePayload: UnpinIssuePayload;
  UnpinnedEvent: UnpinnedEvent;
  UnresolveReviewThreadInput: UnresolveReviewThreadInput;
  UnresolveReviewThreadPayload: UnresolveReviewThreadPayload;
  UnsubscribeFromNotificationsInput: UnsubscribeFromNotificationsInput;
  UnsubscribeFromNotificationsPayload: UnsubscribeFromNotificationsPayload;
  UnsubscribedEvent: UnsubscribedEvent;
  Updatable: ResolversInterfaceTypes<ResolversParentTypes>['Updatable'];
  UpdatableComment: ResolversInterfaceTypes<ResolversParentTypes>['UpdatableComment'];
  UpdateBranchProtectionRuleInput: UpdateBranchProtectionRuleInput;
  UpdateBranchProtectionRulePayload: UpdateBranchProtectionRulePayload;
  UpdateCheckRunInput: UpdateCheckRunInput;
  UpdateCheckRunPayload: UpdateCheckRunPayload;
  UpdateCheckSuitePreferencesInput: UpdateCheckSuitePreferencesInput;
  UpdateCheckSuitePreferencesPayload: UpdateCheckSuitePreferencesPayload;
  UpdateDiscussionCommentInput: UpdateDiscussionCommentInput;
  UpdateDiscussionCommentPayload: UpdateDiscussionCommentPayload;
  UpdateDiscussionInput: UpdateDiscussionInput;
  UpdateDiscussionPayload: UpdateDiscussionPayload;
  UpdateEnterpriseAdministratorRoleInput: UpdateEnterpriseAdministratorRoleInput;
  UpdateEnterpriseAdministratorRolePayload: UpdateEnterpriseAdministratorRolePayload;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload;
  UpdateEnterpriseDefaultRepositoryPermissionSettingInput: UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
  UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: UpdateEnterpriseDefaultRepositoryPermissionSettingPayload;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingInput: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload;
  UpdateEnterpriseMembersCanDeleteIssuesSettingInput: UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
  UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: UpdateEnterpriseMembersCanDeleteIssuesSettingPayload;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload;
  UpdateEnterpriseMembersCanMakePurchasesSettingInput: UpdateEnterpriseMembersCanMakePurchasesSettingInput;
  UpdateEnterpriseMembersCanMakePurchasesSettingPayload: UpdateEnterpriseMembersCanMakePurchasesSettingPayload;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload;
  UpdateEnterpriseOrganizationProjectsSettingInput: UpdateEnterpriseOrganizationProjectsSettingInput;
  UpdateEnterpriseOrganizationProjectsSettingPayload: UpdateEnterpriseOrganizationProjectsSettingPayload;
  UpdateEnterpriseOwnerOrganizationRoleInput: UpdateEnterpriseOwnerOrganizationRoleInput;
  UpdateEnterpriseOwnerOrganizationRolePayload: UpdateEnterpriseOwnerOrganizationRolePayload;
  UpdateEnterpriseProfileInput: UpdateEnterpriseProfileInput;
  UpdateEnterpriseProfilePayload: UpdateEnterpriseProfilePayload;
  UpdateEnterpriseRepositoryProjectsSettingInput: UpdateEnterpriseRepositoryProjectsSettingInput;
  UpdateEnterpriseRepositoryProjectsSettingPayload: UpdateEnterpriseRepositoryProjectsSettingPayload;
  UpdateEnterpriseTeamDiscussionsSettingInput: UpdateEnterpriseTeamDiscussionsSettingInput;
  UpdateEnterpriseTeamDiscussionsSettingPayload: UpdateEnterpriseTeamDiscussionsSettingPayload;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload;
  UpdateEnvironmentInput: UpdateEnvironmentInput;
  UpdateEnvironmentPayload: UpdateEnvironmentPayload;
  UpdateIpAllowListEnabledSettingInput: UpdateIpAllowListEnabledSettingInput;
  UpdateIpAllowListEnabledSettingPayload: Omit<UpdateIpAllowListEnabledSettingPayload, 'owner'> & { owner?: Maybe<ResolversParentTypes['IpAllowListOwner']> };
  UpdateIpAllowListEntryInput: UpdateIpAllowListEntryInput;
  UpdateIpAllowListEntryPayload: UpdateIpAllowListEntryPayload;
  UpdateIpAllowListForInstalledAppsEnabledSettingInput: UpdateIpAllowListForInstalledAppsEnabledSettingInput;
  UpdateIpAllowListForInstalledAppsEnabledSettingPayload: Omit<UpdateIpAllowListForInstalledAppsEnabledSettingPayload, 'owner'> & { owner?: Maybe<ResolversParentTypes['IpAllowListOwner']> };
  UpdateIssueCommentInput: UpdateIssueCommentInput;
  UpdateIssueCommentPayload: UpdateIssueCommentPayload;
  UpdateIssueInput: UpdateIssueInput;
  UpdateIssuePayload: UpdateIssuePayload;
  UpdateLabelInput: UpdateLabelInput;
  UpdateLabelPayload: UpdateLabelPayload;
  UpdateNotificationRestrictionSettingInput: UpdateNotificationRestrictionSettingInput;
  UpdateNotificationRestrictionSettingPayload: Omit<UpdateNotificationRestrictionSettingPayload, 'owner'> & { owner?: Maybe<ResolversParentTypes['VerifiableDomainOwner']> };
  UpdateOrganizationAllowPrivateRepositoryForkingSettingInput: UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
  UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload: UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload;
  UpdateOrganizationWebCommitSignoffSettingInput: UpdateOrganizationWebCommitSignoffSettingInput;
  UpdateOrganizationWebCommitSignoffSettingPayload: UpdateOrganizationWebCommitSignoffSettingPayload;
  UpdateParameters: UpdateParameters;
  UpdateParametersInput: UpdateParametersInput;
  UpdatePatreonSponsorabilityInput: UpdatePatreonSponsorabilityInput;
  UpdatePatreonSponsorabilityPayload: UpdatePatreonSponsorabilityPayload;
  UpdateProjectCardInput: UpdateProjectCardInput;
  UpdateProjectCardPayload: UpdateProjectCardPayload;
  UpdateProjectColumnInput: UpdateProjectColumnInput;
  UpdateProjectColumnPayload: UpdateProjectColumnPayload;
  UpdateProjectInput: UpdateProjectInput;
  UpdateProjectPayload: UpdateProjectPayload;
  UpdateProjectV2CollaboratorsInput: UpdateProjectV2CollaboratorsInput;
  UpdateProjectV2CollaboratorsPayload: UpdateProjectV2CollaboratorsPayload;
  UpdateProjectV2DraftIssueInput: UpdateProjectV2DraftIssueInput;
  UpdateProjectV2DraftIssuePayload: UpdateProjectV2DraftIssuePayload;
  UpdateProjectV2Input: UpdateProjectV2Input;
  UpdateProjectV2ItemFieldValueInput: UpdateProjectV2ItemFieldValueInput;
  UpdateProjectV2ItemFieldValuePayload: UpdateProjectV2ItemFieldValuePayload;
  UpdateProjectV2ItemPositionInput: UpdateProjectV2ItemPositionInput;
  UpdateProjectV2ItemPositionPayload: UpdateProjectV2ItemPositionPayload;
  UpdateProjectV2Payload: UpdateProjectV2Payload;
  UpdatePullRequestBranchInput: UpdatePullRequestBranchInput;
  UpdatePullRequestBranchPayload: UpdatePullRequestBranchPayload;
  UpdatePullRequestInput: UpdatePullRequestInput;
  UpdatePullRequestPayload: UpdatePullRequestPayload;
  UpdatePullRequestReviewCommentInput: UpdatePullRequestReviewCommentInput;
  UpdatePullRequestReviewCommentPayload: UpdatePullRequestReviewCommentPayload;
  UpdatePullRequestReviewInput: UpdatePullRequestReviewInput;
  UpdatePullRequestReviewPayload: UpdatePullRequestReviewPayload;
  UpdateRefInput: UpdateRefInput;
  UpdateRefPayload: UpdateRefPayload;
  UpdateRefsInput: UpdateRefsInput;
  UpdateRefsPayload: UpdateRefsPayload;
  UpdateRepositoryInput: UpdateRepositoryInput;
  UpdateRepositoryPayload: UpdateRepositoryPayload;
  UpdateRepositoryRulesetInput: UpdateRepositoryRulesetInput;
  UpdateRepositoryRulesetPayload: UpdateRepositoryRulesetPayload;
  UpdateRepositoryWebCommitSignoffSettingInput: UpdateRepositoryWebCommitSignoffSettingInput;
  UpdateRepositoryWebCommitSignoffSettingPayload: UpdateRepositoryWebCommitSignoffSettingPayload;
  UpdateSponsorshipPreferencesInput: UpdateSponsorshipPreferencesInput;
  UpdateSponsorshipPreferencesPayload: UpdateSponsorshipPreferencesPayload;
  UpdateSubscriptionInput: UpdateSubscriptionInput;
  UpdateSubscriptionPayload: UpdateSubscriptionPayload;
  UpdateTeamDiscussionCommentInput: UpdateTeamDiscussionCommentInput;
  UpdateTeamDiscussionCommentPayload: UpdateTeamDiscussionCommentPayload;
  UpdateTeamDiscussionInput: UpdateTeamDiscussionInput;
  UpdateTeamDiscussionPayload: UpdateTeamDiscussionPayload;
  UpdateTeamReviewAssignmentInput: UpdateTeamReviewAssignmentInput;
  UpdateTeamReviewAssignmentPayload: UpdateTeamReviewAssignmentPayload;
  UpdateTeamsRepositoryInput: UpdateTeamsRepositoryInput;
  UpdateTeamsRepositoryPayload: UpdateTeamsRepositoryPayload;
  UpdateTopicsInput: UpdateTopicsInput;
  UpdateTopicsPayload: UpdateTopicsPayload;
  UpdateUserListInput: UpdateUserListInput;
  UpdateUserListPayload: UpdateUserListPayload;
  UpdateUserListsForItemInput: UpdateUserListsForItemInput;
  UpdateUserListsForItemPayload: Omit<UpdateUserListsForItemPayload, 'item'> & { item?: Maybe<ResolversParentTypes['UserListItems']> };
  User: User;
  UserBlockedEvent: UserBlockedEvent;
  UserConnection: UserConnection;
  UserContentEdit: UserContentEdit;
  UserContentEditConnection: UserContentEditConnection;
  UserContentEditEdge: UserContentEditEdge;
  UserEdge: UserEdge;
  UserEmailMetadata: UserEmailMetadata;
  UserList: UserList;
  UserListConnection: UserListConnection;
  UserListEdge: UserListEdge;
  UserListItems: ResolversUnionTypes<ResolversParentTypes>['UserListItems'];
  UserListItemsConnection: Omit<UserListItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['UserListItems']>>> };
  UserListItemsEdge: Omit<UserListItemsEdge, 'node'> & { node?: Maybe<ResolversParentTypes['UserListItems']> };
  UserListSuggestion: UserListSuggestion;
  UserStatus: UserStatus;
  UserStatusConnection: UserStatusConnection;
  UserStatusEdge: UserStatusEdge;
  UserStatusOrder: UserStatusOrder;
  VerifiableDomain: Omit<VerifiableDomain, 'owner'> & { owner: ResolversParentTypes['VerifiableDomainOwner'] };
  VerifiableDomainConnection: VerifiableDomainConnection;
  VerifiableDomainEdge: VerifiableDomainEdge;
  VerifiableDomainOrder: VerifiableDomainOrder;
  VerifiableDomainOwner: ResolversUnionTypes<ResolversParentTypes>['VerifiableDomainOwner'];
  VerifyVerifiableDomainInput: VerifyVerifiableDomainInput;
  VerifyVerifiableDomainPayload: VerifyVerifiableDomainPayload;
  ViewerHovercardContext: ViewerHovercardContext;
  Votable: ResolversInterfaceTypes<ResolversParentTypes>['Votable'];
  Workflow: Workflow;
  WorkflowFileReference: WorkflowFileReference;
  WorkflowFileReferenceInput: WorkflowFileReferenceInput;
  WorkflowRun: WorkflowRun;
  WorkflowRunConnection: WorkflowRunConnection;
  WorkflowRunEdge: WorkflowRunEdge;
  WorkflowRunFile: WorkflowRunFile;
  WorkflowRunOrder: WorkflowRunOrder;
  WorkflowsParameters: WorkflowsParameters;
  WorkflowsParametersInput: WorkflowsParametersInput;
  X509Certificate: Scalars['X509Certificate']['output'];
}>;

export type requiredCapabilitiesDirectiveArgs = {
  requiredCapabilities?: Maybe<Array<Scalars['String']['input']>>;
};

export type requiredCapabilitiesDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = requiredCapabilitiesDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type previewDirectiveArgs = {
  toggledBy: Scalars['String']['input'];
};

export type previewDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = previewDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type possibleTypesDirectiveArgs = {
  abstractType?: Maybe<Scalars['String']['input']>;
  concreteTypes: Array<Scalars['String']['input']>;
};

export type possibleTypesDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = possibleTypesDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type AbortQueuedMigrationsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AbortQueuedMigrationsPayload'] = ResolversParentTypes['AbortQueuedMigrationsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AbortRepositoryMigrationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AbortRepositoryMigrationPayload'] = ResolversParentTypes['AbortRepositoryMigrationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AcceptEnterpriseAdministratorInvitationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AcceptEnterpriseAdministratorInvitationPayload'] = ResolversParentTypes['AcceptEnterpriseAdministratorInvitationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<ResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AcceptTopicSuggestionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AcceptTopicSuggestionPayload'] = ResolversParentTypes['AcceptTopicSuggestionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['Topic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Actor'] = ResolversParentTypes['Actor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Bot' | 'EnterpriseUserAccount' | 'Mannequin' | 'Organization' | 'User', ParentType, ContextType>;
  avatarUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType, Partial<ActoravatarUrlArgs>>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
}>;

export type ActorLocationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ActorLocation'] = ResolversParentTypes['ActorLocation']> = ResolversObject<{
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  countryCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  region?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  regionCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddAssigneesToAssignablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddAssigneesToAssignablePayload'] = ResolversParentTypes['AddAssigneesToAssignablePayload']> = ResolversObject<{
  assignable?: Resolver<Maybe<ResolversTypes['Assignable']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddCommentPayload'] = ResolversParentTypes['AddCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  commentEdge?: Resolver<Maybe<ResolversTypes['IssueCommentEdge']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType>;
  timelineEdge?: Resolver<Maybe<ResolversTypes['IssueTimelineItemEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddDiscussionCommentPayload'] = ResolversParentTypes['AddDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['DiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddDiscussionPollVotePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddDiscussionPollVotePayload'] = ResolversParentTypes['AddDiscussionPollVotePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pollOption?: Resolver<Maybe<ResolversTypes['DiscussionPollOption']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddEnterpriseOrganizationMemberPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddEnterpriseOrganizationMemberPayload'] = ResolversParentTypes['AddEnterpriseOrganizationMemberPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<Array<ResolversTypes['User']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddEnterpriseSupportEntitlementPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddEnterpriseSupportEntitlementPayload'] = ResolversParentTypes['AddEnterpriseSupportEntitlementPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddLabelsToLabelablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddLabelsToLabelablePayload'] = ResolversParentTypes['AddLabelsToLabelablePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labelable?: Resolver<Maybe<ResolversTypes['Labelable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddProjectCardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddProjectCardPayload'] = ResolversParentTypes['AddProjectCardPayload']> = ResolversObject<{
  cardEdge?: Resolver<Maybe<ResolversTypes['ProjectCardEdge']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectColumn?: Resolver<Maybe<ResolversTypes['ProjectColumn']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddProjectColumnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddProjectColumnPayload'] = ResolversParentTypes['AddProjectColumnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  columnEdge?: Resolver<Maybe<ResolversTypes['ProjectColumnEdge']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddProjectV2DraftIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddProjectV2DraftIssuePayload'] = ResolversParentTypes['AddProjectV2DraftIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectItem?: Resolver<Maybe<ResolversTypes['ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddProjectV2ItemByIdPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddProjectV2ItemByIdPayload'] = ResolversParentTypes['AddProjectV2ItemByIdPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddPullRequestReviewCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddPullRequestReviewCommentPayload'] = ResolversParentTypes['AddPullRequestReviewCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>;
  commentEdge?: Resolver<Maybe<ResolversTypes['PullRequestReviewCommentEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddPullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddPullRequestReviewPayload'] = ResolversParentTypes['AddPullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  reviewEdge?: Resolver<Maybe<ResolversTypes['PullRequestReviewEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddPullRequestReviewThreadPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddPullRequestReviewThreadPayload'] = ResolversParentTypes['AddPullRequestReviewThreadPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  thread?: Resolver<Maybe<ResolversTypes['PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddPullRequestReviewThreadReplyPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddPullRequestReviewThreadReplyPayload'] = ResolversParentTypes['AddPullRequestReviewThreadReplyPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddReactionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddReactionPayload'] = ResolversParentTypes['AddReactionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reaction?: Resolver<Maybe<ResolversTypes['Reaction']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['Reactable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddStarPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddStarPayload'] = ResolversParentTypes['AddStarPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  starrable?: Resolver<Maybe<ResolversTypes['Starrable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddUpvotePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddUpvotePayload'] = ResolversParentTypes['AddUpvotePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['Votable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddVerifiableDomainPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddVerifiableDomainPayload'] = ResolversParentTypes['AddVerifiableDomainPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domain?: Resolver<Maybe<ResolversTypes['VerifiableDomain']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddedToMergeQueueEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddedToMergeQueueEvent'] = ResolversParentTypes['AddedToMergeQueueEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enqueuer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  mergeQueue?: Resolver<Maybe<ResolversTypes['MergeQueue']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AddedToProjectEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AddedToProjectEvent'] = ResolversParentTypes['AddedToProjectEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['ProjectCard']>, ParentType, ContextType>;
  projectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AnnouncementBannerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AnnouncementBanner'] = ResolversParentTypes['AnnouncementBanner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Enterprise' | 'Organization', ParentType, ContextType>;
  announcement?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  announcementExpiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  announcementUserDismissible?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
}>;

export type AppResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['App'] = ResolversParentTypes['App']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ipAllowListEntries?: Resolver<ResolversTypes['IpAllowListEntryConnection'], ParentType, ContextType, RequireFields<AppipAllowListEntriesArgs, 'orderBy'>>;
  logoBackgroundColor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logoUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType, Partial<ApplogoUrlArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ApproveDeploymentsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ApproveDeploymentsPayload'] = ResolversParentTypes['ApproveDeploymentsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deployments?: Resolver<Maybe<Array<ResolversTypes['Deployment']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ApproveVerifiableDomainPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ApproveVerifiableDomainPayload'] = ResolversParentTypes['ApproveVerifiableDomainPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domain?: Resolver<Maybe<ResolversTypes['VerifiableDomain']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ArchiveProjectV2ItemPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ArchiveProjectV2ItemPayload'] = ResolversParentTypes['ArchiveProjectV2ItemPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ArchiveRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ArchiveRepositoryPayload'] = ResolversParentTypes['ArchiveRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AssignableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Assignable'] = ResolversParentTypes['Assignable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
  assignees?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<AssignableassigneesArgs>>;
}>;

export type AssignedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AssignedEvent'] = ResolversParentTypes['AssignedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  assignable?: Resolver<ResolversTypes['Assignable'], ParentType, ContextType>;
  assignee?: Resolver<Maybe<ResolversTypes['Assignee']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AssigneeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Assignee'] = ResolversParentTypes['Assignee']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Bot' | 'Mannequin' | 'Organization' | 'User', ParentType, ContextType>;
}>;

export type AuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuditEntry'] = ResolversParentTypes['AuditEntry']> = ResolversObject<{
  __resolveType: TypeResolveFn<'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'OauthApplicationCreateAuditEntry' | 'OrgAddBillingManagerAuditEntry' | 'OrgAddMemberAuditEntry' | 'OrgBlockUserAuditEntry' | 'OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'OrgCreateAuditEntry' | 'OrgDisableOauthAppRestrictionsAuditEntry' | 'OrgDisableSamlAuditEntry' | 'OrgDisableTwoFactorRequirementAuditEntry' | 'OrgEnableOauthAppRestrictionsAuditEntry' | 'OrgEnableSamlAuditEntry' | 'OrgEnableTwoFactorRequirementAuditEntry' | 'OrgInviteMemberAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessBlockedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry' | 'OrgOauthAppAccessUnblockedAuditEntry' | 'OrgRemoveBillingManagerAuditEntry' | 'OrgRemoveMemberAuditEntry' | 'OrgRemoveOutsideCollaboratorAuditEntry' | 'OrgRestoreMemberAuditEntry' | 'OrgUnblockUserAuditEntry' | 'OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'OrgUpdateMemberAuditEntry' | 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
}>;

export type AuditEntryActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AuditEntryActor'] = ResolversParentTypes['AuditEntryActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Bot' | 'Organization' | 'User', ParentType, ContextType>;
}>;

export type AutoMergeDisabledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AutoMergeDisabledEvent'] = ResolversParentTypes['AutoMergeDisabledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  disabler?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reasonCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AutoMergeEnabledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AutoMergeEnabledEvent'] = ResolversParentTypes['AutoMergeEnabledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enabler?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AutoMergeRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AutoMergeRequest'] = ResolversParentTypes['AutoMergeRequest']> = ResolversObject<{
  authorEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  commitBody?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  commitHeadline?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enabledAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  enabledBy?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  mergeMethod?: Resolver<ResolversTypes['PullRequestMergeMethod'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AutoRebaseEnabledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AutoRebaseEnabledEvent'] = ResolversParentTypes['AutoRebaseEnabledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enabler?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AutoSquashEnabledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AutoSquashEnabledEvent'] = ResolversParentTypes['AutoSquashEnabledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enabler?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AutomaticBaseChangeFailedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AutomaticBaseChangeFailedEvent'] = ResolversParentTypes['AutomaticBaseChangeFailedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  newBase?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  oldBase?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AutomaticBaseChangeSucceededEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AutomaticBaseChangeSucceededEvent'] = ResolversParentTypes['AutomaticBaseChangeSucceededEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  newBase?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  oldBase?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface Base64StringScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Base64String'], any> {
  name: 'Base64String';
}

export type BaseRefChangedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BaseRefChangedEvent'] = ResolversParentTypes['BaseRefChangedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  currentRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  previousRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BaseRefDeletedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BaseRefDeletedEvent'] = ResolversParentTypes['BaseRefDeletedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  baseRefName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BaseRefForcePushedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BaseRefForcePushedEvent'] = ResolversParentTypes['BaseRefForcePushedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  afterCommit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  beforeCommit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
  name: 'BigInt';
}

export type BlameResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Blame'] = ResolversParentTypes['Blame']> = ResolversObject<{
  ranges?: Resolver<Array<ResolversTypes['BlameRange']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BlameRangeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BlameRange'] = ResolversParentTypes['BlameRange']> = ResolversObject<{
  age?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  commit?: Resolver<ResolversTypes['Commit'], ParentType, ContextType>;
  endingLine?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  startingLine?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BlobResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Blob'] = ResolversParentTypes['Blob']> = ResolversObject<{
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  byteSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isBinary?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isTruncated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BotResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Bot'] = ResolversParentTypes['Bot']> = ResolversObject<{
  avatarUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType, Partial<BotavatarUrlArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BranchActorAllowanceActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BranchActorAllowanceActor'] = ResolversParentTypes['BranchActorAllowanceActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'App' | 'Team' | 'User', ParentType, ContextType>;
}>;

export type BranchNamePatternParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BranchNamePatternParameters'] = ResolversParentTypes['BranchNamePatternParameters']> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BranchProtectionRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BranchProtectionRule'] = ResolversParentTypes['BranchProtectionRule']> = ResolversObject<{
  allowsDeletions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  allowsForcePushes?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  blocksCreations?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  branchProtectionRuleConflicts?: Resolver<ResolversTypes['BranchProtectionRuleConflictConnection'], ParentType, ContextType, Partial<BranchProtectionRulebranchProtectionRuleConflictsArgs>>;
  bypassForcePushAllowances?: Resolver<ResolversTypes['BypassForcePushAllowanceConnection'], ParentType, ContextType, Partial<BranchProtectionRulebypassForcePushAllowancesArgs>>;
  bypassPullRequestAllowances?: Resolver<ResolversTypes['BypassPullRequestAllowanceConnection'], ParentType, ContextType, Partial<BranchProtectionRulebypassPullRequestAllowancesArgs>>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  dismissesStaleReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isAdminEnforced?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lockAllowsFetchAndMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lockBranch?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  matchingRefs?: Resolver<ResolversTypes['RefConnection'], ParentType, ContextType, Partial<BranchProtectionRulematchingRefsArgs>>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pushAllowances?: Resolver<ResolversTypes['PushAllowanceConnection'], ParentType, ContextType, Partial<BranchProtectionRulepushAllowancesArgs>>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  requireLastPushApproval?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiredApprovingReviewCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  requiredDeploymentEnvironments?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  requiredStatusCheckContexts?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  requiredStatusChecks?: Resolver<Maybe<Array<ResolversTypes['RequiredStatusCheckDescription']>>, ParentType, ContextType>;
  requiresApprovingReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresCodeOwnerReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresCommitSignatures?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresConversationResolution?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresDeployments?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresLinearHistory?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresStatusChecks?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresStrictStatusChecks?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  restrictsPushes?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  restrictsReviewDismissals?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  reviewDismissalAllowances?: Resolver<ResolversTypes['ReviewDismissalAllowanceConnection'], ParentType, ContextType, Partial<BranchProtectionRulereviewDismissalAllowancesArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BranchProtectionRuleConflictResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BranchProtectionRuleConflict'] = ResolversParentTypes['BranchProtectionRuleConflict']> = ResolversObject<{
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  conflictingBranchProtectionRule?: Resolver<Maybe<ResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BranchProtectionRuleConflictConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BranchProtectionRuleConflictConnection'] = ResolversParentTypes['BranchProtectionRuleConflictConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['BranchProtectionRuleConflictEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['BranchProtectionRuleConflict']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BranchProtectionRuleConflictEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BranchProtectionRuleConflictEdge'] = ResolversParentTypes['BranchProtectionRuleConflictEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['BranchProtectionRuleConflict']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BranchProtectionRuleConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BranchProtectionRuleConnection'] = ResolversParentTypes['BranchProtectionRuleConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['BranchProtectionRuleEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['BranchProtectionRule']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BranchProtectionRuleEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BranchProtectionRuleEdge'] = ResolversParentTypes['BranchProtectionRuleEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BypassActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BypassActor'] = ResolversParentTypes['BypassActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'App' | 'Team', ParentType, ContextType>;
}>;

export type BypassForcePushAllowanceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BypassForcePushAllowance'] = ResolversParentTypes['BypassForcePushAllowance']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['BranchActorAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BypassForcePushAllowanceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BypassForcePushAllowanceConnection'] = ResolversParentTypes['BypassForcePushAllowanceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['BypassForcePushAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['BypassForcePushAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BypassForcePushAllowanceEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BypassForcePushAllowanceEdge'] = ResolversParentTypes['BypassForcePushAllowanceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['BypassForcePushAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BypassPullRequestAllowanceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BypassPullRequestAllowance'] = ResolversParentTypes['BypassPullRequestAllowance']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['BranchActorAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BypassPullRequestAllowanceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BypassPullRequestAllowanceConnection'] = ResolversParentTypes['BypassPullRequestAllowanceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['BypassPullRequestAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['BypassPullRequestAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BypassPullRequestAllowanceEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BypassPullRequestAllowanceEdge'] = ResolversParentTypes['BypassPullRequestAllowanceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['BypassPullRequestAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CVSSResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CVSS'] = ResolversParentTypes['CVSS']> = ResolversObject<{
  score?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  vectorString?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CWEResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CWE'] = ResolversParentTypes['CWE']> = ResolversObject<{
  cweId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CWEConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CWEConnection'] = ResolversParentTypes['CWEConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CWEEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['CWE']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CWEEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CWEEdge'] = ResolversParentTypes['CWEEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CWE']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CancelEnterpriseAdminInvitationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CancelEnterpriseAdminInvitationPayload'] = ResolversParentTypes['CancelEnterpriseAdminInvitationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<ResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CancelSponsorshipPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CancelSponsorshipPayload'] = ResolversParentTypes['CancelSponsorshipPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChangeUserStatusPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChangeUserStatusPayload'] = ResolversParentTypes['ChangeUserStatusPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['UserStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckAnnotationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckAnnotation'] = ResolversParentTypes['CheckAnnotation']> = ResolversObject<{
  annotationLevel?: Resolver<Maybe<ResolversTypes['CheckAnnotationLevel']>, ParentType, ContextType>;
  blobUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  location?: Resolver<ResolversTypes['CheckAnnotationSpan'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  rawDetails?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckAnnotationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckAnnotationConnection'] = ResolversParentTypes['CheckAnnotationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CheckAnnotationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['CheckAnnotation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckAnnotationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckAnnotationEdge'] = ResolversParentTypes['CheckAnnotationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CheckAnnotation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckAnnotationPositionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckAnnotationPosition'] = ResolversParentTypes['CheckAnnotationPosition']> = ResolversObject<{
  column?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  line?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckAnnotationSpanResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckAnnotationSpan'] = ResolversParentTypes['CheckAnnotationSpan']> = ResolversObject<{
  end?: Resolver<ResolversTypes['CheckAnnotationPosition'], ParentType, ContextType>;
  start?: Resolver<ResolversTypes['CheckAnnotationPosition'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckRunResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckRun'] = ResolversParentTypes['CheckRun']> = ResolversObject<{
  annotations?: Resolver<Maybe<ResolversTypes['CheckAnnotationConnection']>, ParentType, ContextType, Partial<CheckRunannotationsArgs>>;
  checkSuite?: Resolver<ResolversTypes['CheckSuite'], ParentType, ContextType>;
  completedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  conclusion?: Resolver<Maybe<ResolversTypes['CheckConclusionState']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deployment?: Resolver<Maybe<ResolversTypes['Deployment']>, ParentType, ContextType>;
  detailsUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<CheckRunisRequiredArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingDeploymentRequest?: Resolver<Maybe<ResolversTypes['DeploymentRequest']>, ParentType, ContextType>;
  permalink?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  startedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['CheckStatusState'], ParentType, ContextType>;
  steps?: Resolver<Maybe<ResolversTypes['CheckStepConnection']>, ParentType, ContextType, Partial<CheckRunstepsArgs>>;
  summary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckRunConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckRunConnection'] = ResolversParentTypes['CheckRunConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CheckRunEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['CheckRun']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckRunEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckRunEdge'] = ResolversParentTypes['CheckRunEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CheckRun']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckRunStateCountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckRunStateCount'] = ResolversParentTypes['CheckRunStateCount']> = ResolversObject<{
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['CheckRunState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckStepResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckStep'] = ResolversParentTypes['CheckStep']> = ResolversObject<{
  completedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  conclusion?: Resolver<Maybe<ResolversTypes['CheckConclusionState']>, ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  secondsToCompletion?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  startedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['CheckStatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckStepConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckStepConnection'] = ResolversParentTypes['CheckStepConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CheckStepEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['CheckStep']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckStepEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckStepEdge'] = ResolversParentTypes['CheckStepEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CheckStep']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckSuiteResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckSuite'] = ResolversParentTypes['CheckSuite']> = ResolversObject<{
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  branch?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  checkRuns?: Resolver<Maybe<ResolversTypes['CheckRunConnection']>, ParentType, ContextType, Partial<CheckSuitecheckRunsArgs>>;
  commit?: Resolver<ResolversTypes['Commit'], ParentType, ContextType>;
  conclusion?: Resolver<Maybe<ResolversTypes['CheckConclusionState']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  matchingPullRequests?: Resolver<Maybe<ResolversTypes['PullRequestConnection']>, ParentType, ContextType, Partial<CheckSuitematchingPullRequestsArgs>>;
  push?: Resolver<Maybe<ResolversTypes['Push']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['CheckStatusState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  workflowRun?: Resolver<Maybe<ResolversTypes['WorkflowRun']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckSuiteConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckSuiteConnection'] = ResolversParentTypes['CheckSuiteConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CheckSuiteEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['CheckSuite']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CheckSuiteEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CheckSuiteEdge'] = ResolversParentTypes['CheckSuiteEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CheckSuite']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ClaimableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Claimable'] = ResolversParentTypes['Claimable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Mannequin' | 'User', ParentType, ContextType>;
}>;

export type ClearLabelsFromLabelablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ClearLabelsFromLabelablePayload'] = ResolversParentTypes['ClearLabelsFromLabelablePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labelable?: Resolver<Maybe<ResolversTypes['Labelable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ClearProjectV2ItemFieldValuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ClearProjectV2ItemFieldValuePayload'] = ResolversParentTypes['ClearProjectV2ItemFieldValuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2Item?: Resolver<Maybe<ResolversTypes['ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CloneProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CloneProjectPayload'] = ResolversParentTypes['CloneProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  jobStatusId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CloneTemplateRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CloneTemplateRepositoryPayload'] = ResolversParentTypes['CloneTemplateRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ClosableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Closable'] = ResolversParentTypes['Closable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Discussion' | 'Issue' | 'Milestone' | 'Project' | 'ProjectV2' | 'PullRequest', ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type CloseDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CloseDiscussionPayload'] = ResolversParentTypes['CloseDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CloseIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CloseIssuePayload'] = ResolversParentTypes['CloseIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ClosePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ClosePullRequestPayload'] = ResolversParentTypes['ClosePullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ClosedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ClosedEvent'] = ResolversParentTypes['ClosedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  closable?: Resolver<ResolversTypes['Closable'], ParentType, ContextType>;
  closer?: Resolver<Maybe<ResolversTypes['Closer']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  stateReason?: Resolver<Maybe<ResolversTypes['IssueStateReason']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CloserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Closer'] = ResolversParentTypes['Closer']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Commit' | 'PullRequest', ParentType, ContextType>;
}>;

export type CodeOfConductResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CodeOfConduct'] = ResolversParentTypes['CodeOfConduct']> = ResolversObject<{
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Comment'] = ResolversParentTypes['Comment']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CommitComment' | 'Discussion' | 'DiscussionComment' | 'GistComment' | 'Issue' | 'IssueComment' | 'PullRequest' | 'PullRequestReview' | 'PullRequestReviewComment' | 'TeamDiscussion' | 'TeamDiscussionComment', ParentType, ContextType>;
  author?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['UserContentEditConnection']>, ParentType, ContextType, Partial<CommentuserContentEditsArgs>>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type CommentDeletedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommentDeletedEvent'] = ResolversParentTypes['CommentDeletedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deletedCommentAuthor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommitResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Commit'] = ResolversParentTypes['Commit']> = ResolversObject<{
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  additions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  associatedPullRequests?: Resolver<Maybe<ResolversTypes['PullRequestConnection']>, ParentType, ContextType, RequireFields<CommitassociatedPullRequestsArgs, 'orderBy'>>;
  author?: Resolver<Maybe<ResolversTypes['GitActor']>, ParentType, ContextType>;
  authoredByCommitter?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  authoredDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  authors?: Resolver<ResolversTypes['GitActorConnection'], ParentType, ContextType, Partial<CommitauthorsArgs>>;
  blame?: Resolver<ResolversTypes['Blame'], ParentType, ContextType, RequireFields<CommitblameArgs, 'path'>>;
  changedFiles?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  changedFilesIfAvailable?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  checkSuites?: Resolver<Maybe<ResolversTypes['CheckSuiteConnection']>, ParentType, ContextType, Partial<CommitcheckSuitesArgs>>;
  comments?: Resolver<ResolversTypes['CommitCommentConnection'], ParentType, ContextType, Partial<CommitcommentsArgs>>;
  commitResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  committedDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  committedViaWeb?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  committer?: Resolver<Maybe<ResolversTypes['GitActor']>, ParentType, ContextType>;
  deletions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  deployments?: Resolver<Maybe<ResolversTypes['DeploymentConnection']>, ParentType, ContextType, RequireFields<CommitdeploymentsArgs, 'orderBy'>>;
  file?: Resolver<Maybe<ResolversTypes['TreeEntry']>, ParentType, ContextType, RequireFields<CommitfileArgs, 'path'>>;
  history?: Resolver<ResolversTypes['CommitHistoryConnection'], ParentType, ContextType, Partial<CommithistoryArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  messageBody?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  messageBodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  messageHeadline?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  messageHeadlineHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['GitObjectID'], ParentType, ContextType>;
  onBehalfOf?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  parents?: Resolver<ResolversTypes['CommitConnection'], ParentType, ContextType, Partial<CommitparentsArgs>>;
  pushedDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  signature?: Resolver<Maybe<ResolversTypes['GitSignature']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  statusCheckRollup?: Resolver<Maybe<ResolversTypes['StatusCheckRollup']>, ParentType, ContextType>;
  submodules?: Resolver<ResolversTypes['SubmoduleConnection'], ParentType, ContextType, Partial<CommitsubmodulesArgs>>;
  tarballUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  tree?: Resolver<ResolversTypes['Tree'], ParentType, ContextType>;
  treeResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  treeUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['SubscriptionState']>, ParentType, ContextType>;
  zipballUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommitAuthorEmailPatternParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitAuthorEmailPatternParameters'] = ResolversParentTypes['CommitAuthorEmailPatternParameters']> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommitCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitComment'] = ResolversParentTypes['CommitComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['ReactionConnection'], ParentType, ContextType, Partial<CommitCommentreactionsArgs>>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['UserContentEditConnection']>, ParentType, ContextType, Partial<CommitCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommitCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitCommentConnection'] = ResolversParentTypes['CommitCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CommitCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['CommitComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommitCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitCommentEdge'] = ResolversParentTypes['CommitCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CommitComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommitCommentThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitCommentThread'] = ResolversParentTypes['CommitCommentThread']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['CommitCommentConnection'], ParentType, ContextType, Partial<CommitCommentThreadcommentsArgs>>;
  commit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommitConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitConnection'] = ResolversParentTypes['CommitConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Commit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommitContributionsByRepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitContributionsByRepository'] = ResolversParentTypes['CommitContributionsByRepository']> = ResolversObject<{
  contributions?: Resolver<ResolversTypes['CreatedCommitContributionConnection'], ParentType, ContextType, RequireFields<CommitContributionsByRepositorycontributionsArgs, 'orderBy'>>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommitEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitEdge'] = ResolversParentTypes['CommitEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommitHistoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitHistoryConnection'] = ResolversParentTypes['CommitHistoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Commit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommitMessagePatternParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitMessagePatternParameters'] = ResolversParentTypes['CommitMessagePatternParameters']> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommitterEmailPatternParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitterEmailPatternParameters'] = ResolversParentTypes['CommitterEmailPatternParameters']> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ComparisonResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Comparison'] = ResolversParentTypes['Comparison']> = ResolversObject<{
  aheadBy?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  baseTarget?: Resolver<ResolversTypes['GitObject'], ParentType, ContextType>;
  behindBy?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  commits?: Resolver<ResolversTypes['ComparisonCommitConnection'], ParentType, ContextType, Partial<ComparisoncommitsArgs>>;
  headTarget?: Resolver<ResolversTypes['GitObject'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['ComparisonStatus'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ComparisonCommitConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ComparisonCommitConnection'] = ResolversParentTypes['ComparisonCommitConnection']> = ResolversObject<{
  authorCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Commit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConnectedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ConnectedEvent'] = ResolversParentTypes['ConnectedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContributingGuidelinesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ContributingGuidelines'] = ResolversParentTypes['ContributingGuidelines']> = ResolversObject<{
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  resourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Contribution'] = ResolversParentTypes['Contribution']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CreatedCommitContribution' | 'CreatedIssueContribution' | 'CreatedPullRequestContribution' | 'CreatedPullRequestReviewContribution' | 'CreatedRepositoryContribution' | 'JoinedGitHubContribution' | 'RestrictedContribution', ParentType, ContextType>;
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
}>;

export type ContributionCalendarResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ContributionCalendar'] = ResolversParentTypes['ContributionCalendar']> = ResolversObject<{
  colors?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  isHalloween?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  months?: Resolver<Array<ResolversTypes['ContributionCalendarMonth']>, ParentType, ContextType>;
  totalContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  weeks?: Resolver<Array<ResolversTypes['ContributionCalendarWeek']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContributionCalendarDayResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ContributionCalendarDay'] = ResolversParentTypes['ContributionCalendarDay']> = ResolversObject<{
  color?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  contributionCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  contributionLevel?: Resolver<ResolversTypes['ContributionLevel'], ParentType, ContextType>;
  date?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  weekday?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContributionCalendarMonthResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ContributionCalendarMonth'] = ResolversParentTypes['ContributionCalendarMonth']> = ResolversObject<{
  firstDay?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalWeeks?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  year?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContributionCalendarWeekResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ContributionCalendarWeek'] = ResolversParentTypes['ContributionCalendarWeek']> = ResolversObject<{
  contributionDays?: Resolver<Array<ResolversTypes['ContributionCalendarDay']>, ParentType, ContextType>;
  firstDay?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContributionsCollectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ContributionsCollection'] = ResolversParentTypes['ContributionsCollection']> = ResolversObject<{
  commitContributionsByRepository?: Resolver<Array<ResolversTypes['CommitContributionsByRepository']>, ParentType, ContextType, RequireFields<ContributionsCollectioncommitContributionsByRepositoryArgs, 'maxRepositories'>>;
  contributionCalendar?: Resolver<ResolversTypes['ContributionCalendar'], ParentType, ContextType>;
  contributionYears?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
  doesEndInCurrentMonth?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  earliestRestrictedContributionDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  endedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  firstIssueContribution?: Resolver<Maybe<ResolversTypes['CreatedIssueOrRestrictedContribution']>, ParentType, ContextType>;
  firstPullRequestContribution?: Resolver<Maybe<ResolversTypes['CreatedPullRequestOrRestrictedContribution']>, ParentType, ContextType>;
  firstRepositoryContribution?: Resolver<Maybe<ResolversTypes['CreatedRepositoryOrRestrictedContribution']>, ParentType, ContextType>;
  hasActivityInThePast?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasAnyContributions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasAnyRestrictedContributions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSingleDay?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issueContributions?: Resolver<ResolversTypes['CreatedIssueContributionConnection'], ParentType, ContextType, RequireFields<ContributionsCollectionissueContributionsArgs, 'excludeFirst' | 'excludePopular' | 'orderBy'>>;
  issueContributionsByRepository?: Resolver<Array<ResolversTypes['IssueContributionsByRepository']>, ParentType, ContextType, RequireFields<ContributionsCollectionissueContributionsByRepositoryArgs, 'excludeFirst' | 'excludePopular' | 'maxRepositories'>>;
  joinedGitHubContribution?: Resolver<Maybe<ResolversTypes['JoinedGitHubContribution']>, ParentType, ContextType>;
  latestRestrictedContributionDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  mostRecentCollectionWithActivity?: Resolver<Maybe<ResolversTypes['ContributionsCollection']>, ParentType, ContextType>;
  mostRecentCollectionWithoutActivity?: Resolver<Maybe<ResolversTypes['ContributionsCollection']>, ParentType, ContextType>;
  popularIssueContribution?: Resolver<Maybe<ResolversTypes['CreatedIssueContribution']>, ParentType, ContextType>;
  popularPullRequestContribution?: Resolver<Maybe<ResolversTypes['CreatedPullRequestContribution']>, ParentType, ContextType>;
  pullRequestContributions?: Resolver<ResolversTypes['CreatedPullRequestContributionConnection'], ParentType, ContextType, RequireFields<ContributionsCollectionpullRequestContributionsArgs, 'excludeFirst' | 'excludePopular' | 'orderBy'>>;
  pullRequestContributionsByRepository?: Resolver<Array<ResolversTypes['PullRequestContributionsByRepository']>, ParentType, ContextType, RequireFields<ContributionsCollectionpullRequestContributionsByRepositoryArgs, 'excludeFirst' | 'excludePopular' | 'maxRepositories'>>;
  pullRequestReviewContributions?: Resolver<ResolversTypes['CreatedPullRequestReviewContributionConnection'], ParentType, ContextType, RequireFields<ContributionsCollectionpullRequestReviewContributionsArgs, 'orderBy'>>;
  pullRequestReviewContributionsByRepository?: Resolver<Array<ResolversTypes['PullRequestReviewContributionsByRepository']>, ParentType, ContextType, RequireFields<ContributionsCollectionpullRequestReviewContributionsByRepositoryArgs, 'maxRepositories'>>;
  repositoryContributions?: Resolver<ResolversTypes['CreatedRepositoryContributionConnection'], ParentType, ContextType, RequireFields<ContributionsCollectionrepositoryContributionsArgs, 'excludeFirst' | 'orderBy'>>;
  restrictedContributionsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  startedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  totalCommitContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalIssueContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<ContributionsCollectiontotalIssueContributionsArgs, 'excludeFirst' | 'excludePopular'>>;
  totalPullRequestContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<ContributionsCollectiontotalPullRequestContributionsArgs, 'excludeFirst' | 'excludePopular'>>;
  totalPullRequestReviewContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRepositoriesWithContributedCommits?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRepositoriesWithContributedIssues?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<ContributionsCollectiontotalRepositoriesWithContributedIssuesArgs, 'excludeFirst' | 'excludePopular'>>;
  totalRepositoriesWithContributedPullRequestReviews?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRepositoriesWithContributedPullRequests?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<ContributionsCollectiontotalRepositoriesWithContributedPullRequestsArgs, 'excludeFirst' | 'excludePopular'>>;
  totalRepositoryContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<ContributionsCollectiontotalRepositoryContributionsArgs, 'excludeFirst'>>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConvertProjectCardNoteToIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ConvertProjectCardNoteToIssuePayload'] = ResolversParentTypes['ConvertProjectCardNoteToIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['ProjectCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConvertPullRequestToDraftPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ConvertPullRequestToDraftPayload'] = ResolversParentTypes['ConvertPullRequestToDraftPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConvertToDraftEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ConvertToDraftEvent'] = ResolversParentTypes['ConvertToDraftEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConvertedNoteToIssueEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ConvertedNoteToIssueEvent'] = ResolversParentTypes['ConvertedNoteToIssueEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['ProjectCard']>, ParentType, ContextType>;
  projectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConvertedToDiscussionEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ConvertedToDiscussionEvent'] = ResolversParentTypes['ConvertedToDiscussionEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Discussion']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CopyProjectV2PayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CopyProjectV2Payload'] = ResolversParentTypes['CopyProjectV2Payload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateAttributionInvitationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateAttributionInvitationPayload'] = ResolversParentTypes['CreateAttributionInvitationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  source?: Resolver<Maybe<ResolversTypes['Claimable']>, ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['Claimable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateBranchProtectionRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateBranchProtectionRulePayload'] = ResolversParentTypes['CreateBranchProtectionRulePayload']> = ResolversObject<{
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCheckRunPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCheckRunPayload'] = ResolversParentTypes['CreateCheckRunPayload']> = ResolversObject<{
  checkRun?: Resolver<Maybe<ResolversTypes['CheckRun']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCheckSuitePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCheckSuitePayload'] = ResolversParentTypes['CreateCheckSuitePayload']> = ResolversObject<{
  checkSuite?: Resolver<Maybe<ResolversTypes['CheckSuite']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCommitOnBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCommitOnBranchPayload'] = ResolversParentTypes['CreateCommitOnBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateDeploymentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateDeploymentPayload'] = ResolversParentTypes['CreateDeploymentPayload']> = ResolversObject<{
  autoMerged?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deployment?: Resolver<Maybe<ResolversTypes['Deployment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateDeploymentStatusPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateDeploymentStatusPayload'] = ResolversParentTypes['CreateDeploymentStatusPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deploymentStatus?: Resolver<Maybe<ResolversTypes['DeploymentStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateDiscussionPayload'] = ResolversParentTypes['CreateDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateEnterpriseOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateEnterpriseOrganizationPayload'] = ResolversParentTypes['CreateEnterpriseOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateEnvironmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateEnvironmentPayload'] = ResolversParentTypes['CreateEnvironmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['Environment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateIpAllowListEntryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateIpAllowListEntryPayload'] = ResolversParentTypes['CreateIpAllowListEntryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ipAllowListEntry?: Resolver<Maybe<ResolversTypes['IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateIssuePayload'] = ResolversParentTypes['CreateIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateLabelPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateLabelPayload'] = ResolversParentTypes['CreateLabelPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateLinkedBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateLinkedBranchPayload'] = ResolversParentTypes['CreateLinkedBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Issue']>, ParentType, ContextType>;
  linkedBranch?: Resolver<Maybe<ResolversTypes['LinkedBranch']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateMigrationSourcePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateMigrationSourcePayload'] = ResolversParentTypes['CreateMigrationSourcePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  migrationSource?: Resolver<Maybe<ResolversTypes['MigrationSource']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateProjectPayload'] = ResolversParentTypes['CreateProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateProjectV2FieldPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateProjectV2FieldPayload'] = ResolversParentTypes['CreateProjectV2FieldPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2Field?: Resolver<Maybe<ResolversTypes['ProjectV2FieldConfiguration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateProjectV2PayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateProjectV2Payload'] = ResolversParentTypes['CreateProjectV2Payload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatePullRequestPayload'] = ResolversParentTypes['CreatePullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateRefPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateRefPayload'] = ResolversParentTypes['CreateRefPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateRepositoryPayload'] = ResolversParentTypes['CreateRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateRepositoryRulesetPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateRepositoryRulesetPayload'] = ResolversParentTypes['CreateRepositoryRulesetPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ruleset?: Resolver<Maybe<ResolversTypes['RepositoryRuleset']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateSponsorsListingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateSponsorsListingPayload'] = ResolversParentTypes['CreateSponsorsListingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['SponsorsListing']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateSponsorsTierPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateSponsorsTierPayload'] = ResolversParentTypes['CreateSponsorsTierPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateSponsorshipPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateSponsorshipPayload'] = ResolversParentTypes['CreateSponsorshipPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorship?: Resolver<Maybe<ResolversTypes['Sponsorship']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateSponsorshipsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateSponsorshipsPayload'] = ResolversParentTypes['CreateSponsorshipsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorables?: Resolver<Maybe<Array<ResolversTypes['Sponsorable']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateTeamDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateTeamDiscussionCommentPayload'] = ResolversParentTypes['CreateTeamDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussionComment?: Resolver<Maybe<ResolversTypes['TeamDiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateTeamDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateTeamDiscussionPayload'] = ResolversParentTypes['CreateTeamDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussion?: Resolver<Maybe<ResolversTypes['TeamDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateUserListPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateUserListPayload'] = ResolversParentTypes['CreateUserListPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  list?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedCommitContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedCommitContribution'] = ResolversParentTypes['CreatedCommitContribution']> = ResolversObject<{
  commitCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedCommitContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedCommitContributionConnection'] = ResolversParentTypes['CreatedCommitContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CreatedCommitContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['CreatedCommitContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedCommitContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedCommitContributionEdge'] = ResolversParentTypes['CreatedCommitContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CreatedCommitContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedIssueContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedIssueContribution'] = ResolversParentTypes['CreatedIssueContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['Issue'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedIssueContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedIssueContributionConnection'] = ResolversParentTypes['CreatedIssueContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CreatedIssueContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['CreatedIssueContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedIssueContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedIssueContributionEdge'] = ResolversParentTypes['CreatedIssueContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CreatedIssueContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedIssueOrRestrictedContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedIssueOrRestrictedContribution'] = ResolversParentTypes['CreatedIssueOrRestrictedContribution']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CreatedIssueContribution' | 'RestrictedContribution', ParentType, ContextType>;
}>;

export type CreatedPullRequestContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedPullRequestContribution'] = ResolversParentTypes['CreatedPullRequestContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedPullRequestContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedPullRequestContributionConnection'] = ResolversParentTypes['CreatedPullRequestContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CreatedPullRequestContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['CreatedPullRequestContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedPullRequestContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedPullRequestContributionEdge'] = ResolversParentTypes['CreatedPullRequestContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CreatedPullRequestContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedPullRequestOrRestrictedContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedPullRequestOrRestrictedContribution'] = ResolversParentTypes['CreatedPullRequestOrRestrictedContribution']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CreatedPullRequestContribution' | 'RestrictedContribution', ParentType, ContextType>;
}>;

export type CreatedPullRequestReviewContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedPullRequestReviewContribution'] = ResolversParentTypes['CreatedPullRequestReviewContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  pullRequestReview?: Resolver<ResolversTypes['PullRequestReview'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedPullRequestReviewContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedPullRequestReviewContributionConnection'] = ResolversParentTypes['CreatedPullRequestReviewContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CreatedPullRequestReviewContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['CreatedPullRequestReviewContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedPullRequestReviewContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedPullRequestReviewContributionEdge'] = ResolversParentTypes['CreatedPullRequestReviewContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CreatedPullRequestReviewContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedRepositoryContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedRepositoryContribution'] = ResolversParentTypes['CreatedRepositoryContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedRepositoryContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedRepositoryContributionConnection'] = ResolversParentTypes['CreatedRepositoryContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CreatedRepositoryContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['CreatedRepositoryContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedRepositoryContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedRepositoryContributionEdge'] = ResolversParentTypes['CreatedRepositoryContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CreatedRepositoryContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatedRepositoryOrRestrictedContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatedRepositoryOrRestrictedContribution'] = ResolversParentTypes['CreatedRepositoryOrRestrictedContribution']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CreatedRepositoryContribution' | 'RestrictedContribution', ParentType, ContextType>;
}>;

export type CrossReferencedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CrossReferencedEvent'] = ResolversParentTypes['CrossReferencedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  referencedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  target?: Resolver<ResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  willCloseTarget?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
  name: 'Date';
}

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
  name: 'DateTime';
}

export type DeclineTopicSuggestionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeclineTopicSuggestionPayload'] = ResolversParentTypes['DeclineTopicSuggestionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['Topic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeletableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Deletable'] = ResolversParentTypes['Deletable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CommitComment' | 'Discussion' | 'DiscussionComment' | 'GistComment' | 'Issue' | 'IssueComment' | 'PullRequestReview' | 'PullRequestReviewComment' | 'TeamDiscussion' | 'TeamDiscussionComment', ParentType, ContextType>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type DeleteBranchProtectionRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteBranchProtectionRulePayload'] = ResolversParentTypes['DeleteBranchProtectionRulePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteDeploymentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteDeploymentPayload'] = ResolversParentTypes['DeleteDeploymentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteDiscussionCommentPayload'] = ResolversParentTypes['DeleteDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['DiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteDiscussionPayload'] = ResolversParentTypes['DeleteDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteEnvironmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteEnvironmentPayload'] = ResolversParentTypes['DeleteEnvironmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteIpAllowListEntryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteIpAllowListEntryPayload'] = ResolversParentTypes['DeleteIpAllowListEntryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ipAllowListEntry?: Resolver<Maybe<ResolversTypes['IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteIssueCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteIssueCommentPayload'] = ResolversParentTypes['DeleteIssueCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteIssuePayload'] = ResolversParentTypes['DeleteIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteLabelPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteLabelPayload'] = ResolversParentTypes['DeleteLabelPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteLinkedBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteLinkedBranchPayload'] = ResolversParentTypes['DeleteLinkedBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeletePackageVersionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeletePackageVersionPayload'] = ResolversParentTypes['DeletePackageVersionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteProjectCardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteProjectCardPayload'] = ResolversParentTypes['DeleteProjectCardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  column?: Resolver<Maybe<ResolversTypes['ProjectColumn']>, ParentType, ContextType>;
  deletedCardId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteProjectColumnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteProjectColumnPayload'] = ResolversParentTypes['DeleteProjectColumnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedColumnId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteProjectPayload'] = ResolversParentTypes['DeleteProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['ProjectOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteProjectV2FieldPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteProjectV2FieldPayload'] = ResolversParentTypes['DeleteProjectV2FieldPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2Field?: Resolver<Maybe<ResolversTypes['ProjectV2FieldConfiguration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteProjectV2ItemPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteProjectV2ItemPayload'] = ResolversParentTypes['DeleteProjectV2ItemPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedItemId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteProjectV2PayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteProjectV2Payload'] = ResolversParentTypes['DeleteProjectV2Payload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteProjectV2WorkflowPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteProjectV2WorkflowPayload'] = ResolversParentTypes['DeleteProjectV2WorkflowPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedWorkflowId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeletePullRequestReviewCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeletePullRequestReviewCommentPayload'] = ResolversParentTypes['DeletePullRequestReviewCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  pullRequestReviewComment?: Resolver<Maybe<ResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeletePullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeletePullRequestReviewPayload'] = ResolversParentTypes['DeletePullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteRefPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteRefPayload'] = ResolversParentTypes['DeleteRefPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteRepositoryRulesetPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteRepositoryRulesetPayload'] = ResolversParentTypes['DeleteRepositoryRulesetPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteTeamDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteTeamDiscussionCommentPayload'] = ResolversParentTypes['DeleteTeamDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteTeamDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteTeamDiscussionPayload'] = ResolversParentTypes['DeleteTeamDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteUserListPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteUserListPayload'] = ResolversParentTypes['DeleteUserListPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteVerifiableDomainPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteVerifiableDomainPayload'] = ResolversParentTypes['DeleteVerifiableDomainPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['VerifiableDomainOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DemilestonedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DemilestonedEvent'] = ResolversParentTypes['DemilestonedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  milestoneTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['MilestoneItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DependabotUpdateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DependabotUpdate'] = ResolversParentTypes['DependabotUpdate']> = ResolversObject<{
  error?: Resolver<Maybe<ResolversTypes['DependabotUpdateError']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DependabotUpdateErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DependabotUpdateError'] = ResolversParentTypes['DependabotUpdateError']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  errorType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DependencyGraphDependencyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DependencyGraphDependency'] = ResolversParentTypes['DependencyGraphDependency']> = ResolversObject<{
  hasDependencies?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  packageLabel?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  packageManager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  packageName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  requirements?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DependencyGraphDependencyConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DependencyGraphDependencyConnection'] = ResolversParentTypes['DependencyGraphDependencyConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DependencyGraphDependencyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['DependencyGraphDependency']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DependencyGraphDependencyEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DependencyGraphDependencyEdge'] = ResolversParentTypes['DependencyGraphDependencyEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DependencyGraphDependency']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DependencyGraphManifestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DependencyGraphManifest'] = ResolversParentTypes['DependencyGraphManifest']> = ResolversObject<{
  blobPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  dependencies?: Resolver<Maybe<ResolversTypes['DependencyGraphDependencyConnection']>, ParentType, ContextType, Partial<DependencyGraphManifestdependenciesArgs>>;
  dependenciesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  exceedsMaxSize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  filename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parseable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DependencyGraphManifestConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DependencyGraphManifestConnection'] = ResolversParentTypes['DependencyGraphManifestConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DependencyGraphManifestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['DependencyGraphManifest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DependencyGraphManifestEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DependencyGraphManifestEdge'] = ResolversParentTypes['DependencyGraphManifestEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DependencyGraphManifest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeployKeyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeployKey'] = ResolversParentTypes['DeployKey']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  readOnly?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeployKeyConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeployKeyConnection'] = ResolversParentTypes['DeployKeyConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeployKeyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeployKey']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeployKeyEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeployKeyEdge'] = ResolversParentTypes['DeployKeyEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DeployKey']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeployedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeployedEvent'] = ResolversParentTypes['DeployedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deployment?: Resolver<ResolversTypes['Deployment'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Deployment'] = ResolversParentTypes['Deployment']> = ResolversObject<{
  commit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  commitOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<ResolversTypes['Actor'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  latestEnvironment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latestStatus?: Resolver<Maybe<ResolversTypes['DeploymentStatus']>, ParentType, ContextType>;
  originalEnvironment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  payload?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['DeploymentState']>, ParentType, ContextType>;
  statuses?: Resolver<Maybe<ResolversTypes['DeploymentStatusConnection']>, ParentType, ContextType, Partial<DeploymentstatusesArgs>>;
  task?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentConnection'] = ResolversParentTypes['DeploymentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeploymentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Deployment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentEdge'] = ResolversParentTypes['DeploymentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Deployment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentEnvironmentChangedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentEnvironmentChangedEvent'] = ResolversParentTypes['DeploymentEnvironmentChangedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  deploymentStatus?: Resolver<ResolversTypes['DeploymentStatus'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentProtectionRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentProtectionRule'] = ResolversParentTypes['DeploymentProtectionRule']> = ResolversObject<{
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  preventSelfReview?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  reviewers?: Resolver<ResolversTypes['DeploymentReviewerConnection'], ParentType, ContextType, Partial<DeploymentProtectionRulereviewersArgs>>;
  timeout?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['DeploymentProtectionRuleType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentProtectionRuleConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentProtectionRuleConnection'] = ResolversParentTypes['DeploymentProtectionRuleConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeploymentProtectionRuleEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeploymentProtectionRule']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentProtectionRuleEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentProtectionRuleEdge'] = ResolversParentTypes['DeploymentProtectionRuleEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DeploymentProtectionRule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentRequest'] = ResolversParentTypes['DeploymentRequest']> = ResolversObject<{
  currentUserCanApprove?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  environment?: Resolver<ResolversTypes['Environment'], ParentType, ContextType>;
  reviewers?: Resolver<ResolversTypes['DeploymentReviewerConnection'], ParentType, ContextType, Partial<DeploymentRequestreviewersArgs>>;
  waitTimer?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  waitTimerStartedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentRequestConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentRequestConnection'] = ResolversParentTypes['DeploymentRequestConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeploymentRequestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeploymentRequest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentRequestEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentRequestEdge'] = ResolversParentTypes['DeploymentRequestEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DeploymentRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentReviewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentReview'] = ResolversParentTypes['DeploymentReview']> = ResolversObject<{
  comment?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  environments?: Resolver<ResolversTypes['EnvironmentConnection'], ParentType, ContextType, Partial<DeploymentReviewenvironmentsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['DeploymentReviewState'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentReviewConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentReviewConnection'] = ResolversParentTypes['DeploymentReviewConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeploymentReviewEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeploymentReview']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentReviewEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentReviewEdge'] = ResolversParentTypes['DeploymentReviewEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DeploymentReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentReviewerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentReviewer'] = ResolversParentTypes['DeploymentReviewer']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Team' | 'User', ParentType, ContextType>;
}>;

export type DeploymentReviewerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentReviewerConnection'] = ResolversParentTypes['DeploymentReviewerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeploymentReviewerEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeploymentReviewer']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentReviewerEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentReviewerEdge'] = ResolversParentTypes['DeploymentReviewerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DeploymentReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentStatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentStatus'] = ResolversParentTypes['DeploymentStatus']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<ResolversTypes['Actor'], ParentType, ContextType>;
  deployment?: Resolver<ResolversTypes['Deployment'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environmentUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  logUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['DeploymentStatusState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentStatusConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentStatusConnection'] = ResolversParentTypes['DeploymentStatusConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeploymentStatusEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeploymentStatus']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeploymentStatusEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeploymentStatusEdge'] = ResolversParentTypes['DeploymentStatusEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DeploymentStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DequeuePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DequeuePullRequestPayload'] = ResolversParentTypes['DequeuePullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mergeQueueEntry?: Resolver<Maybe<ResolversTypes['MergeQueueEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DisablePullRequestAutoMergePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DisablePullRequestAutoMergePayload'] = ResolversParentTypes['DisablePullRequestAutoMergePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DisconnectedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DisconnectedEvent'] = ResolversParentTypes['DisconnectedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DiscussionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Discussion'] = ResolversParentTypes['Discussion']> = ResolversObject<{
  activeLockReason?: Resolver<Maybe<ResolversTypes['LockReason']>, ParentType, ContextType>;
  answer?: Resolver<Maybe<ResolversTypes['DiscussionComment']>, ParentType, ContextType>;
  answerChosenAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  answerChosenBy?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  author?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  category?: Resolver<ResolversTypes['DiscussionCategory'], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['DiscussionCommentConnection'], ParentType, ContextType, Partial<DiscussioncommentsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isAnswered?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType, RequireFields<DiscussionlabelsArgs, 'orderBy'>>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  locked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  poll?: Resolver<Maybe<ResolversTypes['DiscussionPoll']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['ReactionConnection'], ParentType, ContextType, Partial<DiscussionreactionsArgs>>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  stateReason?: Resolver<Maybe<ResolversTypes['DiscussionStateReason']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  upvoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['UserContentEditConnection']>, ParentType, ContextType, Partial<DiscussionuserContentEditsArgs>>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpvote?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasUpvoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DiscussionCategoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DiscussionCategory'] = ResolversParentTypes['DiscussionCategory']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emoji?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  emojiHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isAnswerable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DiscussionCategoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DiscussionCategoryConnection'] = ResolversParentTypes['DiscussionCategoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DiscussionCategoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['DiscussionCategory']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DiscussionCategoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DiscussionCategoryEdge'] = ResolversParentTypes['DiscussionCategoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DiscussionCategory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DiscussionCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DiscussionComment'] = ResolversParentTypes['DiscussionComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deletedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Discussion']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isAnswer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['ReactionConnection'], ParentType, ContextType, Partial<DiscussionCommentreactionsArgs>>;
  replies?: Resolver<ResolversTypes['DiscussionCommentConnection'], ParentType, ContextType, Partial<DiscussionCommentrepliesArgs>>;
  replyTo?: Resolver<Maybe<ResolversTypes['DiscussionComment']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  upvoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['UserContentEditConnection']>, ParentType, ContextType, Partial<DiscussionCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMarkAsAnswer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUnmarkAsAnswer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpvote?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasUpvoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DiscussionCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DiscussionCommentConnection'] = ResolversParentTypes['DiscussionCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DiscussionCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['DiscussionComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DiscussionCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DiscussionCommentEdge'] = ResolversParentTypes['DiscussionCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DiscussionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DiscussionConnection'] = ResolversParentTypes['DiscussionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DiscussionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Discussion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DiscussionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DiscussionEdge'] = ResolversParentTypes['DiscussionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DiscussionPollResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DiscussionPoll'] = ResolversParentTypes['DiscussionPoll']> = ResolversObject<{
  discussion?: Resolver<Maybe<ResolversTypes['Discussion']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  options?: Resolver<Maybe<ResolversTypes['DiscussionPollOptionConnection']>, ParentType, ContextType, RequireFields<DiscussionPolloptionsArgs, 'orderBy'>>;
  question?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalVoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerCanVote?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasVoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DiscussionPollOptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DiscussionPollOption'] = ResolversParentTypes['DiscussionPollOption']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  option?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  poll?: Resolver<Maybe<ResolversTypes['DiscussionPoll']>, ParentType, ContextType>;
  totalVoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerHasVoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DiscussionPollOptionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DiscussionPollOptionConnection'] = ResolversParentTypes['DiscussionPollOptionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DiscussionPollOptionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['DiscussionPollOption']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DiscussionPollOptionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DiscussionPollOptionEdge'] = ResolversParentTypes['DiscussionPollOptionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DiscussionPollOption']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DismissPullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DismissPullRequestReviewPayload'] = ResolversParentTypes['DismissPullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DismissRepositoryVulnerabilityAlertPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DismissRepositoryVulnerabilityAlertPayload'] = ResolversParentTypes['DismissRepositoryVulnerabilityAlertPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryVulnerabilityAlert?: Resolver<Maybe<ResolversTypes['RepositoryVulnerabilityAlert']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DraftIssueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DraftIssue'] = ResolversParentTypes['DraftIssue']> = ResolversObject<{
  assignees?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<DraftIssueassigneesArgs>>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  projectV2Items?: Resolver<ResolversTypes['ProjectV2ItemConnection'], ParentType, ContextType, Partial<DraftIssueprojectV2ItemsArgs>>;
  projectsV2?: Resolver<ResolversTypes['ProjectV2Connection'], ParentType, ContextType, Partial<DraftIssueprojectsV2Args>>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnablePullRequestAutoMergePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnablePullRequestAutoMergePayload'] = ResolversParentTypes['EnablePullRequestAutoMergePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnqueuePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnqueuePullRequestPayload'] = ResolversParentTypes['EnqueuePullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mergeQueueEntry?: Resolver<Maybe<ResolversTypes['MergeQueueEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Enterprise'] = ResolversParentTypes['Enterprise']> = ResolversObject<{
  announcement?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  announcementExpiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  announcementUserDismissible?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  avatarUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType, Partial<EnterpriseavatarUrlArgs>>;
  billingInfo?: Resolver<Maybe<ResolversTypes['EnterpriseBillingInfo']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  members?: Resolver<ResolversTypes['EnterpriseMemberConnection'], ParentType, ContextType, RequireFields<EnterprisemembersArgs, 'hasTwoFactorEnabled' | 'orderBy'>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  organizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseorganizationsArgs, 'orderBy'>>;
  ownerInfo?: Resolver<Maybe<ResolversTypes['EnterpriseOwnerInfo']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  viewerIsAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  websiteUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseAdministratorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseAdministratorConnection'] = ResolversParentTypes['EnterpriseAdministratorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseAdministratorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseAdministratorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseAdministratorEdge'] = ResolversParentTypes['EnterpriseAdministratorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  role?: Resolver<ResolversTypes['EnterpriseAdministratorRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseAdministratorInvitationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseAdministratorInvitation'] = ResolversParentTypes['EnterpriseAdministratorInvitation']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<ResolversTypes['Enterprise'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitee?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  inviter?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  role?: Resolver<ResolversTypes['EnterpriseAdministratorRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseAdministratorInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseAdministratorInvitationConnection'] = ResolversParentTypes['EnterpriseAdministratorInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseAdministratorInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseAdministratorInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseAdministratorInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseAdministratorInvitationEdge'] = ResolversParentTypes['EnterpriseAdministratorInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseAuditEntryData'] = ResolversParentTypes['EnterpriseAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry', ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
}>;

export type EnterpriseBillingInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseBillingInfo'] = ResolversParentTypes['EnterpriseBillingInfo']> = ResolversObject<{
  allLicensableUsersCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  assetPacks?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  bandwidthQuota?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  bandwidthUsage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  bandwidthUsagePercentage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  storageQuota?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  storageUsage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  storageUsagePercentage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalAvailableLicenses?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalLicenses?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseConnection'] = ResolversParentTypes['EnterpriseConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Enterprise']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseEdge'] = ResolversParentTypes['EnterpriseEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseFailedInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseFailedInvitationConnection'] = ResolversParentTypes['EnterpriseFailedInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseFailedInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['OrganizationInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalUniqueUserCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseFailedInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseFailedInvitationEdge'] = ResolversParentTypes['EnterpriseFailedInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['OrganizationInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseIdentityProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseIdentityProvider'] = ResolversParentTypes['EnterpriseIdentityProvider']> = ResolversObject<{
  digestMethod?: Resolver<Maybe<ResolversTypes['SamlDigestAlgorithm']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  externalIdentities?: Resolver<ResolversTypes['ExternalIdentityConnection'], ParentType, ContextType, Partial<EnterpriseIdentityProviderexternalIdentitiesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  idpCertificate?: Resolver<Maybe<ResolversTypes['X509Certificate']>, ParentType, ContextType>;
  issuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  recoveryCodes?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  signatureMethod?: Resolver<Maybe<ResolversTypes['SamlSignatureAlgorithm']>, ParentType, ContextType>;
  ssoUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseMemberResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseMember'] = ResolversParentTypes['EnterpriseMember']> = ResolversObject<{
  __resolveType: TypeResolveFn<'EnterpriseUserAccount' | 'User', ParentType, ContextType>;
}>;

export type EnterpriseMemberConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseMemberConnection'] = ResolversParentTypes['EnterpriseMemberConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseMemberEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseMember']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseMemberEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseMemberEdge'] = ResolversParentTypes['EnterpriseMemberEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['EnterpriseMember']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseOrganizationMembershipConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseOrganizationMembershipConnection'] = ResolversParentTypes['EnterpriseOrganizationMembershipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseOrganizationMembershipEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Organization']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseOrganizationMembershipEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseOrganizationMembershipEdge'] = ResolversParentTypes['EnterpriseOrganizationMembershipEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  role?: Resolver<ResolversTypes['EnterpriseUserAccountMembershipRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseOutsideCollaboratorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseOutsideCollaboratorConnection'] = ResolversParentTypes['EnterpriseOutsideCollaboratorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseOutsideCollaboratorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseOutsideCollaboratorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseOutsideCollaboratorEdge'] = ResolversParentTypes['EnterpriseOutsideCollaboratorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  repositories?: Resolver<ResolversTypes['EnterpriseRepositoryInfoConnection'], ParentType, ContextType, RequireFields<EnterpriseOutsideCollaboratorEdgerepositoriesArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseOwnerInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseOwnerInfo'] = ResolversParentTypes['EnterpriseOwnerInfo']> = ResolversObject<{
  admins?: Resolver<ResolversTypes['EnterpriseAdministratorConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfoadminsArgs, 'hasTwoFactorEnabled' | 'orderBy'>>;
  affiliatedUsersWithTwoFactorDisabled?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<EnterpriseOwnerInfoaffiliatedUsersWithTwoFactorDisabledArgs>>;
  affiliatedUsersWithTwoFactorDisabledExist?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  allowPrivateRepositoryForkingSetting?: Resolver<ResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  allowPrivateRepositoryForkingSettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfoallowPrivateRepositoryForkingSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  allowPrivateRepositoryForkingSettingPolicyValue?: Resolver<Maybe<ResolversTypes['EnterpriseAllowPrivateRepositoryForkingPolicyValue']>, ParentType, ContextType>;
  defaultRepositoryPermissionSetting?: Resolver<ResolversTypes['EnterpriseDefaultRepositoryPermissionSettingValue'], ParentType, ContextType>;
  defaultRepositoryPermissionSettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfodefaultRepositoryPermissionSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  domains?: Resolver<ResolversTypes['VerifiableDomainConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfodomainsArgs, 'isApproved' | 'isVerified' | 'orderBy'>>;
  enterpriseServerInstallations?: Resolver<ResolversTypes['EnterpriseServerInstallationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfoenterpriseServerInstallationsArgs, 'connectedOnly' | 'orderBy'>>;
  failedInvitations?: Resolver<ResolversTypes['EnterpriseFailedInvitationConnection'], ParentType, ContextType, Partial<EnterpriseOwnerInfofailedInvitationsArgs>>;
  ipAllowListEnabledSetting?: Resolver<ResolversTypes['IpAllowListEnabledSettingValue'], ParentType, ContextType>;
  ipAllowListEntries?: Resolver<ResolversTypes['IpAllowListEntryConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfoipAllowListEntriesArgs, 'orderBy'>>;
  ipAllowListForInstalledAppsEnabledSetting?: Resolver<ResolversTypes['IpAllowListForInstalledAppsEnabledSettingValue'], ParentType, ContextType>;
  isUpdatingDefaultRepositoryPermission?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isUpdatingTwoFactorRequirement?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  membersCanChangeRepositoryVisibilitySetting?: Resolver<ResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanChangeRepositoryVisibilitySettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfomembersCanChangeRepositoryVisibilitySettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanCreateInternalRepositoriesSetting?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  membersCanCreatePrivateRepositoriesSetting?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  membersCanCreatePublicRepositoriesSetting?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  membersCanCreateRepositoriesSetting?: Resolver<Maybe<ResolversTypes['EnterpriseMembersCanCreateRepositoriesSettingValue']>, ParentType, ContextType>;
  membersCanCreateRepositoriesSettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfomembersCanCreateRepositoriesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanDeleteIssuesSetting?: Resolver<ResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanDeleteIssuesSettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfomembersCanDeleteIssuesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanDeleteRepositoriesSetting?: Resolver<ResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanDeleteRepositoriesSettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfomembersCanDeleteRepositoriesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanInviteCollaboratorsSetting?: Resolver<ResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanInviteCollaboratorsSettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfomembersCanInviteCollaboratorsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanMakePurchasesSetting?: Resolver<ResolversTypes['EnterpriseMembersCanMakePurchasesSettingValue'], ParentType, ContextType>;
  membersCanUpdateProtectedBranchesSetting?: Resolver<ResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanUpdateProtectedBranchesSettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfomembersCanUpdateProtectedBranchesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanViewDependencyInsightsSetting?: Resolver<ResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanViewDependencyInsightsSettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfomembersCanViewDependencyInsightsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  notificationDeliveryRestrictionEnabledSetting?: Resolver<ResolversTypes['NotificationRestrictionSettingValue'], ParentType, ContextType>;
  oidcProvider?: Resolver<Maybe<ResolversTypes['OIDCProvider']>, ParentType, ContextType>;
  organizationProjectsSetting?: Resolver<ResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  organizationProjectsSettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfoorganizationProjectsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  outsideCollaborators?: Resolver<ResolversTypes['EnterpriseOutsideCollaboratorConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfooutsideCollaboratorsArgs, 'hasTwoFactorEnabled' | 'orderBy'>>;
  pendingAdminInvitations?: Resolver<ResolversTypes['EnterpriseAdministratorInvitationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfopendingAdminInvitationsArgs, 'orderBy'>>;
  pendingCollaboratorInvitations?: Resolver<ResolversTypes['RepositoryInvitationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfopendingCollaboratorInvitationsArgs, 'orderBy'>>;
  pendingMemberInvitations?: Resolver<ResolversTypes['EnterprisePendingMemberInvitationConnection'], ParentType, ContextType, Partial<EnterpriseOwnerInfopendingMemberInvitationsArgs>>;
  repositoryProjectsSetting?: Resolver<ResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  repositoryProjectsSettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInforepositoryProjectsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  samlIdentityProvider?: Resolver<Maybe<ResolversTypes['EnterpriseIdentityProvider']>, ParentType, ContextType>;
  samlIdentityProviderSettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfosamlIdentityProviderSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  supportEntitlements?: Resolver<ResolversTypes['EnterpriseMemberConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfosupportEntitlementsArgs, 'orderBy'>>;
  teamDiscussionsSetting?: Resolver<ResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  teamDiscussionsSettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfoteamDiscussionsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  twoFactorRequiredSetting?: Resolver<ResolversTypes['EnterpriseEnabledSettingValue'], ParentType, ContextType>;
  twoFactorRequiredSettingOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<EnterpriseOwnerInfotwoFactorRequiredSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterprisePendingMemberInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterprisePendingMemberInvitationConnection'] = ResolversParentTypes['EnterprisePendingMemberInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterprisePendingMemberInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['OrganizationInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalUniqueUserCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterprisePendingMemberInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterprisePendingMemberInvitationEdge'] = ResolversParentTypes['EnterprisePendingMemberInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['OrganizationInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseRepositoryInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseRepositoryInfo'] = ResolversParentTypes['EnterpriseRepositoryInfo']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameWithOwner?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseRepositoryInfoConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseRepositoryInfoConnection'] = ResolversParentTypes['EnterpriseRepositoryInfoConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseRepositoryInfoEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseRepositoryInfo']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseRepositoryInfoEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseRepositoryInfoEdge'] = ResolversParentTypes['EnterpriseRepositoryInfoEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['EnterpriseRepositoryInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerInstallationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerInstallation'] = ResolversParentTypes['EnterpriseServerInstallation']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  customerName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  hostName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isConnected?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userAccounts?: Resolver<ResolversTypes['EnterpriseServerUserAccountConnection'], ParentType, ContextType, RequireFields<EnterpriseServerInstallationuserAccountsArgs, 'orderBy'>>;
  userAccountsUploads?: Resolver<ResolversTypes['EnterpriseServerUserAccountsUploadConnection'], ParentType, ContextType, RequireFields<EnterpriseServerInstallationuserAccountsUploadsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerInstallationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerInstallationConnection'] = ResolversParentTypes['EnterpriseServerInstallationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseServerInstallationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseServerInstallation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerInstallationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerInstallationEdge'] = ResolversParentTypes['EnterpriseServerInstallationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['EnterpriseServerInstallation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerInstallationMembershipConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerInstallationMembershipConnection'] = ResolversParentTypes['EnterpriseServerInstallationMembershipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseServerInstallationMembershipEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseServerInstallation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerInstallationMembershipEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerInstallationMembershipEdge'] = ResolversParentTypes['EnterpriseServerInstallationMembershipEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['EnterpriseServerInstallation']>, ParentType, ContextType>;
  role?: Resolver<ResolversTypes['EnterpriseUserAccountMembershipRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerUserAccountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerUserAccount'] = ResolversParentTypes['EnterpriseServerUserAccount']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  emails?: Resolver<ResolversTypes['EnterpriseServerUserAccountEmailConnection'], ParentType, ContextType, RequireFields<EnterpriseServerUserAccountemailsArgs, 'orderBy'>>;
  enterpriseServerInstallation?: Resolver<ResolversTypes['EnterpriseServerInstallation'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isSiteAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  profileName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  remoteCreatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  remoteUserId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerUserAccountConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerUserAccountConnection'] = ResolversParentTypes['EnterpriseServerUserAccountConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseServerUserAccountEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseServerUserAccount']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerUserAccountEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerUserAccountEdge'] = ResolversParentTypes['EnterpriseServerUserAccountEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['EnterpriseServerUserAccount']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerUserAccountEmailResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerUserAccountEmail'] = ResolversParentTypes['EnterpriseServerUserAccountEmail']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPrimary?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userAccount?: Resolver<ResolversTypes['EnterpriseServerUserAccount'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerUserAccountEmailConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerUserAccountEmailConnection'] = ResolversParentTypes['EnterpriseServerUserAccountEmailConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseServerUserAccountEmailEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseServerUserAccountEmail']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerUserAccountEmailEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerUserAccountEmailEdge'] = ResolversParentTypes['EnterpriseServerUserAccountEmailEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['EnterpriseServerUserAccountEmail']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerUserAccountsUploadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerUserAccountsUpload'] = ResolversParentTypes['EnterpriseServerUserAccountsUpload']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enterprise?: Resolver<ResolversTypes['Enterprise'], ParentType, ContextType>;
  enterpriseServerInstallation?: Resolver<ResolversTypes['EnterpriseServerInstallation'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  syncState?: Resolver<ResolversTypes['EnterpriseServerUserAccountsUploadSyncState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerUserAccountsUploadConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerUserAccountsUploadConnection'] = ResolversParentTypes['EnterpriseServerUserAccountsUploadConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseServerUserAccountsUploadEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnterpriseServerUserAccountsUpload']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseServerUserAccountsUploadEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseServerUserAccountsUploadEdge'] = ResolversParentTypes['EnterpriseServerUserAccountsUploadEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['EnterpriseServerUserAccountsUpload']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnterpriseUserAccountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnterpriseUserAccount'] = ResolversParentTypes['EnterpriseUserAccount']> = ResolversObject<{
  avatarUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType, Partial<EnterpriseUserAccountavatarUrlArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enterprise?: Resolver<ResolversTypes['Enterprise'], ParentType, ContextType>;
  enterpriseInstallations?: Resolver<ResolversTypes['EnterpriseServerInstallationMembershipConnection'], ParentType, ContextType, RequireFields<EnterpriseUserAccountenterpriseInstallationsArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizations?: Resolver<ResolversTypes['EnterpriseOrganizationMembershipConnection'], ParentType, ContextType, RequireFields<EnterpriseUserAccountorganizationsArgs, 'orderBy'>>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnvironmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Environment'] = ResolversParentTypes['Environment']> = ResolversObject<{
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  protectionRules?: Resolver<ResolversTypes['DeploymentProtectionRuleConnection'], ParentType, ContextType, Partial<EnvironmentprotectionRulesArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnvironmentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnvironmentConnection'] = ResolversParentTypes['EnvironmentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EnvironmentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Environment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnvironmentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EnvironmentEdge'] = ResolversParentTypes['EnvironmentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Environment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExternalIdentityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ExternalIdentity'] = ResolversParentTypes['ExternalIdentity']> = ResolversObject<{
  guid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organizationInvitation?: Resolver<Maybe<ResolversTypes['OrganizationInvitation']>, ParentType, ContextType>;
  samlIdentity?: Resolver<Maybe<ResolversTypes['ExternalIdentitySamlAttributes']>, ParentType, ContextType>;
  scimIdentity?: Resolver<Maybe<ResolversTypes['ExternalIdentityScimAttributes']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExternalIdentityAttributeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ExternalIdentityAttribute'] = ResolversParentTypes['ExternalIdentityAttribute']> = ResolversObject<{
  metadata?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExternalIdentityConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ExternalIdentityConnection'] = ResolversParentTypes['ExternalIdentityConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ExternalIdentityEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ExternalIdentity']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExternalIdentityEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ExternalIdentityEdge'] = ResolversParentTypes['ExternalIdentityEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ExternalIdentity']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExternalIdentitySamlAttributesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ExternalIdentitySamlAttributes'] = ResolversParentTypes['ExternalIdentitySamlAttributes']> = ResolversObject<{
  attributes?: Resolver<Array<ResolversTypes['ExternalIdentityAttribute']>, ParentType, ContextType>;
  emails?: Resolver<Maybe<Array<ResolversTypes['UserEmailMetadata']>>, ParentType, ContextType>;
  familyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  givenName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groups?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  nameId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExternalIdentityScimAttributesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ExternalIdentityScimAttributes'] = ResolversParentTypes['ExternalIdentityScimAttributes']> = ResolversObject<{
  emails?: Resolver<Maybe<Array<ResolversTypes['UserEmailMetadata']>>, ParentType, ContextType>;
  familyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  givenName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groups?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FollowOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FollowOrganizationPayload'] = ResolversParentTypes['FollowOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FollowUserPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FollowUserPayload'] = ResolversParentTypes['FollowUserPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FollowerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FollowerConnection'] = ResolversParentTypes['FollowerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FollowingConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FollowingConnection'] = ResolversParentTypes['FollowingConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FundingLinkResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FundingLink'] = ResolversParentTypes['FundingLink']> = ResolversObject<{
  platform?: Resolver<ResolversTypes['FundingPlatform'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GenericHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GenericHovercardContext'] = ResolversParentTypes['GenericHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GistResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Gist'] = ResolversParentTypes['Gist']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['GistCommentConnection'], ParentType, ContextType, Partial<GistcommentsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  files?: Resolver<Maybe<Array<Maybe<ResolversTypes['GistFile']>>>, ParentType, ContextType, RequireFields<GistfilesArgs, 'limit'>>;
  forks?: Resolver<ResolversTypes['GistConnection'], ParentType, ContextType, Partial<GistforksArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isFork?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPublic?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['RepositoryOwner']>, ParentType, ContextType>;
  pushedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  stargazerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stargazers?: Resolver<ResolversTypes['StargazerConnection'], ParentType, ContextType, Partial<GiststargazersArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  viewerHasStarred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GistCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GistComment'] = ResolversParentTypes['GistComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  gist?: Resolver<ResolversTypes['Gist'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['UserContentEditConnection']>, ParentType, ContextType, Partial<GistCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GistCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GistCommentConnection'] = ResolversParentTypes['GistCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['GistCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['GistComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GistCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GistCommentEdge'] = ResolversParentTypes['GistCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['GistComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GistConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GistConnection'] = ResolversParentTypes['GistConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['GistEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Gist']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GistEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GistEdge'] = ResolversParentTypes['GistEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Gist']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GistFileResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GistFile'] = ResolversParentTypes['GistFile']> = ResolversObject<{
  encodedName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  encoding?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  extension?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isImage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isTruncated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  language?: Resolver<Maybe<ResolversTypes['Language']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<GistFiletextArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GitActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GitActor'] = ResolversParentTypes['GitActor']> = ResolversObject<{
  avatarUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType, Partial<GitActoravatarUrlArgs>>;
  date?: Resolver<Maybe<ResolversTypes['GitTimestamp']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GitActorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GitActorConnection'] = ResolversParentTypes['GitActorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['GitActorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['GitActor']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GitActorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GitActorEdge'] = ResolversParentTypes['GitActorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['GitActor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GitHubMetadataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GitHubMetadata'] = ResolversParentTypes['GitHubMetadata']> = ResolversObject<{
  gitHubServicesSha?: Resolver<ResolversTypes['GitObjectID'], ParentType, ContextType>;
  gitIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  githubEnterpriseImporterIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  hookIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  importerIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  isPasswordAuthenticationVerifiable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  pagesIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GitObjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GitObject'] = ResolversParentTypes['GitObject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Blob' | 'Commit' | 'Tag' | 'Tree', ParentType, ContextType>;
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
}>;

export interface GitObjectIDScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['GitObjectID'], any> {
  name: 'GitObjectID';
}

export interface GitRefnameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['GitRefname'], any> {
  name: 'GitRefname';
}

export interface GitSSHRemoteScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['GitSSHRemote'], any> {
  name: 'GitSSHRemote';
}

export type GitSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GitSignature'] = ResolversParentTypes['GitSignature']> = ResolversObject<{
  __resolveType: TypeResolveFn<'GpgSignature' | 'SmimeSignature' | 'SshSignature' | 'UnknownSignature', ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export interface GitTimestampScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['GitTimestamp'], any> {
  name: 'GitTimestamp';
}

export type GpgSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GpgSignature'] = ResolversParentTypes['GpgSignature']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  keyId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GrantEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GrantEnterpriseOrganizationsMigratorRolePayload'] = ResolversParentTypes['GrantEnterpriseOrganizationsMigratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizations?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType, Partial<GrantEnterpriseOrganizationsMigratorRolePayloadorganizationsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GrantMigratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GrantMigratorRolePayload'] = ResolversParentTypes['GrantMigratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface HTMLScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['HTML'], any> {
  name: 'HTML';
}

export type HeadRefDeletedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['HeadRefDeletedEvent'] = ResolversParentTypes['HeadRefDeletedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  headRef?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  headRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type HeadRefForcePushedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['HeadRefForcePushedEvent'] = ResolversParentTypes['HeadRefForcePushedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  afterCommit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  beforeCommit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type HeadRefRestoredEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['HeadRefRestoredEvent'] = ResolversParentTypes['HeadRefRestoredEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type HovercardResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Hovercard'] = ResolversParentTypes['Hovercard']> = ResolversObject<{
  contexts?: Resolver<Array<ResolversTypes['HovercardContext']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type HovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['HovercardContext'] = ResolversParentTypes['HovercardContext']> = ResolversObject<{
  __resolveType: TypeResolveFn<'GenericHovercardContext' | 'OrganizationTeamsHovercardContext' | 'OrganizationsHovercardContext' | 'ReviewStatusHovercardContext' | 'ViewerHovercardContext', ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
}>;

export type ImportProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ImportProjectPayload'] = ResolversParentTypes['ImportProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InviteEnterpriseAdminPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['InviteEnterpriseAdminPayload'] = ResolversParentTypes['InviteEnterpriseAdminPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<ResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IpAllowListEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IpAllowListEntry'] = ResolversParentTypes['IpAllowListEntry']> = ResolversObject<{
  allowListValue?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['IpAllowListOwner'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IpAllowListEntryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IpAllowListEntryConnection'] = ResolversParentTypes['IpAllowListEntryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IpAllowListEntryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['IpAllowListEntry']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IpAllowListEntryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IpAllowListEntryEdge'] = ResolversParentTypes['IpAllowListEntryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IpAllowListOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IpAllowListOwner'] = ResolversParentTypes['IpAllowListOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'App' | 'Enterprise' | 'Organization', ParentType, ContextType>;
}>;

export type IssueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Issue'] = ResolversParentTypes['Issue']> = ResolversObject<{
  activeLockReason?: Resolver<Maybe<ResolversTypes['LockReason']>, ParentType, ContextType>;
  assignees?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<IssueassigneesArgs>>;
  author?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  bodyResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['IssueCommentConnection'], ParentType, ContextType, Partial<IssuecommentsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  fullDatabaseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  hovercard?: Resolver<ResolversTypes['Hovercard'], ParentType, ContextType, RequireFields<IssuehovercardArgs, 'includeNotificationContexts'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPinned?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isReadByViewer?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType, RequireFields<IssuelabelsArgs, 'orderBy'>>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  linkedBranches?: Resolver<ResolversTypes['LinkedBranchConnection'], ParentType, ContextType, Partial<IssuelinkedBranchesArgs>>;
  locked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  milestone?: Resolver<Maybe<ResolversTypes['Milestone']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  participants?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<IssueparticipantsArgs>>;
  projectCards?: Resolver<ResolversTypes['ProjectCardConnection'], ParentType, ContextType, RequireFields<IssueprojectCardsArgs, 'archivedStates'>>;
  projectItems?: Resolver<ResolversTypes['ProjectV2ItemConnection'], ParentType, ContextType, RequireFields<IssueprojectItemsArgs, 'includeArchived'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType, RequireFields<IssueprojectV2Args, 'number'>>;
  projectsV2?: Resolver<ResolversTypes['ProjectV2Connection'], ParentType, ContextType, RequireFields<IssueprojectsV2Args, 'orderBy'>>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['ReactionConnection'], ParentType, ContextType, Partial<IssuereactionsArgs>>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['IssueState'], ParentType, ContextType>;
  stateReason?: Resolver<Maybe<ResolversTypes['IssueStateReason']>, ParentType, ContextType>;
  timeline?: Resolver<ResolversTypes['IssueTimelineConnection'], ParentType, ContextType, Partial<IssuetimelineArgs>>;
  timelineItems?: Resolver<ResolversTypes['IssueTimelineItemsConnection'], ParentType, ContextType, Partial<IssuetimelineItemsArgs>>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  trackedInIssues?: Resolver<ResolversTypes['IssueConnection'], ParentType, ContextType, Partial<IssuetrackedInIssuesArgs>>;
  trackedIssues?: Resolver<ResolversTypes['IssueConnection'], ParentType, ContextType, Partial<IssuetrackedIssuesArgs>>;
  trackedIssuesCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType, Partial<IssuetrackedIssuesCountArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['UserContentEditConnection']>, ParentType, ContextType, Partial<IssueuserContentEditsArgs>>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['SubscriptionState']>, ParentType, ContextType>;
  viewerThreadSubscriptionFormAction?: Resolver<Maybe<ResolversTypes['ThreadSubscriptionFormAction']>, ParentType, ContextType>;
  viewerThreadSubscriptionStatus?: Resolver<Maybe<ResolversTypes['ThreadSubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IssueCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueComment'] = ResolversParentTypes['IssueComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  fullDatabaseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['Issue'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['ReactionConnection'], ParentType, ContextType, Partial<IssueCommentreactionsArgs>>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['UserContentEditConnection']>, ParentType, ContextType, Partial<IssueCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IssueCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueCommentConnection'] = ResolversParentTypes['IssueCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IssueCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['IssueComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IssueCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueCommentEdge'] = ResolversParentTypes['IssueCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['IssueComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IssueConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueConnection'] = ResolversParentTypes['IssueConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IssueEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Issue']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IssueContributionsByRepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueContributionsByRepository'] = ResolversParentTypes['IssueContributionsByRepository']> = ResolversObject<{
  contributions?: Resolver<ResolversTypes['CreatedIssueContributionConnection'], ParentType, ContextType, RequireFields<IssueContributionsByRepositorycontributionsArgs, 'orderBy'>>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IssueEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueEdge'] = ResolversParentTypes['IssueEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IssueOrPullRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueOrPullRequest'] = ResolversParentTypes['IssueOrPullRequest']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
}>;

export type IssueTemplateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueTemplate'] = ResolversParentTypes['IssueTemplate']> = ResolversObject<{
  about?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assignees?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<IssueTemplateassigneesArgs>>;
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType, RequireFields<IssueTemplatelabelsArgs, 'orderBy'>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IssueTimelineConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueTimelineConnection'] = ResolversParentTypes['IssueTimelineConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IssueTimelineItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['IssueTimelineItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IssueTimelineItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueTimelineItem'] = ResolversParentTypes['IssueTimelineItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AssignedEvent' | 'ClosedEvent' | 'Commit' | 'CrossReferencedEvent' | 'DemilestonedEvent' | 'IssueComment' | 'LabeledEvent' | 'LockedEvent' | 'MilestonedEvent' | 'ReferencedEvent' | 'RenamedTitleEvent' | 'ReopenedEvent' | 'SubscribedEvent' | 'TransferredEvent' | 'UnassignedEvent' | 'UnlabeledEvent' | 'UnlockedEvent' | 'UnsubscribedEvent' | 'UserBlockedEvent', ParentType, ContextType>;
}>;

export type IssueTimelineItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueTimelineItemEdge'] = ResolversParentTypes['IssueTimelineItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['IssueTimelineItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IssueTimelineItemsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueTimelineItems'] = ResolversParentTypes['IssueTimelineItems']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AddedToProjectEvent' | 'AssignedEvent' | 'ClosedEvent' | 'CommentDeletedEvent' | 'ConnectedEvent' | 'ConvertedNoteToIssueEvent' | 'ConvertedToDiscussionEvent' | 'CrossReferencedEvent' | 'DemilestonedEvent' | 'DisconnectedEvent' | 'IssueComment' | 'LabeledEvent' | 'LockedEvent' | 'MarkedAsDuplicateEvent' | 'MentionedEvent' | 'MilestonedEvent' | 'MovedColumnsInProjectEvent' | 'PinnedEvent' | 'ReferencedEvent' | 'RemovedFromProjectEvent' | 'RenamedTitleEvent' | 'ReopenedEvent' | 'SubscribedEvent' | 'TransferredEvent' | 'UnassignedEvent' | 'UnlabeledEvent' | 'UnlockedEvent' | 'UnmarkedAsDuplicateEvent' | 'UnpinnedEvent' | 'UnsubscribedEvent' | 'UserBlockedEvent', ParentType, ContextType>;
}>;

export type IssueTimelineItemsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueTimelineItemsConnection'] = ResolversParentTypes['IssueTimelineItemsConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IssueTimelineItemsEdge']>>>, ParentType, ContextType>;
  filteredCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['IssueTimelineItems']>>>, ParentType, ContextType>;
  pageCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IssueTimelineItemsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IssueTimelineItemsEdge'] = ResolversParentTypes['IssueTimelineItemsEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['IssueTimelineItems']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type JoinedGitHubContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['JoinedGitHubContribution'] = ResolversParentTypes['JoinedGitHubContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LabelResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Label'] = ResolversParentTypes['Label']> = ResolversObject<{
  color?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isDefault?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issues?: Resolver<ResolversTypes['IssueConnection'], ParentType, ContextType, Partial<LabelissuesArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequests?: Resolver<ResolversTypes['PullRequestConnection'], ParentType, ContextType, Partial<LabelpullRequestsArgs>>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LabelConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LabelConnection'] = ResolversParentTypes['LabelConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['LabelEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Label']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LabelEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LabelEdge'] = ResolversParentTypes['LabelEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LabelableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Labelable'] = ResolversParentTypes['Labelable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Discussion' | 'Issue' | 'PullRequest', ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType, RequireFields<LabelablelabelsArgs, 'orderBy'>>;
}>;

export type LabeledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LabeledEvent'] = ResolversParentTypes['LabeledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['Label'], ParentType, ContextType>;
  labelable?: Resolver<ResolversTypes['Labelable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LanguageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Language'] = ResolversParentTypes['Language']> = ResolversObject<{
  color?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LanguageConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LanguageConnection'] = ResolversParentTypes['LanguageConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['LanguageEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Language']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LanguageEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LanguageEdge'] = ResolversParentTypes['LanguageEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Language'], ParentType, ContextType>;
  size?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LicenseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['License'] = ResolversParentTypes['License']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  conditions?: Resolver<Array<Maybe<ResolversTypes['LicenseRule']>>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  featured?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hidden?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  implementation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  limitations?: Resolver<Array<Maybe<ResolversTypes['LicenseRule']>>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nickname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Array<Maybe<ResolversTypes['LicenseRule']>>, ParentType, ContextType>;
  pseudoLicense?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spdxId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LicenseRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LicenseRule'] = ResolversParentTypes['LicenseRule']> = ResolversObject<{
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LinkProjectV2ToRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LinkProjectV2ToRepositoryPayload'] = ResolversParentTypes['LinkProjectV2ToRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LinkProjectV2ToTeamPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LinkProjectV2ToTeamPayload'] = ResolversParentTypes['LinkProjectV2ToTeamPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LinkRepositoryToProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LinkRepositoryToProjectPayload'] = ResolversParentTypes['LinkRepositoryToProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LinkedBranchResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LinkedBranch'] = ResolversParentTypes['LinkedBranch']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LinkedBranchConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LinkedBranchConnection'] = ResolversParentTypes['LinkedBranchConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['LinkedBranchEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['LinkedBranch']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LinkedBranchEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LinkedBranchEdge'] = ResolversParentTypes['LinkedBranchEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['LinkedBranch']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LockLockablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LockLockablePayload'] = ResolversParentTypes['LockLockablePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lockedRecord?: Resolver<Maybe<ResolversTypes['Lockable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LockableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Lockable'] = ResolversParentTypes['Lockable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Discussion' | 'Issue' | 'PullRequest', ParentType, ContextType>;
  activeLockReason?: Resolver<Maybe<ResolversTypes['LockReason']>, ParentType, ContextType>;
  locked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type LockedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LockedEvent'] = ResolversParentTypes['LockedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lockReason?: Resolver<Maybe<ResolversTypes['LockReason']>, ParentType, ContextType>;
  lockable?: Resolver<ResolversTypes['Lockable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MannequinResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Mannequin'] = ResolversParentTypes['Mannequin']> = ResolversObject<{
  avatarUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType, Partial<MannequinavatarUrlArgs>>;
  claimant?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MannequinConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MannequinConnection'] = ResolversParentTypes['MannequinConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['MannequinEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Mannequin']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MannequinEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MannequinEdge'] = ResolversParentTypes['MannequinEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Mannequin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarkDiscussionCommentAsAnswerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MarkDiscussionCommentAsAnswerPayload'] = ResolversParentTypes['MarkDiscussionCommentAsAnswerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarkFileAsViewedPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MarkFileAsViewedPayload'] = ResolversParentTypes['MarkFileAsViewedPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarkProjectV2AsTemplatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MarkProjectV2AsTemplatePayload'] = ResolversParentTypes['MarkProjectV2AsTemplatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarkPullRequestReadyForReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MarkPullRequestReadyForReviewPayload'] = ResolversParentTypes['MarkPullRequestReadyForReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarkedAsDuplicateEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MarkedAsDuplicateEvent'] = ResolversParentTypes['MarkedAsDuplicateEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  canonical?: Resolver<Maybe<ResolversTypes['IssueOrPullRequest']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  duplicate?: Resolver<Maybe<ResolversTypes['IssueOrPullRequest']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarketplaceCategoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MarketplaceCategory'] = ResolversParentTypes['MarketplaceCategory']> = ResolversObject<{
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  howItWorks?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  primaryListingCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  secondaryListingCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarketplaceListingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MarketplaceListing'] = ResolversParentTypes['MarketplaceListing']> = ResolversObject<{
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  companyUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  configurationResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  configurationUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  documentationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  extendedDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  extendedDescriptionHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  fullDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fullDescriptionHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  hasPublishedFreeTrialPlans?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasTermsOfService?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasVerifiedOwner?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  howItWorks?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  howItWorksHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  installationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  installedForViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPaid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPublic?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRejected?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isUnverified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isUnverifiedPending?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerificationPendingFromDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerificationPendingFromUnverified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  logoBackgroundColor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logoUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType, RequireFields<MarketplaceListinglogoUrlArgs, 'size'>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  normalizedShortDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pricingUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  primaryCategory?: Resolver<ResolversTypes['MarketplaceCategory'], ParentType, ContextType>;
  privacyPolicyUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  screenshotUrls?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  secondaryCategory?: Resolver<Maybe<ResolversTypes['MarketplaceCategory']>, ParentType, ContextType>;
  shortDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  statusUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  supportEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  supportUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  termsOfServiceUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  viewerCanAddPlans?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanApprove?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDelist?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEditCategories?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEditPlans?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanRedraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReject?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanRequestApproval?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasPurchased?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasPurchasedForAllOrganizations?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsListingAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarketplaceListingConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MarketplaceListingConnection'] = ResolversParentTypes['MarketplaceListingConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['MarketplaceListingEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['MarketplaceListing']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarketplaceListingEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MarketplaceListingEdge'] = ResolversParentTypes['MarketplaceListingEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['MarketplaceListing']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MemberFeatureRequestNotificationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MemberFeatureRequestNotification'] = ResolversParentTypes['MemberFeatureRequestNotification']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MemberStatusableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MemberStatusable'] = ResolversParentTypes['MemberStatusable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'Team', ParentType, ContextType>;
  memberStatuses?: Resolver<ResolversTypes['UserStatusConnection'], ParentType, ContextType, RequireFields<MemberStatusablememberStatusesArgs, 'orderBy'>>;
}>;

export type MembersCanDeleteReposClearAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MembersCanDeleteReposClearAuditEntry'] = ResolversParentTypes['MembersCanDeleteReposClearAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MembersCanDeleteReposDisableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MembersCanDeleteReposDisableAuditEntry'] = ResolversParentTypes['MembersCanDeleteReposDisableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MembersCanDeleteReposEnableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MembersCanDeleteReposEnableAuditEntry'] = ResolversParentTypes['MembersCanDeleteReposEnableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MentionedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MentionedEvent'] = ResolversParentTypes['MentionedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MergeBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MergeBranchPayload'] = ResolversParentTypes['MergeBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mergeCommit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MergePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MergePullRequestPayload'] = ResolversParentTypes['MergePullRequestPayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MergeQueueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MergeQueue'] = ResolversParentTypes['MergeQueue']> = ResolversObject<{
  configuration?: Resolver<Maybe<ResolversTypes['MergeQueueConfiguration']>, ParentType, ContextType>;
  entries?: Resolver<Maybe<ResolversTypes['MergeQueueEntryConnection']>, ParentType, ContextType, Partial<MergeQueueentriesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  nextEntryEstimatedTimeToMerge?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MergeQueueConfigurationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MergeQueueConfiguration'] = ResolversParentTypes['MergeQueueConfiguration']> = ResolversObject<{
  checkResponseTimeout?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximumEntriesToBuild?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximumEntriesToMerge?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  mergeMethod?: Resolver<Maybe<ResolversTypes['PullRequestMergeMethod']>, ParentType, ContextType>;
  mergingStrategy?: Resolver<Maybe<ResolversTypes['MergeQueueMergingStrategy']>, ParentType, ContextType>;
  minimumEntriesToMerge?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  minimumEntriesToMergeWaitTime?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MergeQueueEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MergeQueueEntry'] = ResolversParentTypes['MergeQueueEntry']> = ResolversObject<{
  baseCommit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  enqueuedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enqueuer?: Resolver<ResolversTypes['Actor'], ParentType, ContextType>;
  estimatedTimeToMerge?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  headCommit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  jump?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mergeQueue?: Resolver<Maybe<ResolversTypes['MergeQueue']>, ParentType, ContextType>;
  position?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  solo?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['MergeQueueEntryState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MergeQueueEntryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MergeQueueEntryConnection'] = ResolversParentTypes['MergeQueueEntryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['MergeQueueEntryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['MergeQueueEntry']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MergeQueueEntryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MergeQueueEntryEdge'] = ResolversParentTypes['MergeQueueEntryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['MergeQueueEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MergedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MergedEvent'] = ResolversParentTypes['MergedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  mergeRef?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  mergeRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MigrationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Migration'] = ResolversParentTypes['Migration']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RepositoryMigration', ParentType, ContextType>;
  continueOnError?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  failureReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  migrationLogUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  migrationSource?: Resolver<ResolversTypes['MigrationSource'], ParentType, ContextType>;
  repositoryName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sourceUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['MigrationState'], ParentType, ContextType>;
  warningsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
}>;

export type MigrationSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MigrationSource'] = ResolversParentTypes['MigrationSource']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['MigrationSourceType'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MilestoneResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Milestone'] = ResolversParentTypes['Milestone']> = ResolversObject<{
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dueOn?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issues?: Resolver<ResolversTypes['IssueConnection'], ParentType, ContextType, Partial<MilestoneissuesArgs>>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  progressPercentage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  pullRequests?: Resolver<ResolversTypes['PullRequestConnection'], ParentType, ContextType, Partial<MilestonepullRequestsArgs>>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['MilestoneState'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MilestoneConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MilestoneConnection'] = ResolversParentTypes['MilestoneConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['MilestoneEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Milestone']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MilestoneEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MilestoneEdge'] = ResolversParentTypes['MilestoneEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Milestone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MilestoneItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MilestoneItem'] = ResolversParentTypes['MilestoneItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
}>;

export type MilestonedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MilestonedEvent'] = ResolversParentTypes['MilestonedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  milestoneTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['MilestoneItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MinimizableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Minimizable'] = ResolversParentTypes['Minimizable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CommitComment' | 'DiscussionComment' | 'GistComment' | 'IssueComment' | 'PullRequestReview' | 'PullRequestReviewComment', ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type MinimizeCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MinimizeCommentPayload'] = ResolversParentTypes['MinimizeCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimizedComment?: Resolver<Maybe<ResolversTypes['Minimizable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MoveProjectCardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MoveProjectCardPayload'] = ResolversParentTypes['MoveProjectCardPayload']> = ResolversObject<{
  cardEdge?: Resolver<Maybe<ResolversTypes['ProjectCardEdge']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MoveProjectColumnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MoveProjectColumnPayload'] = ResolversParentTypes['MoveProjectColumnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  columnEdge?: Resolver<Maybe<ResolversTypes['ProjectColumnEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MovedColumnsInProjectEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MovedColumnsInProjectEvent'] = ResolversParentTypes['MovedColumnsInProjectEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  previousProjectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['ProjectCard']>, ParentType, ContextType>;
  projectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MutationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = ResolversObject<{
  abortQueuedMigrations?: Resolver<Maybe<ResolversTypes['AbortQueuedMigrationsPayload']>, ParentType, ContextType, RequireFields<MutationabortQueuedMigrationsArgs, 'input'>>;
  abortRepositoryMigration?: Resolver<Maybe<ResolversTypes['AbortRepositoryMigrationPayload']>, ParentType, ContextType, RequireFields<MutationabortRepositoryMigrationArgs, 'input'>>;
  acceptEnterpriseAdministratorInvitation?: Resolver<Maybe<ResolversTypes['AcceptEnterpriseAdministratorInvitationPayload']>, ParentType, ContextType, RequireFields<MutationacceptEnterpriseAdministratorInvitationArgs, 'input'>>;
  acceptTopicSuggestion?: Resolver<Maybe<ResolversTypes['AcceptTopicSuggestionPayload']>, ParentType, ContextType, RequireFields<MutationacceptTopicSuggestionArgs, 'input'>>;
  addAssigneesToAssignable?: Resolver<Maybe<ResolversTypes['AddAssigneesToAssignablePayload']>, ParentType, ContextType, RequireFields<MutationaddAssigneesToAssignableArgs, 'input'>>;
  addComment?: Resolver<Maybe<ResolversTypes['AddCommentPayload']>, ParentType, ContextType, RequireFields<MutationaddCommentArgs, 'input'>>;
  addDiscussionComment?: Resolver<Maybe<ResolversTypes['AddDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<MutationaddDiscussionCommentArgs, 'input'>>;
  addDiscussionPollVote?: Resolver<Maybe<ResolversTypes['AddDiscussionPollVotePayload']>, ParentType, ContextType, RequireFields<MutationaddDiscussionPollVoteArgs, 'input'>>;
  addEnterpriseOrganizationMember?: Resolver<Maybe<ResolversTypes['AddEnterpriseOrganizationMemberPayload']>, ParentType, ContextType, RequireFields<MutationaddEnterpriseOrganizationMemberArgs, 'input'>>;
  addEnterpriseSupportEntitlement?: Resolver<Maybe<ResolversTypes['AddEnterpriseSupportEntitlementPayload']>, ParentType, ContextType, RequireFields<MutationaddEnterpriseSupportEntitlementArgs, 'input'>>;
  addLabelsToLabelable?: Resolver<Maybe<ResolversTypes['AddLabelsToLabelablePayload']>, ParentType, ContextType, RequireFields<MutationaddLabelsToLabelableArgs, 'input'>>;
  addProjectCard?: Resolver<Maybe<ResolversTypes['AddProjectCardPayload']>, ParentType, ContextType, RequireFields<MutationaddProjectCardArgs, 'input'>>;
  addProjectColumn?: Resolver<Maybe<ResolversTypes['AddProjectColumnPayload']>, ParentType, ContextType, RequireFields<MutationaddProjectColumnArgs, 'input'>>;
  addProjectV2DraftIssue?: Resolver<Maybe<ResolversTypes['AddProjectV2DraftIssuePayload']>, ParentType, ContextType, RequireFields<MutationaddProjectV2DraftIssueArgs, 'input'>>;
  addProjectV2ItemById?: Resolver<Maybe<ResolversTypes['AddProjectV2ItemByIdPayload']>, ParentType, ContextType, RequireFields<MutationaddProjectV2ItemByIdArgs, 'input'>>;
  addPullRequestReview?: Resolver<Maybe<ResolversTypes['AddPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<MutationaddPullRequestReviewArgs, 'input'>>;
  addPullRequestReviewComment?: Resolver<Maybe<ResolversTypes['AddPullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<MutationaddPullRequestReviewCommentArgs, 'input'>>;
  addPullRequestReviewThread?: Resolver<Maybe<ResolversTypes['AddPullRequestReviewThreadPayload']>, ParentType, ContextType, RequireFields<MutationaddPullRequestReviewThreadArgs, 'input'>>;
  addPullRequestReviewThreadReply?: Resolver<Maybe<ResolversTypes['AddPullRequestReviewThreadReplyPayload']>, ParentType, ContextType, RequireFields<MutationaddPullRequestReviewThreadReplyArgs, 'input'>>;
  addReaction?: Resolver<Maybe<ResolversTypes['AddReactionPayload']>, ParentType, ContextType, RequireFields<MutationaddReactionArgs, 'input'>>;
  addStar?: Resolver<Maybe<ResolversTypes['AddStarPayload']>, ParentType, ContextType, RequireFields<MutationaddStarArgs, 'input'>>;
  addUpvote?: Resolver<Maybe<ResolversTypes['AddUpvotePayload']>, ParentType, ContextType, RequireFields<MutationaddUpvoteArgs, 'input'>>;
  addVerifiableDomain?: Resolver<Maybe<ResolversTypes['AddVerifiableDomainPayload']>, ParentType, ContextType, RequireFields<MutationaddVerifiableDomainArgs, 'input'>>;
  approveDeployments?: Resolver<Maybe<ResolversTypes['ApproveDeploymentsPayload']>, ParentType, ContextType, RequireFields<MutationapproveDeploymentsArgs, 'input'>>;
  approveVerifiableDomain?: Resolver<Maybe<ResolversTypes['ApproveVerifiableDomainPayload']>, ParentType, ContextType, RequireFields<MutationapproveVerifiableDomainArgs, 'input'>>;
  archiveProjectV2Item?: Resolver<Maybe<ResolversTypes['ArchiveProjectV2ItemPayload']>, ParentType, ContextType, RequireFields<MutationarchiveProjectV2ItemArgs, 'input'>>;
  archiveRepository?: Resolver<Maybe<ResolversTypes['ArchiveRepositoryPayload']>, ParentType, ContextType, RequireFields<MutationarchiveRepositoryArgs, 'input'>>;
  cancelEnterpriseAdminInvitation?: Resolver<Maybe<ResolversTypes['CancelEnterpriseAdminInvitationPayload']>, ParentType, ContextType, RequireFields<MutationcancelEnterpriseAdminInvitationArgs, 'input'>>;
  cancelSponsorship?: Resolver<Maybe<ResolversTypes['CancelSponsorshipPayload']>, ParentType, ContextType, RequireFields<MutationcancelSponsorshipArgs, 'input'>>;
  changeUserStatus?: Resolver<Maybe<ResolversTypes['ChangeUserStatusPayload']>, ParentType, ContextType, RequireFields<MutationchangeUserStatusArgs, 'input'>>;
  clearLabelsFromLabelable?: Resolver<Maybe<ResolversTypes['ClearLabelsFromLabelablePayload']>, ParentType, ContextType, RequireFields<MutationclearLabelsFromLabelableArgs, 'input'>>;
  clearProjectV2ItemFieldValue?: Resolver<Maybe<ResolversTypes['ClearProjectV2ItemFieldValuePayload']>, ParentType, ContextType, RequireFields<MutationclearProjectV2ItemFieldValueArgs, 'input'>>;
  cloneProject?: Resolver<Maybe<ResolversTypes['CloneProjectPayload']>, ParentType, ContextType, RequireFields<MutationcloneProjectArgs, 'input'>>;
  cloneTemplateRepository?: Resolver<Maybe<ResolversTypes['CloneTemplateRepositoryPayload']>, ParentType, ContextType, RequireFields<MutationcloneTemplateRepositoryArgs, 'input'>>;
  closeDiscussion?: Resolver<Maybe<ResolversTypes['CloseDiscussionPayload']>, ParentType, ContextType, RequireFields<MutationcloseDiscussionArgs, 'input'>>;
  closeIssue?: Resolver<Maybe<ResolversTypes['CloseIssuePayload']>, ParentType, ContextType, RequireFields<MutationcloseIssueArgs, 'input'>>;
  closePullRequest?: Resolver<Maybe<ResolversTypes['ClosePullRequestPayload']>, ParentType, ContextType, RequireFields<MutationclosePullRequestArgs, 'input'>>;
  convertProjectCardNoteToIssue?: Resolver<Maybe<ResolversTypes['ConvertProjectCardNoteToIssuePayload']>, ParentType, ContextType, RequireFields<MutationconvertProjectCardNoteToIssueArgs, 'input'>>;
  convertPullRequestToDraft?: Resolver<Maybe<ResolversTypes['ConvertPullRequestToDraftPayload']>, ParentType, ContextType, RequireFields<MutationconvertPullRequestToDraftArgs, 'input'>>;
  copyProjectV2?: Resolver<Maybe<ResolversTypes['CopyProjectV2Payload']>, ParentType, ContextType, RequireFields<MutationcopyProjectV2Args, 'input'>>;
  createAttributionInvitation?: Resolver<Maybe<ResolversTypes['CreateAttributionInvitationPayload']>, ParentType, ContextType, RequireFields<MutationcreateAttributionInvitationArgs, 'input'>>;
  createBranchProtectionRule?: Resolver<Maybe<ResolversTypes['CreateBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<MutationcreateBranchProtectionRuleArgs, 'input'>>;
  createCheckRun?: Resolver<Maybe<ResolversTypes['CreateCheckRunPayload']>, ParentType, ContextType, RequireFields<MutationcreateCheckRunArgs, 'input'>>;
  createCheckSuite?: Resolver<Maybe<ResolversTypes['CreateCheckSuitePayload']>, ParentType, ContextType, RequireFields<MutationcreateCheckSuiteArgs, 'input'>>;
  createCommitOnBranch?: Resolver<Maybe<ResolversTypes['CreateCommitOnBranchPayload']>, ParentType, ContextType, RequireFields<MutationcreateCommitOnBranchArgs, 'input'>>;
  createDeployment?: Resolver<Maybe<ResolversTypes['CreateDeploymentPayload']>, ParentType, ContextType, RequireFields<MutationcreateDeploymentArgs, 'input'>>;
  createDeploymentStatus?: Resolver<Maybe<ResolversTypes['CreateDeploymentStatusPayload']>, ParentType, ContextType, RequireFields<MutationcreateDeploymentStatusArgs, 'input'>>;
  createDiscussion?: Resolver<Maybe<ResolversTypes['CreateDiscussionPayload']>, ParentType, ContextType, RequireFields<MutationcreateDiscussionArgs, 'input'>>;
  createEnterpriseOrganization?: Resolver<Maybe<ResolversTypes['CreateEnterpriseOrganizationPayload']>, ParentType, ContextType, RequireFields<MutationcreateEnterpriseOrganizationArgs, 'input'>>;
  createEnvironment?: Resolver<Maybe<ResolversTypes['CreateEnvironmentPayload']>, ParentType, ContextType, RequireFields<MutationcreateEnvironmentArgs, 'input'>>;
  createIpAllowListEntry?: Resolver<Maybe<ResolversTypes['CreateIpAllowListEntryPayload']>, ParentType, ContextType, RequireFields<MutationcreateIpAllowListEntryArgs, 'input'>>;
  createIssue?: Resolver<Maybe<ResolversTypes['CreateIssuePayload']>, ParentType, ContextType, RequireFields<MutationcreateIssueArgs, 'input'>>;
  createLabel?: Resolver<Maybe<ResolversTypes['CreateLabelPayload']>, ParentType, ContextType, RequireFields<MutationcreateLabelArgs, 'input'>>;
  createLinkedBranch?: Resolver<Maybe<ResolversTypes['CreateLinkedBranchPayload']>, ParentType, ContextType, RequireFields<MutationcreateLinkedBranchArgs, 'input'>>;
  createMigrationSource?: Resolver<Maybe<ResolversTypes['CreateMigrationSourcePayload']>, ParentType, ContextType, RequireFields<MutationcreateMigrationSourceArgs, 'input'>>;
  createProject?: Resolver<Maybe<ResolversTypes['CreateProjectPayload']>, ParentType, ContextType, RequireFields<MutationcreateProjectArgs, 'input'>>;
  createProjectV2?: Resolver<Maybe<ResolversTypes['CreateProjectV2Payload']>, ParentType, ContextType, RequireFields<MutationcreateProjectV2Args, 'input'>>;
  createProjectV2Field?: Resolver<Maybe<ResolversTypes['CreateProjectV2FieldPayload']>, ParentType, ContextType, RequireFields<MutationcreateProjectV2FieldArgs, 'input'>>;
  createPullRequest?: Resolver<Maybe<ResolversTypes['CreatePullRequestPayload']>, ParentType, ContextType, RequireFields<MutationcreatePullRequestArgs, 'input'>>;
  createRef?: Resolver<Maybe<ResolversTypes['CreateRefPayload']>, ParentType, ContextType, RequireFields<MutationcreateRefArgs, 'input'>>;
  createRepository?: Resolver<Maybe<ResolversTypes['CreateRepositoryPayload']>, ParentType, ContextType, RequireFields<MutationcreateRepositoryArgs, 'input'>>;
  createRepositoryRuleset?: Resolver<Maybe<ResolversTypes['CreateRepositoryRulesetPayload']>, ParentType, ContextType, RequireFields<MutationcreateRepositoryRulesetArgs, 'input'>>;
  createSponsorsListing?: Resolver<Maybe<ResolversTypes['CreateSponsorsListingPayload']>, ParentType, ContextType, RequireFields<MutationcreateSponsorsListingArgs, 'input'>>;
  createSponsorsTier?: Resolver<Maybe<ResolversTypes['CreateSponsorsTierPayload']>, ParentType, ContextType, RequireFields<MutationcreateSponsorsTierArgs, 'input'>>;
  createSponsorship?: Resolver<Maybe<ResolversTypes['CreateSponsorshipPayload']>, ParentType, ContextType, RequireFields<MutationcreateSponsorshipArgs, 'input'>>;
  createSponsorships?: Resolver<Maybe<ResolversTypes['CreateSponsorshipsPayload']>, ParentType, ContextType, RequireFields<MutationcreateSponsorshipsArgs, 'input'>>;
  createTeamDiscussion?: Resolver<Maybe<ResolversTypes['CreateTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<MutationcreateTeamDiscussionArgs, 'input'>>;
  createTeamDiscussionComment?: Resolver<Maybe<ResolversTypes['CreateTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<MutationcreateTeamDiscussionCommentArgs, 'input'>>;
  createUserList?: Resolver<Maybe<ResolversTypes['CreateUserListPayload']>, ParentType, ContextType, RequireFields<MutationcreateUserListArgs, 'input'>>;
  declineTopicSuggestion?: Resolver<Maybe<ResolversTypes['DeclineTopicSuggestionPayload']>, ParentType, ContextType, RequireFields<MutationdeclineTopicSuggestionArgs, 'input'>>;
  deleteBranchProtectionRule?: Resolver<Maybe<ResolversTypes['DeleteBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<MutationdeleteBranchProtectionRuleArgs, 'input'>>;
  deleteDeployment?: Resolver<Maybe<ResolversTypes['DeleteDeploymentPayload']>, ParentType, ContextType, RequireFields<MutationdeleteDeploymentArgs, 'input'>>;
  deleteDiscussion?: Resolver<Maybe<ResolversTypes['DeleteDiscussionPayload']>, ParentType, ContextType, RequireFields<MutationdeleteDiscussionArgs, 'input'>>;
  deleteDiscussionComment?: Resolver<Maybe<ResolversTypes['DeleteDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<MutationdeleteDiscussionCommentArgs, 'input'>>;
  deleteEnvironment?: Resolver<Maybe<ResolversTypes['DeleteEnvironmentPayload']>, ParentType, ContextType, RequireFields<MutationdeleteEnvironmentArgs, 'input'>>;
  deleteIpAllowListEntry?: Resolver<Maybe<ResolversTypes['DeleteIpAllowListEntryPayload']>, ParentType, ContextType, RequireFields<MutationdeleteIpAllowListEntryArgs, 'input'>>;
  deleteIssue?: Resolver<Maybe<ResolversTypes['DeleteIssuePayload']>, ParentType, ContextType, RequireFields<MutationdeleteIssueArgs, 'input'>>;
  deleteIssueComment?: Resolver<Maybe<ResolversTypes['DeleteIssueCommentPayload']>, ParentType, ContextType, RequireFields<MutationdeleteIssueCommentArgs, 'input'>>;
  deleteLabel?: Resolver<Maybe<ResolversTypes['DeleteLabelPayload']>, ParentType, ContextType, RequireFields<MutationdeleteLabelArgs, 'input'>>;
  deleteLinkedBranch?: Resolver<Maybe<ResolversTypes['DeleteLinkedBranchPayload']>, ParentType, ContextType, RequireFields<MutationdeleteLinkedBranchArgs, 'input'>>;
  deletePackageVersion?: Resolver<Maybe<ResolversTypes['DeletePackageVersionPayload']>, ParentType, ContextType, RequireFields<MutationdeletePackageVersionArgs, 'input'>>;
  deleteProject?: Resolver<Maybe<ResolversTypes['DeleteProjectPayload']>, ParentType, ContextType, RequireFields<MutationdeleteProjectArgs, 'input'>>;
  deleteProjectCard?: Resolver<Maybe<ResolversTypes['DeleteProjectCardPayload']>, ParentType, ContextType, RequireFields<MutationdeleteProjectCardArgs, 'input'>>;
  deleteProjectColumn?: Resolver<Maybe<ResolversTypes['DeleteProjectColumnPayload']>, ParentType, ContextType, RequireFields<MutationdeleteProjectColumnArgs, 'input'>>;
  deleteProjectV2?: Resolver<Maybe<ResolversTypes['DeleteProjectV2Payload']>, ParentType, ContextType, RequireFields<MutationdeleteProjectV2Args, 'input'>>;
  deleteProjectV2Field?: Resolver<Maybe<ResolversTypes['DeleteProjectV2FieldPayload']>, ParentType, ContextType, RequireFields<MutationdeleteProjectV2FieldArgs, 'input'>>;
  deleteProjectV2Item?: Resolver<Maybe<ResolversTypes['DeleteProjectV2ItemPayload']>, ParentType, ContextType, RequireFields<MutationdeleteProjectV2ItemArgs, 'input'>>;
  deleteProjectV2Workflow?: Resolver<Maybe<ResolversTypes['DeleteProjectV2WorkflowPayload']>, ParentType, ContextType, RequireFields<MutationdeleteProjectV2WorkflowArgs, 'input'>>;
  deletePullRequestReview?: Resolver<Maybe<ResolversTypes['DeletePullRequestReviewPayload']>, ParentType, ContextType, RequireFields<MutationdeletePullRequestReviewArgs, 'input'>>;
  deletePullRequestReviewComment?: Resolver<Maybe<ResolversTypes['DeletePullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<MutationdeletePullRequestReviewCommentArgs, 'input'>>;
  deleteRef?: Resolver<Maybe<ResolversTypes['DeleteRefPayload']>, ParentType, ContextType, RequireFields<MutationdeleteRefArgs, 'input'>>;
  deleteRepositoryRuleset?: Resolver<Maybe<ResolversTypes['DeleteRepositoryRulesetPayload']>, ParentType, ContextType, RequireFields<MutationdeleteRepositoryRulesetArgs, 'input'>>;
  deleteTeamDiscussion?: Resolver<Maybe<ResolversTypes['DeleteTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTeamDiscussionArgs, 'input'>>;
  deleteTeamDiscussionComment?: Resolver<Maybe<ResolversTypes['DeleteTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTeamDiscussionCommentArgs, 'input'>>;
  deleteUserList?: Resolver<Maybe<ResolversTypes['DeleteUserListPayload']>, ParentType, ContextType, RequireFields<MutationdeleteUserListArgs, 'input'>>;
  deleteVerifiableDomain?: Resolver<Maybe<ResolversTypes['DeleteVerifiableDomainPayload']>, ParentType, ContextType, RequireFields<MutationdeleteVerifiableDomainArgs, 'input'>>;
  dequeuePullRequest?: Resolver<Maybe<ResolversTypes['DequeuePullRequestPayload']>, ParentType, ContextType, RequireFields<MutationdequeuePullRequestArgs, 'input'>>;
  disablePullRequestAutoMerge?: Resolver<Maybe<ResolversTypes['DisablePullRequestAutoMergePayload']>, ParentType, ContextType, RequireFields<MutationdisablePullRequestAutoMergeArgs, 'input'>>;
  dismissPullRequestReview?: Resolver<Maybe<ResolversTypes['DismissPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<MutationdismissPullRequestReviewArgs, 'input'>>;
  dismissRepositoryVulnerabilityAlert?: Resolver<Maybe<ResolversTypes['DismissRepositoryVulnerabilityAlertPayload']>, ParentType, ContextType, RequireFields<MutationdismissRepositoryVulnerabilityAlertArgs, 'input'>>;
  enablePullRequestAutoMerge?: Resolver<Maybe<ResolversTypes['EnablePullRequestAutoMergePayload']>, ParentType, ContextType, RequireFields<MutationenablePullRequestAutoMergeArgs, 'input'>>;
  enqueuePullRequest?: Resolver<Maybe<ResolversTypes['EnqueuePullRequestPayload']>, ParentType, ContextType, RequireFields<MutationenqueuePullRequestArgs, 'input'>>;
  followOrganization?: Resolver<Maybe<ResolversTypes['FollowOrganizationPayload']>, ParentType, ContextType, RequireFields<MutationfollowOrganizationArgs, 'input'>>;
  followUser?: Resolver<Maybe<ResolversTypes['FollowUserPayload']>, ParentType, ContextType, RequireFields<MutationfollowUserArgs, 'input'>>;
  grantEnterpriseOrganizationsMigratorRole?: Resolver<Maybe<ResolversTypes['GrantEnterpriseOrganizationsMigratorRolePayload']>, ParentType, ContextType, RequireFields<MutationgrantEnterpriseOrganizationsMigratorRoleArgs, 'input'>>;
  grantMigratorRole?: Resolver<Maybe<ResolversTypes['GrantMigratorRolePayload']>, ParentType, ContextType, RequireFields<MutationgrantMigratorRoleArgs, 'input'>>;
  importProject?: Resolver<Maybe<ResolversTypes['ImportProjectPayload']>, ParentType, ContextType, RequireFields<MutationimportProjectArgs, 'input'>>;
  inviteEnterpriseAdmin?: Resolver<Maybe<ResolversTypes['InviteEnterpriseAdminPayload']>, ParentType, ContextType, RequireFields<MutationinviteEnterpriseAdminArgs, 'input'>>;
  linkProjectV2ToRepository?: Resolver<Maybe<ResolversTypes['LinkProjectV2ToRepositoryPayload']>, ParentType, ContextType, RequireFields<MutationlinkProjectV2ToRepositoryArgs, 'input'>>;
  linkProjectV2ToTeam?: Resolver<Maybe<ResolversTypes['LinkProjectV2ToTeamPayload']>, ParentType, ContextType, RequireFields<MutationlinkProjectV2ToTeamArgs, 'input'>>;
  linkRepositoryToProject?: Resolver<Maybe<ResolversTypes['LinkRepositoryToProjectPayload']>, ParentType, ContextType, RequireFields<MutationlinkRepositoryToProjectArgs, 'input'>>;
  lockLockable?: Resolver<Maybe<ResolversTypes['LockLockablePayload']>, ParentType, ContextType, RequireFields<MutationlockLockableArgs, 'input'>>;
  markDiscussionCommentAsAnswer?: Resolver<Maybe<ResolversTypes['MarkDiscussionCommentAsAnswerPayload']>, ParentType, ContextType, RequireFields<MutationmarkDiscussionCommentAsAnswerArgs, 'input'>>;
  markFileAsViewed?: Resolver<Maybe<ResolversTypes['MarkFileAsViewedPayload']>, ParentType, ContextType, RequireFields<MutationmarkFileAsViewedArgs, 'input'>>;
  markProjectV2AsTemplate?: Resolver<Maybe<ResolversTypes['MarkProjectV2AsTemplatePayload']>, ParentType, ContextType, RequireFields<MutationmarkProjectV2AsTemplateArgs, 'input'>>;
  markPullRequestReadyForReview?: Resolver<Maybe<ResolversTypes['MarkPullRequestReadyForReviewPayload']>, ParentType, ContextType, RequireFields<MutationmarkPullRequestReadyForReviewArgs, 'input'>>;
  mergeBranch?: Resolver<Maybe<ResolversTypes['MergeBranchPayload']>, ParentType, ContextType, RequireFields<MutationmergeBranchArgs, 'input'>>;
  mergePullRequest?: Resolver<Maybe<ResolversTypes['MergePullRequestPayload']>, ParentType, ContextType, RequireFields<MutationmergePullRequestArgs, 'input'>>;
  minimizeComment?: Resolver<Maybe<ResolversTypes['MinimizeCommentPayload']>, ParentType, ContextType, RequireFields<MutationminimizeCommentArgs, 'input'>>;
  moveProjectCard?: Resolver<Maybe<ResolversTypes['MoveProjectCardPayload']>, ParentType, ContextType, RequireFields<MutationmoveProjectCardArgs, 'input'>>;
  moveProjectColumn?: Resolver<Maybe<ResolversTypes['MoveProjectColumnPayload']>, ParentType, ContextType, RequireFields<MutationmoveProjectColumnArgs, 'input'>>;
  pinIssue?: Resolver<Maybe<ResolversTypes['PinIssuePayload']>, ParentType, ContextType, RequireFields<MutationpinIssueArgs, 'input'>>;
  publishSponsorsTier?: Resolver<Maybe<ResolversTypes['PublishSponsorsTierPayload']>, ParentType, ContextType, RequireFields<MutationpublishSponsorsTierArgs, 'input'>>;
  regenerateEnterpriseIdentityProviderRecoveryCodes?: Resolver<Maybe<ResolversTypes['RegenerateEnterpriseIdentityProviderRecoveryCodesPayload']>, ParentType, ContextType, RequireFields<MutationregenerateEnterpriseIdentityProviderRecoveryCodesArgs, 'input'>>;
  regenerateVerifiableDomainToken?: Resolver<Maybe<ResolversTypes['RegenerateVerifiableDomainTokenPayload']>, ParentType, ContextType, RequireFields<MutationregenerateVerifiableDomainTokenArgs, 'input'>>;
  rejectDeployments?: Resolver<Maybe<ResolversTypes['RejectDeploymentsPayload']>, ParentType, ContextType, RequireFields<MutationrejectDeploymentsArgs, 'input'>>;
  removeAssigneesFromAssignable?: Resolver<Maybe<ResolversTypes['RemoveAssigneesFromAssignablePayload']>, ParentType, ContextType, RequireFields<MutationremoveAssigneesFromAssignableArgs, 'input'>>;
  removeEnterpriseAdmin?: Resolver<Maybe<ResolversTypes['RemoveEnterpriseAdminPayload']>, ParentType, ContextType, RequireFields<MutationremoveEnterpriseAdminArgs, 'input'>>;
  removeEnterpriseIdentityProvider?: Resolver<Maybe<ResolversTypes['RemoveEnterpriseIdentityProviderPayload']>, ParentType, ContextType, RequireFields<MutationremoveEnterpriseIdentityProviderArgs, 'input'>>;
  removeEnterpriseMember?: Resolver<Maybe<ResolversTypes['RemoveEnterpriseMemberPayload']>, ParentType, ContextType, RequireFields<MutationremoveEnterpriseMemberArgs, 'input'>>;
  removeEnterpriseOrganization?: Resolver<Maybe<ResolversTypes['RemoveEnterpriseOrganizationPayload']>, ParentType, ContextType, RequireFields<MutationremoveEnterpriseOrganizationArgs, 'input'>>;
  removeEnterpriseSupportEntitlement?: Resolver<Maybe<ResolversTypes['RemoveEnterpriseSupportEntitlementPayload']>, ParentType, ContextType, RequireFields<MutationremoveEnterpriseSupportEntitlementArgs, 'input'>>;
  removeLabelsFromLabelable?: Resolver<Maybe<ResolversTypes['RemoveLabelsFromLabelablePayload']>, ParentType, ContextType, RequireFields<MutationremoveLabelsFromLabelableArgs, 'input'>>;
  removeOutsideCollaborator?: Resolver<Maybe<ResolversTypes['RemoveOutsideCollaboratorPayload']>, ParentType, ContextType, RequireFields<MutationremoveOutsideCollaboratorArgs, 'input'>>;
  removeReaction?: Resolver<Maybe<ResolversTypes['RemoveReactionPayload']>, ParentType, ContextType, RequireFields<MutationremoveReactionArgs, 'input'>>;
  removeStar?: Resolver<Maybe<ResolversTypes['RemoveStarPayload']>, ParentType, ContextType, RequireFields<MutationremoveStarArgs, 'input'>>;
  removeUpvote?: Resolver<Maybe<ResolversTypes['RemoveUpvotePayload']>, ParentType, ContextType, RequireFields<MutationremoveUpvoteArgs, 'input'>>;
  reopenDiscussion?: Resolver<Maybe<ResolversTypes['ReopenDiscussionPayload']>, ParentType, ContextType, RequireFields<MutationreopenDiscussionArgs, 'input'>>;
  reopenIssue?: Resolver<Maybe<ResolversTypes['ReopenIssuePayload']>, ParentType, ContextType, RequireFields<MutationreopenIssueArgs, 'input'>>;
  reopenPullRequest?: Resolver<Maybe<ResolversTypes['ReopenPullRequestPayload']>, ParentType, ContextType, RequireFields<MutationreopenPullRequestArgs, 'input'>>;
  requestReviews?: Resolver<Maybe<ResolversTypes['RequestReviewsPayload']>, ParentType, ContextType, RequireFields<MutationrequestReviewsArgs, 'input'>>;
  rerequestCheckSuite?: Resolver<Maybe<ResolversTypes['RerequestCheckSuitePayload']>, ParentType, ContextType, RequireFields<MutationrerequestCheckSuiteArgs, 'input'>>;
  resolveReviewThread?: Resolver<Maybe<ResolversTypes['ResolveReviewThreadPayload']>, ParentType, ContextType, RequireFields<MutationresolveReviewThreadArgs, 'input'>>;
  retireSponsorsTier?: Resolver<Maybe<ResolversTypes['RetireSponsorsTierPayload']>, ParentType, ContextType, RequireFields<MutationretireSponsorsTierArgs, 'input'>>;
  revertPullRequest?: Resolver<Maybe<ResolversTypes['RevertPullRequestPayload']>, ParentType, ContextType, RequireFields<MutationrevertPullRequestArgs, 'input'>>;
  revokeEnterpriseOrganizationsMigratorRole?: Resolver<Maybe<ResolversTypes['RevokeEnterpriseOrganizationsMigratorRolePayload']>, ParentType, ContextType, RequireFields<MutationrevokeEnterpriseOrganizationsMigratorRoleArgs, 'input'>>;
  revokeMigratorRole?: Resolver<Maybe<ResolversTypes['RevokeMigratorRolePayload']>, ParentType, ContextType, RequireFields<MutationrevokeMigratorRoleArgs, 'input'>>;
  setEnterpriseIdentityProvider?: Resolver<Maybe<ResolversTypes['SetEnterpriseIdentityProviderPayload']>, ParentType, ContextType, RequireFields<MutationsetEnterpriseIdentityProviderArgs, 'input'>>;
  setOrganizationInteractionLimit?: Resolver<Maybe<ResolversTypes['SetOrganizationInteractionLimitPayload']>, ParentType, ContextType, RequireFields<MutationsetOrganizationInteractionLimitArgs, 'input'>>;
  setRepositoryInteractionLimit?: Resolver<Maybe<ResolversTypes['SetRepositoryInteractionLimitPayload']>, ParentType, ContextType, RequireFields<MutationsetRepositoryInteractionLimitArgs, 'input'>>;
  setUserInteractionLimit?: Resolver<Maybe<ResolversTypes['SetUserInteractionLimitPayload']>, ParentType, ContextType, RequireFields<MutationsetUserInteractionLimitArgs, 'input'>>;
  startOrganizationMigration?: Resolver<Maybe<ResolversTypes['StartOrganizationMigrationPayload']>, ParentType, ContextType, RequireFields<MutationstartOrganizationMigrationArgs, 'input'>>;
  startRepositoryMigration?: Resolver<Maybe<ResolversTypes['StartRepositoryMigrationPayload']>, ParentType, ContextType, RequireFields<MutationstartRepositoryMigrationArgs, 'input'>>;
  submitPullRequestReview?: Resolver<Maybe<ResolversTypes['SubmitPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<MutationsubmitPullRequestReviewArgs, 'input'>>;
  transferEnterpriseOrganization?: Resolver<Maybe<ResolversTypes['TransferEnterpriseOrganizationPayload']>, ParentType, ContextType, RequireFields<MutationtransferEnterpriseOrganizationArgs, 'input'>>;
  transferIssue?: Resolver<Maybe<ResolversTypes['TransferIssuePayload']>, ParentType, ContextType, RequireFields<MutationtransferIssueArgs, 'input'>>;
  unarchiveProjectV2Item?: Resolver<Maybe<ResolversTypes['UnarchiveProjectV2ItemPayload']>, ParentType, ContextType, RequireFields<MutationunarchiveProjectV2ItemArgs, 'input'>>;
  unarchiveRepository?: Resolver<Maybe<ResolversTypes['UnarchiveRepositoryPayload']>, ParentType, ContextType, RequireFields<MutationunarchiveRepositoryArgs, 'input'>>;
  unfollowOrganization?: Resolver<Maybe<ResolversTypes['UnfollowOrganizationPayload']>, ParentType, ContextType, RequireFields<MutationunfollowOrganizationArgs, 'input'>>;
  unfollowUser?: Resolver<Maybe<ResolversTypes['UnfollowUserPayload']>, ParentType, ContextType, RequireFields<MutationunfollowUserArgs, 'input'>>;
  unlinkProjectV2FromRepository?: Resolver<Maybe<ResolversTypes['UnlinkProjectV2FromRepositoryPayload']>, ParentType, ContextType, RequireFields<MutationunlinkProjectV2FromRepositoryArgs, 'input'>>;
  unlinkProjectV2FromTeam?: Resolver<Maybe<ResolversTypes['UnlinkProjectV2FromTeamPayload']>, ParentType, ContextType, RequireFields<MutationunlinkProjectV2FromTeamArgs, 'input'>>;
  unlinkRepositoryFromProject?: Resolver<Maybe<ResolversTypes['UnlinkRepositoryFromProjectPayload']>, ParentType, ContextType, RequireFields<MutationunlinkRepositoryFromProjectArgs, 'input'>>;
  unlockLockable?: Resolver<Maybe<ResolversTypes['UnlockLockablePayload']>, ParentType, ContextType, RequireFields<MutationunlockLockableArgs, 'input'>>;
  unmarkDiscussionCommentAsAnswer?: Resolver<Maybe<ResolversTypes['UnmarkDiscussionCommentAsAnswerPayload']>, ParentType, ContextType, RequireFields<MutationunmarkDiscussionCommentAsAnswerArgs, 'input'>>;
  unmarkFileAsViewed?: Resolver<Maybe<ResolversTypes['UnmarkFileAsViewedPayload']>, ParentType, ContextType, RequireFields<MutationunmarkFileAsViewedArgs, 'input'>>;
  unmarkIssueAsDuplicate?: Resolver<Maybe<ResolversTypes['UnmarkIssueAsDuplicatePayload']>, ParentType, ContextType, RequireFields<MutationunmarkIssueAsDuplicateArgs, 'input'>>;
  unmarkProjectV2AsTemplate?: Resolver<Maybe<ResolversTypes['UnmarkProjectV2AsTemplatePayload']>, ParentType, ContextType, RequireFields<MutationunmarkProjectV2AsTemplateArgs, 'input'>>;
  unminimizeComment?: Resolver<Maybe<ResolversTypes['UnminimizeCommentPayload']>, ParentType, ContextType, RequireFields<MutationunminimizeCommentArgs, 'input'>>;
  unpinIssue?: Resolver<Maybe<ResolversTypes['UnpinIssuePayload']>, ParentType, ContextType, RequireFields<MutationunpinIssueArgs, 'input'>>;
  unresolveReviewThread?: Resolver<Maybe<ResolversTypes['UnresolveReviewThreadPayload']>, ParentType, ContextType, RequireFields<MutationunresolveReviewThreadArgs, 'input'>>;
  unsubscribeFromNotifications?: Resolver<Maybe<ResolversTypes['UnsubscribeFromNotificationsPayload']>, ParentType, ContextType, RequireFields<MutationunsubscribeFromNotificationsArgs, 'input'>>;
  updateBranchProtectionRule?: Resolver<Maybe<ResolversTypes['UpdateBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<MutationupdateBranchProtectionRuleArgs, 'input'>>;
  updateCheckRun?: Resolver<Maybe<ResolversTypes['UpdateCheckRunPayload']>, ParentType, ContextType, RequireFields<MutationupdateCheckRunArgs, 'input'>>;
  updateCheckSuitePreferences?: Resolver<Maybe<ResolversTypes['UpdateCheckSuitePreferencesPayload']>, ParentType, ContextType, RequireFields<MutationupdateCheckSuitePreferencesArgs, 'input'>>;
  updateDiscussion?: Resolver<Maybe<ResolversTypes['UpdateDiscussionPayload']>, ParentType, ContextType, RequireFields<MutationupdateDiscussionArgs, 'input'>>;
  updateDiscussionComment?: Resolver<Maybe<ResolversTypes['UpdateDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<MutationupdateDiscussionCommentArgs, 'input'>>;
  updateEnterpriseAdministratorRole?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseAdministratorRolePayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseAdministratorRoleArgs, 'input'>>;
  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseAllowPrivateRepositoryForkingSettingArgs, 'input'>>;
  updateEnterpriseDefaultRepositoryPermissionSetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseDefaultRepositoryPermissionSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseDefaultRepositoryPermissionSettingArgs, 'input'>>;
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs, 'input'>>;
  updateEnterpriseMembersCanCreateRepositoriesSetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseMembersCanCreateRepositoriesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanDeleteIssuesSetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseMembersCanDeleteIssuesSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseMembersCanDeleteIssuesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseMembersCanDeleteRepositoriesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseMembersCanInviteCollaboratorsSettingArgs, 'input'>>;
  updateEnterpriseMembersCanMakePurchasesSetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseMembersCanMakePurchasesSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseMembersCanMakePurchasesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseMembersCanViewDependencyInsightsSettingArgs, 'input'>>;
  updateEnterpriseOrganizationProjectsSetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseOrganizationProjectsSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseOrganizationProjectsSettingArgs, 'input'>>;
  updateEnterpriseOwnerOrganizationRole?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseOwnerOrganizationRolePayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseOwnerOrganizationRoleArgs, 'input'>>;
  updateEnterpriseProfile?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseProfilePayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseProfileArgs, 'input'>>;
  updateEnterpriseRepositoryProjectsSetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseRepositoryProjectsSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseRepositoryProjectsSettingArgs, 'input'>>;
  updateEnterpriseTeamDiscussionsSetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseTeamDiscussionsSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseTeamDiscussionsSettingArgs, 'input'>>;
  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Resolver<Maybe<ResolversTypes['UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs, 'input'>>;
  updateEnvironment?: Resolver<Maybe<ResolversTypes['UpdateEnvironmentPayload']>, ParentType, ContextType, RequireFields<MutationupdateEnvironmentArgs, 'input'>>;
  updateIpAllowListEnabledSetting?: Resolver<Maybe<ResolversTypes['UpdateIpAllowListEnabledSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateIpAllowListEnabledSettingArgs, 'input'>>;
  updateIpAllowListEntry?: Resolver<Maybe<ResolversTypes['UpdateIpAllowListEntryPayload']>, ParentType, ContextType, RequireFields<MutationupdateIpAllowListEntryArgs, 'input'>>;
  updateIpAllowListForInstalledAppsEnabledSetting?: Resolver<Maybe<ResolversTypes['UpdateIpAllowListForInstalledAppsEnabledSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateIpAllowListForInstalledAppsEnabledSettingArgs, 'input'>>;
  updateIssue?: Resolver<Maybe<ResolversTypes['UpdateIssuePayload']>, ParentType, ContextType, RequireFields<MutationupdateIssueArgs, 'input'>>;
  updateIssueComment?: Resolver<Maybe<ResolversTypes['UpdateIssueCommentPayload']>, ParentType, ContextType, RequireFields<MutationupdateIssueCommentArgs, 'input'>>;
  updateLabel?: Resolver<Maybe<ResolversTypes['UpdateLabelPayload']>, ParentType, ContextType, RequireFields<MutationupdateLabelArgs, 'input'>>;
  updateNotificationRestrictionSetting?: Resolver<Maybe<ResolversTypes['UpdateNotificationRestrictionSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateNotificationRestrictionSettingArgs, 'input'>>;
  updateOrganizationAllowPrivateRepositoryForkingSetting?: Resolver<Maybe<ResolversTypes['UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateOrganizationAllowPrivateRepositoryForkingSettingArgs, 'input'>>;
  updateOrganizationWebCommitSignoffSetting?: Resolver<Maybe<ResolversTypes['UpdateOrganizationWebCommitSignoffSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateOrganizationWebCommitSignoffSettingArgs, 'input'>>;
  updatePatreonSponsorability?: Resolver<Maybe<ResolversTypes['UpdatePatreonSponsorabilityPayload']>, ParentType, ContextType, RequireFields<MutationupdatePatreonSponsorabilityArgs, 'input'>>;
  updateProject?: Resolver<Maybe<ResolversTypes['UpdateProjectPayload']>, ParentType, ContextType, RequireFields<MutationupdateProjectArgs, 'input'>>;
  updateProjectCard?: Resolver<Maybe<ResolversTypes['UpdateProjectCardPayload']>, ParentType, ContextType, RequireFields<MutationupdateProjectCardArgs, 'input'>>;
  updateProjectColumn?: Resolver<Maybe<ResolversTypes['UpdateProjectColumnPayload']>, ParentType, ContextType, RequireFields<MutationupdateProjectColumnArgs, 'input'>>;
  updateProjectV2?: Resolver<Maybe<ResolversTypes['UpdateProjectV2Payload']>, ParentType, ContextType, RequireFields<MutationupdateProjectV2Args, 'input'>>;
  updateProjectV2Collaborators?: Resolver<Maybe<ResolversTypes['UpdateProjectV2CollaboratorsPayload']>, ParentType, ContextType, RequireFields<MutationupdateProjectV2CollaboratorsArgs, 'input'>>;
  updateProjectV2DraftIssue?: Resolver<Maybe<ResolversTypes['UpdateProjectV2DraftIssuePayload']>, ParentType, ContextType, RequireFields<MutationupdateProjectV2DraftIssueArgs, 'input'>>;
  updateProjectV2ItemFieldValue?: Resolver<Maybe<ResolversTypes['UpdateProjectV2ItemFieldValuePayload']>, ParentType, ContextType, RequireFields<MutationupdateProjectV2ItemFieldValueArgs, 'input'>>;
  updateProjectV2ItemPosition?: Resolver<Maybe<ResolversTypes['UpdateProjectV2ItemPositionPayload']>, ParentType, ContextType, RequireFields<MutationupdateProjectV2ItemPositionArgs, 'input'>>;
  updatePullRequest?: Resolver<Maybe<ResolversTypes['UpdatePullRequestPayload']>, ParentType, ContextType, RequireFields<MutationupdatePullRequestArgs, 'input'>>;
  updatePullRequestBranch?: Resolver<Maybe<ResolversTypes['UpdatePullRequestBranchPayload']>, ParentType, ContextType, RequireFields<MutationupdatePullRequestBranchArgs, 'input'>>;
  updatePullRequestReview?: Resolver<Maybe<ResolversTypes['UpdatePullRequestReviewPayload']>, ParentType, ContextType, RequireFields<MutationupdatePullRequestReviewArgs, 'input'>>;
  updatePullRequestReviewComment?: Resolver<Maybe<ResolversTypes['UpdatePullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<MutationupdatePullRequestReviewCommentArgs, 'input'>>;
  updateRef?: Resolver<Maybe<ResolversTypes['UpdateRefPayload']>, ParentType, ContextType, RequireFields<MutationupdateRefArgs, 'input'>>;
  updateRefs?: Resolver<Maybe<ResolversTypes['UpdateRefsPayload']>, ParentType, ContextType, RequireFields<MutationupdateRefsArgs, 'input'>>;
  updateRepository?: Resolver<Maybe<ResolversTypes['UpdateRepositoryPayload']>, ParentType, ContextType, RequireFields<MutationupdateRepositoryArgs, 'input'>>;
  updateRepositoryRuleset?: Resolver<Maybe<ResolversTypes['UpdateRepositoryRulesetPayload']>, ParentType, ContextType, RequireFields<MutationupdateRepositoryRulesetArgs, 'input'>>;
  updateRepositoryWebCommitSignoffSetting?: Resolver<Maybe<ResolversTypes['UpdateRepositoryWebCommitSignoffSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateRepositoryWebCommitSignoffSettingArgs, 'input'>>;
  updateSponsorshipPreferences?: Resolver<Maybe<ResolversTypes['UpdateSponsorshipPreferencesPayload']>, ParentType, ContextType, RequireFields<MutationupdateSponsorshipPreferencesArgs, 'input'>>;
  updateSubscription?: Resolver<Maybe<ResolversTypes['UpdateSubscriptionPayload']>, ParentType, ContextType, RequireFields<MutationupdateSubscriptionArgs, 'input'>>;
  updateTeamDiscussion?: Resolver<Maybe<ResolversTypes['UpdateTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<MutationupdateTeamDiscussionArgs, 'input'>>;
  updateTeamDiscussionComment?: Resolver<Maybe<ResolversTypes['UpdateTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<MutationupdateTeamDiscussionCommentArgs, 'input'>>;
  updateTeamReviewAssignment?: Resolver<Maybe<ResolversTypes['UpdateTeamReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationupdateTeamReviewAssignmentArgs, 'input'>>;
  updateTeamsRepository?: Resolver<Maybe<ResolversTypes['UpdateTeamsRepositoryPayload']>, ParentType, ContextType, RequireFields<MutationupdateTeamsRepositoryArgs, 'input'>>;
  updateTopics?: Resolver<Maybe<ResolversTypes['UpdateTopicsPayload']>, ParentType, ContextType, RequireFields<MutationupdateTopicsArgs, 'input'>>;
  updateUserList?: Resolver<Maybe<ResolversTypes['UpdateUserListPayload']>, ParentType, ContextType, RequireFields<MutationupdateUserListArgs, 'input'>>;
  updateUserListsForItem?: Resolver<Maybe<ResolversTypes['UpdateUserListsForItemPayload']>, ParentType, ContextType, RequireFields<MutationupdateUserListsForItemArgs, 'input'>>;
  verifyVerifiableDomain?: Resolver<Maybe<ResolversTypes['VerifyVerifiableDomainPayload']>, ParentType, ContextType, RequireFields<MutationverifyVerifiableDomainArgs, 'input'>>;
}>;

export type NodeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AddedToMergeQueueEvent' | 'AddedToProjectEvent' | 'App' | 'AssignedEvent' | 'AutoMergeDisabledEvent' | 'AutoMergeEnabledEvent' | 'AutoRebaseEnabledEvent' | 'AutoSquashEnabledEvent' | 'AutomaticBaseChangeFailedEvent' | 'AutomaticBaseChangeSucceededEvent' | 'BaseRefChangedEvent' | 'BaseRefDeletedEvent' | 'BaseRefForcePushedEvent' | 'Blob' | 'Bot' | 'BranchProtectionRule' | 'BypassForcePushAllowance' | 'BypassPullRequestAllowance' | 'CWE' | 'CheckRun' | 'CheckSuite' | 'ClosedEvent' | 'CodeOfConduct' | 'CommentDeletedEvent' | 'Commit' | 'CommitComment' | 'CommitCommentThread' | 'Comparison' | 'ConnectedEvent' | 'ConvertToDraftEvent' | 'ConvertedNoteToIssueEvent' | 'ConvertedToDiscussionEvent' | 'CrossReferencedEvent' | 'DemilestonedEvent' | 'DependencyGraphManifest' | 'DeployKey' | 'DeployedEvent' | 'Deployment' | 'DeploymentEnvironmentChangedEvent' | 'DeploymentReview' | 'DeploymentStatus' | 'DisconnectedEvent' | 'Discussion' | 'DiscussionCategory' | 'DiscussionComment' | 'DiscussionPoll' | 'DiscussionPollOption' | 'DraftIssue' | 'Enterprise' | 'EnterpriseAdministratorInvitation' | 'EnterpriseIdentityProvider' | 'EnterpriseRepositoryInfo' | 'EnterpriseServerInstallation' | 'EnterpriseServerUserAccount' | 'EnterpriseServerUserAccountEmail' | 'EnterpriseServerUserAccountsUpload' | 'EnterpriseUserAccount' | 'Environment' | 'ExternalIdentity' | 'Gist' | 'GistComment' | 'HeadRefDeletedEvent' | 'HeadRefForcePushedEvent' | 'HeadRefRestoredEvent' | 'IpAllowListEntry' | 'Issue' | 'IssueComment' | 'Label' | 'LabeledEvent' | 'Language' | 'License' | 'LinkedBranch' | 'LockedEvent' | 'Mannequin' | 'MarkedAsDuplicateEvent' | 'MarketplaceCategory' | 'MarketplaceListing' | 'MemberFeatureRequestNotification' | 'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'MentionedEvent' | 'MergeQueue' | 'MergeQueueEntry' | 'MergedEvent' | 'MigrationSource' | 'Milestone' | 'MilestonedEvent' | 'MovedColumnsInProjectEvent' | 'OIDCProvider' | 'OauthApplicationCreateAuditEntry' | 'OrgAddBillingManagerAuditEntry' | 'OrgAddMemberAuditEntry' | 'OrgBlockUserAuditEntry' | 'OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'OrgCreateAuditEntry' | 'OrgDisableOauthAppRestrictionsAuditEntry' | 'OrgDisableSamlAuditEntry' | 'OrgDisableTwoFactorRequirementAuditEntry' | 'OrgEnableOauthAppRestrictionsAuditEntry' | 'OrgEnableSamlAuditEntry' | 'OrgEnableTwoFactorRequirementAuditEntry' | 'OrgInviteMemberAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessBlockedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry' | 'OrgOauthAppAccessUnblockedAuditEntry' | 'OrgRemoveBillingManagerAuditEntry' | 'OrgRemoveMemberAuditEntry' | 'OrgRemoveOutsideCollaboratorAuditEntry' | 'OrgRestoreMemberAuditEntry' | 'OrgUnblockUserAuditEntry' | 'OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'OrgUpdateMemberAuditEntry' | 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'Organization' | 'OrganizationIdentityProvider' | 'OrganizationInvitation' | 'OrganizationMigration' | 'Package' | 'PackageFile' | 'PackageTag' | 'PackageVersion' | 'PinnedDiscussion' | 'PinnedEvent' | 'PinnedIssue' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'Project' | 'ProjectCard' | 'ProjectColumn' | 'ProjectV2' | 'ProjectV2Field' | 'ProjectV2Item' | 'ProjectV2ItemFieldDateValue' | 'ProjectV2ItemFieldIterationValue' | 'ProjectV2ItemFieldNumberValue' | 'ProjectV2ItemFieldSingleSelectValue' | 'ProjectV2ItemFieldTextValue' | 'ProjectV2IterationField' | 'ProjectV2SingleSelectField' | 'ProjectV2View' | 'ProjectV2Workflow' | 'PublicKey' | 'PullRequest' | 'PullRequestCommit' | 'PullRequestCommitCommentThread' | 'PullRequestReview' | 'PullRequestReviewComment' | 'PullRequestReviewThread' | 'PullRequestThread' | 'Push' | 'PushAllowance' | 'Reaction' | 'ReadyForReviewEvent' | 'Ref' | 'ReferencedEvent' | 'Release' | 'ReleaseAsset' | 'RemovedFromMergeQueueEvent' | 'RemovedFromProjectEvent' | 'RenamedTitleEvent' | 'ReopenedEvent' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'Repository' | 'RepositoryInvitation' | 'RepositoryMigration' | 'RepositoryRule' | 'RepositoryRuleset' | 'RepositoryRulesetBypassActor' | 'RepositoryTopic' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry' | 'RepositoryVulnerabilityAlert' | 'ReviewDismissalAllowance' | 'ReviewDismissedEvent' | 'ReviewRequest' | 'ReviewRequestRemovedEvent' | 'ReviewRequestedEvent' | 'SavedReply' | 'SecurityAdvisory' | 'SponsorsActivity' | 'SponsorsListing' | 'SponsorsListingFeaturedItem' | 'SponsorsTier' | 'Sponsorship' | 'SponsorshipNewsletter' | 'Status' | 'StatusCheckRollup' | 'StatusContext' | 'SubscribedEvent' | 'Tag' | 'Team' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamDiscussion' | 'TeamDiscussionComment' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry' | 'Topic' | 'TransferredEvent' | 'Tree' | 'UnassignedEvent' | 'UnlabeledEvent' | 'UnlockedEvent' | 'UnmarkedAsDuplicateEvent' | 'UnpinnedEvent' | 'UnsubscribedEvent' | 'User' | 'UserBlockedEvent' | 'UserContentEdit' | 'UserList' | 'UserStatus' | 'VerifiableDomain' | 'Workflow' | 'WorkflowRun' | 'WorkflowRunFile', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
}>;

export type OIDCProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OIDCProvider'] = ResolversParentTypes['OIDCProvider']> = ResolversObject<{
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  externalIdentities?: Resolver<ResolversTypes['ExternalIdentityConnection'], ParentType, ContextType, Partial<OIDCProviderexternalIdentitiesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  providerType?: Resolver<ResolversTypes['OIDCProviderType'], ParentType, ContextType>;
  tenantId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OauthApplicationAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OauthApplicationAuditEntryData'] = ResolversParentTypes['OauthApplicationAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OauthApplicationCreateAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessBlockedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry' | 'OrgOauthAppAccessUnblockedAuditEntry', ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
}>;

export type OauthApplicationCreateAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OauthApplicationCreateAuditEntry'] = ResolversParentTypes['OauthApplicationCreateAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  applicationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  callbackUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  rateLimit?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['OauthApplicationCreateAuditEntryState']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgAddBillingManagerAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgAddBillingManagerAuditEntry'] = ResolversParentTypes['OrgAddBillingManagerAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitationEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgAddMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgAddMemberAuditEntry'] = ResolversParentTypes['OrgAddMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<ResolversTypes['OrgAddMemberAuditEntryPermission']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgBlockUserAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgBlockUserAuditEntry'] = ResolversParentTypes['OrgBlockUserAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  blockedUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  blockedUserName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  blockedUserResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  blockedUserUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry'] = ResolversParentTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry'] = ResolversParentTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgCreateAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgCreateAuditEntry'] = ResolversParentTypes['OrgCreateAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  billingPlan?: Resolver<Maybe<ResolversTypes['OrgCreateAuditEntryBillingPlan']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgDisableOauthAppRestrictionsAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgDisableOauthAppRestrictionsAuditEntry'] = ResolversParentTypes['OrgDisableOauthAppRestrictionsAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgDisableSamlAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgDisableSamlAuditEntry'] = ResolversParentTypes['OrgDisableSamlAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  digestMethodUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issuerUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  signatureMethodUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  singleSignOnUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgDisableTwoFactorRequirementAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgDisableTwoFactorRequirementAuditEntry'] = ResolversParentTypes['OrgDisableTwoFactorRequirementAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgEnableOauthAppRestrictionsAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgEnableOauthAppRestrictionsAuditEntry'] = ResolversParentTypes['OrgEnableOauthAppRestrictionsAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgEnableSamlAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgEnableSamlAuditEntry'] = ResolversParentTypes['OrgEnableSamlAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  digestMethodUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issuerUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  signatureMethodUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  singleSignOnUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgEnableTwoFactorRequirementAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgEnableTwoFactorRequirementAuditEntry'] = ResolversParentTypes['OrgEnableTwoFactorRequirementAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgInviteMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgInviteMemberAuditEntry'] = ResolversParentTypes['OrgInviteMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationInvitation?: Resolver<Maybe<ResolversTypes['OrganizationInvitation']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgInviteToBusinessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgInviteToBusinessAuditEntry'] = ResolversParentTypes['OrgInviteToBusinessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgOauthAppAccessApprovedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgOauthAppAccessApprovedAuditEntry'] = ResolversParentTypes['OrgOauthAppAccessApprovedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgOauthAppAccessBlockedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgOauthAppAccessBlockedAuditEntry'] = ResolversParentTypes['OrgOauthAppAccessBlockedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgOauthAppAccessDeniedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgOauthAppAccessDeniedAuditEntry'] = ResolversParentTypes['OrgOauthAppAccessDeniedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgOauthAppAccessRequestedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgOauthAppAccessRequestedAuditEntry'] = ResolversParentTypes['OrgOauthAppAccessRequestedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgOauthAppAccessUnblockedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgOauthAppAccessUnblockedAuditEntry'] = ResolversParentTypes['OrgOauthAppAccessUnblockedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgRemoveBillingManagerAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgRemoveBillingManagerAuditEntry'] = ResolversParentTypes['OrgRemoveBillingManagerAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['OrgRemoveBillingManagerAuditEntryReason']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgRemoveMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgRemoveMemberAuditEntry'] = ResolversParentTypes['OrgRemoveMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  membershipTypes?: Resolver<Maybe<Array<ResolversTypes['OrgRemoveMemberAuditEntryMembershipType']>>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['OrgRemoveMemberAuditEntryReason']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgRemoveOutsideCollaboratorAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgRemoveOutsideCollaboratorAuditEntry'] = ResolversParentTypes['OrgRemoveOutsideCollaboratorAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  membershipTypes?: Resolver<Maybe<Array<ResolversTypes['OrgRemoveOutsideCollaboratorAuditEntryMembershipType']>>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['OrgRemoveOutsideCollaboratorAuditEntryReason']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgRestoreMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgRestoreMemberAuditEntry'] = ResolversParentTypes['OrgRestoreMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  restoredCustomEmailRoutingsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredIssueAssignmentsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredMemberships?: Resolver<Maybe<Array<ResolversTypes['OrgRestoreMemberAuditEntryMembership']>>, ParentType, ContextType>;
  restoredMembershipsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredRepositoriesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredRepositoryStarsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredRepositoryWatchesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgRestoreMemberAuditEntryMembershipResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgRestoreMemberAuditEntryMembership'] = ResolversParentTypes['OrgRestoreMemberAuditEntryMembership']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OrgRestoreMemberMembershipOrganizationAuditEntryData' | 'OrgRestoreMemberMembershipRepositoryAuditEntryData' | 'OrgRestoreMemberMembershipTeamAuditEntryData', ParentType, ContextType>;
}>;

export type OrgRestoreMemberMembershipOrganizationAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgRestoreMemberMembershipOrganizationAuditEntryData'] = ResolversParentTypes['OrgRestoreMemberMembershipOrganizationAuditEntryData']> = ResolversObject<{
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgRestoreMemberMembershipRepositoryAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgRestoreMemberMembershipRepositoryAuditEntryData'] = ResolversParentTypes['OrgRestoreMemberMembershipRepositoryAuditEntryData']> = ResolversObject<{
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgRestoreMemberMembershipTeamAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgRestoreMemberMembershipTeamAuditEntryData'] = ResolversParentTypes['OrgRestoreMemberMembershipTeamAuditEntryData']> = ResolversObject<{
  team?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgUnblockUserAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgUnblockUserAuditEntry'] = ResolversParentTypes['OrgUnblockUserAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  blockedUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  blockedUserName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  blockedUserResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  blockedUserUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgUpdateDefaultRepositoryPermissionAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry'] = ResolversParentTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<ResolversTypes['OrgUpdateDefaultRepositoryPermissionAuditEntryPermission']>, ParentType, ContextType>;
  permissionWas?: Resolver<Maybe<ResolversTypes['OrgUpdateDefaultRepositoryPermissionAuditEntryPermission']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgUpdateMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgUpdateMemberAuditEntry'] = ResolversParentTypes['OrgUpdateMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<ResolversTypes['OrgUpdateMemberAuditEntryPermission']>, ParentType, ContextType>;
  permissionWas?: Resolver<Maybe<ResolversTypes['OrgUpdateMemberAuditEntryPermission']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgUpdateMemberRepositoryCreationPermissionAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] = ResolversParentTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  canCreateRepositories?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrgUpdateMemberRepositoryInvitationPermissionAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] = ResolversParentTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  canInviteOutsideCollaboratorsToRepositories?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Organization'] = ResolversParentTypes['Organization']> = ResolversObject<{
  announcement?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  announcementExpiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  announcementUserDismissible?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  anyPinnableItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<OrganizationanyPinnableItemsArgs>>;
  archivedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  auditLog?: Resolver<ResolversTypes['OrganizationAuditEntryConnection'], ParentType, ContextType, RequireFields<OrganizationauditLogArgs, 'orderBy'>>;
  avatarUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType, Partial<OrganizationavatarUrlArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domains?: Resolver<Maybe<ResolversTypes['VerifiableDomainConnection']>, ParentType, ContextType, RequireFields<OrganizationdomainsArgs, 'isApproved' | 'isVerified' | 'orderBy'>>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseOwners?: Resolver<ResolversTypes['OrganizationEnterpriseOwnerConnection'], ParentType, ContextType, RequireFields<OrganizationenterpriseOwnersArgs, 'orderBy'>>;
  estimatedNextSponsorsPayoutInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hasSponsorsListing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  interactionAbility?: Resolver<Maybe<ResolversTypes['RepositoryInteractionAbility']>, ParentType, ContextType>;
  ipAllowListEnabledSetting?: Resolver<ResolversTypes['IpAllowListEnabledSettingValue'], ParentType, ContextType>;
  ipAllowListEntries?: Resolver<ResolversTypes['IpAllowListEntryConnection'], ParentType, ContextType, RequireFields<OrganizationipAllowListEntriesArgs, 'orderBy'>>;
  ipAllowListForInstalledAppsEnabledSetting?: Resolver<ResolversTypes['IpAllowListForInstalledAppsEnabledSettingValue'], ParentType, ContextType>;
  isSponsoredBy?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<OrganizationisSponsoredByArgs, 'accountLogin'>>;
  isSponsoringViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  itemShowcase?: Resolver<ResolversTypes['ProfileItemShowcase'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  mannequins?: Resolver<ResolversTypes['MannequinConnection'], ParentType, ContextType, RequireFields<OrganizationmannequinsArgs, 'orderBy'>>;
  memberStatuses?: Resolver<ResolversTypes['UserStatusConnection'], ParentType, ContextType, RequireFields<OrganizationmemberStatusesArgs, 'orderBy'>>;
  membersCanForkPrivateRepositories?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  membersWithRole?: Resolver<ResolversTypes['OrganizationMemberConnection'], ParentType, ContextType, Partial<OrganizationmembersWithRoleArgs>>;
  monthlyEstimatedSponsorsIncomeInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  newTeamResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  newTeamUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  notificationDeliveryRestrictionEnabledSetting?: Resolver<ResolversTypes['NotificationRestrictionSettingValue'], ParentType, ContextType>;
  organizationBillingEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  packages?: Resolver<ResolversTypes['PackageConnection'], ParentType, ContextType, RequireFields<OrganizationpackagesArgs, 'orderBy'>>;
  pendingMembers?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<OrganizationpendingMembersArgs>>;
  pinnableItems?: Resolver<ResolversTypes['PinnableItemConnection'], ParentType, ContextType, Partial<OrganizationpinnableItemsArgs>>;
  pinnedItems?: Resolver<ResolversTypes['PinnableItemConnection'], ParentType, ContextType, Partial<OrganizationpinnedItemsArgs>>;
  pinnedItemsRemaining?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType, RequireFields<OrganizationprojectArgs, 'number'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType, RequireFields<OrganizationprojectV2Args, 'number'>>;
  projects?: Resolver<ResolversTypes['ProjectConnection'], ParentType, ContextType, Partial<OrganizationprojectsArgs>>;
  projectsResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  projectsV2?: Resolver<ResolversTypes['ProjectV2Connection'], ParentType, ContextType, RequireFields<OrganizationprojectsV2Args, 'orderBy'>>;
  recentProjects?: Resolver<ResolversTypes['ProjectV2Connection'], ParentType, ContextType, Partial<OrganizationrecentProjectsArgs>>;
  repositories?: Resolver<ResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<OrganizationrepositoriesArgs, 'ownerAffiliations'>>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType, RequireFields<OrganizationrepositoryArgs, 'followRenames' | 'name'>>;
  repositoryDiscussionComments?: Resolver<ResolversTypes['DiscussionCommentConnection'], ParentType, ContextType, RequireFields<OrganizationrepositoryDiscussionCommentsArgs, 'onlyAnswers'>>;
  repositoryDiscussions?: Resolver<ResolversTypes['DiscussionConnection'], ParentType, ContextType, RequireFields<OrganizationrepositoryDiscussionsArgs, 'answered' | 'orderBy' | 'states'>>;
  repositoryMigrations?: Resolver<ResolversTypes['RepositoryMigrationConnection'], ParentType, ContextType, RequireFields<OrganizationrepositoryMigrationsArgs, 'orderBy'>>;
  requiresTwoFactorAuthentication?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  ruleset?: Resolver<Maybe<ResolversTypes['RepositoryRuleset']>, ParentType, ContextType, RequireFields<OrganizationrulesetArgs, 'databaseId'>>;
  rulesets?: Resolver<Maybe<ResolversTypes['RepositoryRulesetConnection']>, ParentType, ContextType, RequireFields<OrganizationrulesetsArgs, 'includeParents'>>;
  samlIdentityProvider?: Resolver<Maybe<ResolversTypes['OrganizationIdentityProvider']>, ParentType, ContextType>;
  sponsoring?: Resolver<ResolversTypes['SponsorConnection'], ParentType, ContextType, RequireFields<OrganizationsponsoringArgs, 'orderBy'>>;
  sponsors?: Resolver<ResolversTypes['SponsorConnection'], ParentType, ContextType, RequireFields<OrganizationsponsorsArgs, 'orderBy'>>;
  sponsorsActivities?: Resolver<ResolversTypes['SponsorsActivityConnection'], ParentType, ContextType, RequireFields<OrganizationsponsorsActivitiesArgs, 'actions' | 'includeAsSponsor' | 'includePrivate' | 'orderBy' | 'period'>>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['SponsorsListing']>, ParentType, ContextType>;
  sponsorshipForViewerAsSponsor?: Resolver<Maybe<ResolversTypes['Sponsorship']>, ParentType, ContextType, RequireFields<OrganizationsponsorshipForViewerAsSponsorArgs, 'activeOnly'>>;
  sponsorshipForViewerAsSponsorable?: Resolver<Maybe<ResolversTypes['Sponsorship']>, ParentType, ContextType, RequireFields<OrganizationsponsorshipForViewerAsSponsorableArgs, 'activeOnly'>>;
  sponsorshipNewsletters?: Resolver<ResolversTypes['SponsorshipNewsletterConnection'], ParentType, ContextType, RequireFields<OrganizationsponsorshipNewslettersArgs, 'orderBy'>>;
  sponsorshipsAsMaintainer?: Resolver<ResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<OrganizationsponsorshipsAsMaintainerArgs, 'activeOnly' | 'includePrivate'>>;
  sponsorshipsAsSponsor?: Resolver<ResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<OrganizationsponsorshipsAsSponsorArgs, 'activeOnly'>>;
  team?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType, RequireFields<OrganizationteamArgs, 'slug'>>;
  teams?: Resolver<ResolversTypes['TeamConnection'], ParentType, ContextType, RequireFields<OrganizationteamsArgs, 'rootTeamsOnly'>>;
  teamsResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  teamsUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  totalSponsorshipAmountAsSponsorInCents?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<OrganizationtotalSponsorshipAmountAsSponsorInCentsArgs, 'sponsorableLogins'>>;
  twitterUsername?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanChangePinnedItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateRepositories?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateTeams?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSponsor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsAMember?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsFollowing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsSponsoring?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  webCommitSignoffRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  websiteUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationAuditEntry'] = ResolversParentTypes['OrganizationAuditEntry']> = ResolversObject<{
  __resolveType: TypeResolveFn<'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'OauthApplicationCreateAuditEntry' | 'OrgAddBillingManagerAuditEntry' | 'OrgAddMemberAuditEntry' | 'OrgBlockUserAuditEntry' | 'OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'OrgCreateAuditEntry' | 'OrgDisableOauthAppRestrictionsAuditEntry' | 'OrgDisableSamlAuditEntry' | 'OrgDisableTwoFactorRequirementAuditEntry' | 'OrgEnableOauthAppRestrictionsAuditEntry' | 'OrgEnableSamlAuditEntry' | 'OrgEnableTwoFactorRequirementAuditEntry' | 'OrgInviteMemberAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessBlockedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry' | 'OrgOauthAppAccessUnblockedAuditEntry' | 'OrgRemoveBillingManagerAuditEntry' | 'OrgRemoveMemberAuditEntry' | 'OrgRemoveOutsideCollaboratorAuditEntry' | 'OrgRestoreMemberAuditEntry' | 'OrgUnblockUserAuditEntry' | 'OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'OrgUpdateMemberAuditEntry' | 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
}>;

export type OrganizationAuditEntryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationAuditEntryConnection'] = ResolversParentTypes['OrganizationAuditEntryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['OrganizationAuditEntryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['OrganizationAuditEntry']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationAuditEntryData'] = ResolversParentTypes['OrganizationAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'OauthApplicationCreateAuditEntry' | 'OrgAddBillingManagerAuditEntry' | 'OrgAddMemberAuditEntry' | 'OrgBlockUserAuditEntry' | 'OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'OrgCreateAuditEntry' | 'OrgDisableOauthAppRestrictionsAuditEntry' | 'OrgDisableSamlAuditEntry' | 'OrgDisableTwoFactorRequirementAuditEntry' | 'OrgEnableOauthAppRestrictionsAuditEntry' | 'OrgEnableSamlAuditEntry' | 'OrgEnableTwoFactorRequirementAuditEntry' | 'OrgInviteMemberAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessBlockedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry' | 'OrgOauthAppAccessUnblockedAuditEntry' | 'OrgRemoveBillingManagerAuditEntry' | 'OrgRemoveMemberAuditEntry' | 'OrgRemoveOutsideCollaboratorAuditEntry' | 'OrgRestoreMemberAuditEntry' | 'OrgRestoreMemberMembershipOrganizationAuditEntryData' | 'OrgUnblockUserAuditEntry' | 'OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'OrgUpdateMemberAuditEntry' | 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
}>;

export type OrganizationAuditEntryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationAuditEntryEdge'] = ResolversParentTypes['OrganizationAuditEntryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['OrganizationAuditEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationConnection'] = ResolversParentTypes['OrganizationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['OrganizationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Organization']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationEdge'] = ResolversParentTypes['OrganizationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationEnterpriseOwnerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationEnterpriseOwnerConnection'] = ResolversParentTypes['OrganizationEnterpriseOwnerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['OrganizationEnterpriseOwnerEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationEnterpriseOwnerEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationEnterpriseOwnerEdge'] = ResolversParentTypes['OrganizationEnterpriseOwnerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  organizationRole?: Resolver<ResolversTypes['RoleInOrganization'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationIdentityProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationIdentityProvider'] = ResolversParentTypes['OrganizationIdentityProvider']> = ResolversObject<{
  digestMethod?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  externalIdentities?: Resolver<ResolversTypes['ExternalIdentityConnection'], ParentType, ContextType, Partial<OrganizationIdentityProviderexternalIdentitiesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  idpCertificate?: Resolver<Maybe<ResolversTypes['X509Certificate']>, ParentType, ContextType>;
  issuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  signatureMethod?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  ssoUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationInvitationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationInvitation'] = ResolversParentTypes['OrganizationInvitation']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitationSource?: Resolver<ResolversTypes['OrganizationInvitationSource'], ParentType, ContextType>;
  invitationType?: Resolver<ResolversTypes['OrganizationInvitationType'], ParentType, ContextType>;
  invitee?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  inviter?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  organization?: Resolver<ResolversTypes['Organization'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['OrganizationInvitationRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationInvitationConnection'] = ResolversParentTypes['OrganizationInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['OrganizationInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['OrganizationInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationInvitationEdge'] = ResolversParentTypes['OrganizationInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['OrganizationInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationMemberConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationMemberConnection'] = ResolversParentTypes['OrganizationMemberConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['OrganizationMemberEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationMemberEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationMemberEdge'] = ResolversParentTypes['OrganizationMemberEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  hasTwoFactorEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['OrganizationMemberRole']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationMigrationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationMigration'] = ResolversParentTypes['OrganizationMigration']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  failureReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  remainingRepositoriesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sourceOrgName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sourceOrgUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['OrganizationMigrationState'], ParentType, ContextType>;
  targetOrgName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalRepositoriesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationOrUserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationOrUser'] = ResolversParentTypes['OrganizationOrUser']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'User', ParentType, ContextType>;
}>;

export type OrganizationTeamsHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationTeamsHovercardContext'] = ResolversParentTypes['OrganizationTeamsHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  relevantTeams?: Resolver<ResolversTypes['TeamConnection'], ParentType, ContextType, Partial<OrganizationTeamsHovercardContextrelevantTeamsArgs>>;
  teamsResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  teamsUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  totalTeamCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationsHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrganizationsHovercardContext'] = ResolversParentTypes['OrganizationsHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  relevantOrganizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<OrganizationsHovercardContextrelevantOrganizationsArgs, 'orderBy'>>;
  totalOrganizationCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PackageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Package'] = ResolversParentTypes['Package']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  latestVersion?: Resolver<Maybe<ResolversTypes['PackageVersion']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  packageType?: Resolver<ResolversTypes['PackageType'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  statistics?: Resolver<Maybe<ResolversTypes['PackageStatistics']>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['PackageVersion']>, ParentType, ContextType, RequireFields<PackageversionArgs, 'version'>>;
  versions?: Resolver<ResolversTypes['PackageVersionConnection'], ParentType, ContextType, RequireFields<PackageversionsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PackageConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PackageConnection'] = ResolversParentTypes['PackageConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PackageEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Package']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PackageEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PackageEdge'] = ResolversParentTypes['PackageEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Package']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PackageFileResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PackageFile'] = ResolversParentTypes['PackageFile']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  md5?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  packageVersion?: Resolver<Maybe<ResolversTypes['PackageVersion']>, ParentType, ContextType>;
  sha1?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sha256?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PackageFileConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PackageFileConnection'] = ResolversParentTypes['PackageFileConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PackageFileEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PackageFile']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PackageFileEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PackageFileEdge'] = ResolversParentTypes['PackageFileEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PackageFile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PackageOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PackageOwner'] = ResolversParentTypes['PackageOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'Repository' | 'User', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  packages?: Resolver<ResolversTypes['PackageConnection'], ParentType, ContextType, RequireFields<PackageOwnerpackagesArgs, 'orderBy'>>;
}>;

export type PackageStatisticsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PackageStatistics'] = ResolversParentTypes['PackageStatistics']> = ResolversObject<{
  downloadsTotalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PackageTagResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PackageTag'] = ResolversParentTypes['PackageTag']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['PackageVersion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PackageVersionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PackageVersion'] = ResolversParentTypes['PackageVersion']> = ResolversObject<{
  files?: Resolver<ResolversTypes['PackageFileConnection'], ParentType, ContextType, RequireFields<PackageVersionfilesArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  package?: Resolver<Maybe<ResolversTypes['Package']>, ParentType, ContextType>;
  platform?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  preRelease?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  readme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  release?: Resolver<Maybe<ResolversTypes['Release']>, ParentType, ContextType>;
  statistics?: Resolver<Maybe<ResolversTypes['PackageVersionStatistics']>, ParentType, ContextType>;
  summary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PackageVersionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PackageVersionConnection'] = ResolversParentTypes['PackageVersionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PackageVersionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PackageVersion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PackageVersionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PackageVersionEdge'] = ResolversParentTypes['PackageVersionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PackageVersion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PackageVersionStatisticsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PackageVersionStatistics'] = ResolversParentTypes['PackageVersionStatistics']> = ResolversObject<{
  downloadsTotalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PageInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = ResolversObject<{
  endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PermissionGranterResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PermissionGranter'] = ResolversParentTypes['PermissionGranter']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'Repository' | 'Team', ParentType, ContextType>;
}>;

export type PermissionSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PermissionSource'] = ResolversParentTypes['PermissionSource']> = ResolversObject<{
  organization?: Resolver<ResolversTypes['Organization'], ParentType, ContextType>;
  permission?: Resolver<ResolversTypes['DefaultRepositoryPermissionField'], ParentType, ContextType>;
  roleName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  source?: Resolver<ResolversTypes['PermissionGranter'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PinIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PinIssuePayload'] = ResolversParentTypes['PinIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PinnableItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PinnableItem'] = ResolversParentTypes['PinnableItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Gist' | 'Repository', ParentType, ContextType>;
}>;

export type PinnableItemConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PinnableItemConnection'] = ResolversParentTypes['PinnableItemConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PinnableItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PinnableItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PinnableItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PinnableItemEdge'] = ResolversParentTypes['PinnableItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PinnableItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PinnedDiscussionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PinnedDiscussion'] = ResolversParentTypes['PinnedDiscussion']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  discussion?: Resolver<ResolversTypes['Discussion'], ParentType, ContextType>;
  gradientStopColors?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['PinnedDiscussionPattern'], ParentType, ContextType>;
  pinnedBy?: Resolver<ResolversTypes['Actor'], ParentType, ContextType>;
  preconfiguredGradient?: Resolver<Maybe<ResolversTypes['PinnedDiscussionGradient']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PinnedDiscussionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PinnedDiscussionConnection'] = ResolversParentTypes['PinnedDiscussionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PinnedDiscussionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PinnedDiscussion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PinnedDiscussionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PinnedDiscussionEdge'] = ResolversParentTypes['PinnedDiscussionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PinnedDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PinnedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PinnedEvent'] = ResolversParentTypes['PinnedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['Issue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PinnedIssueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PinnedIssue'] = ResolversParentTypes['PinnedIssue']> = ResolversObject<{
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fullDatabaseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['Issue'], ParentType, ContextType>;
  pinnedBy?: Resolver<ResolversTypes['Actor'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PinnedIssueConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PinnedIssueConnection'] = ResolversParentTypes['PinnedIssueConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PinnedIssueEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PinnedIssue']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PinnedIssueEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PinnedIssueEdge'] = ResolversParentTypes['PinnedIssueEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PinnedIssue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface PreciseDateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['PreciseDateTime'], any> {
  name: 'PreciseDateTime';
}

export type PrivateRepositoryForkingDisableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PrivateRepositoryForkingDisableAuditEntry'] = ResolversParentTypes['PrivateRepositoryForkingDisableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PrivateRepositoryForkingEnableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PrivateRepositoryForkingEnableAuditEntry'] = ResolversParentTypes['PrivateRepositoryForkingEnableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProfileItemShowcaseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProfileItemShowcase'] = ResolversParentTypes['ProfileItemShowcase']> = ResolversObject<{
  hasPinnedItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  items?: Resolver<ResolversTypes['PinnableItemConnection'], ParentType, ContextType, Partial<ProfileItemShowcaseitemsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProfileOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProfileOwner'] = ResolversParentTypes['ProfileOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'User', ParentType, ContextType>;
  anyPinnableItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<ProfileOwneranyPinnableItemsArgs>>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  itemShowcase?: Resolver<ResolversTypes['ProfileItemShowcase'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pinnableItems?: Resolver<ResolversTypes['PinnableItemConnection'], ParentType, ContextType, Partial<ProfileOwnerpinnableItemsArgs>>;
  pinnedItems?: Resolver<ResolversTypes['PinnableItemConnection'], ParentType, ContextType, Partial<ProfileOwnerpinnedItemsArgs>>;
  pinnedItemsRemaining?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerCanChangePinnedItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  websiteUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
}>;

export type ProjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Project'] = ResolversParentTypes['Project']> = ResolversObject<{
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  columns?: Resolver<ResolversTypes['ProjectColumnConnection'], ParentType, ContextType, Partial<ProjectcolumnsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['ProjectOwner'], ParentType, ContextType>;
  pendingCards?: Resolver<ResolversTypes['ProjectCardConnection'], ParentType, ContextType, RequireFields<ProjectpendingCardsArgs, 'archivedStates'>>;
  progress?: Resolver<ResolversTypes['ProjectProgress'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['ProjectState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectCardResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectCard'] = ResolversParentTypes['ProjectCard']> = ResolversObject<{
  column?: Resolver<Maybe<ResolversTypes['ProjectColumn']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['ProjectCardItem']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  note?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<ResolversTypes['Project'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['ProjectCardState']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectCardConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectCardConnection'] = ResolversParentTypes['ProjectCardConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectCardEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectCard']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectCardEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectCardEdge'] = ResolversParentTypes['ProjectCardEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProjectCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectCardItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectCardItem'] = ResolversParentTypes['ProjectCardItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
}>;

export type ProjectColumnResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectColumn'] = ResolversParentTypes['ProjectColumn']> = ResolversObject<{
  cards?: Resolver<ResolversTypes['ProjectCardConnection'], ParentType, ContextType, RequireFields<ProjectColumncardsArgs, 'archivedStates'>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['Project'], ParentType, ContextType>;
  purpose?: Resolver<Maybe<ResolversTypes['ProjectColumnPurpose']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectColumnConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectColumnConnection'] = ResolversParentTypes['ProjectColumnConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectColumnEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectColumn']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectColumnEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectColumnEdge'] = ResolversParentTypes['ProjectColumnEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProjectColumn']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectConnection'] = ResolversParentTypes['ProjectConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Project']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectEdge'] = ResolversParentTypes['ProjectEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectOwner'] = ResolversParentTypes['ProjectOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'Repository' | 'User', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType, RequireFields<ProjectOwnerprojectArgs, 'number'>>;
  projects?: Resolver<ResolversTypes['ProjectConnection'], ParentType, ContextType, Partial<ProjectOwnerprojectsArgs>>;
  projectsResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type ProjectProgressResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectProgress'] = ResolversParentTypes['ProjectProgress']> = ResolversObject<{
  doneCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  donePercentage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  inProgressCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  inProgressPercentage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  todoCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  todoPercentage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2Resolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2'] = ResolversParentTypes['ProjectV2']> = ResolversObject<{
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['ProjectV2FieldConfiguration']>, ParentType, ContextType, RequireFields<ProjectV2fieldArgs, 'name'>>;
  fields?: Resolver<ResolversTypes['ProjectV2FieldConfigurationConnection'], ParentType, ContextType, RequireFields<ProjectV2fieldsArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  items?: Resolver<ResolversTypes['ProjectV2ItemConnection'], ParentType, ContextType, RequireFields<ProjectV2itemsArgs, 'orderBy'>>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['ProjectV2Owner'], ParentType, ContextType>;
  public?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  readme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositories?: Resolver<ResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<ProjectV2repositoriesArgs, 'orderBy'>>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  shortDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teams?: Resolver<ResolversTypes['TeamConnection'], ParentType, ContextType, RequireFields<ProjectV2teamsArgs, 'orderBy'>>;
  template?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  view?: Resolver<Maybe<ResolversTypes['ProjectV2View']>, ParentType, ContextType, RequireFields<ProjectV2viewArgs, 'number'>>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  views?: Resolver<ResolversTypes['ProjectV2ViewConnection'], ParentType, ContextType, RequireFields<ProjectV2viewsArgs, 'orderBy'>>;
  workflow?: Resolver<Maybe<ResolversTypes['ProjectV2Workflow']>, ParentType, ContextType, RequireFields<ProjectV2workflowArgs, 'number'>>;
  workflows?: Resolver<ResolversTypes['ProjectV2WorkflowConnection'], ParentType, ContextType, RequireFields<ProjectV2workflowsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2Actor'] = ResolversParentTypes['ProjectV2Actor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Team' | 'User', ParentType, ContextType>;
}>;

export type ProjectV2ActorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ActorConnection'] = ResolversParentTypes['ProjectV2ActorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2ActorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2Actor']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ActorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ActorEdge'] = ResolversParentTypes['ProjectV2ActorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProjectV2Actor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2Connection'] = ResolversParentTypes['ProjectV2Connection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2Edge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2EdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2Edge'] = ResolversParentTypes['ProjectV2Edge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2FieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2Field'] = ResolversParentTypes['ProjectV2Field']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['ProjectV2FieldType'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2FieldCommonResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2FieldCommon'] = ResolversParentTypes['ProjectV2FieldCommon']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ProjectV2Field' | 'ProjectV2IterationField' | 'ProjectV2SingleSelectField', ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['ProjectV2FieldType'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
}>;

export type ProjectV2FieldConfigurationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2FieldConfiguration'] = ResolversParentTypes['ProjectV2FieldConfiguration']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ProjectV2Field' | 'ProjectV2IterationField' | 'ProjectV2SingleSelectField', ParentType, ContextType>;
}>;

export type ProjectV2FieldConfigurationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2FieldConfigurationConnection'] = ResolversParentTypes['ProjectV2FieldConfigurationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2FieldConfigurationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2FieldConfiguration']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2FieldConfigurationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2FieldConfigurationEdge'] = ResolversParentTypes['ProjectV2FieldConfigurationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProjectV2FieldConfiguration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2FieldConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2FieldConnection'] = ResolversParentTypes['ProjectV2FieldConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2FieldEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2Field']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2FieldEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2FieldEdge'] = ResolversParentTypes['ProjectV2FieldEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProjectV2Field']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2Item'] = ResolversParentTypes['ProjectV2Item']> = ResolversObject<{
  content?: Resolver<Maybe<ResolversTypes['ProjectV2ItemContent']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fieldValueByName?: Resolver<Maybe<ResolversTypes['ProjectV2ItemFieldValue']>, ParentType, ContextType, RequireFields<ProjectV2ItemfieldValueByNameArgs, 'name'>>;
  fieldValues?: Resolver<ResolversTypes['ProjectV2ItemFieldValueConnection'], ParentType, ContextType, RequireFields<ProjectV2ItemfieldValuesArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['ProjectV2'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['ProjectV2ItemType'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemConnection'] = ResolversParentTypes['ProjectV2ItemConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2ItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2Item']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemContentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemContent'] = ResolversParentTypes['ProjectV2ItemContent']> = ResolversObject<{
  __resolveType: TypeResolveFn<'DraftIssue' | 'Issue' | 'PullRequest', ParentType, ContextType>;
}>;

export type ProjectV2ItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemEdge'] = ResolversParentTypes['ProjectV2ItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldDateValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldDateValue'] = ResolversParentTypes['ProjectV2ItemFieldDateValue']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['ProjectV2Item'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldIterationValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldIterationValue'] = ResolversParentTypes['ProjectV2ItemFieldIterationValue']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  duration?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  field?: Resolver<ResolversTypes['ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['ProjectV2Item'], ParentType, ContextType>;
  iterationId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  startDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldLabelValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldLabelValue'] = ResolversParentTypes['ProjectV2ItemFieldLabelValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['ProjectV2FieldConfiguration'], ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType, Partial<ProjectV2ItemFieldLabelValuelabelsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldMilestoneValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldMilestoneValue'] = ResolversParentTypes['ProjectV2ItemFieldMilestoneValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['ProjectV2FieldConfiguration'], ParentType, ContextType>;
  milestone?: Resolver<Maybe<ResolversTypes['Milestone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldNumberValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldNumberValue'] = ResolversParentTypes['ProjectV2ItemFieldNumberValue']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['ProjectV2Item'], ParentType, ContextType>;
  number?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldPullRequestValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldPullRequestValue'] = ResolversParentTypes['ProjectV2ItemFieldPullRequestValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['ProjectV2FieldConfiguration'], ParentType, ContextType>;
  pullRequests?: Resolver<Maybe<ResolversTypes['PullRequestConnection']>, ParentType, ContextType, RequireFields<ProjectV2ItemFieldPullRequestValuepullRequestsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldRepositoryValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldRepositoryValue'] = ResolversParentTypes['ProjectV2ItemFieldRepositoryValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['ProjectV2FieldConfiguration'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldReviewerValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldReviewerValue'] = ResolversParentTypes['ProjectV2ItemFieldReviewerValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['ProjectV2FieldConfiguration'], ParentType, ContextType>;
  reviewers?: Resolver<Maybe<ResolversTypes['RequestedReviewerConnection']>, ParentType, ContextType, Partial<ProjectV2ItemFieldReviewerValuereviewersArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldSingleSelectValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldSingleSelectValue'] = ResolversParentTypes['ProjectV2ItemFieldSingleSelectValue']> = ResolversObject<{
  color?: Resolver<ResolversTypes['ProjectV2SingleSelectFieldOptionColor'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['ProjectV2Item'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nameHTML?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  optionId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldTextValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldTextValue'] = ResolversParentTypes['ProjectV2ItemFieldTextValue']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['ProjectV2Item'], ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldUserValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldUserValue'] = ResolversParentTypes['ProjectV2ItemFieldUserValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['ProjectV2FieldConfiguration'], ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['UserConnection']>, ParentType, ContextType, Partial<ProjectV2ItemFieldUserValueusersArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldValue'] = ResolversParentTypes['ProjectV2ItemFieldValue']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ProjectV2ItemFieldDateValue' | 'ProjectV2ItemFieldIterationValue' | 'ProjectV2ItemFieldLabelValue' | 'ProjectV2ItemFieldMilestoneValue' | 'ProjectV2ItemFieldNumberValue' | 'ProjectV2ItemFieldPullRequestValue' | 'ProjectV2ItemFieldRepositoryValue' | 'ProjectV2ItemFieldReviewerValue' | 'ProjectV2ItemFieldSingleSelectValue' | 'ProjectV2ItemFieldTextValue' | 'ProjectV2ItemFieldUserValue', ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldValueCommonResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldValueCommon'] = ResolversParentTypes['ProjectV2ItemFieldValueCommon']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ProjectV2ItemFieldDateValue' | 'ProjectV2ItemFieldIterationValue' | 'ProjectV2ItemFieldNumberValue' | 'ProjectV2ItemFieldSingleSelectValue' | 'ProjectV2ItemFieldTextValue', ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['ProjectV2Item'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldValueConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldValueConnection'] = ResolversParentTypes['ProjectV2ItemFieldValueConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2ItemFieldValueEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2ItemFieldValue']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ItemFieldValueEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ItemFieldValueEdge'] = ResolversParentTypes['ProjectV2ItemFieldValueEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProjectV2ItemFieldValue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2IterationFieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2IterationField'] = ResolversParentTypes['ProjectV2IterationField']> = ResolversObject<{
  configuration?: Resolver<ResolversTypes['ProjectV2IterationFieldConfiguration'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['ProjectV2FieldType'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2IterationFieldConfigurationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2IterationFieldConfiguration'] = ResolversParentTypes['ProjectV2IterationFieldConfiguration']> = ResolversObject<{
  completedIterations?: Resolver<Array<ResolversTypes['ProjectV2IterationFieldIteration']>, ParentType, ContextType>;
  duration?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  iterations?: Resolver<Array<ResolversTypes['ProjectV2IterationFieldIteration']>, ParentType, ContextType>;
  startDay?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2IterationFieldIterationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2IterationFieldIteration'] = ResolversParentTypes['ProjectV2IterationFieldIteration']> = ResolversObject<{
  duration?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  startDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2OwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2Owner'] = ResolversParentTypes['ProjectV2Owner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Issue' | 'Organization' | 'PullRequest' | 'User', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType, RequireFields<ProjectV2OwnerprojectV2Args, 'number'>>;
  projectsV2?: Resolver<ResolversTypes['ProjectV2Connection'], ParentType, ContextType, RequireFields<ProjectV2OwnerprojectsV2Args, 'orderBy'>>;
}>;

export type ProjectV2RecentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2Recent'] = ResolversParentTypes['ProjectV2Recent']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'Repository' | 'User', ParentType, ContextType>;
  recentProjects?: Resolver<ResolversTypes['ProjectV2Connection'], ParentType, ContextType, Partial<ProjectV2RecentrecentProjectsArgs>>;
}>;

export type ProjectV2SingleSelectFieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2SingleSelectField'] = ResolversParentTypes['ProjectV2SingleSelectField']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['ProjectV2FieldType'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['ProjectV2SingleSelectFieldOption']>, ParentType, ContextType, Partial<ProjectV2SingleSelectFieldoptionsArgs>>;
  project?: Resolver<ResolversTypes['ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2SingleSelectFieldOptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2SingleSelectFieldOption'] = ResolversParentTypes['ProjectV2SingleSelectFieldOption']> = ResolversObject<{
  color?: Resolver<ResolversTypes['ProjectV2SingleSelectFieldOptionColor'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2SortByResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2SortBy'] = ResolversParentTypes['ProjectV2SortBy']> = ResolversObject<{
  direction?: Resolver<ResolversTypes['OrderDirection'], ParentType, ContextType>;
  field?: Resolver<ResolversTypes['ProjectV2Field'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2SortByConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2SortByConnection'] = ResolversParentTypes['ProjectV2SortByConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2SortByEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2SortBy']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2SortByEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2SortByEdge'] = ResolversParentTypes['ProjectV2SortByEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProjectV2SortBy']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2SortByFieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2SortByField'] = ResolversParentTypes['ProjectV2SortByField']> = ResolversObject<{
  direction?: Resolver<ResolversTypes['OrderDirection'], ParentType, ContextType>;
  field?: Resolver<ResolversTypes['ProjectV2FieldConfiguration'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2SortByFieldConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2SortByFieldConnection'] = ResolversParentTypes['ProjectV2SortByFieldConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2SortByFieldEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2SortByField']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2SortByFieldEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2SortByFieldEdge'] = ResolversParentTypes['ProjectV2SortByFieldEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProjectV2SortByField']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ViewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2View'] = ResolversParentTypes['ProjectV2View']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fields?: Resolver<Maybe<ResolversTypes['ProjectV2FieldConfigurationConnection']>, ParentType, ContextType, RequireFields<ProjectV2ViewfieldsArgs, 'orderBy'>>;
  filter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groupBy?: Resolver<Maybe<ResolversTypes['ProjectV2FieldConnection']>, ParentType, ContextType, RequireFields<ProjectV2ViewgroupByArgs, 'orderBy'>>;
  groupByFields?: Resolver<Maybe<ResolversTypes['ProjectV2FieldConfigurationConnection']>, ParentType, ContextType, RequireFields<ProjectV2ViewgroupByFieldsArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  layout?: Resolver<ResolversTypes['ProjectV2ViewLayout'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['ProjectV2'], ParentType, ContextType>;
  sortBy?: Resolver<Maybe<ResolversTypes['ProjectV2SortByConnection']>, ParentType, ContextType, Partial<ProjectV2ViewsortByArgs>>;
  sortByFields?: Resolver<Maybe<ResolversTypes['ProjectV2SortByFieldConnection']>, ParentType, ContextType, Partial<ProjectV2ViewsortByFieldsArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  verticalGroupBy?: Resolver<Maybe<ResolversTypes['ProjectV2FieldConnection']>, ParentType, ContextType, RequireFields<ProjectV2ViewverticalGroupByArgs, 'orderBy'>>;
  verticalGroupByFields?: Resolver<Maybe<ResolversTypes['ProjectV2FieldConfigurationConnection']>, ParentType, ContextType, RequireFields<ProjectV2ViewverticalGroupByFieldsArgs, 'orderBy'>>;
  visibleFields?: Resolver<Maybe<ResolversTypes['ProjectV2FieldConnection']>, ParentType, ContextType, RequireFields<ProjectV2ViewvisibleFieldsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ViewConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ViewConnection'] = ResolversParentTypes['ProjectV2ViewConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2ViewEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2View']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2ViewEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2ViewEdge'] = ResolversParentTypes['ProjectV2ViewEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProjectV2View']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2WorkflowResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2Workflow'] = ResolversParentTypes['ProjectV2Workflow']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2WorkflowConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2WorkflowConnection'] = ResolversParentTypes['ProjectV2WorkflowConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2WorkflowEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProjectV2Workflow']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectV2WorkflowEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectV2WorkflowEdge'] = ResolversParentTypes['ProjectV2WorkflowEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProjectV2Workflow']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PublicKeyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PublicKey'] = ResolversParentTypes['PublicKey']> = ResolversObject<{
  accessedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  fingerprint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isReadOnly?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PublicKeyConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PublicKeyConnection'] = ResolversParentTypes['PublicKeyConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PublicKeyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PublicKey']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PublicKeyEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PublicKeyEdge'] = ResolversParentTypes['PublicKeyEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PublicKey']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PublishSponsorsTierPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PublishSponsorsTierPayload'] = ResolversParentTypes['PublishSponsorsTierPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequest'] = ResolversParentTypes['PullRequest']> = ResolversObject<{
  activeLockReason?: Resolver<Maybe<ResolversTypes['LockReason']>, ParentType, ContextType>;
  additions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  assignees?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<PullRequestassigneesArgs>>;
  author?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  autoMergeRequest?: Resolver<Maybe<ResolversTypes['AutoMergeRequest']>, ParentType, ContextType>;
  baseRef?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  baseRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  baseRefOid?: Resolver<ResolversTypes['GitObjectID'], ParentType, ContextType>;
  baseRepository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  canBeRebased?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  changedFiles?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  checksResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  checksUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  closingIssuesReferences?: Resolver<Maybe<ResolversTypes['IssueConnection']>, ParentType, ContextType, RequireFields<PullRequestclosingIssuesReferencesArgs, 'userLinkedOnly'>>;
  comments?: Resolver<ResolversTypes['IssueCommentConnection'], ParentType, ContextType, Partial<PullRequestcommentsArgs>>;
  commits?: Resolver<ResolversTypes['PullRequestCommitConnection'], ParentType, ContextType, Partial<PullRequestcommitsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deletions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  files?: Resolver<Maybe<ResolversTypes['PullRequestChangedFileConnection']>, ParentType, ContextType, Partial<PullRequestfilesArgs>>;
  headRef?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  headRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  headRefOid?: Resolver<ResolversTypes['GitObjectID'], ParentType, ContextType>;
  headRepository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  headRepositoryOwner?: Resolver<Maybe<ResolversTypes['RepositoryOwner']>, ParentType, ContextType>;
  hovercard?: Resolver<ResolversTypes['Hovercard'], ParentType, ContextType, RequireFields<PullRequesthovercardArgs, 'includeNotificationContexts'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isReadByViewer?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType, RequireFields<PullRequestlabelsArgs, 'orderBy'>>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  latestOpinionatedReviews?: Resolver<Maybe<ResolversTypes['PullRequestReviewConnection']>, ParentType, ContextType, RequireFields<PullRequestlatestOpinionatedReviewsArgs, 'writersOnly'>>;
  latestReviews?: Resolver<Maybe<ResolversTypes['PullRequestReviewConnection']>, ParentType, ContextType, Partial<PullRequestlatestReviewsArgs>>;
  locked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  maintainerCanModify?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mergeCommit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  mergeQueueEntry?: Resolver<Maybe<ResolversTypes['MergeQueueEntry']>, ParentType, ContextType>;
  mergeStateStatus?: Resolver<ResolversTypes['MergeStateStatus'], ParentType, ContextType>;
  mergeable?: Resolver<ResolversTypes['MergeableState'], ParentType, ContextType>;
  merged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mergedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  mergedBy?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  milestone?: Resolver<Maybe<ResolversTypes['Milestone']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  participants?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<PullRequestparticipantsArgs>>;
  permalink?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  potentialMergeCommit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  projectCards?: Resolver<ResolversTypes['ProjectCardConnection'], ParentType, ContextType, RequireFields<PullRequestprojectCardsArgs, 'archivedStates'>>;
  projectItems?: Resolver<ResolversTypes['ProjectV2ItemConnection'], ParentType, ContextType, RequireFields<PullRequestprojectItemsArgs, 'includeArchived'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType, RequireFields<PullRequestprojectV2Args, 'number'>>;
  projectsV2?: Resolver<ResolversTypes['ProjectV2Connection'], ParentType, ContextType, RequireFields<PullRequestprojectsV2Args, 'orderBy'>>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['ReactionConnection'], ParentType, ContextType, Partial<PullRequestreactionsArgs>>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  revertResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  revertUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['PullRequestReviewDecision']>, ParentType, ContextType>;
  reviewRequests?: Resolver<Maybe<ResolversTypes['ReviewRequestConnection']>, ParentType, ContextType, Partial<PullRequestreviewRequestsArgs>>;
  reviewThreads?: Resolver<ResolversTypes['PullRequestReviewThreadConnection'], ParentType, ContextType, Partial<PullRequestreviewThreadsArgs>>;
  reviews?: Resolver<Maybe<ResolversTypes['PullRequestReviewConnection']>, ParentType, ContextType, Partial<PullRequestreviewsArgs>>;
  state?: Resolver<ResolversTypes['PullRequestState'], ParentType, ContextType>;
  suggestedReviewers?: Resolver<Array<Maybe<ResolversTypes['SuggestedReviewer']>>, ParentType, ContextType>;
  timeline?: Resolver<ResolversTypes['PullRequestTimelineConnection'], ParentType, ContextType, Partial<PullRequesttimelineArgs>>;
  timelineItems?: Resolver<ResolversTypes['PullRequestTimelineItemsConnection'], ParentType, ContextType, Partial<PullRequesttimelineItemsArgs>>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  totalCommentsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['UserContentEditConnection']>, ParentType, ContextType, Partial<PullRequestuserContentEditsArgs>>;
  viewerCanApplySuggestion?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDeleteHeadRef?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDisableAutoMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEditFiles?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEnableAutoMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMergeAsAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdateBranch?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerLatestReview?: Resolver<Maybe<ResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  viewerLatestReviewRequest?: Resolver<Maybe<ResolversTypes['ReviewRequest']>, ParentType, ContextType>;
  viewerMergeBodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType, Partial<PullRequestviewerMergeBodyTextArgs>>;
  viewerMergeHeadlineText?: Resolver<ResolversTypes['String'], ParentType, ContextType, Partial<PullRequestviewerMergeHeadlineTextArgs>>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestChangedFileResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestChangedFile'] = ResolversParentTypes['PullRequestChangedFile']> = ResolversObject<{
  additions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  changeType?: Resolver<ResolversTypes['PatchStatus'], ParentType, ContextType>;
  deletions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  viewerViewedState?: Resolver<ResolversTypes['FileViewedState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestChangedFileConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestChangedFileConnection'] = ResolversParentTypes['PullRequestChangedFileConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestChangedFileEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestChangedFile']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestChangedFileEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestChangedFileEdge'] = ResolversParentTypes['PullRequestChangedFileEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PullRequestChangedFile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestCommitResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestCommit'] = ResolversParentTypes['PullRequestCommit']> = ResolversObject<{
  commit?: Resolver<ResolversTypes['Commit'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestCommitCommentThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestCommitCommentThread'] = ResolversParentTypes['PullRequestCommitCommentThread']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['CommitCommentConnection'], ParentType, ContextType, Partial<PullRequestCommitCommentThreadcommentsArgs>>;
  commit?: Resolver<ResolversTypes['Commit'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestCommitConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestCommitConnection'] = ResolversParentTypes['PullRequestCommitConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestCommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestCommit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestCommitEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestCommitEdge'] = ResolversParentTypes['PullRequestCommitEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PullRequestCommit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestConnection'] = ResolversParentTypes['PullRequestConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestContributionsByRepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestContributionsByRepository'] = ResolversParentTypes['PullRequestContributionsByRepository']> = ResolversObject<{
  contributions?: Resolver<ResolversTypes['CreatedPullRequestContributionConnection'], ParentType, ContextType, RequireFields<PullRequestContributionsByRepositorycontributionsArgs, 'orderBy'>>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestEdge'] = ResolversParentTypes['PullRequestEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestParameters'] = ResolversParentTypes['PullRequestParameters']> = ResolversObject<{
  dismissStaleReviewsOnPush?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requireCodeOwnerReview?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requireLastPushApproval?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiredApprovingReviewCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  requiredReviewThreadResolution?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestReviewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestReview'] = ResolversParentTypes['PullRequestReview']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  authorCanPushToRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['PullRequestReviewCommentConnection'], ParentType, ContextType, Partial<PullRequestReviewcommentsArgs>>;
  commit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  onBehalfOf?: Resolver<ResolversTypes['TeamConnection'], ParentType, ContextType, Partial<PullRequestReviewonBehalfOfArgs>>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['ReactionConnection'], ParentType, ContextType, Partial<PullRequestReviewreactionsArgs>>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['PullRequestReviewState'], ParentType, ContextType>;
  submittedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['UserContentEditConnection']>, ParentType, ContextType, Partial<PullRequestReviewuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestReviewCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestReviewComment'] = ResolversParentTypes['PullRequestReviewComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  diffHunk?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  draftedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  line?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  originalCommit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  originalLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  originalPosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  originalStartLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  outdated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['ReactionConnection'], ParentType, ContextType, Partial<PullRequestReviewCommentreactionsArgs>>;
  replyTo?: Resolver<Maybe<ResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  startLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['PullRequestReviewCommentState'], ParentType, ContextType>;
  subjectType?: Resolver<ResolversTypes['PullRequestReviewThreadSubjectType'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['UserContentEditConnection']>, ParentType, ContextType, Partial<PullRequestReviewCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestReviewCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestReviewCommentConnection'] = ResolversParentTypes['PullRequestReviewCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestReviewCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestReviewComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestReviewCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestReviewCommentEdge'] = ResolversParentTypes['PullRequestReviewCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestReviewConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestReviewConnection'] = ResolversParentTypes['PullRequestReviewConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestReviewEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestReview']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestReviewContributionsByRepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestReviewContributionsByRepository'] = ResolversParentTypes['PullRequestReviewContributionsByRepository']> = ResolversObject<{
  contributions?: Resolver<ResolversTypes['CreatedPullRequestReviewContributionConnection'], ParentType, ContextType, RequireFields<PullRequestReviewContributionsByRepositorycontributionsArgs, 'orderBy'>>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestReviewEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestReviewEdge'] = ResolversParentTypes['PullRequestReviewEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestReviewThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestReviewThread'] = ResolversParentTypes['PullRequestReviewThread']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['PullRequestReviewCommentConnection'], ParentType, ContextType, Partial<PullRequestReviewThreadcommentsArgs>>;
  diffSide?: Resolver<ResolversTypes['DiffSide'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCollapsed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOutdated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isResolved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  line?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  originalLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  originalStartLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resolvedBy?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  startDiffSide?: Resolver<Maybe<ResolversTypes['DiffSide']>, ParentType, ContextType>;
  startLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  subjectType?: Resolver<ResolversTypes['PullRequestReviewThreadSubjectType'], ParentType, ContextType>;
  viewerCanReply?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanResolve?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUnresolve?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestReviewThreadConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestReviewThreadConnection'] = ResolversParentTypes['PullRequestReviewThreadConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestReviewThreadEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestReviewThread']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestReviewThreadEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestReviewThreadEdge'] = ResolversParentTypes['PullRequestReviewThreadEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestRevisionMarkerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestRevisionMarker'] = ResolversParentTypes['PullRequestRevisionMarker']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastSeenCommit?: Resolver<ResolversTypes['Commit'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestTemplateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestTemplate'] = ResolversParentTypes['PullRequestTemplate']> = ResolversObject<{
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filename?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestThread'] = ResolversParentTypes['PullRequestThread']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['PullRequestReviewCommentConnection'], ParentType, ContextType, Partial<PullRequestThreadcommentsArgs>>;
  diffSide?: Resolver<ResolversTypes['DiffSide'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCollapsed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOutdated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isResolved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  line?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resolvedBy?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  startDiffSide?: Resolver<Maybe<ResolversTypes['DiffSide']>, ParentType, ContextType>;
  startLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  subjectType?: Resolver<ResolversTypes['PullRequestReviewThreadSubjectType'], ParentType, ContextType>;
  viewerCanReply?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanResolve?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUnresolve?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestTimelineConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestTimelineConnection'] = ResolversParentTypes['PullRequestTimelineConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestTimelineItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestTimelineItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestTimelineItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestTimelineItem'] = ResolversParentTypes['PullRequestTimelineItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AssignedEvent' | 'BaseRefDeletedEvent' | 'BaseRefForcePushedEvent' | 'ClosedEvent' | 'Commit' | 'CommitCommentThread' | 'CrossReferencedEvent' | 'DemilestonedEvent' | 'DeployedEvent' | 'DeploymentEnvironmentChangedEvent' | 'HeadRefDeletedEvent' | 'HeadRefForcePushedEvent' | 'HeadRefRestoredEvent' | 'IssueComment' | 'LabeledEvent' | 'LockedEvent' | 'MergedEvent' | 'MilestonedEvent' | 'PullRequestReview' | 'PullRequestReviewComment' | 'PullRequestReviewThread' | 'ReferencedEvent' | 'RenamedTitleEvent' | 'ReopenedEvent' | 'ReviewDismissedEvent' | 'ReviewRequestRemovedEvent' | 'ReviewRequestedEvent' | 'SubscribedEvent' | 'UnassignedEvent' | 'UnlabeledEvent' | 'UnlockedEvent' | 'UnsubscribedEvent' | 'UserBlockedEvent', ParentType, ContextType>;
}>;

export type PullRequestTimelineItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestTimelineItemEdge'] = ResolversParentTypes['PullRequestTimelineItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PullRequestTimelineItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestTimelineItemsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestTimelineItems'] = ResolversParentTypes['PullRequestTimelineItems']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AddedToMergeQueueEvent' | 'AddedToProjectEvent' | 'AssignedEvent' | 'AutoMergeDisabledEvent' | 'AutoMergeEnabledEvent' | 'AutoRebaseEnabledEvent' | 'AutoSquashEnabledEvent' | 'AutomaticBaseChangeFailedEvent' | 'AutomaticBaseChangeSucceededEvent' | 'BaseRefChangedEvent' | 'BaseRefDeletedEvent' | 'BaseRefForcePushedEvent' | 'ClosedEvent' | 'CommentDeletedEvent' | 'ConnectedEvent' | 'ConvertToDraftEvent' | 'ConvertedNoteToIssueEvent' | 'ConvertedToDiscussionEvent' | 'CrossReferencedEvent' | 'DemilestonedEvent' | 'DeployedEvent' | 'DeploymentEnvironmentChangedEvent' | 'DisconnectedEvent' | 'HeadRefDeletedEvent' | 'HeadRefForcePushedEvent' | 'HeadRefRestoredEvent' | 'IssueComment' | 'LabeledEvent' | 'LockedEvent' | 'MarkedAsDuplicateEvent' | 'MentionedEvent' | 'MergedEvent' | 'MilestonedEvent' | 'MovedColumnsInProjectEvent' | 'PinnedEvent' | 'PullRequestCommit' | 'PullRequestCommitCommentThread' | 'PullRequestReview' | 'PullRequestReviewThread' | 'PullRequestRevisionMarker' | 'ReadyForReviewEvent' | 'ReferencedEvent' | 'RemovedFromMergeQueueEvent' | 'RemovedFromProjectEvent' | 'RenamedTitleEvent' | 'ReopenedEvent' | 'ReviewDismissedEvent' | 'ReviewRequestRemovedEvent' | 'ReviewRequestedEvent' | 'SubscribedEvent' | 'TransferredEvent' | 'UnassignedEvent' | 'UnlabeledEvent' | 'UnlockedEvent' | 'UnmarkedAsDuplicateEvent' | 'UnpinnedEvent' | 'UnsubscribedEvent' | 'UserBlockedEvent', ParentType, ContextType>;
}>;

export type PullRequestTimelineItemsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestTimelineItemsConnection'] = ResolversParentTypes['PullRequestTimelineItemsConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestTimelineItemsEdge']>>>, ParentType, ContextType>;
  filteredCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PullRequestTimelineItems']>>>, ParentType, ContextType>;
  pageCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PullRequestTimelineItemsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PullRequestTimelineItemsEdge'] = ResolversParentTypes['PullRequestTimelineItemsEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PullRequestTimelineItems']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PushResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Push'] = ResolversParentTypes['Push']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  nextSha?: Resolver<Maybe<ResolversTypes['GitObjectID']>, ParentType, ContextType>;
  permalink?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  previousSha?: Resolver<Maybe<ResolversTypes['GitObjectID']>, ParentType, ContextType>;
  pusher?: Resolver<ResolversTypes['Actor'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PushAllowanceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PushAllowance'] = ResolversParentTypes['PushAllowance']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['PushAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PushAllowanceActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PushAllowanceActor'] = ResolversParentTypes['PushAllowanceActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'App' | 'Team' | 'User', ParentType, ContextType>;
}>;

export type PushAllowanceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PushAllowanceConnection'] = ResolversParentTypes['PushAllowanceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PushAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['PushAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PushAllowanceEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PushAllowanceEdge'] = ResolversParentTypes['PushAllowanceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PushAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{
  codeOfConduct?: Resolver<Maybe<ResolversTypes['CodeOfConduct']>, ParentType, ContextType, RequireFields<QuerycodeOfConductArgs, 'key'>>;
  codesOfConduct?: Resolver<Maybe<Array<Maybe<ResolversTypes['CodeOfConduct']>>>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType, RequireFields<QueryenterpriseArgs, 'slug'>>;
  enterpriseAdministratorInvitation?: Resolver<Maybe<ResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType, RequireFields<QueryenterpriseAdministratorInvitationArgs, 'enterpriseSlug' | 'role' | 'userLogin'>>;
  enterpriseAdministratorInvitationByToken?: Resolver<Maybe<ResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType, RequireFields<QueryenterpriseAdministratorInvitationByTokenArgs, 'invitationToken'>>;
  license?: Resolver<Maybe<ResolversTypes['License']>, ParentType, ContextType, RequireFields<QuerylicenseArgs, 'key'>>;
  licenses?: Resolver<Array<Maybe<ResolversTypes['License']>>, ParentType, ContextType>;
  marketplaceCategories?: Resolver<Array<ResolversTypes['MarketplaceCategory']>, ParentType, ContextType, Partial<QuerymarketplaceCategoriesArgs>>;
  marketplaceCategory?: Resolver<Maybe<ResolversTypes['MarketplaceCategory']>, ParentType, ContextType, RequireFields<QuerymarketplaceCategoryArgs, 'slug'>>;
  marketplaceListing?: Resolver<Maybe<ResolversTypes['MarketplaceListing']>, ParentType, ContextType, RequireFields<QuerymarketplaceListingArgs, 'slug'>>;
  marketplaceListings?: Resolver<ResolversTypes['MarketplaceListingConnection'], ParentType, ContextType, RequireFields<QuerymarketplaceListingsArgs, 'primaryCategoryOnly' | 'withFreeTrialsOnly'>>;
  meta?: Resolver<ResolversTypes['GitHubMetadata'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType, RequireFields<QuerynodeArgs, 'id'>>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['Node']>>, ParentType, ContextType, RequireFields<QuerynodesArgs, 'ids'>>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType, RequireFields<QueryorganizationArgs, 'login'>>;
  rateLimit?: Resolver<Maybe<ResolversTypes['RateLimit']>, ParentType, ContextType, RequireFields<QueryrateLimitArgs, 'dryRun'>>;
  relay?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType, RequireFields<QueryrepositoryArgs, 'followRenames' | 'name' | 'owner'>>;
  repositoryOwner?: Resolver<Maybe<ResolversTypes['RepositoryOwner']>, ParentType, ContextType, RequireFields<QueryrepositoryOwnerArgs, 'login'>>;
  resource?: Resolver<Maybe<ResolversTypes['UniformResourceLocatable']>, ParentType, ContextType, RequireFields<QueryresourceArgs, 'url'>>;
  search?: Resolver<ResolversTypes['SearchResultItemConnection'], ParentType, ContextType, RequireFields<QuerysearchArgs, 'query' | 'type'>>;
  securityAdvisories?: Resolver<ResolversTypes['SecurityAdvisoryConnection'], ParentType, ContextType, RequireFields<QuerysecurityAdvisoriesArgs, 'orderBy'>>;
  securityAdvisory?: Resolver<Maybe<ResolversTypes['SecurityAdvisory']>, ParentType, ContextType, RequireFields<QuerysecurityAdvisoryArgs, 'ghsaId'>>;
  securityVulnerabilities?: Resolver<ResolversTypes['SecurityVulnerabilityConnection'], ParentType, ContextType, RequireFields<QuerysecurityVulnerabilitiesArgs, 'orderBy'>>;
  sponsorables?: Resolver<ResolversTypes['SponsorableItemConnection'], ParentType, ContextType, RequireFields<QuerysponsorablesArgs, 'onlyDependencies' | 'orderBy'>>;
  topic?: Resolver<Maybe<ResolversTypes['Topic']>, ParentType, ContextType, RequireFields<QuerytopicArgs, 'name'>>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryuserArgs, 'login'>>;
  viewer?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
}>;

export type RateLimitResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RateLimit'] = ResolversParentTypes['RateLimit']> = ResolversObject<{
  cost?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  limit?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  remaining?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  resetAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  used?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReactableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Reactable'] = ResolversParentTypes['Reactable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CommitComment' | 'Discussion' | 'DiscussionComment' | 'Issue' | 'IssueComment' | 'PullRequest' | 'PullRequestReview' | 'PullRequestReviewComment' | 'Release' | 'TeamDiscussion' | 'TeamDiscussionComment', ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['ReactionConnection'], ParentType, ContextType, Partial<ReactablereactionsArgs>>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type ReactingUserConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReactingUserConnection'] = ResolversParentTypes['ReactingUserConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ReactingUserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReactingUserEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReactingUserEdge'] = ResolversParentTypes['ReactingUserEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  reactedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReactionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Reaction'] = ResolversParentTypes['Reaction']> = ResolversObject<{
  content?: Resolver<ResolversTypes['ReactionContent'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  reactable?: Resolver<ResolversTypes['Reactable'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReactionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReactionConnection'] = ResolversParentTypes['ReactionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ReactionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Reaction']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerHasReacted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReactionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReactionEdge'] = ResolversParentTypes['ReactionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Reaction']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReactionGroupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReactionGroup'] = ResolversParentTypes['ReactionGroup']> = ResolversObject<{
  content?: Resolver<ResolversTypes['ReactionContent'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactors?: Resolver<ResolversTypes['ReactorConnection'], ParentType, ContextType, Partial<ReactionGroupreactorsArgs>>;
  subject?: Resolver<ResolversTypes['Reactable'], ParentType, ContextType>;
  users?: Resolver<ResolversTypes['ReactingUserConnection'], ParentType, ContextType, Partial<ReactionGroupusersArgs>>;
  viewerHasReacted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReactorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Reactor'] = ResolversParentTypes['Reactor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Bot' | 'Mannequin' | 'Organization' | 'User', ParentType, ContextType>;
}>;

export type ReactorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReactorConnection'] = ResolversParentTypes['ReactorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ReactorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Reactor']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReactorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReactorEdge'] = ResolversParentTypes['ReactorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Reactor'], ParentType, ContextType>;
  reactedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReadyForReviewEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReadyForReviewEvent'] = ResolversParentTypes['ReadyForReviewEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RefResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Ref'] = ResolversParentTypes['Ref']> = ResolversObject<{
  associatedPullRequests?: Resolver<ResolversTypes['PullRequestConnection'], ParentType, ContextType, Partial<RefassociatedPullRequestsArgs>>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  compare?: Resolver<Maybe<ResolversTypes['Comparison']>, ParentType, ContextType, RequireFields<RefcompareArgs, 'headRef'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  prefix?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  refUpdateRule?: Resolver<Maybe<ResolversTypes['RefUpdateRule']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['GitObject']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RefConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RefConnection'] = ResolversParentTypes['RefConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RefEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Ref']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RefEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RefEdge'] = ResolversParentTypes['RefEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RefNameConditionTargetResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RefNameConditionTarget'] = ResolversParentTypes['RefNameConditionTarget']> = ResolversObject<{
  exclude?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  include?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RefUpdateRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RefUpdateRule'] = ResolversParentTypes['RefUpdateRule']> = ResolversObject<{
  allowsDeletions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  allowsForcePushes?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  blocksCreations?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  requiredApprovingReviewCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  requiredStatusCheckContexts?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  requiresCodeOwnerReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresConversationResolution?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresLinearHistory?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresSignatures?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerAllowedToDismissReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanPush?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReferencedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReferencedEvent'] = ResolversParentTypes['ReferencedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  commitRepository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDirectReference?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReferencedSubjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReferencedSubject'] = ResolversParentTypes['ReferencedSubject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
}>;

export type RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RegenerateEnterpriseIdentityProviderRecoveryCodesPayload'] = ResolversParentTypes['RegenerateEnterpriseIdentityProviderRecoveryCodesPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identityProvider?: Resolver<Maybe<ResolversTypes['EnterpriseIdentityProvider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RegenerateVerifiableDomainTokenPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RegenerateVerifiableDomainTokenPayload'] = ResolversParentTypes['RegenerateVerifiableDomainTokenPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  verificationToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RejectDeploymentsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RejectDeploymentsPayload'] = ResolversParentTypes['RejectDeploymentsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deployments?: Resolver<Maybe<Array<ResolversTypes['Deployment']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReleaseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Release'] = ResolversParentTypes['Release']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<Maybe<ResolversTypes['HTML']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isLatest?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPrerelease?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mentions?: Resolver<Maybe<ResolversTypes['UserConnection']>, ParentType, ContextType, Partial<ReleasementionsArgs>>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['ReactionConnection'], ParentType, ContextType, Partial<ReleasereactionsArgs>>;
  releaseAssets?: Resolver<ResolversTypes['ReleaseAssetConnection'], ParentType, ContextType, Partial<ReleasereleaseAssetsArgs>>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<Maybe<ResolversTypes['HTML']>, ParentType, ContextType, RequireFields<ReleaseshortDescriptionHTMLArgs, 'limit'>>;
  tag?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  tagCommit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  tagName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReleaseAssetResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReleaseAsset'] = ResolversParentTypes['ReleaseAsset']> = ResolversObject<{
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  downloadCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  downloadUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  release?: Resolver<Maybe<ResolversTypes['Release']>, ParentType, ContextType>;
  size?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  uploadedBy?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReleaseAssetConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReleaseAssetConnection'] = ResolversParentTypes['ReleaseAssetConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ReleaseAssetEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ReleaseAsset']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReleaseAssetEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReleaseAssetEdge'] = ResolversParentTypes['ReleaseAssetEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReleaseAsset']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReleaseConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReleaseConnection'] = ResolversParentTypes['ReleaseConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ReleaseEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Release']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReleaseEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReleaseEdge'] = ResolversParentTypes['ReleaseEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Release']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RemoveAssigneesFromAssignablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RemoveAssigneesFromAssignablePayload'] = ResolversParentTypes['RemoveAssigneesFromAssignablePayload']> = ResolversObject<{
  assignable?: Resolver<Maybe<ResolversTypes['Assignable']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RemoveEnterpriseAdminPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RemoveEnterpriseAdminPayload'] = ResolversParentTypes['RemoveEnterpriseAdminPayload']> = ResolversObject<{
  admin?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RemoveEnterpriseIdentityProviderPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RemoveEnterpriseIdentityProviderPayload'] = ResolversParentTypes['RemoveEnterpriseIdentityProviderPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identityProvider?: Resolver<Maybe<ResolversTypes['EnterpriseIdentityProvider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RemoveEnterpriseMemberPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RemoveEnterpriseMemberPayload'] = ResolversParentTypes['RemoveEnterpriseMemberPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RemoveEnterpriseOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RemoveEnterpriseOrganizationPayload'] = ResolversParentTypes['RemoveEnterpriseOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RemoveEnterpriseSupportEntitlementPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RemoveEnterpriseSupportEntitlementPayload'] = ResolversParentTypes['RemoveEnterpriseSupportEntitlementPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RemoveLabelsFromLabelablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RemoveLabelsFromLabelablePayload'] = ResolversParentTypes['RemoveLabelsFromLabelablePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labelable?: Resolver<Maybe<ResolversTypes['Labelable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RemoveOutsideCollaboratorPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RemoveOutsideCollaboratorPayload'] = ResolversParentTypes['RemoveOutsideCollaboratorPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  removedUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RemoveReactionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RemoveReactionPayload'] = ResolversParentTypes['RemoveReactionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reaction?: Resolver<Maybe<ResolversTypes['Reaction']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['Reactable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RemoveStarPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RemoveStarPayload'] = ResolversParentTypes['RemoveStarPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  starrable?: Resolver<Maybe<ResolversTypes['Starrable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RemoveUpvotePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RemoveUpvotePayload'] = ResolversParentTypes['RemoveUpvotePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['Votable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RemovedFromMergeQueueEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RemovedFromMergeQueueEvent'] = ResolversParentTypes['RemovedFromMergeQueueEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  beforeCommit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enqueuer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  mergeQueue?: Resolver<Maybe<ResolversTypes['MergeQueue']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RemovedFromProjectEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RemovedFromProjectEvent'] = ResolversParentTypes['RemovedFromProjectEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  projectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RenamedTitleEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RenamedTitleEvent'] = ResolversParentTypes['RenamedTitleEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  currentTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  previousTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['RenamedTitleSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RenamedTitleSubjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RenamedTitleSubject'] = ResolversParentTypes['RenamedTitleSubject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
}>;

export type ReopenDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReopenDiscussionPayload'] = ResolversParentTypes['ReopenDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReopenIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReopenIssuePayload'] = ResolversParentTypes['ReopenIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReopenPullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReopenPullRequestPayload'] = ResolversParentTypes['ReopenPullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReopenedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReopenedEvent'] = ResolversParentTypes['ReopenedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  closable?: Resolver<ResolversTypes['Closable'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  stateReason?: Resolver<Maybe<ResolversTypes['IssueStateReason']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoAccessAuditEntry'] = ResolversParentTypes['RepoAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['RepoAccessAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoAddMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoAddMemberAuditEntry'] = ResolversParentTypes['RepoAddMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['RepoAddMemberAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoAddTopicAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoAddTopicAuditEntry'] = ResolversParentTypes['RepoAddTopicAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['Topic']>, ParentType, ContextType>;
  topicName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoArchivedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoArchivedAuditEntry'] = ResolversParentTypes['RepoArchivedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['RepoArchivedAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoChangeMergeSettingAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoChangeMergeSettingAuditEntry'] = ResolversParentTypes['RepoChangeMergeSettingAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  mergeType?: Resolver<Maybe<ResolversTypes['RepoChangeMergeSettingAuditEntryMergeType']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoConfigDisableAnonymousGitAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] = ResolversParentTypes['RepoConfigDisableAnonymousGitAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] = ResolversParentTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoConfigDisableContributorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoConfigDisableContributorsOnlyAuditEntry'] = ResolversParentTypes['RepoConfigDisableContributorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoConfigDisableSockpuppetDisallowedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] = ResolversParentTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoConfigEnableAnonymousGitAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] = ResolversParentTypes['RepoConfigEnableAnonymousGitAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] = ResolversParentTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoConfigEnableContributorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoConfigEnableContributorsOnlyAuditEntry'] = ResolversParentTypes['RepoConfigEnableContributorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoConfigEnableSockpuppetDisallowedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] = ResolversParentTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoConfigLockAnonymousGitAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] = ResolversParentTypes['RepoConfigLockAnonymousGitAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoConfigUnlockAnonymousGitAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] = ResolversParentTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoCreateAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoCreateAuditEntry'] = ResolversParentTypes['RepoCreateAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  forkParentName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  forkSourceName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['RepoCreateAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoDestroyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoDestroyAuditEntry'] = ResolversParentTypes['RepoDestroyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['RepoDestroyAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoRemoveMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoRemoveMemberAuditEntry'] = ResolversParentTypes['RepoRemoveMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['RepoRemoveMemberAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepoRemoveTopicAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepoRemoveTopicAuditEntry'] = ResolversParentTypes['RepoRemoveTopicAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['Topic']>, ParentType, ContextType>;
  topicName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Repository'] = ResolversParentTypes['Repository']> = ResolversObject<{
  allowUpdateBranch?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  archivedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  assignableUsers?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<RepositoryassignableUsersArgs>>;
  autoMergeAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  branchProtectionRules?: Resolver<ResolversTypes['BranchProtectionRuleConnection'], ParentType, ContextType, Partial<RepositorybranchProtectionRulesArgs>>;
  codeOfConduct?: Resolver<Maybe<ResolversTypes['CodeOfConduct']>, ParentType, ContextType>;
  codeowners?: Resolver<Maybe<ResolversTypes['RepositoryCodeowners']>, ParentType, ContextType, Partial<RepositorycodeownersArgs>>;
  collaborators?: Resolver<Maybe<ResolversTypes['RepositoryCollaboratorConnection']>, ParentType, ContextType, Partial<RepositorycollaboratorsArgs>>;
  commitComments?: Resolver<ResolversTypes['CommitCommentConnection'], ParentType, ContextType, Partial<RepositorycommitCommentsArgs>>;
  contactLinks?: Resolver<Maybe<Array<ResolversTypes['RepositoryContactLink']>>, ParentType, ContextType>;
  contributingGuidelines?: Resolver<Maybe<ResolversTypes['ContributingGuidelines']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  defaultBranchRef?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  deleteBranchOnMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  dependencyGraphManifests?: Resolver<Maybe<ResolversTypes['DependencyGraphManifestConnection']>, ParentType, ContextType, Partial<RepositorydependencyGraphManifestsArgs>>;
  deployKeys?: Resolver<ResolversTypes['DeployKeyConnection'], ParentType, ContextType, Partial<RepositorydeployKeysArgs>>;
  deployments?: Resolver<ResolversTypes['DeploymentConnection'], ParentType, ContextType, RequireFields<RepositorydeploymentsArgs, 'orderBy'>>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Discussion']>, ParentType, ContextType, RequireFields<RepositorydiscussionArgs, 'number'>>;
  discussionCategories?: Resolver<ResolversTypes['DiscussionCategoryConnection'], ParentType, ContextType, RequireFields<RepositorydiscussionCategoriesArgs, 'filterByAssignable'>>;
  discussionCategory?: Resolver<Maybe<ResolversTypes['DiscussionCategory']>, ParentType, ContextType, RequireFields<RepositorydiscussionCategoryArgs, 'slug'>>;
  discussions?: Resolver<ResolversTypes['DiscussionConnection'], ParentType, ContextType, RequireFields<RepositorydiscussionsArgs, 'answered' | 'categoryId' | 'orderBy' | 'states'>>;
  diskUsage?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['Environment']>, ParentType, ContextType, RequireFields<RepositoryenvironmentArgs, 'name'>>;
  environments?: Resolver<ResolversTypes['EnvironmentConnection'], ParentType, ContextType, RequireFields<RepositoryenvironmentsArgs, 'orderBy'>>;
  forkCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  forkingAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  forks?: Resolver<ResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<RepositoryforksArgs, 'ownerAffiliations'>>;
  fundingLinks?: Resolver<Array<ResolversTypes['FundingLink']>, ParentType, ContextType>;
  hasDiscussionsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasIssuesEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasProjectsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasVulnerabilityAlertsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasWikiEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  homepageUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  interactionAbility?: Resolver<Maybe<ResolversTypes['RepositoryInteractionAbility']>, ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isBlankIssuesEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDisabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isEmpty?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isFork?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isInOrganization?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isLocked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMirror?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSecurityPolicyEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isTemplate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isUserConfigurationRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Issue']>, ParentType, ContextType, RequireFields<RepositoryissueArgs, 'number'>>;
  issueOrPullRequest?: Resolver<Maybe<ResolversTypes['IssueOrPullRequest']>, ParentType, ContextType, RequireFields<RepositoryissueOrPullRequestArgs, 'number'>>;
  issueTemplates?: Resolver<Maybe<Array<ResolversTypes['IssueTemplate']>>, ParentType, ContextType>;
  issues?: Resolver<ResolversTypes['IssueConnection'], ParentType, ContextType, Partial<RepositoryissuesArgs>>;
  label?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType, RequireFields<RepositorylabelArgs, 'name'>>;
  labels?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType, RequireFields<RepositorylabelsArgs, 'orderBy'>>;
  languages?: Resolver<Maybe<ResolversTypes['LanguageConnection']>, ParentType, ContextType, Partial<RepositorylanguagesArgs>>;
  latestRelease?: Resolver<Maybe<ResolversTypes['Release']>, ParentType, ContextType>;
  licenseInfo?: Resolver<Maybe<ResolversTypes['License']>, ParentType, ContextType>;
  lockReason?: Resolver<Maybe<ResolversTypes['RepositoryLockReason']>, ParentType, ContextType>;
  mentionableUsers?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<RepositorymentionableUsersArgs>>;
  mergeCommitAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mergeCommitMessage?: Resolver<ResolversTypes['MergeCommitMessage'], ParentType, ContextType>;
  mergeCommitTitle?: Resolver<ResolversTypes['MergeCommitTitle'], ParentType, ContextType>;
  mergeQueue?: Resolver<Maybe<ResolversTypes['MergeQueue']>, ParentType, ContextType, Partial<RepositorymergeQueueArgs>>;
  milestone?: Resolver<Maybe<ResolversTypes['Milestone']>, ParentType, ContextType, RequireFields<RepositorymilestoneArgs, 'number'>>;
  milestones?: Resolver<Maybe<ResolversTypes['MilestoneConnection']>, ParentType, ContextType, Partial<RepositorymilestonesArgs>>;
  mirrorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameWithOwner?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  object?: Resolver<Maybe<ResolversTypes['GitObject']>, ParentType, ContextType, Partial<RepositoryobjectArgs>>;
  openGraphImageUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['RepositoryOwner'], ParentType, ContextType>;
  packages?: Resolver<ResolversTypes['PackageConnection'], ParentType, ContextType, RequireFields<RepositorypackagesArgs, 'orderBy'>>;
  parent?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  pinnedDiscussions?: Resolver<ResolversTypes['PinnedDiscussionConnection'], ParentType, ContextType, Partial<RepositorypinnedDiscussionsArgs>>;
  pinnedIssues?: Resolver<Maybe<ResolversTypes['PinnedIssueConnection']>, ParentType, ContextType, Partial<RepositorypinnedIssuesArgs>>;
  primaryLanguage?: Resolver<Maybe<ResolversTypes['Language']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType, RequireFields<RepositoryprojectArgs, 'number'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType, RequireFields<RepositoryprojectV2Args, 'number'>>;
  projects?: Resolver<ResolversTypes['ProjectConnection'], ParentType, ContextType, Partial<RepositoryprojectsArgs>>;
  projectsResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  projectsV2?: Resolver<ResolversTypes['ProjectV2Connection'], ParentType, ContextType, RequireFields<RepositoryprojectsV2Args, 'orderBy'>>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType, RequireFields<RepositorypullRequestArgs, 'number'>>;
  pullRequestTemplates?: Resolver<Maybe<Array<ResolversTypes['PullRequestTemplate']>>, ParentType, ContextType>;
  pullRequests?: Resolver<ResolversTypes['PullRequestConnection'], ParentType, ContextType, Partial<RepositorypullRequestsArgs>>;
  pushedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  rebaseMergeAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  recentProjects?: Resolver<ResolversTypes['ProjectV2Connection'], ParentType, ContextType, Partial<RepositoryrecentProjectsArgs>>;
  ref?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType, RequireFields<RepositoryrefArgs, 'qualifiedName'>>;
  refs?: Resolver<Maybe<ResolversTypes['RefConnection']>, ParentType, ContextType, RequireFields<RepositoryrefsArgs, 'refPrefix'>>;
  release?: Resolver<Maybe<ResolversTypes['Release']>, ParentType, ContextType, RequireFields<RepositoryreleaseArgs, 'tagName'>>;
  releases?: Resolver<ResolversTypes['ReleaseConnection'], ParentType, ContextType, Partial<RepositoryreleasesArgs>>;
  repositoryTopics?: Resolver<ResolversTypes['RepositoryTopicConnection'], ParentType, ContextType, Partial<RepositoryrepositoryTopicsArgs>>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  ruleset?: Resolver<Maybe<ResolversTypes['RepositoryRuleset']>, ParentType, ContextType, RequireFields<RepositoryrulesetArgs, 'databaseId' | 'includeParents'>>;
  rulesets?: Resolver<Maybe<ResolversTypes['RepositoryRulesetConnection']>, ParentType, ContextType, RequireFields<RepositoryrulesetsArgs, 'includeParents'>>;
  securityPolicyUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType, RequireFields<RepositoryshortDescriptionHTMLArgs, 'limit'>>;
  squashMergeAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  squashMergeCommitMessage?: Resolver<ResolversTypes['SquashMergeCommitMessage'], ParentType, ContextType>;
  squashMergeCommitTitle?: Resolver<ResolversTypes['SquashMergeCommitTitle'], ParentType, ContextType>;
  squashPrTitleUsedAsDefault?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sshUrl?: Resolver<ResolversTypes['GitSSHRemote'], ParentType, ContextType>;
  stargazerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stargazers?: Resolver<ResolversTypes['StargazerConnection'], ParentType, ContextType, Partial<RepositorystargazersArgs>>;
  submodules?: Resolver<ResolversTypes['SubmoduleConnection'], ParentType, ContextType, Partial<RepositorysubmodulesArgs>>;
  tempCloneToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateRepository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  usesCustomOpenGraphImage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdateTopics?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerDefaultCommitEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  viewerDefaultMergeMethod?: Resolver<ResolversTypes['PullRequestMergeMethod'], ParentType, ContextType>;
  viewerHasStarred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerPermission?: Resolver<Maybe<ResolversTypes['RepositoryPermission']>, ParentType, ContextType>;
  viewerPossibleCommitEmails?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['SubscriptionState']>, ParentType, ContextType>;
  visibility?: Resolver<ResolversTypes['RepositoryVisibility'], ParentType, ContextType>;
  vulnerabilityAlert?: Resolver<Maybe<ResolversTypes['RepositoryVulnerabilityAlert']>, ParentType, ContextType, RequireFields<RepositoryvulnerabilityAlertArgs, 'number'>>;
  vulnerabilityAlerts?: Resolver<Maybe<ResolversTypes['RepositoryVulnerabilityAlertConnection']>, ParentType, ContextType, Partial<RepositoryvulnerabilityAlertsArgs>>;
  watchers?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<RepositorywatchersArgs>>;
  webCommitSignoffRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryAuditEntryData'] = ResolversParentTypes['RepositoryAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OrgRestoreMemberMembershipRepositoryAuditEntryData' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
}>;

export type RepositoryCodeownersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryCodeowners'] = ResolversParentTypes['RepositoryCodeowners']> = ResolversObject<{
  errors?: Resolver<Array<ResolversTypes['RepositoryCodeownersError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryCodeownersErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryCodeownersError'] = ResolversParentTypes['RepositoryCodeownersError']> = ResolversObject<{
  column?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  line?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  suggestion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryCollaboratorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryCollaboratorConnection'] = ResolversParentTypes['RepositoryCollaboratorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryCollaboratorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryCollaboratorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryCollaboratorEdge'] = ResolversParentTypes['RepositoryCollaboratorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  permission?: Resolver<ResolversTypes['RepositoryPermission'], ParentType, ContextType>;
  permissionSources?: Resolver<Maybe<Array<ResolversTypes['PermissionSource']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryConnection'] = ResolversParentTypes['RepositoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Repository']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalDiskUsage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryContactLinkResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryContactLink'] = ResolversParentTypes['RepositoryContactLink']> = ResolversObject<{
  about?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryDiscussionAuthorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryDiscussionAuthor'] = ResolversParentTypes['RepositoryDiscussionAuthor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'User', ParentType, ContextType>;
  repositoryDiscussions?: Resolver<ResolversTypes['DiscussionConnection'], ParentType, ContextType, RequireFields<RepositoryDiscussionAuthorrepositoryDiscussionsArgs, 'answered' | 'orderBy' | 'states'>>;
}>;

export type RepositoryDiscussionCommentAuthorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryDiscussionCommentAuthor'] = ResolversParentTypes['RepositoryDiscussionCommentAuthor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'User', ParentType, ContextType>;
  repositoryDiscussionComments?: Resolver<ResolversTypes['DiscussionCommentConnection'], ParentType, ContextType, RequireFields<RepositoryDiscussionCommentAuthorrepositoryDiscussionCommentsArgs, 'onlyAnswers'>>;
}>;

export type RepositoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryEdge'] = ResolversParentTypes['RepositoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryIdConditionTargetResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryIdConditionTarget'] = ResolversParentTypes['RepositoryIdConditionTarget']> = ResolversObject<{
  repositoryIds?: Resolver<Array<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryInfo'] = ResolversParentTypes['RepositoryInfo']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Repository', ParentType, ContextType>;
  archivedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  forkCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hasDiscussionsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasIssuesEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasProjectsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasWikiEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  homepageUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isFork?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isInOrganization?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isLocked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMirror?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isTemplate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  licenseInfo?: Resolver<Maybe<ResolversTypes['License']>, ParentType, ContextType>;
  lockReason?: Resolver<Maybe<ResolversTypes['RepositoryLockReason']>, ParentType, ContextType>;
  mirrorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameWithOwner?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  openGraphImageUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['RepositoryOwner'], ParentType, ContextType>;
  pushedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType, RequireFields<RepositoryInfoshortDescriptionHTMLArgs, 'limit'>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  usesCustomOpenGraphImage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  visibility?: Resolver<ResolversTypes['RepositoryVisibility'], ParentType, ContextType>;
}>;

export type RepositoryInteractionAbilityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryInteractionAbility'] = ResolversParentTypes['RepositoryInteractionAbility']> = ResolversObject<{
  expiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  limit?: Resolver<ResolversTypes['RepositoryInteractionLimit'], ParentType, ContextType>;
  origin?: Resolver<ResolversTypes['RepositoryInteractionLimitOrigin'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryInvitationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryInvitation'] = ResolversParentTypes['RepositoryInvitation']> = ResolversObject<{
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitee?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  inviter?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  permalink?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  permission?: Resolver<ResolversTypes['RepositoryPermission'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['RepositoryInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryInvitationConnection'] = ResolversParentTypes['RepositoryInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryInvitationEdge'] = ResolversParentTypes['RepositoryInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['RepositoryInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryMigrationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryMigration'] = ResolversParentTypes['RepositoryMigration']> = ResolversObject<{
  continueOnError?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  failureReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  migrationLogUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  migrationSource?: Resolver<ResolversTypes['MigrationSource'], ParentType, ContextType>;
  repositoryName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sourceUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['MigrationState'], ParentType, ContextType>;
  warningsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryMigrationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryMigrationConnection'] = ResolversParentTypes['RepositoryMigrationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryMigrationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryMigration']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryMigrationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryMigrationEdge'] = ResolversParentTypes['RepositoryMigrationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['RepositoryMigration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryNameConditionTargetResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryNameConditionTarget'] = ResolversParentTypes['RepositoryNameConditionTarget']> = ResolversObject<{
  exclude?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  include?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  protected?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryNodeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryNode'] = ResolversParentTypes['RepositoryNode']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CommitComment' | 'CommitCommentThread' | 'DependabotUpdate' | 'Discussion' | 'DiscussionCategory' | 'Issue' | 'IssueComment' | 'PinnedDiscussion' | 'PullRequest' | 'PullRequestCommitCommentThread' | 'PullRequestReview' | 'PullRequestReviewComment' | 'RepositoryVulnerabilityAlert', ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
}>;

export type RepositoryOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryOwner'] = ResolversParentTypes['RepositoryOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'User', ParentType, ContextType>;
  avatarUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType, Partial<RepositoryOwneravatarUrlArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  repositories?: Resolver<ResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<RepositoryOwnerrepositoriesArgs, 'ownerAffiliations'>>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType, RequireFields<RepositoryOwnerrepositoryArgs, 'followRenames' | 'name'>>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
}>;

export type RepositoryRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryRule'] = ResolversParentTypes['RepositoryRule']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parameters?: Resolver<Maybe<ResolversTypes['RuleParameters']>, ParentType, ContextType>;
  repositoryRuleset?: Resolver<Maybe<ResolversTypes['RepositoryRuleset']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['RepositoryRuleType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryRuleConditionsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryRuleConditions'] = ResolversParentTypes['RepositoryRuleConditions']> = ResolversObject<{
  refName?: Resolver<Maybe<ResolversTypes['RefNameConditionTarget']>, ParentType, ContextType>;
  repositoryId?: Resolver<Maybe<ResolversTypes['RepositoryIdConditionTarget']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['RepositoryNameConditionTarget']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryRuleConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryRuleConnection'] = ResolversParentTypes['RepositoryRuleConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryRuleEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryRule']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryRuleEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryRuleEdge'] = ResolversParentTypes['RepositoryRuleEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['RepositoryRule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryRulesetResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryRuleset'] = ResolversParentTypes['RepositoryRuleset']> = ResolversObject<{
  bypassActors?: Resolver<Maybe<ResolversTypes['RepositoryRulesetBypassActorConnection']>, ParentType, ContextType, Partial<RepositoryRulesetbypassActorsArgs>>;
  conditions?: Resolver<ResolversTypes['RepositoryRuleConditions'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  enforcement?: Resolver<ResolversTypes['RuleEnforcement'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  rules?: Resolver<Maybe<ResolversTypes['RepositoryRuleConnection']>, ParentType, ContextType, Partial<RepositoryRulesetrulesArgs>>;
  source?: Resolver<ResolversTypes['RuleSource'], ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['RepositoryRulesetTarget']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryRulesetBypassActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryRulesetBypassActor'] = ResolversParentTypes['RepositoryRulesetBypassActor']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['BypassActor']>, ParentType, ContextType>;
  bypassMode?: Resolver<Maybe<ResolversTypes['RepositoryRulesetBypassActorBypassMode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organizationAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  repositoryRoleDatabaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  repositoryRoleName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryRuleset?: Resolver<Maybe<ResolversTypes['RepositoryRuleset']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryRulesetBypassActorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryRulesetBypassActorConnection'] = ResolversParentTypes['RepositoryRulesetBypassActorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryRulesetBypassActorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryRulesetBypassActor']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryRulesetBypassActorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryRulesetBypassActorEdge'] = ResolversParentTypes['RepositoryRulesetBypassActorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['RepositoryRulesetBypassActor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryRulesetConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryRulesetConnection'] = ResolversParentTypes['RepositoryRulesetConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryRulesetEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryRuleset']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryRulesetEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryRulesetEdge'] = ResolversParentTypes['RepositoryRulesetEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['RepositoryRuleset']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryTopicResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryTopic'] = ResolversParentTypes['RepositoryTopic']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  topic?: Resolver<ResolversTypes['Topic'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryTopicConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryTopicConnection'] = ResolversParentTypes['RepositoryTopicConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryTopicEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryTopic']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryTopicEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryTopicEdge'] = ResolversParentTypes['RepositoryTopicEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['RepositoryTopic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryVisibilityChangeDisableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryVisibilityChangeDisableAuditEntry'] = ResolversParentTypes['RepositoryVisibilityChangeDisableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryVisibilityChangeEnableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryVisibilityChangeEnableAuditEntry'] = ResolversParentTypes['RepositoryVisibilityChangeEnableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryVulnerabilityAlertResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryVulnerabilityAlert'] = ResolversParentTypes['RepositoryVulnerabilityAlert']> = ResolversObject<{
  autoDismissedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dependabotUpdate?: Resolver<Maybe<ResolversTypes['DependabotUpdate']>, ParentType, ContextType>;
  dependencyScope?: Resolver<Maybe<ResolversTypes['RepositoryVulnerabilityAlertDependencyScope']>, ParentType, ContextType>;
  dismissComment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dismissReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dismissedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  dismisser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  fixedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  securityAdvisory?: Resolver<Maybe<ResolversTypes['SecurityAdvisory']>, ParentType, ContextType>;
  securityVulnerability?: Resolver<Maybe<ResolversTypes['SecurityVulnerability']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['RepositoryVulnerabilityAlertState'], ParentType, ContextType>;
  vulnerableManifestFilename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  vulnerableManifestPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  vulnerableRequirements?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryVulnerabilityAlertConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryVulnerabilityAlertConnection'] = ResolversParentTypes['RepositoryVulnerabilityAlertConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryVulnerabilityAlertEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['RepositoryVulnerabilityAlert']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RepositoryVulnerabilityAlertEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RepositoryVulnerabilityAlertEdge'] = ResolversParentTypes['RepositoryVulnerabilityAlertEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['RepositoryVulnerabilityAlert']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RequestReviewsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RequestReviewsPayload'] = ResolversParentTypes['RequestReviewsPayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  requestedReviewersEdge?: Resolver<Maybe<ResolversTypes['UserEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RequestedReviewerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RequestedReviewer'] = ResolversParentTypes['RequestedReviewer']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Bot' | 'Mannequin' | 'Team' | 'User', ParentType, ContextType>;
}>;

export type RequestedReviewerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RequestedReviewerConnection'] = ResolversParentTypes['RequestedReviewerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RequestedReviewerEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['RequestedReviewer']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RequestedReviewerEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RequestedReviewerEdge'] = ResolversParentTypes['RequestedReviewerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RequirableByPullRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RequirableByPullRequest'] = ResolversParentTypes['RequirableByPullRequest']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CheckRun' | 'StatusContext', ParentType, ContextType>;
  isRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<RequirableByPullRequestisRequiredArgs>>;
}>;

export type RequiredDeploymentsParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RequiredDeploymentsParameters'] = ResolversParentTypes['RequiredDeploymentsParameters']> = ResolversObject<{
  requiredDeploymentEnvironments?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RequiredStatusCheckDescriptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RequiredStatusCheckDescription'] = ResolversParentTypes['RequiredStatusCheckDescription']> = ResolversObject<{
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  context?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RequiredStatusChecksParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RequiredStatusChecksParameters'] = ResolversParentTypes['RequiredStatusChecksParameters']> = ResolversObject<{
  requiredStatusChecks?: Resolver<Array<ResolversTypes['StatusCheckConfiguration']>, ParentType, ContextType>;
  strictRequiredStatusChecksPolicy?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RerequestCheckSuitePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RerequestCheckSuitePayload'] = ResolversParentTypes['RerequestCheckSuitePayload']> = ResolversObject<{
  checkSuite?: Resolver<Maybe<ResolversTypes['CheckSuite']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ResolveReviewThreadPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ResolveReviewThreadPayload'] = ResolversParentTypes['ResolveReviewThreadPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  thread?: Resolver<Maybe<ResolversTypes['PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RestrictedContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RestrictedContribution'] = ResolversParentTypes['RestrictedContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RetireSponsorsTierPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RetireSponsorsTierPayload'] = ResolversParentTypes['RetireSponsorsTierPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RevertPullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RevertPullRequestPayload'] = ResolversParentTypes['RevertPullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  revertPullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReviewDismissalAllowanceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReviewDismissalAllowance'] = ResolversParentTypes['ReviewDismissalAllowance']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['ReviewDismissalAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReviewDismissalAllowanceActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReviewDismissalAllowanceActor'] = ResolversParentTypes['ReviewDismissalAllowanceActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'App' | 'Team' | 'User', ParentType, ContextType>;
}>;

export type ReviewDismissalAllowanceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReviewDismissalAllowanceConnection'] = ResolversParentTypes['ReviewDismissalAllowanceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ReviewDismissalAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ReviewDismissalAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReviewDismissalAllowanceEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReviewDismissalAllowanceEdge'] = ResolversParentTypes['ReviewDismissalAllowanceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewDismissalAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReviewDismissedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReviewDismissedEvent'] = ResolversParentTypes['ReviewDismissedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  dismissalMessage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dismissalMessageHTML?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  previousReviewState?: Resolver<ResolversTypes['PullRequestReviewState'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  pullRequestCommit?: Resolver<Maybe<ResolversTypes['PullRequestCommit']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReviewRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReviewRequest'] = ResolversParentTypes['ReviewRequest']> = ResolversObject<{
  asCodeOwner?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  requestedReviewer?: Resolver<Maybe<ResolversTypes['RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReviewRequestConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReviewRequestConnection'] = ResolversParentTypes['ReviewRequestConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ReviewRequestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['ReviewRequest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReviewRequestEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReviewRequestEdge'] = ResolversParentTypes['ReviewRequestEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReviewRequestRemovedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReviewRequestRemovedEvent'] = ResolversParentTypes['ReviewRequestRemovedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  requestedReviewer?: Resolver<Maybe<ResolversTypes['RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReviewRequestedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReviewRequestedEvent'] = ResolversParentTypes['ReviewRequestedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['PullRequest'], ParentType, ContextType>;
  requestedReviewer?: Resolver<Maybe<ResolversTypes['RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReviewStatusHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReviewStatusHovercardContext'] = ResolversParentTypes['ReviewStatusHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['PullRequestReviewDecision']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RevokeEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RevokeEnterpriseOrganizationsMigratorRolePayload'] = ResolversParentTypes['RevokeEnterpriseOrganizationsMigratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizations?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType, Partial<RevokeEnterpriseOrganizationsMigratorRolePayloadorganizationsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RevokeMigratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RevokeMigratorRolePayload'] = ResolversParentTypes['RevokeMigratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RuleParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RuleParameters'] = ResolversParentTypes['RuleParameters']> = ResolversObject<{
  __resolveType: TypeResolveFn<'BranchNamePatternParameters' | 'CommitAuthorEmailPatternParameters' | 'CommitMessagePatternParameters' | 'CommitterEmailPatternParameters' | 'PullRequestParameters' | 'RequiredDeploymentsParameters' | 'RequiredStatusChecksParameters' | 'TagNamePatternParameters' | 'UpdateParameters' | 'WorkflowsParameters', ParentType, ContextType>;
}>;

export type RuleSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RuleSource'] = ResolversParentTypes['RuleSource']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'Repository', ParentType, ContextType>;
}>;

export type SavedReplyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SavedReply'] = ResolversParentTypes['SavedReply']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SavedReplyConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SavedReplyConnection'] = ResolversParentTypes['SavedReplyConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SavedReplyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['SavedReply']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SavedReplyEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SavedReplyEdge'] = ResolversParentTypes['SavedReplyEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SavedReply']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SearchResultItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SearchResultItem'] = ResolversParentTypes['SearchResultItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'App' | 'Discussion' | 'Issue' | 'MarketplaceListing' | 'Organization' | 'PullRequest' | 'Repository' | 'User', ParentType, ContextType>;
}>;

export type SearchResultItemConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SearchResultItemConnection'] = ResolversParentTypes['SearchResultItemConnection']> = ResolversObject<{
  codeCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  discussionCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SearchResultItemEdge']>>>, ParentType, ContextType>;
  issueCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['SearchResultItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  repositoryCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  userCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  wikiCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SearchResultItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SearchResultItemEdge'] = ResolversParentTypes['SearchResultItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SearchResultItem']>, ParentType, ContextType>;
  textMatches?: Resolver<Maybe<Array<Maybe<ResolversTypes['TextMatch']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SecurityAdvisoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SecurityAdvisory'] = ResolversParentTypes['SecurityAdvisory']> = ResolversObject<{
  classification?: Resolver<ResolversTypes['SecurityAdvisoryClassification'], ParentType, ContextType>;
  cvss?: Resolver<ResolversTypes['CVSS'], ParentType, ContextType>;
  cwes?: Resolver<ResolversTypes['CWEConnection'], ParentType, ContextType, Partial<SecurityAdvisorycwesArgs>>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ghsaId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifiers?: Resolver<Array<ResolversTypes['SecurityAdvisoryIdentifier']>, ParentType, ContextType>;
  notificationsPermalink?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  origin?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  permalink?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  publishedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  references?: Resolver<Array<ResolversTypes['SecurityAdvisoryReference']>, ParentType, ContextType>;
  severity?: Resolver<ResolversTypes['SecurityAdvisorySeverity'], ParentType, ContextType>;
  summary?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  vulnerabilities?: Resolver<ResolversTypes['SecurityVulnerabilityConnection'], ParentType, ContextType, RequireFields<SecurityAdvisoryvulnerabilitiesArgs, 'orderBy'>>;
  withdrawnAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SecurityAdvisoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SecurityAdvisoryConnection'] = ResolversParentTypes['SecurityAdvisoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SecurityAdvisoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['SecurityAdvisory']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SecurityAdvisoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SecurityAdvisoryEdge'] = ResolversParentTypes['SecurityAdvisoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SecurityAdvisory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SecurityAdvisoryIdentifierResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SecurityAdvisoryIdentifier'] = ResolversParentTypes['SecurityAdvisoryIdentifier']> = ResolversObject<{
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SecurityAdvisoryPackageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SecurityAdvisoryPackage'] = ResolversParentTypes['SecurityAdvisoryPackage']> = ResolversObject<{
  ecosystem?: Resolver<ResolversTypes['SecurityAdvisoryEcosystem'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SecurityAdvisoryPackageVersionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SecurityAdvisoryPackageVersion'] = ResolversParentTypes['SecurityAdvisoryPackageVersion']> = ResolversObject<{
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SecurityAdvisoryReferenceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SecurityAdvisoryReference'] = ResolversParentTypes['SecurityAdvisoryReference']> = ResolversObject<{
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SecurityVulnerabilityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SecurityVulnerability'] = ResolversParentTypes['SecurityVulnerability']> = ResolversObject<{
  advisory?: Resolver<ResolversTypes['SecurityAdvisory'], ParentType, ContextType>;
  firstPatchedVersion?: Resolver<Maybe<ResolversTypes['SecurityAdvisoryPackageVersion']>, ParentType, ContextType>;
  package?: Resolver<ResolversTypes['SecurityAdvisoryPackage'], ParentType, ContextType>;
  severity?: Resolver<ResolversTypes['SecurityAdvisorySeverity'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  vulnerableVersionRange?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SecurityVulnerabilityConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SecurityVulnerabilityConnection'] = ResolversParentTypes['SecurityVulnerabilityConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SecurityVulnerabilityEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['SecurityVulnerability']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SecurityVulnerabilityEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SecurityVulnerabilityEdge'] = ResolversParentTypes['SecurityVulnerabilityEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SecurityVulnerability']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SetEnterpriseIdentityProviderPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SetEnterpriseIdentityProviderPayload'] = ResolversParentTypes['SetEnterpriseIdentityProviderPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identityProvider?: Resolver<Maybe<ResolversTypes['EnterpriseIdentityProvider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SetOrganizationInteractionLimitPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SetOrganizationInteractionLimitPayload'] = ResolversParentTypes['SetOrganizationInteractionLimitPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SetRepositoryInteractionLimitPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SetRepositoryInteractionLimitPayload'] = ResolversParentTypes['SetRepositoryInteractionLimitPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SetUserInteractionLimitPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SetUserInteractionLimitPayload'] = ResolversParentTypes['SetUserInteractionLimitPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SmimeSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SmimeSignature'] = ResolversParentTypes['SmimeSignature']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SocialAccountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SocialAccount'] = ResolversParentTypes['SocialAccount']> = ResolversObject<{
  displayName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  provider?: Resolver<ResolversTypes['SocialAccountProvider'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SocialAccountConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SocialAccountConnection'] = ResolversParentTypes['SocialAccountConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SocialAccountEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['SocialAccount']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SocialAccountEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SocialAccountEdge'] = ResolversParentTypes['SocialAccountEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SocialAccount']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Sponsor'] = ResolversParentTypes['Sponsor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'User', ParentType, ContextType>;
}>;

export type SponsorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorConnection'] = ResolversParentTypes['SponsorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SponsorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Sponsor']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorEdge'] = ResolversParentTypes['SponsorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Sponsor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Sponsorable'] = ResolversParentTypes['Sponsorable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'User', ParentType, ContextType>;
  estimatedNextSponsorsPayoutInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hasSponsorsListing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSponsoredBy?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<SponsorableisSponsoredByArgs, 'accountLogin'>>;
  isSponsoringViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  monthlyEstimatedSponsorsIncomeInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  sponsoring?: Resolver<ResolversTypes['SponsorConnection'], ParentType, ContextType, RequireFields<SponsorablesponsoringArgs, 'orderBy'>>;
  sponsors?: Resolver<ResolversTypes['SponsorConnection'], ParentType, ContextType, RequireFields<SponsorablesponsorsArgs, 'orderBy'>>;
  sponsorsActivities?: Resolver<ResolversTypes['SponsorsActivityConnection'], ParentType, ContextType, RequireFields<SponsorablesponsorsActivitiesArgs, 'actions' | 'includeAsSponsor' | 'includePrivate' | 'orderBy' | 'period'>>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['SponsorsListing']>, ParentType, ContextType>;
  sponsorshipForViewerAsSponsor?: Resolver<Maybe<ResolversTypes['Sponsorship']>, ParentType, ContextType, RequireFields<SponsorablesponsorshipForViewerAsSponsorArgs, 'activeOnly'>>;
  sponsorshipForViewerAsSponsorable?: Resolver<Maybe<ResolversTypes['Sponsorship']>, ParentType, ContextType, RequireFields<SponsorablesponsorshipForViewerAsSponsorableArgs, 'activeOnly'>>;
  sponsorshipNewsletters?: Resolver<ResolversTypes['SponsorshipNewsletterConnection'], ParentType, ContextType, RequireFields<SponsorablesponsorshipNewslettersArgs, 'orderBy'>>;
  sponsorshipsAsMaintainer?: Resolver<ResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<SponsorablesponsorshipsAsMaintainerArgs, 'activeOnly' | 'includePrivate'>>;
  sponsorshipsAsSponsor?: Resolver<ResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<SponsorablesponsorshipsAsSponsorArgs, 'activeOnly'>>;
  totalSponsorshipAmountAsSponsorInCents?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<SponsorabletotalSponsorshipAmountAsSponsorInCentsArgs, 'sponsorableLogins'>>;
  viewerCanSponsor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsSponsoring?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type SponsorableItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorableItem'] = ResolversParentTypes['SponsorableItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Organization' | 'User', ParentType, ContextType>;
}>;

export type SponsorableItemConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorableItemConnection'] = ResolversParentTypes['SponsorableItemConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SponsorableItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['SponsorableItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorableItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorableItemEdge'] = ResolversParentTypes['SponsorableItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SponsorableItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorsActivityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorsActivity'] = ResolversParentTypes['SponsorsActivity']> = ResolversObject<{
  action?: Resolver<ResolversTypes['SponsorsActivityAction'], ParentType, ContextType>;
  currentPrivacyLevel?: Resolver<Maybe<ResolversTypes['SponsorshipPrivacy']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  paymentSource?: Resolver<Maybe<ResolversTypes['SponsorshipPaymentSource']>, ParentType, ContextType>;
  previousSponsorsTier?: Resolver<Maybe<ResolversTypes['SponsorsTier']>, ParentType, ContextType>;
  sponsor?: Resolver<Maybe<ResolversTypes['Sponsor']>, ParentType, ContextType>;
  sponsorable?: Resolver<ResolversTypes['Sponsorable'], ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['SponsorsTier']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  viaBulkSponsorship?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorsActivityConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorsActivityConnection'] = ResolversParentTypes['SponsorsActivityConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SponsorsActivityEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['SponsorsActivity']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorsActivityEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorsActivityEdge'] = ResolversParentTypes['SponsorsActivityEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SponsorsActivity']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorsGoalResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorsGoal'] = ResolversParentTypes['SponsorsGoal']> = ResolversObject<{
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['SponsorsGoalKind'], ParentType, ContextType>;
  percentComplete?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  targetValue?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorsListingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorsListing'] = ResolversParentTypes['SponsorsListing']> = ResolversObject<{
  activeGoal?: Resolver<Maybe<ResolversTypes['SponsorsGoal']>, ParentType, ContextType>;
  activeStripeConnectAccount?: Resolver<Maybe<ResolversTypes['StripeConnectAccount']>, ParentType, ContextType>;
  billingCountryOrRegion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contactEmailAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dashboardResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  dashboardUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  featuredItems?: Resolver<Array<ResolversTypes['SponsorsListingFeaturedItem']>, ParentType, ContextType, RequireFields<SponsorsListingfeaturedItemsArgs, 'featureableTypes'>>;
  fiscalHost?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  fullDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fullDescriptionHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPublic?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nextPayoutDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  residenceCountryOrRegion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  shortDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sponsorable?: Resolver<ResolversTypes['Sponsorable'], ParentType, ContextType>;
  tiers?: Resolver<Maybe<ResolversTypes['SponsorsTierConnection']>, ParentType, ContextType, RequireFields<SponsorsListingtiersArgs, 'includeUnpublished' | 'orderBy'>>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorsListingFeatureableItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorsListingFeatureableItem'] = ResolversParentTypes['SponsorsListingFeatureableItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Repository' | 'User', ParentType, ContextType>;
}>;

export type SponsorsListingFeaturedItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorsListingFeaturedItem'] = ResolversParentTypes['SponsorsListingFeaturedItem']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  featureable?: Resolver<ResolversTypes['SponsorsListingFeatureableItem'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  position?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  sponsorsListing?: Resolver<ResolversTypes['SponsorsListing'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorsTierResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorsTier'] = ResolversParentTypes['SponsorsTier']> = ResolversObject<{
  adminInfo?: Resolver<Maybe<ResolversTypes['SponsorsTierAdminInfo']>, ParentType, ContextType>;
  closestLesserValueTier?: Resolver<Maybe<ResolversTypes['SponsorsTier']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCustomAmount?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOneTime?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  monthlyPriceInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  monthlyPriceInDollars?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sponsorsListing?: Resolver<ResolversTypes['SponsorsListing'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorsTierAdminInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorsTierAdminInfo'] = ResolversParentTypes['SponsorsTierAdminInfo']> = ResolversObject<{
  isDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPublished?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRetired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sponsorships?: Resolver<ResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<SponsorsTierAdminInfosponsorshipsArgs, 'includePrivate'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorsTierConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorsTierConnection'] = ResolversParentTypes['SponsorsTierConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SponsorsTierEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['SponsorsTier']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorsTierEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorsTierEdge'] = ResolversParentTypes['SponsorsTierEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorshipResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Sponsorship'] = ResolversParentTypes['Sponsorship']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOneTimePayment?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSponsorOptedIntoEmail?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  maintainer?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  paymentSource?: Resolver<Maybe<ResolversTypes['SponsorshipPaymentSource']>, ParentType, ContextType>;
  privacyLevel?: Resolver<ResolversTypes['SponsorshipPrivacy'], ParentType, ContextType>;
  sponsor?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  sponsorEntity?: Resolver<Maybe<ResolversTypes['Sponsor']>, ParentType, ContextType>;
  sponsorable?: Resolver<ResolversTypes['Sponsorable'], ParentType, ContextType>;
  tier?: Resolver<Maybe<ResolversTypes['SponsorsTier']>, ParentType, ContextType>;
  tierSelectedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorshipConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorshipConnection'] = ResolversParentTypes['SponsorshipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SponsorshipEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Sponsorship']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRecurringMonthlyPriceInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRecurringMonthlyPriceInDollars?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorshipEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorshipEdge'] = ResolversParentTypes['SponsorshipEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Sponsorship']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorshipNewsletterResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorshipNewsletter'] = ResolversParentTypes['SponsorshipNewsletter']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPublished?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sponsorable?: Resolver<ResolversTypes['Sponsorable'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorshipNewsletterConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorshipNewsletterConnection'] = ResolversParentTypes['SponsorshipNewsletterConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SponsorshipNewsletterEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['SponsorshipNewsletter']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SponsorshipNewsletterEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SponsorshipNewsletterEdge'] = ResolversParentTypes['SponsorshipNewsletterEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SponsorshipNewsletter']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SshSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SshSignature'] = ResolversParentTypes['SshSignature']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  keyFingerprint?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StargazerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StargazerConnection'] = ResolversParentTypes['StargazerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StargazerEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StargazerEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StargazerEdge'] = ResolversParentTypes['StargazerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  starredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StarrableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Starrable'] = ResolversParentTypes['Starrable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Gist' | 'Repository' | 'Topic', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  stargazerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stargazers?: Resolver<ResolversTypes['StargazerConnection'], ParentType, ContextType, Partial<StarrablestargazersArgs>>;
  viewerHasStarred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type StarredRepositoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StarredRepositoryConnection'] = ResolversParentTypes['StarredRepositoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StarredRepositoryEdge']>>>, ParentType, ContextType>;
  isOverLimit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Repository']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StarredRepositoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StarredRepositoryEdge'] = ResolversParentTypes['StarredRepositoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  starredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StartOrganizationMigrationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StartOrganizationMigrationPayload'] = ResolversParentTypes['StartOrganizationMigrationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orgMigration?: Resolver<Maybe<ResolversTypes['OrganizationMigration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StartRepositoryMigrationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StartRepositoryMigrationPayload'] = ResolversParentTypes['StartRepositoryMigrationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryMigration?: Resolver<Maybe<ResolversTypes['RepositoryMigration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Status'] = ResolversParentTypes['Status']> = ResolversObject<{
  combinedContexts?: Resolver<ResolversTypes['StatusCheckRollupContextConnection'], ParentType, ContextType, Partial<StatuscombinedContextsArgs>>;
  commit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  context?: Resolver<Maybe<ResolversTypes['StatusContext']>, ParentType, ContextType, RequireFields<StatuscontextArgs, 'name'>>;
  contexts?: Resolver<Array<ResolversTypes['StatusContext']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['StatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatusCheckConfigurationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StatusCheckConfiguration'] = ResolversParentTypes['StatusCheckConfiguration']> = ResolversObject<{
  context?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  integrationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatusCheckRollupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StatusCheckRollup'] = ResolversParentTypes['StatusCheckRollup']> = ResolversObject<{
  commit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  contexts?: Resolver<ResolversTypes['StatusCheckRollupContextConnection'], ParentType, ContextType, Partial<StatusCheckRollupcontextsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['StatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatusCheckRollupContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StatusCheckRollupContext'] = ResolversParentTypes['StatusCheckRollupContext']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CheckRun' | 'StatusContext', ParentType, ContextType>;
}>;

export type StatusCheckRollupContextConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StatusCheckRollupContextConnection'] = ResolversParentTypes['StatusCheckRollupContextConnection']> = ResolversObject<{
  checkRunCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  checkRunCountsByState?: Resolver<Maybe<Array<ResolversTypes['CheckRunStateCount']>>, ParentType, ContextType>;
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StatusCheckRollupContextEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['StatusCheckRollupContext']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  statusContextCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  statusContextCountsByState?: Resolver<Maybe<Array<ResolversTypes['StatusContextStateCount']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatusCheckRollupContextEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StatusCheckRollupContextEdge'] = ResolversParentTypes['StatusCheckRollupContextEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['StatusCheckRollupContext']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatusContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StatusContext'] = ResolversParentTypes['StatusContext']> = ResolversObject<{
  avatarUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType, RequireFields<StatusContextavatarUrlArgs, 'size'>>;
  commit?: Resolver<Maybe<ResolversTypes['Commit']>, ParentType, ContextType>;
  context?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<StatusContextisRequiredArgs>>;
  state?: Resolver<ResolversTypes['StatusState'], ParentType, ContextType>;
  targetUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatusContextStateCountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StatusContextStateCount'] = ResolversParentTypes['StatusContextStateCount']> = ResolversObject<{
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['StatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StripeConnectAccountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StripeConnectAccount'] = ResolversParentTypes['StripeConnectAccount']> = ResolversObject<{
  accountId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  billingCountryOrRegion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  countryOrRegion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sponsorsListing?: Resolver<ResolversTypes['SponsorsListing'], ParentType, ContextType>;
  stripeDashboardUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubmitPullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SubmitPullRequestReviewPayload'] = ResolversParentTypes['SubmitPullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubmoduleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Submodule'] = ResolversParentTypes['Submodule']> = ResolversObject<{
  branch?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gitUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameRaw?: Resolver<ResolversTypes['Base64String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pathRaw?: Resolver<ResolversTypes['Base64String'], ParentType, ContextType>;
  subprojectCommitOid?: Resolver<Maybe<ResolversTypes['GitObjectID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubmoduleConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SubmoduleConnection'] = ResolversParentTypes['SubmoduleConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SubmoduleEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Submodule']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubmoduleEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SubmoduleEdge'] = ResolversParentTypes['SubmoduleEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Submodule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubscribableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Subscribable'] = ResolversParentTypes['Subscribable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Commit' | 'Discussion' | 'Issue' | 'PullRequest' | 'Repository' | 'Team' | 'TeamDiscussion', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['SubscriptionState']>, ParentType, ContextType>;
}>;

export type SubscribableThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SubscribableThread'] = ResolversParentTypes['SubscribableThread']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Issue', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  viewerThreadSubscriptionFormAction?: Resolver<Maybe<ResolversTypes['ThreadSubscriptionFormAction']>, ParentType, ContextType>;
  viewerThreadSubscriptionStatus?: Resolver<Maybe<ResolversTypes['ThreadSubscriptionState']>, ParentType, ContextType>;
}>;

export type SubscribedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SubscribedEvent'] = ResolversParentTypes['SubscribedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  subscribable?: Resolver<ResolversTypes['Subscribable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SuggestedReviewerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SuggestedReviewer'] = ResolversParentTypes['SuggestedReviewer']> = ResolversObject<{
  isAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isCommenter?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  reviewer?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TagResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Tag'] = ResolversParentTypes['Tag']> = ResolversObject<{
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  tagger?: Resolver<Maybe<ResolversTypes['GitActor']>, ParentType, ContextType>;
  target?: Resolver<ResolversTypes['GitObject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TagNamePatternParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TagNamePatternParameters'] = ResolversParentTypes['TagNamePatternParameters']> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Team'] = ResolversParentTypes['Team']> = ResolversObject<{
  ancestors?: Resolver<ResolversTypes['TeamConnection'], ParentType, ContextType, Partial<TeamancestorsArgs>>;
  avatarUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType, RequireFields<TeamavatarUrlArgs, 'size'>>;
  childTeams?: Resolver<ResolversTypes['TeamConnection'], ParentType, ContextType, RequireFields<TeamchildTeamsArgs, 'immediateOnly'>>;
  combinedSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['TeamDiscussion']>, ParentType, ContextType, RequireFields<TeamdiscussionArgs, 'number'>>;
  discussions?: Resolver<ResolversTypes['TeamDiscussionConnection'], ParentType, ContextType, Partial<TeamdiscussionsArgs>>;
  discussionsResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  discussionsUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  editTeamResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  editTeamUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitations?: Resolver<Maybe<ResolversTypes['OrganizationInvitationConnection']>, ParentType, ContextType, Partial<TeaminvitationsArgs>>;
  memberStatuses?: Resolver<ResolversTypes['UserStatusConnection'], ParentType, ContextType, RequireFields<TeammemberStatusesArgs, 'orderBy'>>;
  members?: Resolver<ResolversTypes['TeamMemberConnection'], ParentType, ContextType, RequireFields<TeammembersArgs, 'membership'>>;
  membersResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  membersUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  newTeamResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  newTeamUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  notificationSetting?: Resolver<ResolversTypes['TeamNotificationSetting'], ParentType, ContextType>;
  organization?: Resolver<ResolversTypes['Organization'], ParentType, ContextType>;
  parentTeam?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  privacy?: Resolver<ResolversTypes['TeamPrivacy'], ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType, RequireFields<TeamprojectV2Args, 'number'>>;
  projectsV2?: Resolver<ResolversTypes['ProjectV2Connection'], ParentType, ContextType, RequireFields<TeamprojectsV2Args, 'filterBy' | 'orderBy' | 'query'>>;
  repositories?: Resolver<ResolversTypes['TeamRepositoryConnection'], ParentType, ContextType, Partial<TeamrepositoriesArgs>>;
  repositoriesResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  repositoriesUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  reviewRequestDelegationAlgorithm?: Resolver<Maybe<ResolversTypes['TeamReviewAssignmentAlgorithm']>, ParentType, ContextType>;
  reviewRequestDelegationEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  reviewRequestDelegationMemberCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewRequestDelegationNotifyTeam?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  teamsResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  teamsUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamAddMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamAddMemberAuditEntry'] = ResolversParentTypes['TeamAddMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamAddRepositoryAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamAddRepositoryAuditEntry'] = ResolversParentTypes['TeamAddRepositoryAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamAuditEntryData'] = ResolversParentTypes['TeamAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'OrgRestoreMemberMembershipTeamAuditEntryData' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
}>;

export type TeamChangeParentTeamAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamChangeParentTeamAuditEntry'] = ResolversParentTypes['TeamChangeParentTeamAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  parentTeam?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  parentTeamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parentTeamNameWas?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parentTeamResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  parentTeamUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  parentTeamWas?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  parentTeamWasResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  parentTeamWasUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamConnection'] = ResolversParentTypes['TeamConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['TeamEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Team']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamDiscussionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamDiscussion'] = ResolversParentTypes['TeamDiscussion']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyVersion?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['TeamDiscussionCommentConnection'], ParentType, ContextType, Partial<TeamDiscussioncommentsArgs>>;
  commentsResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  commentsUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPinned?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['ReactionConnection'], ParentType, ContextType, Partial<TeamDiscussionreactionsArgs>>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  team?: Resolver<ResolversTypes['Team'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['UserContentEditConnection']>, ParentType, ContextType, Partial<TeamDiscussionuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanPin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamDiscussionCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamDiscussionComment'] = ResolversParentTypes['TeamDiscussionComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyVersion?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  discussion?: Resolver<ResolversTypes['TeamDiscussion'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['ReactionConnection'], ParentType, ContextType, Partial<TeamDiscussionCommentreactionsArgs>>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['UserContentEditConnection']>, ParentType, ContextType, Partial<TeamDiscussionCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamDiscussionCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamDiscussionCommentConnection'] = ResolversParentTypes['TeamDiscussionCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['TeamDiscussionCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['TeamDiscussionComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamDiscussionCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamDiscussionCommentEdge'] = ResolversParentTypes['TeamDiscussionCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TeamDiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamDiscussionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamDiscussionConnection'] = ResolversParentTypes['TeamDiscussionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['TeamDiscussionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['TeamDiscussion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamDiscussionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamDiscussionEdge'] = ResolversParentTypes['TeamDiscussionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TeamDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamEdge'] = ResolversParentTypes['TeamEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamMemberConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamMemberConnection'] = ResolversParentTypes['TeamMemberConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['TeamMemberEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamMemberEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamMemberEdge'] = ResolversParentTypes['TeamMemberEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  memberAccessResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  memberAccessUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['TeamMemberRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamRemoveMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamRemoveMemberAuditEntry'] = ResolversParentTypes['TeamRemoveMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamRemoveRepositoryAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamRemoveRepositoryAuditEntry'] = ResolversParentTypes['TeamRemoveRepositoryAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamRepositoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamRepositoryConnection'] = ResolversParentTypes['TeamRepositoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['TeamRepositoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Repository']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TeamRepositoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TeamRepositoryEdge'] = ResolversParentTypes['TeamRepositoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  permission?: Resolver<ResolversTypes['RepositoryPermission'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TextMatchResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TextMatch'] = ResolversParentTypes['TextMatch']> = ResolversObject<{
  fragment?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  highlights?: Resolver<Array<ResolversTypes['TextMatchHighlight']>, ParentType, ContextType>;
  property?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TextMatchHighlightResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TextMatchHighlight'] = ResolversParentTypes['TextMatchHighlight']> = ResolversObject<{
  beginIndice?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  endIndice?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  text?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TopicResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Topic'] = ResolversParentTypes['Topic']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  relatedTopics?: Resolver<Array<ResolversTypes['Topic']>, ParentType, ContextType, RequireFields<TopicrelatedTopicsArgs, 'first'>>;
  repositories?: Resolver<ResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<TopicrepositoriesArgs, 'ownerAffiliations' | 'sponsorableOnly'>>;
  stargazerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stargazers?: Resolver<ResolversTypes['StargazerConnection'], ParentType, ContextType, Partial<TopicstargazersArgs>>;
  viewerHasStarred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TopicAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TopicAuditEntryData'] = ResolversParentTypes['TopicAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'RepoAddTopicAuditEntry' | 'RepoRemoveTopicAuditEntry', ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['Topic']>, ParentType, ContextType>;
  topicName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
}>;

export type TransferEnterpriseOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransferEnterpriseOrganizationPayload'] = ResolversParentTypes['TransferEnterpriseOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TransferIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransferIssuePayload'] = ResolversParentTypes['TransferIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TransferredEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransferredEvent'] = ResolversParentTypes['TransferredEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  fromRepository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['Issue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TreeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Tree'] = ResolversParentTypes['Tree']> = ResolversObject<{
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  entries?: Resolver<Maybe<Array<ResolversTypes['TreeEntry']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TreeEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TreeEntry'] = ResolversParentTypes['TreeEntry']> = ResolversObject<{
  extension?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isGenerated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  language?: Resolver<Maybe<ResolversTypes['Language']>, ParentType, ContextType>;
  lineCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  mode?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameRaw?: Resolver<ResolversTypes['Base64String'], ParentType, ContextType>;
  object?: Resolver<Maybe<ResolversTypes['GitObject']>, ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['GitObjectID'], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pathRaw?: Resolver<Maybe<ResolversTypes['Base64String']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Repository'], ParentType, ContextType>;
  size?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  submodule?: Resolver<Maybe<ResolversTypes['Submodule']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface URIScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['URI'], any> {
  name: 'URI';
}

export type UnarchiveProjectV2ItemPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnarchiveProjectV2ItemPayload'] = ResolversParentTypes['UnarchiveProjectV2ItemPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnarchiveRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnarchiveRepositoryPayload'] = ResolversParentTypes['UnarchiveRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnassignedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnassignedEvent'] = ResolversParentTypes['UnassignedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  assignable?: Resolver<ResolversTypes['Assignable'], ParentType, ContextType>;
  assignee?: Resolver<Maybe<ResolversTypes['Assignee']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnfollowOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnfollowOrganizationPayload'] = ResolversParentTypes['UnfollowOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnfollowUserPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnfollowUserPayload'] = ResolversParentTypes['UnfollowUserPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UniformResourceLocatableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UniformResourceLocatable'] = ResolversParentTypes['UniformResourceLocatable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Bot' | 'CheckRun' | 'ClosedEvent' | 'Commit' | 'ConvertToDraftEvent' | 'CrossReferencedEvent' | 'Gist' | 'Issue' | 'Mannequin' | 'MergedEvent' | 'Milestone' | 'Organization' | 'PullRequest' | 'PullRequestCommit' | 'ReadyForReviewEvent' | 'Release' | 'Repository' | 'RepositoryTopic' | 'ReviewDismissedEvent' | 'TeamDiscussion' | 'TeamDiscussionComment' | 'User' | 'Workflow' | 'WorkflowRun' | 'WorkflowRunFile', ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
}>;

export type UnknownSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnknownSignature'] = ResolversParentTypes['UnknownSignature']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnlabeledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnlabeledEvent'] = ResolversParentTypes['UnlabeledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['Label'], ParentType, ContextType>;
  labelable?: Resolver<ResolversTypes['Labelable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnlinkProjectV2FromRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnlinkProjectV2FromRepositoryPayload'] = ResolversParentTypes['UnlinkProjectV2FromRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnlinkProjectV2FromTeamPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnlinkProjectV2FromTeamPayload'] = ResolversParentTypes['UnlinkProjectV2FromTeamPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnlinkRepositoryFromProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnlinkRepositoryFromProjectPayload'] = ResolversParentTypes['UnlinkRepositoryFromProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnlockLockablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnlockLockablePayload'] = ResolversParentTypes['UnlockLockablePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unlockedRecord?: Resolver<Maybe<ResolversTypes['Lockable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnlockedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnlockedEvent'] = ResolversParentTypes['UnlockedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lockable?: Resolver<ResolversTypes['Lockable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnmarkDiscussionCommentAsAnswerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnmarkDiscussionCommentAsAnswerPayload'] = ResolversParentTypes['UnmarkDiscussionCommentAsAnswerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnmarkFileAsViewedPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnmarkFileAsViewedPayload'] = ResolversParentTypes['UnmarkFileAsViewedPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnmarkIssueAsDuplicatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnmarkIssueAsDuplicatePayload'] = ResolversParentTypes['UnmarkIssueAsDuplicatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  duplicate?: Resolver<Maybe<ResolversTypes['IssueOrPullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnmarkProjectV2AsTemplatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnmarkProjectV2AsTemplatePayload'] = ResolversParentTypes['UnmarkProjectV2AsTemplatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnmarkedAsDuplicateEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnmarkedAsDuplicateEvent'] = ResolversParentTypes['UnmarkedAsDuplicateEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  canonical?: Resolver<Maybe<ResolversTypes['IssueOrPullRequest']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  duplicate?: Resolver<Maybe<ResolversTypes['IssueOrPullRequest']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnminimizeCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnminimizeCommentPayload'] = ResolversParentTypes['UnminimizeCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unminimizedComment?: Resolver<Maybe<ResolversTypes['Minimizable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnpinIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnpinIssuePayload'] = ResolversParentTypes['UnpinIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnpinnedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnpinnedEvent'] = ResolversParentTypes['UnpinnedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['Issue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnresolveReviewThreadPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnresolveReviewThreadPayload'] = ResolversParentTypes['UnresolveReviewThreadPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  thread?: Resolver<Maybe<ResolversTypes['PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnsubscribeFromNotificationsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnsubscribeFromNotificationsPayload'] = ResolversParentTypes['UnsubscribeFromNotificationsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UnsubscribedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnsubscribedEvent'] = ResolversParentTypes['UnsubscribedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  subscribable?: Resolver<ResolversTypes['Subscribable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdatableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Updatable'] = ResolversParentTypes['Updatable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CommitComment' | 'Discussion' | 'DiscussionComment' | 'GistComment' | 'Issue' | 'IssueComment' | 'Project' | 'ProjectV2' | 'PullRequest' | 'PullRequestReview' | 'PullRequestReviewComment' | 'TeamDiscussion' | 'TeamDiscussionComment', ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type UpdatableCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdatableComment'] = ResolversParentTypes['UpdatableComment']> = ResolversObject<{
  __resolveType: TypeResolveFn<'CommitComment' | 'DiscussionComment' | 'GistComment' | 'Issue' | 'IssueComment' | 'PullRequest' | 'PullRequestReview' | 'PullRequestReviewComment' | 'TeamDiscussion' | 'TeamDiscussionComment', ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
}>;

export type UpdateBranchProtectionRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateBranchProtectionRulePayload'] = ResolversParentTypes['UpdateBranchProtectionRulePayload']> = ResolversObject<{
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCheckRunPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCheckRunPayload'] = ResolversParentTypes['UpdateCheckRunPayload']> = ResolversObject<{
  checkRun?: Resolver<Maybe<ResolversTypes['CheckRun']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCheckSuitePreferencesPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCheckSuitePreferencesPayload'] = ResolversParentTypes['UpdateCheckSuitePreferencesPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateDiscussionCommentPayload'] = ResolversParentTypes['UpdateDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['DiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateDiscussionPayload'] = ResolversParentTypes['UpdateDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseAdministratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseAdministratorRolePayload'] = ResolversParentTypes['UpdateEnterpriseAdministratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload'] = ResolversParentTypes['UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseDefaultRepositoryPermissionSettingPayload'] = ResolversParentTypes['UpdateEnterpriseDefaultRepositoryPermissionSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload'] = ResolversParentTypes['UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload'] = ResolversParentTypes['UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseMembersCanDeleteIssuesSettingPayload'] = ResolversParentTypes['UpdateEnterpriseMembersCanDeleteIssuesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload'] = ResolversParentTypes['UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload'] = ResolversParentTypes['UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseMembersCanMakePurchasesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseMembersCanMakePurchasesSettingPayload'] = ResolversParentTypes['UpdateEnterpriseMembersCanMakePurchasesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload'] = ResolversParentTypes['UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload'] = ResolversParentTypes['UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseOrganizationProjectsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseOrganizationProjectsSettingPayload'] = ResolversParentTypes['UpdateEnterpriseOrganizationProjectsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseOwnerOrganizationRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseOwnerOrganizationRolePayload'] = ResolversParentTypes['UpdateEnterpriseOwnerOrganizationRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseProfilePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseProfilePayload'] = ResolversParentTypes['UpdateEnterpriseProfilePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseRepositoryProjectsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseRepositoryProjectsSettingPayload'] = ResolversParentTypes['UpdateEnterpriseRepositoryProjectsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseTeamDiscussionsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseTeamDiscussionsSettingPayload'] = ResolversParentTypes['UpdateEnterpriseTeamDiscussionsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload'] = ResolversParentTypes['UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEnvironmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEnvironmentPayload'] = ResolversParentTypes['UpdateEnvironmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['Environment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateIpAllowListEnabledSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateIpAllowListEnabledSettingPayload'] = ResolversParentTypes['UpdateIpAllowListEnabledSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['IpAllowListOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateIpAllowListEntryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateIpAllowListEntryPayload'] = ResolversParentTypes['UpdateIpAllowListEntryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ipAllowListEntry?: Resolver<Maybe<ResolversTypes['IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateIpAllowListForInstalledAppsEnabledSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateIpAllowListForInstalledAppsEnabledSettingPayload'] = ResolversParentTypes['UpdateIpAllowListForInstalledAppsEnabledSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['IpAllowListOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateIssueCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateIssueCommentPayload'] = ResolversParentTypes['UpdateIssueCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issueComment?: Resolver<Maybe<ResolversTypes['IssueComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateIssuePayload'] = ResolversParentTypes['UpdateIssuePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateLabelPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateLabelPayload'] = ResolversParentTypes['UpdateLabelPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateNotificationRestrictionSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateNotificationRestrictionSettingPayload'] = ResolversParentTypes['UpdateNotificationRestrictionSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['VerifiableDomainOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateOrganizationAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload'] = ResolversParentTypes['UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateOrganizationWebCommitSignoffSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateOrganizationWebCommitSignoffSettingPayload'] = ResolversParentTypes['UpdateOrganizationWebCommitSignoffSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateParameters'] = ResolversParentTypes['UpdateParameters']> = ResolversObject<{
  updateAllowsFetchAndMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdatePatreonSponsorabilityPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdatePatreonSponsorabilityPayload'] = ResolversParentTypes['UpdatePatreonSponsorabilityPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['SponsorsListing']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateProjectCardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateProjectCardPayload'] = ResolversParentTypes['UpdateProjectCardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['ProjectCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateProjectColumnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateProjectColumnPayload'] = ResolversParentTypes['UpdateProjectColumnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectColumn?: Resolver<Maybe<ResolversTypes['ProjectColumn']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateProjectPayload'] = ResolversParentTypes['UpdateProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateProjectV2CollaboratorsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateProjectV2CollaboratorsPayload'] = ResolversParentTypes['UpdateProjectV2CollaboratorsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collaborators?: Resolver<Maybe<ResolversTypes['ProjectV2ActorConnection']>, ParentType, ContextType, Partial<UpdateProjectV2CollaboratorsPayloadcollaboratorsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateProjectV2DraftIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateProjectV2DraftIssuePayload'] = ResolversParentTypes['UpdateProjectV2DraftIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  draftIssue?: Resolver<Maybe<ResolversTypes['DraftIssue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateProjectV2ItemFieldValuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateProjectV2ItemFieldValuePayload'] = ResolversParentTypes['UpdateProjectV2ItemFieldValuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2Item?: Resolver<Maybe<ResolversTypes['ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateProjectV2ItemPositionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateProjectV2ItemPositionPayload'] = ResolversParentTypes['UpdateProjectV2ItemPositionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  items?: Resolver<Maybe<ResolversTypes['ProjectV2ItemConnection']>, ParentType, ContextType, Partial<UpdateProjectV2ItemPositionPayloaditemsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateProjectV2PayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateProjectV2Payload'] = ResolversParentTypes['UpdateProjectV2Payload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdatePullRequestBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdatePullRequestBranchPayload'] = ResolversParentTypes['UpdatePullRequestBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdatePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdatePullRequestPayload'] = ResolversParentTypes['UpdatePullRequestPayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdatePullRequestReviewCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdatePullRequestReviewCommentPayload'] = ResolversParentTypes['UpdatePullRequestReviewCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReviewComment?: Resolver<Maybe<ResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdatePullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdatePullRequestReviewPayload'] = ResolversParentTypes['UpdatePullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateRefPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateRefPayload'] = ResolversParentTypes['UpdateRefPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateRefsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateRefsPayload'] = ResolversParentTypes['UpdateRefsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateRepositoryPayload'] = ResolversParentTypes['UpdateRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateRepositoryRulesetPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateRepositoryRulesetPayload'] = ResolversParentTypes['UpdateRepositoryRulesetPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ruleset?: Resolver<Maybe<ResolversTypes['RepositoryRuleset']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateRepositoryWebCommitSignoffSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateRepositoryWebCommitSignoffSettingPayload'] = ResolversParentTypes['UpdateRepositoryWebCommitSignoffSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateSponsorshipPreferencesPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateSponsorshipPreferencesPayload'] = ResolversParentTypes['UpdateSponsorshipPreferencesPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorship?: Resolver<Maybe<ResolversTypes['Sponsorship']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateSubscriptionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateSubscriptionPayload'] = ResolversParentTypes['UpdateSubscriptionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subscribable?: Resolver<Maybe<ResolversTypes['Subscribable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTeamDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTeamDiscussionCommentPayload'] = ResolversParentTypes['UpdateTeamDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussionComment?: Resolver<Maybe<ResolversTypes['TeamDiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTeamDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTeamDiscussionPayload'] = ResolversParentTypes['UpdateTeamDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussion?: Resolver<Maybe<ResolversTypes['TeamDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTeamReviewAssignmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTeamReviewAssignmentPayload'] = ResolversParentTypes['UpdateTeamReviewAssignmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTeamsRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTeamsRepositoryPayload'] = ResolversParentTypes['UpdateTeamsRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  teams?: Resolver<Maybe<Array<ResolversTypes['Team']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTopicsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTopicsPayload'] = ResolversParentTypes['UpdateTopicsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invalidTopicNames?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateUserListPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateUserListPayload'] = ResolversParentTypes['UpdateUserListPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  list?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateUserListsForItemPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateUserListsForItemPayload'] = ResolversParentTypes['UpdateUserListsForItemPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['UserListItems']>, ParentType, ContextType>;
  lists?: Resolver<Maybe<Array<ResolversTypes['UserList']>>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = ResolversObject<{
  anyPinnableItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<UseranyPinnableItemsArgs>>;
  avatarUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType, Partial<UseravatarUrlArgs>>;
  bio?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  bioHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  canReceiveOrganizationEmailsWhenNotificationsRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<UsercanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs, 'login'>>;
  commitComments?: Resolver<ResolversTypes['CommitCommentConnection'], ParentType, ContextType, Partial<UsercommitCommentsArgs>>;
  company?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  companyHTML?: Resolver<ResolversTypes['HTML'], ParentType, ContextType>;
  contributionsCollection?: Resolver<ResolversTypes['ContributionsCollection'], ParentType, ContextType, Partial<UsercontributionsCollectionArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  enterprises?: Resolver<Maybe<ResolversTypes['EnterpriseConnection']>, ParentType, ContextType, RequireFields<UserenterprisesArgs, 'membershipType' | 'orderBy'>>;
  estimatedNextSponsorsPayoutInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  followers?: Resolver<ResolversTypes['FollowerConnection'], ParentType, ContextType, Partial<UserfollowersArgs>>;
  following?: Resolver<ResolversTypes['FollowingConnection'], ParentType, ContextType, Partial<UserfollowingArgs>>;
  gist?: Resolver<Maybe<ResolversTypes['Gist']>, ParentType, ContextType, RequireFields<UsergistArgs, 'name'>>;
  gistComments?: Resolver<ResolversTypes['GistCommentConnection'], ParentType, ContextType, Partial<UsergistCommentsArgs>>;
  gists?: Resolver<ResolversTypes['GistConnection'], ParentType, ContextType, Partial<UsergistsArgs>>;
  hasSponsorsListing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hovercard?: Resolver<ResolversTypes['Hovercard'], ParentType, ContextType, Partial<UserhovercardArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  interactionAbility?: Resolver<Maybe<ResolversTypes['RepositoryInteractionAbility']>, ParentType, ContextType>;
  isBountyHunter?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isCampusExpert?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDeveloperProgramMember?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isEmployee?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isFollowingViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isGitHubStar?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isHireable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSiteAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSponsoredBy?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<UserisSponsoredByArgs, 'accountLogin'>>;
  isSponsoringViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issueComments?: Resolver<ResolversTypes['IssueCommentConnection'], ParentType, ContextType, Partial<UserissueCommentsArgs>>;
  issues?: Resolver<ResolversTypes['IssueConnection'], ParentType, ContextType, Partial<UserissuesArgs>>;
  itemShowcase?: Resolver<ResolversTypes['ProfileItemShowcase'], ParentType, ContextType>;
  lists?: Resolver<ResolversTypes['UserListConnection'], ParentType, ContextType, Partial<UserlistsArgs>>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  monthlyEstimatedSponsorsIncomeInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType, RequireFields<UserorganizationArgs, 'login'>>;
  organizationVerifiedDomainEmails?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType, RequireFields<UserorganizationVerifiedDomainEmailsArgs, 'login'>>;
  organizations?: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<UserorganizationsArgs, 'orderBy'>>;
  packages?: Resolver<ResolversTypes['PackageConnection'], ParentType, ContextType, RequireFields<UserpackagesArgs, 'orderBy'>>;
  pinnableItems?: Resolver<ResolversTypes['PinnableItemConnection'], ParentType, ContextType, Partial<UserpinnableItemsArgs>>;
  pinnedItems?: Resolver<ResolversTypes['PinnableItemConnection'], ParentType, ContextType, Partial<UserpinnedItemsArgs>>;
  pinnedItemsRemaining?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType, RequireFields<UserprojectArgs, 'number'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['ProjectV2']>, ParentType, ContextType, RequireFields<UserprojectV2Args, 'number'>>;
  projects?: Resolver<ResolversTypes['ProjectConnection'], ParentType, ContextType, Partial<UserprojectsArgs>>;
  projectsResourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  projectsV2?: Resolver<ResolversTypes['ProjectV2Connection'], ParentType, ContextType, RequireFields<UserprojectsV2Args, 'orderBy'>>;
  pronouns?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publicKeys?: Resolver<ResolversTypes['PublicKeyConnection'], ParentType, ContextType, Partial<UserpublicKeysArgs>>;
  pullRequests?: Resolver<ResolversTypes['PullRequestConnection'], ParentType, ContextType, Partial<UserpullRequestsArgs>>;
  recentProjects?: Resolver<ResolversTypes['ProjectV2Connection'], ParentType, ContextType, Partial<UserrecentProjectsArgs>>;
  repositories?: Resolver<ResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<UserrepositoriesArgs, 'ownerAffiliations'>>;
  repositoriesContributedTo?: Resolver<ResolversTypes['RepositoryConnection'], ParentType, ContextType, Partial<UserrepositoriesContributedToArgs>>;
  repository?: Resolver<Maybe<ResolversTypes['Repository']>, ParentType, ContextType, RequireFields<UserrepositoryArgs, 'followRenames' | 'name'>>;
  repositoryDiscussionComments?: Resolver<ResolversTypes['DiscussionCommentConnection'], ParentType, ContextType, RequireFields<UserrepositoryDiscussionCommentsArgs, 'onlyAnswers'>>;
  repositoryDiscussions?: Resolver<ResolversTypes['DiscussionConnection'], ParentType, ContextType, RequireFields<UserrepositoryDiscussionsArgs, 'answered' | 'orderBy' | 'states'>>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  savedReplies?: Resolver<Maybe<ResolversTypes['SavedReplyConnection']>, ParentType, ContextType, RequireFields<UsersavedRepliesArgs, 'orderBy'>>;
  socialAccounts?: Resolver<ResolversTypes['SocialAccountConnection'], ParentType, ContextType, Partial<UsersocialAccountsArgs>>;
  sponsoring?: Resolver<ResolversTypes['SponsorConnection'], ParentType, ContextType, RequireFields<UsersponsoringArgs, 'orderBy'>>;
  sponsors?: Resolver<ResolversTypes['SponsorConnection'], ParentType, ContextType, RequireFields<UsersponsorsArgs, 'orderBy'>>;
  sponsorsActivities?: Resolver<ResolversTypes['SponsorsActivityConnection'], ParentType, ContextType, RequireFields<UsersponsorsActivitiesArgs, 'actions' | 'includeAsSponsor' | 'includePrivate' | 'orderBy' | 'period'>>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['SponsorsListing']>, ParentType, ContextType>;
  sponsorshipForViewerAsSponsor?: Resolver<Maybe<ResolversTypes['Sponsorship']>, ParentType, ContextType, RequireFields<UsersponsorshipForViewerAsSponsorArgs, 'activeOnly'>>;
  sponsorshipForViewerAsSponsorable?: Resolver<Maybe<ResolversTypes['Sponsorship']>, ParentType, ContextType, RequireFields<UsersponsorshipForViewerAsSponsorableArgs, 'activeOnly'>>;
  sponsorshipNewsletters?: Resolver<ResolversTypes['SponsorshipNewsletterConnection'], ParentType, ContextType, RequireFields<UsersponsorshipNewslettersArgs, 'orderBy'>>;
  sponsorshipsAsMaintainer?: Resolver<ResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<UsersponsorshipsAsMaintainerArgs, 'activeOnly' | 'includePrivate'>>;
  sponsorshipsAsSponsor?: Resolver<ResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<UsersponsorshipsAsSponsorArgs, 'activeOnly'>>;
  starredRepositories?: Resolver<ResolversTypes['StarredRepositoryConnection'], ParentType, ContextType, Partial<UserstarredRepositoriesArgs>>;
  status?: Resolver<Maybe<ResolversTypes['UserStatus']>, ParentType, ContextType>;
  suggestedListNames?: Resolver<Array<ResolversTypes['UserListSuggestion']>, ParentType, ContextType>;
  topRepositories?: Resolver<ResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<UsertopRepositoriesArgs, 'orderBy'>>;
  totalSponsorshipAmountAsSponsorInCents?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<UsertotalSponsorshipAmountAsSponsorInCentsArgs, 'sponsorableLogins'>>;
  twitterUsername?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  viewerCanChangePinnedItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanFollow?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSponsor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsFollowing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsSponsoring?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  watching?: Resolver<ResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<UserwatchingArgs, 'ownerAffiliations'>>;
  websiteUrl?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserBlockedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserBlockedEvent'] = ResolversParentTypes['UserBlockedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  blockDuration?: Resolver<ResolversTypes['UserBlockDuration'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserConnection'] = ResolversParentTypes['UserConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserContentEditResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserContentEdit'] = ResolversParentTypes['UserContentEdit']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  deletedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  deletedBy?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  diff?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserContentEditConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserContentEditConnection'] = ResolversParentTypes['UserContentEditConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserContentEditEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserContentEdit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserContentEditEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserContentEditEdge'] = ResolversParentTypes['UserContentEditEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UserContentEdit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserEdge'] = ResolversParentTypes['UserEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserEmailMetadataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserEmailMetadata'] = ResolversParentTypes['UserEmailMetadata']> = ResolversObject<{
  primary?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserList'] = ResolversParentTypes['UserList']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  items?: Resolver<ResolversTypes['UserListItemsConnection'], ParentType, ContextType, Partial<UserListitemsArgs>>;
  lastAddedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserListConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserListConnection'] = ResolversParentTypes['UserListConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserListEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserList']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserListEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserListEdge'] = ResolversParentTypes['UserListEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserListItemsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserListItems'] = ResolversParentTypes['UserListItems']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Repository', ParentType, ContextType>;
}>;

export type UserListItemsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserListItemsConnection'] = ResolversParentTypes['UserListItemsConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserListItemsEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserListItems']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserListItemsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserListItemsEdge'] = ResolversParentTypes['UserListItemsEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UserListItems']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserListSuggestionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserListSuggestion'] = ResolversParentTypes['UserListSuggestion']> = ResolversObject<{
  id?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserStatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserStatus'] = ResolversParentTypes['UserStatus']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  emoji?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emojiHTML?: Resolver<Maybe<ResolversTypes['HTML']>, ParentType, ContextType>;
  expiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  indicatesLimitedAvailability?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserStatusConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserStatusConnection'] = ResolversParentTypes['UserStatusConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserStatusEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserStatus']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserStatusEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UserStatusEdge'] = ResolversParentTypes['UserStatusEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UserStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VerifiableDomainResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VerifiableDomain'] = ResolversParentTypes['VerifiableDomain']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  dnsHostName?: Resolver<Maybe<ResolversTypes['URI']>, ParentType, ContextType>;
  domain?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  hasFoundHostName?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasFoundVerificationToken?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isApproved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRequiredForPolicyEnforcement?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['VerifiableDomainOwner'], ParentType, ContextType>;
  punycodeEncodedDomain?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  tokenExpirationTime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  verificationToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VerifiableDomainConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VerifiableDomainConnection'] = ResolversParentTypes['VerifiableDomainConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['VerifiableDomainEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['VerifiableDomain']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VerifiableDomainEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VerifiableDomainEdge'] = ResolversParentTypes['VerifiableDomainEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['VerifiableDomain']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VerifiableDomainOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VerifiableDomainOwner'] = ResolversParentTypes['VerifiableDomainOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Enterprise' | 'Organization', ParentType, ContextType>;
}>;

export type VerifyVerifiableDomainPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VerifyVerifiableDomainPayload'] = ResolversParentTypes['VerifyVerifiableDomainPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domain?: Resolver<Maybe<ResolversTypes['VerifiableDomain']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ViewerHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ViewerHovercardContext'] = ResolversParentTypes['ViewerHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  viewer?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VotableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Votable'] = ResolversParentTypes['Votable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Discussion' | 'DiscussionComment', ParentType, ContextType>;
  upvoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerCanUpvote?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasUpvoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type WorkflowResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Workflow'] = ResolversParentTypes['Workflow']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  runs?: Resolver<ResolversTypes['WorkflowRunConnection'], ParentType, ContextType, RequireFields<WorkflowrunsArgs, 'orderBy'>>;
  state?: Resolver<ResolversTypes['WorkflowState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkflowFileReferenceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WorkflowFileReference'] = ResolversParentTypes['WorkflowFileReference']> = ResolversObject<{
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  sha?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkflowRunResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WorkflowRun'] = ResolversParentTypes['WorkflowRun']> = ResolversObject<{
  checkSuite?: Resolver<ResolversTypes['CheckSuite'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deploymentReviews?: Resolver<ResolversTypes['DeploymentReviewConnection'], ParentType, ContextType, Partial<WorkflowRundeploymentReviewsArgs>>;
  event?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['WorkflowRunFile']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pendingDeploymentRequests?: Resolver<ResolversTypes['DeploymentRequestConnection'], ParentType, ContextType, Partial<WorkflowRunpendingDeploymentRequestsArgs>>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  runNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  workflow?: Resolver<ResolversTypes['Workflow'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkflowRunConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WorkflowRunConnection'] = ResolversParentTypes['WorkflowRunConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkflowRunEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkflowRun']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkflowRunEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WorkflowRunEdge'] = ResolversParentTypes['WorkflowRunEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['WorkflowRun']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkflowRunFileResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WorkflowRunFile'] = ResolversParentTypes['WorkflowRunFile']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  repositoryFileUrl?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  repositoryName?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  run?: Resolver<ResolversTypes['WorkflowRun'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['URI'], ParentType, ContextType>;
  viewerCanPushRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReadRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkflowsParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WorkflowsParameters'] = ResolversParentTypes['WorkflowsParameters']> = ResolversObject<{
  workflows?: Resolver<Array<ResolversTypes['WorkflowFileReference']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface X509CertificateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['X509Certificate'], any> {
  name: 'X509Certificate';
}

export type Resolvers<ContextType = MeshContext> = ResolversObject<{
  AbortQueuedMigrationsPayload?: AbortQueuedMigrationsPayloadResolvers<ContextType>;
  AbortRepositoryMigrationPayload?: AbortRepositoryMigrationPayloadResolvers<ContextType>;
  AcceptEnterpriseAdministratorInvitationPayload?: AcceptEnterpriseAdministratorInvitationPayloadResolvers<ContextType>;
  AcceptTopicSuggestionPayload?: AcceptTopicSuggestionPayloadResolvers<ContextType>;
  Actor?: ActorResolvers<ContextType>;
  ActorLocation?: ActorLocationResolvers<ContextType>;
  AddAssigneesToAssignablePayload?: AddAssigneesToAssignablePayloadResolvers<ContextType>;
  AddCommentPayload?: AddCommentPayloadResolvers<ContextType>;
  AddDiscussionCommentPayload?: AddDiscussionCommentPayloadResolvers<ContextType>;
  AddDiscussionPollVotePayload?: AddDiscussionPollVotePayloadResolvers<ContextType>;
  AddEnterpriseOrganizationMemberPayload?: AddEnterpriseOrganizationMemberPayloadResolvers<ContextType>;
  AddEnterpriseSupportEntitlementPayload?: AddEnterpriseSupportEntitlementPayloadResolvers<ContextType>;
  AddLabelsToLabelablePayload?: AddLabelsToLabelablePayloadResolvers<ContextType>;
  AddProjectCardPayload?: AddProjectCardPayloadResolvers<ContextType>;
  AddProjectColumnPayload?: AddProjectColumnPayloadResolvers<ContextType>;
  AddProjectV2DraftIssuePayload?: AddProjectV2DraftIssuePayloadResolvers<ContextType>;
  AddProjectV2ItemByIdPayload?: AddProjectV2ItemByIdPayloadResolvers<ContextType>;
  AddPullRequestReviewCommentPayload?: AddPullRequestReviewCommentPayloadResolvers<ContextType>;
  AddPullRequestReviewPayload?: AddPullRequestReviewPayloadResolvers<ContextType>;
  AddPullRequestReviewThreadPayload?: AddPullRequestReviewThreadPayloadResolvers<ContextType>;
  AddPullRequestReviewThreadReplyPayload?: AddPullRequestReviewThreadReplyPayloadResolvers<ContextType>;
  AddReactionPayload?: AddReactionPayloadResolvers<ContextType>;
  AddStarPayload?: AddStarPayloadResolvers<ContextType>;
  AddUpvotePayload?: AddUpvotePayloadResolvers<ContextType>;
  AddVerifiableDomainPayload?: AddVerifiableDomainPayloadResolvers<ContextType>;
  AddedToMergeQueueEvent?: AddedToMergeQueueEventResolvers<ContextType>;
  AddedToProjectEvent?: AddedToProjectEventResolvers<ContextType>;
  AnnouncementBanner?: AnnouncementBannerResolvers<ContextType>;
  App?: AppResolvers<ContextType>;
  ApproveDeploymentsPayload?: ApproveDeploymentsPayloadResolvers<ContextType>;
  ApproveVerifiableDomainPayload?: ApproveVerifiableDomainPayloadResolvers<ContextType>;
  ArchiveProjectV2ItemPayload?: ArchiveProjectV2ItemPayloadResolvers<ContextType>;
  ArchiveRepositoryPayload?: ArchiveRepositoryPayloadResolvers<ContextType>;
  Assignable?: AssignableResolvers<ContextType>;
  AssignedEvent?: AssignedEventResolvers<ContextType>;
  Assignee?: AssigneeResolvers<ContextType>;
  AuditEntry?: AuditEntryResolvers<ContextType>;
  AuditEntryActor?: AuditEntryActorResolvers<ContextType>;
  AutoMergeDisabledEvent?: AutoMergeDisabledEventResolvers<ContextType>;
  AutoMergeEnabledEvent?: AutoMergeEnabledEventResolvers<ContextType>;
  AutoMergeRequest?: AutoMergeRequestResolvers<ContextType>;
  AutoRebaseEnabledEvent?: AutoRebaseEnabledEventResolvers<ContextType>;
  AutoSquashEnabledEvent?: AutoSquashEnabledEventResolvers<ContextType>;
  AutomaticBaseChangeFailedEvent?: AutomaticBaseChangeFailedEventResolvers<ContextType>;
  AutomaticBaseChangeSucceededEvent?: AutomaticBaseChangeSucceededEventResolvers<ContextType>;
  Base64String?: GraphQLScalarType;
  BaseRefChangedEvent?: BaseRefChangedEventResolvers<ContextType>;
  BaseRefDeletedEvent?: BaseRefDeletedEventResolvers<ContextType>;
  BaseRefForcePushedEvent?: BaseRefForcePushedEventResolvers<ContextType>;
  BigInt?: GraphQLScalarType;
  Blame?: BlameResolvers<ContextType>;
  BlameRange?: BlameRangeResolvers<ContextType>;
  Blob?: BlobResolvers<ContextType>;
  Bot?: BotResolvers<ContextType>;
  BranchActorAllowanceActor?: BranchActorAllowanceActorResolvers<ContextType>;
  BranchNamePatternParameters?: BranchNamePatternParametersResolvers<ContextType>;
  BranchProtectionRule?: BranchProtectionRuleResolvers<ContextType>;
  BranchProtectionRuleConflict?: BranchProtectionRuleConflictResolvers<ContextType>;
  BranchProtectionRuleConflictConnection?: BranchProtectionRuleConflictConnectionResolvers<ContextType>;
  BranchProtectionRuleConflictEdge?: BranchProtectionRuleConflictEdgeResolvers<ContextType>;
  BranchProtectionRuleConnection?: BranchProtectionRuleConnectionResolvers<ContextType>;
  BranchProtectionRuleEdge?: BranchProtectionRuleEdgeResolvers<ContextType>;
  BypassActor?: BypassActorResolvers<ContextType>;
  BypassForcePushAllowance?: BypassForcePushAllowanceResolvers<ContextType>;
  BypassForcePushAllowanceConnection?: BypassForcePushAllowanceConnectionResolvers<ContextType>;
  BypassForcePushAllowanceEdge?: BypassForcePushAllowanceEdgeResolvers<ContextType>;
  BypassPullRequestAllowance?: BypassPullRequestAllowanceResolvers<ContextType>;
  BypassPullRequestAllowanceConnection?: BypassPullRequestAllowanceConnectionResolvers<ContextType>;
  BypassPullRequestAllowanceEdge?: BypassPullRequestAllowanceEdgeResolvers<ContextType>;
  CVSS?: CVSSResolvers<ContextType>;
  CWE?: CWEResolvers<ContextType>;
  CWEConnection?: CWEConnectionResolvers<ContextType>;
  CWEEdge?: CWEEdgeResolvers<ContextType>;
  CancelEnterpriseAdminInvitationPayload?: CancelEnterpriseAdminInvitationPayloadResolvers<ContextType>;
  CancelSponsorshipPayload?: CancelSponsorshipPayloadResolvers<ContextType>;
  ChangeUserStatusPayload?: ChangeUserStatusPayloadResolvers<ContextType>;
  CheckAnnotation?: CheckAnnotationResolvers<ContextType>;
  CheckAnnotationConnection?: CheckAnnotationConnectionResolvers<ContextType>;
  CheckAnnotationEdge?: CheckAnnotationEdgeResolvers<ContextType>;
  CheckAnnotationPosition?: CheckAnnotationPositionResolvers<ContextType>;
  CheckAnnotationSpan?: CheckAnnotationSpanResolvers<ContextType>;
  CheckRun?: CheckRunResolvers<ContextType>;
  CheckRunConnection?: CheckRunConnectionResolvers<ContextType>;
  CheckRunEdge?: CheckRunEdgeResolvers<ContextType>;
  CheckRunStateCount?: CheckRunStateCountResolvers<ContextType>;
  CheckStep?: CheckStepResolvers<ContextType>;
  CheckStepConnection?: CheckStepConnectionResolvers<ContextType>;
  CheckStepEdge?: CheckStepEdgeResolvers<ContextType>;
  CheckSuite?: CheckSuiteResolvers<ContextType>;
  CheckSuiteConnection?: CheckSuiteConnectionResolvers<ContextType>;
  CheckSuiteEdge?: CheckSuiteEdgeResolvers<ContextType>;
  Claimable?: ClaimableResolvers<ContextType>;
  ClearLabelsFromLabelablePayload?: ClearLabelsFromLabelablePayloadResolvers<ContextType>;
  ClearProjectV2ItemFieldValuePayload?: ClearProjectV2ItemFieldValuePayloadResolvers<ContextType>;
  CloneProjectPayload?: CloneProjectPayloadResolvers<ContextType>;
  CloneTemplateRepositoryPayload?: CloneTemplateRepositoryPayloadResolvers<ContextType>;
  Closable?: ClosableResolvers<ContextType>;
  CloseDiscussionPayload?: CloseDiscussionPayloadResolvers<ContextType>;
  CloseIssuePayload?: CloseIssuePayloadResolvers<ContextType>;
  ClosePullRequestPayload?: ClosePullRequestPayloadResolvers<ContextType>;
  ClosedEvent?: ClosedEventResolvers<ContextType>;
  Closer?: CloserResolvers<ContextType>;
  CodeOfConduct?: CodeOfConductResolvers<ContextType>;
  Comment?: CommentResolvers<ContextType>;
  CommentDeletedEvent?: CommentDeletedEventResolvers<ContextType>;
  Commit?: CommitResolvers<ContextType>;
  CommitAuthorEmailPatternParameters?: CommitAuthorEmailPatternParametersResolvers<ContextType>;
  CommitComment?: CommitCommentResolvers<ContextType>;
  CommitCommentConnection?: CommitCommentConnectionResolvers<ContextType>;
  CommitCommentEdge?: CommitCommentEdgeResolvers<ContextType>;
  CommitCommentThread?: CommitCommentThreadResolvers<ContextType>;
  CommitConnection?: CommitConnectionResolvers<ContextType>;
  CommitContributionsByRepository?: CommitContributionsByRepositoryResolvers<ContextType>;
  CommitEdge?: CommitEdgeResolvers<ContextType>;
  CommitHistoryConnection?: CommitHistoryConnectionResolvers<ContextType>;
  CommitMessagePatternParameters?: CommitMessagePatternParametersResolvers<ContextType>;
  CommitterEmailPatternParameters?: CommitterEmailPatternParametersResolvers<ContextType>;
  Comparison?: ComparisonResolvers<ContextType>;
  ComparisonCommitConnection?: ComparisonCommitConnectionResolvers<ContextType>;
  ConnectedEvent?: ConnectedEventResolvers<ContextType>;
  ContributingGuidelines?: ContributingGuidelinesResolvers<ContextType>;
  Contribution?: ContributionResolvers<ContextType>;
  ContributionCalendar?: ContributionCalendarResolvers<ContextType>;
  ContributionCalendarDay?: ContributionCalendarDayResolvers<ContextType>;
  ContributionCalendarMonth?: ContributionCalendarMonthResolvers<ContextType>;
  ContributionCalendarWeek?: ContributionCalendarWeekResolvers<ContextType>;
  ContributionsCollection?: ContributionsCollectionResolvers<ContextType>;
  ConvertProjectCardNoteToIssuePayload?: ConvertProjectCardNoteToIssuePayloadResolvers<ContextType>;
  ConvertPullRequestToDraftPayload?: ConvertPullRequestToDraftPayloadResolvers<ContextType>;
  ConvertToDraftEvent?: ConvertToDraftEventResolvers<ContextType>;
  ConvertedNoteToIssueEvent?: ConvertedNoteToIssueEventResolvers<ContextType>;
  ConvertedToDiscussionEvent?: ConvertedToDiscussionEventResolvers<ContextType>;
  CopyProjectV2Payload?: CopyProjectV2PayloadResolvers<ContextType>;
  CreateAttributionInvitationPayload?: CreateAttributionInvitationPayloadResolvers<ContextType>;
  CreateBranchProtectionRulePayload?: CreateBranchProtectionRulePayloadResolvers<ContextType>;
  CreateCheckRunPayload?: CreateCheckRunPayloadResolvers<ContextType>;
  CreateCheckSuitePayload?: CreateCheckSuitePayloadResolvers<ContextType>;
  CreateCommitOnBranchPayload?: CreateCommitOnBranchPayloadResolvers<ContextType>;
  CreateDeploymentPayload?: CreateDeploymentPayloadResolvers<ContextType>;
  CreateDeploymentStatusPayload?: CreateDeploymentStatusPayloadResolvers<ContextType>;
  CreateDiscussionPayload?: CreateDiscussionPayloadResolvers<ContextType>;
  CreateEnterpriseOrganizationPayload?: CreateEnterpriseOrganizationPayloadResolvers<ContextType>;
  CreateEnvironmentPayload?: CreateEnvironmentPayloadResolvers<ContextType>;
  CreateIpAllowListEntryPayload?: CreateIpAllowListEntryPayloadResolvers<ContextType>;
  CreateIssuePayload?: CreateIssuePayloadResolvers<ContextType>;
  CreateLabelPayload?: CreateLabelPayloadResolvers<ContextType>;
  CreateLinkedBranchPayload?: CreateLinkedBranchPayloadResolvers<ContextType>;
  CreateMigrationSourcePayload?: CreateMigrationSourcePayloadResolvers<ContextType>;
  CreateProjectPayload?: CreateProjectPayloadResolvers<ContextType>;
  CreateProjectV2FieldPayload?: CreateProjectV2FieldPayloadResolvers<ContextType>;
  CreateProjectV2Payload?: CreateProjectV2PayloadResolvers<ContextType>;
  CreatePullRequestPayload?: CreatePullRequestPayloadResolvers<ContextType>;
  CreateRefPayload?: CreateRefPayloadResolvers<ContextType>;
  CreateRepositoryPayload?: CreateRepositoryPayloadResolvers<ContextType>;
  CreateRepositoryRulesetPayload?: CreateRepositoryRulesetPayloadResolvers<ContextType>;
  CreateSponsorsListingPayload?: CreateSponsorsListingPayloadResolvers<ContextType>;
  CreateSponsorsTierPayload?: CreateSponsorsTierPayloadResolvers<ContextType>;
  CreateSponsorshipPayload?: CreateSponsorshipPayloadResolvers<ContextType>;
  CreateSponsorshipsPayload?: CreateSponsorshipsPayloadResolvers<ContextType>;
  CreateTeamDiscussionCommentPayload?: CreateTeamDiscussionCommentPayloadResolvers<ContextType>;
  CreateTeamDiscussionPayload?: CreateTeamDiscussionPayloadResolvers<ContextType>;
  CreateUserListPayload?: CreateUserListPayloadResolvers<ContextType>;
  CreatedCommitContribution?: CreatedCommitContributionResolvers<ContextType>;
  CreatedCommitContributionConnection?: CreatedCommitContributionConnectionResolvers<ContextType>;
  CreatedCommitContributionEdge?: CreatedCommitContributionEdgeResolvers<ContextType>;
  CreatedIssueContribution?: CreatedIssueContributionResolvers<ContextType>;
  CreatedIssueContributionConnection?: CreatedIssueContributionConnectionResolvers<ContextType>;
  CreatedIssueContributionEdge?: CreatedIssueContributionEdgeResolvers<ContextType>;
  CreatedIssueOrRestrictedContribution?: CreatedIssueOrRestrictedContributionResolvers<ContextType>;
  CreatedPullRequestContribution?: CreatedPullRequestContributionResolvers<ContextType>;
  CreatedPullRequestContributionConnection?: CreatedPullRequestContributionConnectionResolvers<ContextType>;
  CreatedPullRequestContributionEdge?: CreatedPullRequestContributionEdgeResolvers<ContextType>;
  CreatedPullRequestOrRestrictedContribution?: CreatedPullRequestOrRestrictedContributionResolvers<ContextType>;
  CreatedPullRequestReviewContribution?: CreatedPullRequestReviewContributionResolvers<ContextType>;
  CreatedPullRequestReviewContributionConnection?: CreatedPullRequestReviewContributionConnectionResolvers<ContextType>;
  CreatedPullRequestReviewContributionEdge?: CreatedPullRequestReviewContributionEdgeResolvers<ContextType>;
  CreatedRepositoryContribution?: CreatedRepositoryContributionResolvers<ContextType>;
  CreatedRepositoryContributionConnection?: CreatedRepositoryContributionConnectionResolvers<ContextType>;
  CreatedRepositoryContributionEdge?: CreatedRepositoryContributionEdgeResolvers<ContextType>;
  CreatedRepositoryOrRestrictedContribution?: CreatedRepositoryOrRestrictedContributionResolvers<ContextType>;
  CrossReferencedEvent?: CrossReferencedEventResolvers<ContextType>;
  Date?: GraphQLScalarType;
  DateTime?: GraphQLScalarType;
  DeclineTopicSuggestionPayload?: DeclineTopicSuggestionPayloadResolvers<ContextType>;
  Deletable?: DeletableResolvers<ContextType>;
  DeleteBranchProtectionRulePayload?: DeleteBranchProtectionRulePayloadResolvers<ContextType>;
  DeleteDeploymentPayload?: DeleteDeploymentPayloadResolvers<ContextType>;
  DeleteDiscussionCommentPayload?: DeleteDiscussionCommentPayloadResolvers<ContextType>;
  DeleteDiscussionPayload?: DeleteDiscussionPayloadResolvers<ContextType>;
  DeleteEnvironmentPayload?: DeleteEnvironmentPayloadResolvers<ContextType>;
  DeleteIpAllowListEntryPayload?: DeleteIpAllowListEntryPayloadResolvers<ContextType>;
  DeleteIssueCommentPayload?: DeleteIssueCommentPayloadResolvers<ContextType>;
  DeleteIssuePayload?: DeleteIssuePayloadResolvers<ContextType>;
  DeleteLabelPayload?: DeleteLabelPayloadResolvers<ContextType>;
  DeleteLinkedBranchPayload?: DeleteLinkedBranchPayloadResolvers<ContextType>;
  DeletePackageVersionPayload?: DeletePackageVersionPayloadResolvers<ContextType>;
  DeleteProjectCardPayload?: DeleteProjectCardPayloadResolvers<ContextType>;
  DeleteProjectColumnPayload?: DeleteProjectColumnPayloadResolvers<ContextType>;
  DeleteProjectPayload?: DeleteProjectPayloadResolvers<ContextType>;
  DeleteProjectV2FieldPayload?: DeleteProjectV2FieldPayloadResolvers<ContextType>;
  DeleteProjectV2ItemPayload?: DeleteProjectV2ItemPayloadResolvers<ContextType>;
  DeleteProjectV2Payload?: DeleteProjectV2PayloadResolvers<ContextType>;
  DeleteProjectV2WorkflowPayload?: DeleteProjectV2WorkflowPayloadResolvers<ContextType>;
  DeletePullRequestReviewCommentPayload?: DeletePullRequestReviewCommentPayloadResolvers<ContextType>;
  DeletePullRequestReviewPayload?: DeletePullRequestReviewPayloadResolvers<ContextType>;
  DeleteRefPayload?: DeleteRefPayloadResolvers<ContextType>;
  DeleteRepositoryRulesetPayload?: DeleteRepositoryRulesetPayloadResolvers<ContextType>;
  DeleteTeamDiscussionCommentPayload?: DeleteTeamDiscussionCommentPayloadResolvers<ContextType>;
  DeleteTeamDiscussionPayload?: DeleteTeamDiscussionPayloadResolvers<ContextType>;
  DeleteUserListPayload?: DeleteUserListPayloadResolvers<ContextType>;
  DeleteVerifiableDomainPayload?: DeleteVerifiableDomainPayloadResolvers<ContextType>;
  DemilestonedEvent?: DemilestonedEventResolvers<ContextType>;
  DependabotUpdate?: DependabotUpdateResolvers<ContextType>;
  DependabotUpdateError?: DependabotUpdateErrorResolvers<ContextType>;
  DependencyGraphDependency?: DependencyGraphDependencyResolvers<ContextType>;
  DependencyGraphDependencyConnection?: DependencyGraphDependencyConnectionResolvers<ContextType>;
  DependencyGraphDependencyEdge?: DependencyGraphDependencyEdgeResolvers<ContextType>;
  DependencyGraphManifest?: DependencyGraphManifestResolvers<ContextType>;
  DependencyGraphManifestConnection?: DependencyGraphManifestConnectionResolvers<ContextType>;
  DependencyGraphManifestEdge?: DependencyGraphManifestEdgeResolvers<ContextType>;
  DeployKey?: DeployKeyResolvers<ContextType>;
  DeployKeyConnection?: DeployKeyConnectionResolvers<ContextType>;
  DeployKeyEdge?: DeployKeyEdgeResolvers<ContextType>;
  DeployedEvent?: DeployedEventResolvers<ContextType>;
  Deployment?: DeploymentResolvers<ContextType>;
  DeploymentConnection?: DeploymentConnectionResolvers<ContextType>;
  DeploymentEdge?: DeploymentEdgeResolvers<ContextType>;
  DeploymentEnvironmentChangedEvent?: DeploymentEnvironmentChangedEventResolvers<ContextType>;
  DeploymentProtectionRule?: DeploymentProtectionRuleResolvers<ContextType>;
  DeploymentProtectionRuleConnection?: DeploymentProtectionRuleConnectionResolvers<ContextType>;
  DeploymentProtectionRuleEdge?: DeploymentProtectionRuleEdgeResolvers<ContextType>;
  DeploymentRequest?: DeploymentRequestResolvers<ContextType>;
  DeploymentRequestConnection?: DeploymentRequestConnectionResolvers<ContextType>;
  DeploymentRequestEdge?: DeploymentRequestEdgeResolvers<ContextType>;
  DeploymentReview?: DeploymentReviewResolvers<ContextType>;
  DeploymentReviewConnection?: DeploymentReviewConnectionResolvers<ContextType>;
  DeploymentReviewEdge?: DeploymentReviewEdgeResolvers<ContextType>;
  DeploymentReviewer?: DeploymentReviewerResolvers<ContextType>;
  DeploymentReviewerConnection?: DeploymentReviewerConnectionResolvers<ContextType>;
  DeploymentReviewerEdge?: DeploymentReviewerEdgeResolvers<ContextType>;
  DeploymentStatus?: DeploymentStatusResolvers<ContextType>;
  DeploymentStatusConnection?: DeploymentStatusConnectionResolvers<ContextType>;
  DeploymentStatusEdge?: DeploymentStatusEdgeResolvers<ContextType>;
  DequeuePullRequestPayload?: DequeuePullRequestPayloadResolvers<ContextType>;
  DisablePullRequestAutoMergePayload?: DisablePullRequestAutoMergePayloadResolvers<ContextType>;
  DisconnectedEvent?: DisconnectedEventResolvers<ContextType>;
  Discussion?: DiscussionResolvers<ContextType>;
  DiscussionCategory?: DiscussionCategoryResolvers<ContextType>;
  DiscussionCategoryConnection?: DiscussionCategoryConnectionResolvers<ContextType>;
  DiscussionCategoryEdge?: DiscussionCategoryEdgeResolvers<ContextType>;
  DiscussionComment?: DiscussionCommentResolvers<ContextType>;
  DiscussionCommentConnection?: DiscussionCommentConnectionResolvers<ContextType>;
  DiscussionCommentEdge?: DiscussionCommentEdgeResolvers<ContextType>;
  DiscussionConnection?: DiscussionConnectionResolvers<ContextType>;
  DiscussionEdge?: DiscussionEdgeResolvers<ContextType>;
  DiscussionPoll?: DiscussionPollResolvers<ContextType>;
  DiscussionPollOption?: DiscussionPollOptionResolvers<ContextType>;
  DiscussionPollOptionConnection?: DiscussionPollOptionConnectionResolvers<ContextType>;
  DiscussionPollOptionEdge?: DiscussionPollOptionEdgeResolvers<ContextType>;
  DismissPullRequestReviewPayload?: DismissPullRequestReviewPayloadResolvers<ContextType>;
  DismissRepositoryVulnerabilityAlertPayload?: DismissRepositoryVulnerabilityAlertPayloadResolvers<ContextType>;
  DraftIssue?: DraftIssueResolvers<ContextType>;
  EnablePullRequestAutoMergePayload?: EnablePullRequestAutoMergePayloadResolvers<ContextType>;
  EnqueuePullRequestPayload?: EnqueuePullRequestPayloadResolvers<ContextType>;
  Enterprise?: EnterpriseResolvers<ContextType>;
  EnterpriseAdministratorConnection?: EnterpriseAdministratorConnectionResolvers<ContextType>;
  EnterpriseAdministratorEdge?: EnterpriseAdministratorEdgeResolvers<ContextType>;
  EnterpriseAdministratorInvitation?: EnterpriseAdministratorInvitationResolvers<ContextType>;
  EnterpriseAdministratorInvitationConnection?: EnterpriseAdministratorInvitationConnectionResolvers<ContextType>;
  EnterpriseAdministratorInvitationEdge?: EnterpriseAdministratorInvitationEdgeResolvers<ContextType>;
  EnterpriseAuditEntryData?: EnterpriseAuditEntryDataResolvers<ContextType>;
  EnterpriseBillingInfo?: EnterpriseBillingInfoResolvers<ContextType>;
  EnterpriseConnection?: EnterpriseConnectionResolvers<ContextType>;
  EnterpriseEdge?: EnterpriseEdgeResolvers<ContextType>;
  EnterpriseFailedInvitationConnection?: EnterpriseFailedInvitationConnectionResolvers<ContextType>;
  EnterpriseFailedInvitationEdge?: EnterpriseFailedInvitationEdgeResolvers<ContextType>;
  EnterpriseIdentityProvider?: EnterpriseIdentityProviderResolvers<ContextType>;
  EnterpriseMember?: EnterpriseMemberResolvers<ContextType>;
  EnterpriseMemberConnection?: EnterpriseMemberConnectionResolvers<ContextType>;
  EnterpriseMemberEdge?: EnterpriseMemberEdgeResolvers<ContextType>;
  EnterpriseOrganizationMembershipConnection?: EnterpriseOrganizationMembershipConnectionResolvers<ContextType>;
  EnterpriseOrganizationMembershipEdge?: EnterpriseOrganizationMembershipEdgeResolvers<ContextType>;
  EnterpriseOutsideCollaboratorConnection?: EnterpriseOutsideCollaboratorConnectionResolvers<ContextType>;
  EnterpriseOutsideCollaboratorEdge?: EnterpriseOutsideCollaboratorEdgeResolvers<ContextType>;
  EnterpriseOwnerInfo?: EnterpriseOwnerInfoResolvers<ContextType>;
  EnterprisePendingMemberInvitationConnection?: EnterprisePendingMemberInvitationConnectionResolvers<ContextType>;
  EnterprisePendingMemberInvitationEdge?: EnterprisePendingMemberInvitationEdgeResolvers<ContextType>;
  EnterpriseRepositoryInfo?: EnterpriseRepositoryInfoResolvers<ContextType>;
  EnterpriseRepositoryInfoConnection?: EnterpriseRepositoryInfoConnectionResolvers<ContextType>;
  EnterpriseRepositoryInfoEdge?: EnterpriseRepositoryInfoEdgeResolvers<ContextType>;
  EnterpriseServerInstallation?: EnterpriseServerInstallationResolvers<ContextType>;
  EnterpriseServerInstallationConnection?: EnterpriseServerInstallationConnectionResolvers<ContextType>;
  EnterpriseServerInstallationEdge?: EnterpriseServerInstallationEdgeResolvers<ContextType>;
  EnterpriseServerInstallationMembershipConnection?: EnterpriseServerInstallationMembershipConnectionResolvers<ContextType>;
  EnterpriseServerInstallationMembershipEdge?: EnterpriseServerInstallationMembershipEdgeResolvers<ContextType>;
  EnterpriseServerUserAccount?: EnterpriseServerUserAccountResolvers<ContextType>;
  EnterpriseServerUserAccountConnection?: EnterpriseServerUserAccountConnectionResolvers<ContextType>;
  EnterpriseServerUserAccountEdge?: EnterpriseServerUserAccountEdgeResolvers<ContextType>;
  EnterpriseServerUserAccountEmail?: EnterpriseServerUserAccountEmailResolvers<ContextType>;
  EnterpriseServerUserAccountEmailConnection?: EnterpriseServerUserAccountEmailConnectionResolvers<ContextType>;
  EnterpriseServerUserAccountEmailEdge?: EnterpriseServerUserAccountEmailEdgeResolvers<ContextType>;
  EnterpriseServerUserAccountsUpload?: EnterpriseServerUserAccountsUploadResolvers<ContextType>;
  EnterpriseServerUserAccountsUploadConnection?: EnterpriseServerUserAccountsUploadConnectionResolvers<ContextType>;
  EnterpriseServerUserAccountsUploadEdge?: EnterpriseServerUserAccountsUploadEdgeResolvers<ContextType>;
  EnterpriseUserAccount?: EnterpriseUserAccountResolvers<ContextType>;
  Environment?: EnvironmentResolvers<ContextType>;
  EnvironmentConnection?: EnvironmentConnectionResolvers<ContextType>;
  EnvironmentEdge?: EnvironmentEdgeResolvers<ContextType>;
  ExternalIdentity?: ExternalIdentityResolvers<ContextType>;
  ExternalIdentityAttribute?: ExternalIdentityAttributeResolvers<ContextType>;
  ExternalIdentityConnection?: ExternalIdentityConnectionResolvers<ContextType>;
  ExternalIdentityEdge?: ExternalIdentityEdgeResolvers<ContextType>;
  ExternalIdentitySamlAttributes?: ExternalIdentitySamlAttributesResolvers<ContextType>;
  ExternalIdentityScimAttributes?: ExternalIdentityScimAttributesResolvers<ContextType>;
  FollowOrganizationPayload?: FollowOrganizationPayloadResolvers<ContextType>;
  FollowUserPayload?: FollowUserPayloadResolvers<ContextType>;
  FollowerConnection?: FollowerConnectionResolvers<ContextType>;
  FollowingConnection?: FollowingConnectionResolvers<ContextType>;
  FundingLink?: FundingLinkResolvers<ContextType>;
  GenericHovercardContext?: GenericHovercardContextResolvers<ContextType>;
  Gist?: GistResolvers<ContextType>;
  GistComment?: GistCommentResolvers<ContextType>;
  GistCommentConnection?: GistCommentConnectionResolvers<ContextType>;
  GistCommentEdge?: GistCommentEdgeResolvers<ContextType>;
  GistConnection?: GistConnectionResolvers<ContextType>;
  GistEdge?: GistEdgeResolvers<ContextType>;
  GistFile?: GistFileResolvers<ContextType>;
  GitActor?: GitActorResolvers<ContextType>;
  GitActorConnection?: GitActorConnectionResolvers<ContextType>;
  GitActorEdge?: GitActorEdgeResolvers<ContextType>;
  GitHubMetadata?: GitHubMetadataResolvers<ContextType>;
  GitObject?: GitObjectResolvers<ContextType>;
  GitObjectID?: GraphQLScalarType;
  GitRefname?: GraphQLScalarType;
  GitSSHRemote?: GraphQLScalarType;
  GitSignature?: GitSignatureResolvers<ContextType>;
  GitTimestamp?: GraphQLScalarType;
  GpgSignature?: GpgSignatureResolvers<ContextType>;
  GrantEnterpriseOrganizationsMigratorRolePayload?: GrantEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType>;
  GrantMigratorRolePayload?: GrantMigratorRolePayloadResolvers<ContextType>;
  HTML?: GraphQLScalarType;
  HeadRefDeletedEvent?: HeadRefDeletedEventResolvers<ContextType>;
  HeadRefForcePushedEvent?: HeadRefForcePushedEventResolvers<ContextType>;
  HeadRefRestoredEvent?: HeadRefRestoredEventResolvers<ContextType>;
  Hovercard?: HovercardResolvers<ContextType>;
  HovercardContext?: HovercardContextResolvers<ContextType>;
  ImportProjectPayload?: ImportProjectPayloadResolvers<ContextType>;
  InviteEnterpriseAdminPayload?: InviteEnterpriseAdminPayloadResolvers<ContextType>;
  IpAllowListEntry?: IpAllowListEntryResolvers<ContextType>;
  IpAllowListEntryConnection?: IpAllowListEntryConnectionResolvers<ContextType>;
  IpAllowListEntryEdge?: IpAllowListEntryEdgeResolvers<ContextType>;
  IpAllowListOwner?: IpAllowListOwnerResolvers<ContextType>;
  Issue?: IssueResolvers<ContextType>;
  IssueComment?: IssueCommentResolvers<ContextType>;
  IssueCommentConnection?: IssueCommentConnectionResolvers<ContextType>;
  IssueCommentEdge?: IssueCommentEdgeResolvers<ContextType>;
  IssueConnection?: IssueConnectionResolvers<ContextType>;
  IssueContributionsByRepository?: IssueContributionsByRepositoryResolvers<ContextType>;
  IssueEdge?: IssueEdgeResolvers<ContextType>;
  IssueOrPullRequest?: IssueOrPullRequestResolvers<ContextType>;
  IssueTemplate?: IssueTemplateResolvers<ContextType>;
  IssueTimelineConnection?: IssueTimelineConnectionResolvers<ContextType>;
  IssueTimelineItem?: IssueTimelineItemResolvers<ContextType>;
  IssueTimelineItemEdge?: IssueTimelineItemEdgeResolvers<ContextType>;
  IssueTimelineItems?: IssueTimelineItemsResolvers<ContextType>;
  IssueTimelineItemsConnection?: IssueTimelineItemsConnectionResolvers<ContextType>;
  IssueTimelineItemsEdge?: IssueTimelineItemsEdgeResolvers<ContextType>;
  JoinedGitHubContribution?: JoinedGitHubContributionResolvers<ContextType>;
  Label?: LabelResolvers<ContextType>;
  LabelConnection?: LabelConnectionResolvers<ContextType>;
  LabelEdge?: LabelEdgeResolvers<ContextType>;
  Labelable?: LabelableResolvers<ContextType>;
  LabeledEvent?: LabeledEventResolvers<ContextType>;
  Language?: LanguageResolvers<ContextType>;
  LanguageConnection?: LanguageConnectionResolvers<ContextType>;
  LanguageEdge?: LanguageEdgeResolvers<ContextType>;
  License?: LicenseResolvers<ContextType>;
  LicenseRule?: LicenseRuleResolvers<ContextType>;
  LinkProjectV2ToRepositoryPayload?: LinkProjectV2ToRepositoryPayloadResolvers<ContextType>;
  LinkProjectV2ToTeamPayload?: LinkProjectV2ToTeamPayloadResolvers<ContextType>;
  LinkRepositoryToProjectPayload?: LinkRepositoryToProjectPayloadResolvers<ContextType>;
  LinkedBranch?: LinkedBranchResolvers<ContextType>;
  LinkedBranchConnection?: LinkedBranchConnectionResolvers<ContextType>;
  LinkedBranchEdge?: LinkedBranchEdgeResolvers<ContextType>;
  LockLockablePayload?: LockLockablePayloadResolvers<ContextType>;
  Lockable?: LockableResolvers<ContextType>;
  LockedEvent?: LockedEventResolvers<ContextType>;
  Mannequin?: MannequinResolvers<ContextType>;
  MannequinConnection?: MannequinConnectionResolvers<ContextType>;
  MannequinEdge?: MannequinEdgeResolvers<ContextType>;
  MarkDiscussionCommentAsAnswerPayload?: MarkDiscussionCommentAsAnswerPayloadResolvers<ContextType>;
  MarkFileAsViewedPayload?: MarkFileAsViewedPayloadResolvers<ContextType>;
  MarkProjectV2AsTemplatePayload?: MarkProjectV2AsTemplatePayloadResolvers<ContextType>;
  MarkPullRequestReadyForReviewPayload?: MarkPullRequestReadyForReviewPayloadResolvers<ContextType>;
  MarkedAsDuplicateEvent?: MarkedAsDuplicateEventResolvers<ContextType>;
  MarketplaceCategory?: MarketplaceCategoryResolvers<ContextType>;
  MarketplaceListing?: MarketplaceListingResolvers<ContextType>;
  MarketplaceListingConnection?: MarketplaceListingConnectionResolvers<ContextType>;
  MarketplaceListingEdge?: MarketplaceListingEdgeResolvers<ContextType>;
  MemberFeatureRequestNotification?: MemberFeatureRequestNotificationResolvers<ContextType>;
  MemberStatusable?: MemberStatusableResolvers<ContextType>;
  MembersCanDeleteReposClearAuditEntry?: MembersCanDeleteReposClearAuditEntryResolvers<ContextType>;
  MembersCanDeleteReposDisableAuditEntry?: MembersCanDeleteReposDisableAuditEntryResolvers<ContextType>;
  MembersCanDeleteReposEnableAuditEntry?: MembersCanDeleteReposEnableAuditEntryResolvers<ContextType>;
  MentionedEvent?: MentionedEventResolvers<ContextType>;
  MergeBranchPayload?: MergeBranchPayloadResolvers<ContextType>;
  MergePullRequestPayload?: MergePullRequestPayloadResolvers<ContextType>;
  MergeQueue?: MergeQueueResolvers<ContextType>;
  MergeQueueConfiguration?: MergeQueueConfigurationResolvers<ContextType>;
  MergeQueueEntry?: MergeQueueEntryResolvers<ContextType>;
  MergeQueueEntryConnection?: MergeQueueEntryConnectionResolvers<ContextType>;
  MergeQueueEntryEdge?: MergeQueueEntryEdgeResolvers<ContextType>;
  MergedEvent?: MergedEventResolvers<ContextType>;
  Migration?: MigrationResolvers<ContextType>;
  MigrationSource?: MigrationSourceResolvers<ContextType>;
  Milestone?: MilestoneResolvers<ContextType>;
  MilestoneConnection?: MilestoneConnectionResolvers<ContextType>;
  MilestoneEdge?: MilestoneEdgeResolvers<ContextType>;
  MilestoneItem?: MilestoneItemResolvers<ContextType>;
  MilestonedEvent?: MilestonedEventResolvers<ContextType>;
  Minimizable?: MinimizableResolvers<ContextType>;
  MinimizeCommentPayload?: MinimizeCommentPayloadResolvers<ContextType>;
  MoveProjectCardPayload?: MoveProjectCardPayloadResolvers<ContextType>;
  MoveProjectColumnPayload?: MoveProjectColumnPayloadResolvers<ContextType>;
  MovedColumnsInProjectEvent?: MovedColumnsInProjectEventResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  OIDCProvider?: OIDCProviderResolvers<ContextType>;
  OauthApplicationAuditEntryData?: OauthApplicationAuditEntryDataResolvers<ContextType>;
  OauthApplicationCreateAuditEntry?: OauthApplicationCreateAuditEntryResolvers<ContextType>;
  OrgAddBillingManagerAuditEntry?: OrgAddBillingManagerAuditEntryResolvers<ContextType>;
  OrgAddMemberAuditEntry?: OrgAddMemberAuditEntryResolvers<ContextType>;
  OrgBlockUserAuditEntry?: OrgBlockUserAuditEntryResolvers<ContextType>;
  OrgConfigDisableCollaboratorsOnlyAuditEntry?: OrgConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  OrgConfigEnableCollaboratorsOnlyAuditEntry?: OrgConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  OrgCreateAuditEntry?: OrgCreateAuditEntryResolvers<ContextType>;
  OrgDisableOauthAppRestrictionsAuditEntry?: OrgDisableOauthAppRestrictionsAuditEntryResolvers<ContextType>;
  OrgDisableSamlAuditEntry?: OrgDisableSamlAuditEntryResolvers<ContextType>;
  OrgDisableTwoFactorRequirementAuditEntry?: OrgDisableTwoFactorRequirementAuditEntryResolvers<ContextType>;
  OrgEnableOauthAppRestrictionsAuditEntry?: OrgEnableOauthAppRestrictionsAuditEntryResolvers<ContextType>;
  OrgEnableSamlAuditEntry?: OrgEnableSamlAuditEntryResolvers<ContextType>;
  OrgEnableTwoFactorRequirementAuditEntry?: OrgEnableTwoFactorRequirementAuditEntryResolvers<ContextType>;
  OrgInviteMemberAuditEntry?: OrgInviteMemberAuditEntryResolvers<ContextType>;
  OrgInviteToBusinessAuditEntry?: OrgInviteToBusinessAuditEntryResolvers<ContextType>;
  OrgOauthAppAccessApprovedAuditEntry?: OrgOauthAppAccessApprovedAuditEntryResolvers<ContextType>;
  OrgOauthAppAccessBlockedAuditEntry?: OrgOauthAppAccessBlockedAuditEntryResolvers<ContextType>;
  OrgOauthAppAccessDeniedAuditEntry?: OrgOauthAppAccessDeniedAuditEntryResolvers<ContextType>;
  OrgOauthAppAccessRequestedAuditEntry?: OrgOauthAppAccessRequestedAuditEntryResolvers<ContextType>;
  OrgOauthAppAccessUnblockedAuditEntry?: OrgOauthAppAccessUnblockedAuditEntryResolvers<ContextType>;
  OrgRemoveBillingManagerAuditEntry?: OrgRemoveBillingManagerAuditEntryResolvers<ContextType>;
  OrgRemoveMemberAuditEntry?: OrgRemoveMemberAuditEntryResolvers<ContextType>;
  OrgRemoveOutsideCollaboratorAuditEntry?: OrgRemoveOutsideCollaboratorAuditEntryResolvers<ContextType>;
  OrgRestoreMemberAuditEntry?: OrgRestoreMemberAuditEntryResolvers<ContextType>;
  OrgRestoreMemberAuditEntryMembership?: OrgRestoreMemberAuditEntryMembershipResolvers<ContextType>;
  OrgRestoreMemberMembershipOrganizationAuditEntryData?: OrgRestoreMemberMembershipOrganizationAuditEntryDataResolvers<ContextType>;
  OrgRestoreMemberMembershipRepositoryAuditEntryData?: OrgRestoreMemberMembershipRepositoryAuditEntryDataResolvers<ContextType>;
  OrgRestoreMemberMembershipTeamAuditEntryData?: OrgRestoreMemberMembershipTeamAuditEntryDataResolvers<ContextType>;
  OrgUnblockUserAuditEntry?: OrgUnblockUserAuditEntryResolvers<ContextType>;
  OrgUpdateDefaultRepositoryPermissionAuditEntry?: OrgUpdateDefaultRepositoryPermissionAuditEntryResolvers<ContextType>;
  OrgUpdateMemberAuditEntry?: OrgUpdateMemberAuditEntryResolvers<ContextType>;
  OrgUpdateMemberRepositoryCreationPermissionAuditEntry?: OrgUpdateMemberRepositoryCreationPermissionAuditEntryResolvers<ContextType>;
  OrgUpdateMemberRepositoryInvitationPermissionAuditEntry?: OrgUpdateMemberRepositoryInvitationPermissionAuditEntryResolvers<ContextType>;
  Organization?: OrganizationResolvers<ContextType>;
  OrganizationAuditEntry?: OrganizationAuditEntryResolvers<ContextType>;
  OrganizationAuditEntryConnection?: OrganizationAuditEntryConnectionResolvers<ContextType>;
  OrganizationAuditEntryData?: OrganizationAuditEntryDataResolvers<ContextType>;
  OrganizationAuditEntryEdge?: OrganizationAuditEntryEdgeResolvers<ContextType>;
  OrganizationConnection?: OrganizationConnectionResolvers<ContextType>;
  OrganizationEdge?: OrganizationEdgeResolvers<ContextType>;
  OrganizationEnterpriseOwnerConnection?: OrganizationEnterpriseOwnerConnectionResolvers<ContextType>;
  OrganizationEnterpriseOwnerEdge?: OrganizationEnterpriseOwnerEdgeResolvers<ContextType>;
  OrganizationIdentityProvider?: OrganizationIdentityProviderResolvers<ContextType>;
  OrganizationInvitation?: OrganizationInvitationResolvers<ContextType>;
  OrganizationInvitationConnection?: OrganizationInvitationConnectionResolvers<ContextType>;
  OrganizationInvitationEdge?: OrganizationInvitationEdgeResolvers<ContextType>;
  OrganizationMemberConnection?: OrganizationMemberConnectionResolvers<ContextType>;
  OrganizationMemberEdge?: OrganizationMemberEdgeResolvers<ContextType>;
  OrganizationMigration?: OrganizationMigrationResolvers<ContextType>;
  OrganizationOrUser?: OrganizationOrUserResolvers<ContextType>;
  OrganizationTeamsHovercardContext?: OrganizationTeamsHovercardContextResolvers<ContextType>;
  OrganizationsHovercardContext?: OrganizationsHovercardContextResolvers<ContextType>;
  Package?: PackageResolvers<ContextType>;
  PackageConnection?: PackageConnectionResolvers<ContextType>;
  PackageEdge?: PackageEdgeResolvers<ContextType>;
  PackageFile?: PackageFileResolvers<ContextType>;
  PackageFileConnection?: PackageFileConnectionResolvers<ContextType>;
  PackageFileEdge?: PackageFileEdgeResolvers<ContextType>;
  PackageOwner?: PackageOwnerResolvers<ContextType>;
  PackageStatistics?: PackageStatisticsResolvers<ContextType>;
  PackageTag?: PackageTagResolvers<ContextType>;
  PackageVersion?: PackageVersionResolvers<ContextType>;
  PackageVersionConnection?: PackageVersionConnectionResolvers<ContextType>;
  PackageVersionEdge?: PackageVersionEdgeResolvers<ContextType>;
  PackageVersionStatistics?: PackageVersionStatisticsResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  PermissionGranter?: PermissionGranterResolvers<ContextType>;
  PermissionSource?: PermissionSourceResolvers<ContextType>;
  PinIssuePayload?: PinIssuePayloadResolvers<ContextType>;
  PinnableItem?: PinnableItemResolvers<ContextType>;
  PinnableItemConnection?: PinnableItemConnectionResolvers<ContextType>;
  PinnableItemEdge?: PinnableItemEdgeResolvers<ContextType>;
  PinnedDiscussion?: PinnedDiscussionResolvers<ContextType>;
  PinnedDiscussionConnection?: PinnedDiscussionConnectionResolvers<ContextType>;
  PinnedDiscussionEdge?: PinnedDiscussionEdgeResolvers<ContextType>;
  PinnedEvent?: PinnedEventResolvers<ContextType>;
  PinnedIssue?: PinnedIssueResolvers<ContextType>;
  PinnedIssueConnection?: PinnedIssueConnectionResolvers<ContextType>;
  PinnedIssueEdge?: PinnedIssueEdgeResolvers<ContextType>;
  PreciseDateTime?: GraphQLScalarType;
  PrivateRepositoryForkingDisableAuditEntry?: PrivateRepositoryForkingDisableAuditEntryResolvers<ContextType>;
  PrivateRepositoryForkingEnableAuditEntry?: PrivateRepositoryForkingEnableAuditEntryResolvers<ContextType>;
  ProfileItemShowcase?: ProfileItemShowcaseResolvers<ContextType>;
  ProfileOwner?: ProfileOwnerResolvers<ContextType>;
  Project?: ProjectResolvers<ContextType>;
  ProjectCard?: ProjectCardResolvers<ContextType>;
  ProjectCardConnection?: ProjectCardConnectionResolvers<ContextType>;
  ProjectCardEdge?: ProjectCardEdgeResolvers<ContextType>;
  ProjectCardItem?: ProjectCardItemResolvers<ContextType>;
  ProjectColumn?: ProjectColumnResolvers<ContextType>;
  ProjectColumnConnection?: ProjectColumnConnectionResolvers<ContextType>;
  ProjectColumnEdge?: ProjectColumnEdgeResolvers<ContextType>;
  ProjectConnection?: ProjectConnectionResolvers<ContextType>;
  ProjectEdge?: ProjectEdgeResolvers<ContextType>;
  ProjectOwner?: ProjectOwnerResolvers<ContextType>;
  ProjectProgress?: ProjectProgressResolvers<ContextType>;
  ProjectV2?: ProjectV2Resolvers<ContextType>;
  ProjectV2Actor?: ProjectV2ActorResolvers<ContextType>;
  ProjectV2ActorConnection?: ProjectV2ActorConnectionResolvers<ContextType>;
  ProjectV2ActorEdge?: ProjectV2ActorEdgeResolvers<ContextType>;
  ProjectV2Connection?: ProjectV2ConnectionResolvers<ContextType>;
  ProjectV2Edge?: ProjectV2EdgeResolvers<ContextType>;
  ProjectV2Field?: ProjectV2FieldResolvers<ContextType>;
  ProjectV2FieldCommon?: ProjectV2FieldCommonResolvers<ContextType>;
  ProjectV2FieldConfiguration?: ProjectV2FieldConfigurationResolvers<ContextType>;
  ProjectV2FieldConfigurationConnection?: ProjectV2FieldConfigurationConnectionResolvers<ContextType>;
  ProjectV2FieldConfigurationEdge?: ProjectV2FieldConfigurationEdgeResolvers<ContextType>;
  ProjectV2FieldConnection?: ProjectV2FieldConnectionResolvers<ContextType>;
  ProjectV2FieldEdge?: ProjectV2FieldEdgeResolvers<ContextType>;
  ProjectV2Item?: ProjectV2ItemResolvers<ContextType>;
  ProjectV2ItemConnection?: ProjectV2ItemConnectionResolvers<ContextType>;
  ProjectV2ItemContent?: ProjectV2ItemContentResolvers<ContextType>;
  ProjectV2ItemEdge?: ProjectV2ItemEdgeResolvers<ContextType>;
  ProjectV2ItemFieldDateValue?: ProjectV2ItemFieldDateValueResolvers<ContextType>;
  ProjectV2ItemFieldIterationValue?: ProjectV2ItemFieldIterationValueResolvers<ContextType>;
  ProjectV2ItemFieldLabelValue?: ProjectV2ItemFieldLabelValueResolvers<ContextType>;
  ProjectV2ItemFieldMilestoneValue?: ProjectV2ItemFieldMilestoneValueResolvers<ContextType>;
  ProjectV2ItemFieldNumberValue?: ProjectV2ItemFieldNumberValueResolvers<ContextType>;
  ProjectV2ItemFieldPullRequestValue?: ProjectV2ItemFieldPullRequestValueResolvers<ContextType>;
  ProjectV2ItemFieldRepositoryValue?: ProjectV2ItemFieldRepositoryValueResolvers<ContextType>;
  ProjectV2ItemFieldReviewerValue?: ProjectV2ItemFieldReviewerValueResolvers<ContextType>;
  ProjectV2ItemFieldSingleSelectValue?: ProjectV2ItemFieldSingleSelectValueResolvers<ContextType>;
  ProjectV2ItemFieldTextValue?: ProjectV2ItemFieldTextValueResolvers<ContextType>;
  ProjectV2ItemFieldUserValue?: ProjectV2ItemFieldUserValueResolvers<ContextType>;
  ProjectV2ItemFieldValue?: ProjectV2ItemFieldValueResolvers<ContextType>;
  ProjectV2ItemFieldValueCommon?: ProjectV2ItemFieldValueCommonResolvers<ContextType>;
  ProjectV2ItemFieldValueConnection?: ProjectV2ItemFieldValueConnectionResolvers<ContextType>;
  ProjectV2ItemFieldValueEdge?: ProjectV2ItemFieldValueEdgeResolvers<ContextType>;
  ProjectV2IterationField?: ProjectV2IterationFieldResolvers<ContextType>;
  ProjectV2IterationFieldConfiguration?: ProjectV2IterationFieldConfigurationResolvers<ContextType>;
  ProjectV2IterationFieldIteration?: ProjectV2IterationFieldIterationResolvers<ContextType>;
  ProjectV2Owner?: ProjectV2OwnerResolvers<ContextType>;
  ProjectV2Recent?: ProjectV2RecentResolvers<ContextType>;
  ProjectV2SingleSelectField?: ProjectV2SingleSelectFieldResolvers<ContextType>;
  ProjectV2SingleSelectFieldOption?: ProjectV2SingleSelectFieldOptionResolvers<ContextType>;
  ProjectV2SortBy?: ProjectV2SortByResolvers<ContextType>;
  ProjectV2SortByConnection?: ProjectV2SortByConnectionResolvers<ContextType>;
  ProjectV2SortByEdge?: ProjectV2SortByEdgeResolvers<ContextType>;
  ProjectV2SortByField?: ProjectV2SortByFieldResolvers<ContextType>;
  ProjectV2SortByFieldConnection?: ProjectV2SortByFieldConnectionResolvers<ContextType>;
  ProjectV2SortByFieldEdge?: ProjectV2SortByFieldEdgeResolvers<ContextType>;
  ProjectV2View?: ProjectV2ViewResolvers<ContextType>;
  ProjectV2ViewConnection?: ProjectV2ViewConnectionResolvers<ContextType>;
  ProjectV2ViewEdge?: ProjectV2ViewEdgeResolvers<ContextType>;
  ProjectV2Workflow?: ProjectV2WorkflowResolvers<ContextType>;
  ProjectV2WorkflowConnection?: ProjectV2WorkflowConnectionResolvers<ContextType>;
  ProjectV2WorkflowEdge?: ProjectV2WorkflowEdgeResolvers<ContextType>;
  PublicKey?: PublicKeyResolvers<ContextType>;
  PublicKeyConnection?: PublicKeyConnectionResolvers<ContextType>;
  PublicKeyEdge?: PublicKeyEdgeResolvers<ContextType>;
  PublishSponsorsTierPayload?: PublishSponsorsTierPayloadResolvers<ContextType>;
  PullRequest?: PullRequestResolvers<ContextType>;
  PullRequestChangedFile?: PullRequestChangedFileResolvers<ContextType>;
  PullRequestChangedFileConnection?: PullRequestChangedFileConnectionResolvers<ContextType>;
  PullRequestChangedFileEdge?: PullRequestChangedFileEdgeResolvers<ContextType>;
  PullRequestCommit?: PullRequestCommitResolvers<ContextType>;
  PullRequestCommitCommentThread?: PullRequestCommitCommentThreadResolvers<ContextType>;
  PullRequestCommitConnection?: PullRequestCommitConnectionResolvers<ContextType>;
  PullRequestCommitEdge?: PullRequestCommitEdgeResolvers<ContextType>;
  PullRequestConnection?: PullRequestConnectionResolvers<ContextType>;
  PullRequestContributionsByRepository?: PullRequestContributionsByRepositoryResolvers<ContextType>;
  PullRequestEdge?: PullRequestEdgeResolvers<ContextType>;
  PullRequestParameters?: PullRequestParametersResolvers<ContextType>;
  PullRequestReview?: PullRequestReviewResolvers<ContextType>;
  PullRequestReviewComment?: PullRequestReviewCommentResolvers<ContextType>;
  PullRequestReviewCommentConnection?: PullRequestReviewCommentConnectionResolvers<ContextType>;
  PullRequestReviewCommentEdge?: PullRequestReviewCommentEdgeResolvers<ContextType>;
  PullRequestReviewConnection?: PullRequestReviewConnectionResolvers<ContextType>;
  PullRequestReviewContributionsByRepository?: PullRequestReviewContributionsByRepositoryResolvers<ContextType>;
  PullRequestReviewEdge?: PullRequestReviewEdgeResolvers<ContextType>;
  PullRequestReviewThread?: PullRequestReviewThreadResolvers<ContextType>;
  PullRequestReviewThreadConnection?: PullRequestReviewThreadConnectionResolvers<ContextType>;
  PullRequestReviewThreadEdge?: PullRequestReviewThreadEdgeResolvers<ContextType>;
  PullRequestRevisionMarker?: PullRequestRevisionMarkerResolvers<ContextType>;
  PullRequestTemplate?: PullRequestTemplateResolvers<ContextType>;
  PullRequestThread?: PullRequestThreadResolvers<ContextType>;
  PullRequestTimelineConnection?: PullRequestTimelineConnectionResolvers<ContextType>;
  PullRequestTimelineItem?: PullRequestTimelineItemResolvers<ContextType>;
  PullRequestTimelineItemEdge?: PullRequestTimelineItemEdgeResolvers<ContextType>;
  PullRequestTimelineItems?: PullRequestTimelineItemsResolvers<ContextType>;
  PullRequestTimelineItemsConnection?: PullRequestTimelineItemsConnectionResolvers<ContextType>;
  PullRequestTimelineItemsEdge?: PullRequestTimelineItemsEdgeResolvers<ContextType>;
  Push?: PushResolvers<ContextType>;
  PushAllowance?: PushAllowanceResolvers<ContextType>;
  PushAllowanceActor?: PushAllowanceActorResolvers<ContextType>;
  PushAllowanceConnection?: PushAllowanceConnectionResolvers<ContextType>;
  PushAllowanceEdge?: PushAllowanceEdgeResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  RateLimit?: RateLimitResolvers<ContextType>;
  Reactable?: ReactableResolvers<ContextType>;
  ReactingUserConnection?: ReactingUserConnectionResolvers<ContextType>;
  ReactingUserEdge?: ReactingUserEdgeResolvers<ContextType>;
  Reaction?: ReactionResolvers<ContextType>;
  ReactionConnection?: ReactionConnectionResolvers<ContextType>;
  ReactionEdge?: ReactionEdgeResolvers<ContextType>;
  ReactionGroup?: ReactionGroupResolvers<ContextType>;
  Reactor?: ReactorResolvers<ContextType>;
  ReactorConnection?: ReactorConnectionResolvers<ContextType>;
  ReactorEdge?: ReactorEdgeResolvers<ContextType>;
  ReadyForReviewEvent?: ReadyForReviewEventResolvers<ContextType>;
  Ref?: RefResolvers<ContextType>;
  RefConnection?: RefConnectionResolvers<ContextType>;
  RefEdge?: RefEdgeResolvers<ContextType>;
  RefNameConditionTarget?: RefNameConditionTargetResolvers<ContextType>;
  RefUpdateRule?: RefUpdateRuleResolvers<ContextType>;
  ReferencedEvent?: ReferencedEventResolvers<ContextType>;
  ReferencedSubject?: ReferencedSubjectResolvers<ContextType>;
  RegenerateEnterpriseIdentityProviderRecoveryCodesPayload?: RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadResolvers<ContextType>;
  RegenerateVerifiableDomainTokenPayload?: RegenerateVerifiableDomainTokenPayloadResolvers<ContextType>;
  RejectDeploymentsPayload?: RejectDeploymentsPayloadResolvers<ContextType>;
  Release?: ReleaseResolvers<ContextType>;
  ReleaseAsset?: ReleaseAssetResolvers<ContextType>;
  ReleaseAssetConnection?: ReleaseAssetConnectionResolvers<ContextType>;
  ReleaseAssetEdge?: ReleaseAssetEdgeResolvers<ContextType>;
  ReleaseConnection?: ReleaseConnectionResolvers<ContextType>;
  ReleaseEdge?: ReleaseEdgeResolvers<ContextType>;
  RemoveAssigneesFromAssignablePayload?: RemoveAssigneesFromAssignablePayloadResolvers<ContextType>;
  RemoveEnterpriseAdminPayload?: RemoveEnterpriseAdminPayloadResolvers<ContextType>;
  RemoveEnterpriseIdentityProviderPayload?: RemoveEnterpriseIdentityProviderPayloadResolvers<ContextType>;
  RemoveEnterpriseMemberPayload?: RemoveEnterpriseMemberPayloadResolvers<ContextType>;
  RemoveEnterpriseOrganizationPayload?: RemoveEnterpriseOrganizationPayloadResolvers<ContextType>;
  RemoveEnterpriseSupportEntitlementPayload?: RemoveEnterpriseSupportEntitlementPayloadResolvers<ContextType>;
  RemoveLabelsFromLabelablePayload?: RemoveLabelsFromLabelablePayloadResolvers<ContextType>;
  RemoveOutsideCollaboratorPayload?: RemoveOutsideCollaboratorPayloadResolvers<ContextType>;
  RemoveReactionPayload?: RemoveReactionPayloadResolvers<ContextType>;
  RemoveStarPayload?: RemoveStarPayloadResolvers<ContextType>;
  RemoveUpvotePayload?: RemoveUpvotePayloadResolvers<ContextType>;
  RemovedFromMergeQueueEvent?: RemovedFromMergeQueueEventResolvers<ContextType>;
  RemovedFromProjectEvent?: RemovedFromProjectEventResolvers<ContextType>;
  RenamedTitleEvent?: RenamedTitleEventResolvers<ContextType>;
  RenamedTitleSubject?: RenamedTitleSubjectResolvers<ContextType>;
  ReopenDiscussionPayload?: ReopenDiscussionPayloadResolvers<ContextType>;
  ReopenIssuePayload?: ReopenIssuePayloadResolvers<ContextType>;
  ReopenPullRequestPayload?: ReopenPullRequestPayloadResolvers<ContextType>;
  ReopenedEvent?: ReopenedEventResolvers<ContextType>;
  RepoAccessAuditEntry?: RepoAccessAuditEntryResolvers<ContextType>;
  RepoAddMemberAuditEntry?: RepoAddMemberAuditEntryResolvers<ContextType>;
  RepoAddTopicAuditEntry?: RepoAddTopicAuditEntryResolvers<ContextType>;
  RepoArchivedAuditEntry?: RepoArchivedAuditEntryResolvers<ContextType>;
  RepoChangeMergeSettingAuditEntry?: RepoChangeMergeSettingAuditEntryResolvers<ContextType>;
  RepoConfigDisableAnonymousGitAccessAuditEntry?: RepoConfigDisableAnonymousGitAccessAuditEntryResolvers<ContextType>;
  RepoConfigDisableCollaboratorsOnlyAuditEntry?: RepoConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  RepoConfigDisableContributorsOnlyAuditEntry?: RepoConfigDisableContributorsOnlyAuditEntryResolvers<ContextType>;
  RepoConfigDisableSockpuppetDisallowedAuditEntry?: RepoConfigDisableSockpuppetDisallowedAuditEntryResolvers<ContextType>;
  RepoConfigEnableAnonymousGitAccessAuditEntry?: RepoConfigEnableAnonymousGitAccessAuditEntryResolvers<ContextType>;
  RepoConfigEnableCollaboratorsOnlyAuditEntry?: RepoConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  RepoConfigEnableContributorsOnlyAuditEntry?: RepoConfigEnableContributorsOnlyAuditEntryResolvers<ContextType>;
  RepoConfigEnableSockpuppetDisallowedAuditEntry?: RepoConfigEnableSockpuppetDisallowedAuditEntryResolvers<ContextType>;
  RepoConfigLockAnonymousGitAccessAuditEntry?: RepoConfigLockAnonymousGitAccessAuditEntryResolvers<ContextType>;
  RepoConfigUnlockAnonymousGitAccessAuditEntry?: RepoConfigUnlockAnonymousGitAccessAuditEntryResolvers<ContextType>;
  RepoCreateAuditEntry?: RepoCreateAuditEntryResolvers<ContextType>;
  RepoDestroyAuditEntry?: RepoDestroyAuditEntryResolvers<ContextType>;
  RepoRemoveMemberAuditEntry?: RepoRemoveMemberAuditEntryResolvers<ContextType>;
  RepoRemoveTopicAuditEntry?: RepoRemoveTopicAuditEntryResolvers<ContextType>;
  Repository?: RepositoryResolvers<ContextType>;
  RepositoryAuditEntryData?: RepositoryAuditEntryDataResolvers<ContextType>;
  RepositoryCodeowners?: RepositoryCodeownersResolvers<ContextType>;
  RepositoryCodeownersError?: RepositoryCodeownersErrorResolvers<ContextType>;
  RepositoryCollaboratorConnection?: RepositoryCollaboratorConnectionResolvers<ContextType>;
  RepositoryCollaboratorEdge?: RepositoryCollaboratorEdgeResolvers<ContextType>;
  RepositoryConnection?: RepositoryConnectionResolvers<ContextType>;
  RepositoryContactLink?: RepositoryContactLinkResolvers<ContextType>;
  RepositoryDiscussionAuthor?: RepositoryDiscussionAuthorResolvers<ContextType>;
  RepositoryDiscussionCommentAuthor?: RepositoryDiscussionCommentAuthorResolvers<ContextType>;
  RepositoryEdge?: RepositoryEdgeResolvers<ContextType>;
  RepositoryIdConditionTarget?: RepositoryIdConditionTargetResolvers<ContextType>;
  RepositoryInfo?: RepositoryInfoResolvers<ContextType>;
  RepositoryInteractionAbility?: RepositoryInteractionAbilityResolvers<ContextType>;
  RepositoryInvitation?: RepositoryInvitationResolvers<ContextType>;
  RepositoryInvitationConnection?: RepositoryInvitationConnectionResolvers<ContextType>;
  RepositoryInvitationEdge?: RepositoryInvitationEdgeResolvers<ContextType>;
  RepositoryMigration?: RepositoryMigrationResolvers<ContextType>;
  RepositoryMigrationConnection?: RepositoryMigrationConnectionResolvers<ContextType>;
  RepositoryMigrationEdge?: RepositoryMigrationEdgeResolvers<ContextType>;
  RepositoryNameConditionTarget?: RepositoryNameConditionTargetResolvers<ContextType>;
  RepositoryNode?: RepositoryNodeResolvers<ContextType>;
  RepositoryOwner?: RepositoryOwnerResolvers<ContextType>;
  RepositoryRule?: RepositoryRuleResolvers<ContextType>;
  RepositoryRuleConditions?: RepositoryRuleConditionsResolvers<ContextType>;
  RepositoryRuleConnection?: RepositoryRuleConnectionResolvers<ContextType>;
  RepositoryRuleEdge?: RepositoryRuleEdgeResolvers<ContextType>;
  RepositoryRuleset?: RepositoryRulesetResolvers<ContextType>;
  RepositoryRulesetBypassActor?: RepositoryRulesetBypassActorResolvers<ContextType>;
  RepositoryRulesetBypassActorConnection?: RepositoryRulesetBypassActorConnectionResolvers<ContextType>;
  RepositoryRulesetBypassActorEdge?: RepositoryRulesetBypassActorEdgeResolvers<ContextType>;
  RepositoryRulesetConnection?: RepositoryRulesetConnectionResolvers<ContextType>;
  RepositoryRulesetEdge?: RepositoryRulesetEdgeResolvers<ContextType>;
  RepositoryTopic?: RepositoryTopicResolvers<ContextType>;
  RepositoryTopicConnection?: RepositoryTopicConnectionResolvers<ContextType>;
  RepositoryTopicEdge?: RepositoryTopicEdgeResolvers<ContextType>;
  RepositoryVisibilityChangeDisableAuditEntry?: RepositoryVisibilityChangeDisableAuditEntryResolvers<ContextType>;
  RepositoryVisibilityChangeEnableAuditEntry?: RepositoryVisibilityChangeEnableAuditEntryResolvers<ContextType>;
  RepositoryVulnerabilityAlert?: RepositoryVulnerabilityAlertResolvers<ContextType>;
  RepositoryVulnerabilityAlertConnection?: RepositoryVulnerabilityAlertConnectionResolvers<ContextType>;
  RepositoryVulnerabilityAlertEdge?: RepositoryVulnerabilityAlertEdgeResolvers<ContextType>;
  RequestReviewsPayload?: RequestReviewsPayloadResolvers<ContextType>;
  RequestedReviewer?: RequestedReviewerResolvers<ContextType>;
  RequestedReviewerConnection?: RequestedReviewerConnectionResolvers<ContextType>;
  RequestedReviewerEdge?: RequestedReviewerEdgeResolvers<ContextType>;
  RequirableByPullRequest?: RequirableByPullRequestResolvers<ContextType>;
  RequiredDeploymentsParameters?: RequiredDeploymentsParametersResolvers<ContextType>;
  RequiredStatusCheckDescription?: RequiredStatusCheckDescriptionResolvers<ContextType>;
  RequiredStatusChecksParameters?: RequiredStatusChecksParametersResolvers<ContextType>;
  RerequestCheckSuitePayload?: RerequestCheckSuitePayloadResolvers<ContextType>;
  ResolveReviewThreadPayload?: ResolveReviewThreadPayloadResolvers<ContextType>;
  RestrictedContribution?: RestrictedContributionResolvers<ContextType>;
  RetireSponsorsTierPayload?: RetireSponsorsTierPayloadResolvers<ContextType>;
  RevertPullRequestPayload?: RevertPullRequestPayloadResolvers<ContextType>;
  ReviewDismissalAllowance?: ReviewDismissalAllowanceResolvers<ContextType>;
  ReviewDismissalAllowanceActor?: ReviewDismissalAllowanceActorResolvers<ContextType>;
  ReviewDismissalAllowanceConnection?: ReviewDismissalAllowanceConnectionResolvers<ContextType>;
  ReviewDismissalAllowanceEdge?: ReviewDismissalAllowanceEdgeResolvers<ContextType>;
  ReviewDismissedEvent?: ReviewDismissedEventResolvers<ContextType>;
  ReviewRequest?: ReviewRequestResolvers<ContextType>;
  ReviewRequestConnection?: ReviewRequestConnectionResolvers<ContextType>;
  ReviewRequestEdge?: ReviewRequestEdgeResolvers<ContextType>;
  ReviewRequestRemovedEvent?: ReviewRequestRemovedEventResolvers<ContextType>;
  ReviewRequestedEvent?: ReviewRequestedEventResolvers<ContextType>;
  ReviewStatusHovercardContext?: ReviewStatusHovercardContextResolvers<ContextType>;
  RevokeEnterpriseOrganizationsMigratorRolePayload?: RevokeEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType>;
  RevokeMigratorRolePayload?: RevokeMigratorRolePayloadResolvers<ContextType>;
  RuleParameters?: RuleParametersResolvers<ContextType>;
  RuleSource?: RuleSourceResolvers<ContextType>;
  SavedReply?: SavedReplyResolvers<ContextType>;
  SavedReplyConnection?: SavedReplyConnectionResolvers<ContextType>;
  SavedReplyEdge?: SavedReplyEdgeResolvers<ContextType>;
  SearchResultItem?: SearchResultItemResolvers<ContextType>;
  SearchResultItemConnection?: SearchResultItemConnectionResolvers<ContextType>;
  SearchResultItemEdge?: SearchResultItemEdgeResolvers<ContextType>;
  SecurityAdvisory?: SecurityAdvisoryResolvers<ContextType>;
  SecurityAdvisoryConnection?: SecurityAdvisoryConnectionResolvers<ContextType>;
  SecurityAdvisoryEdge?: SecurityAdvisoryEdgeResolvers<ContextType>;
  SecurityAdvisoryIdentifier?: SecurityAdvisoryIdentifierResolvers<ContextType>;
  SecurityAdvisoryPackage?: SecurityAdvisoryPackageResolvers<ContextType>;
  SecurityAdvisoryPackageVersion?: SecurityAdvisoryPackageVersionResolvers<ContextType>;
  SecurityAdvisoryReference?: SecurityAdvisoryReferenceResolvers<ContextType>;
  SecurityVulnerability?: SecurityVulnerabilityResolvers<ContextType>;
  SecurityVulnerabilityConnection?: SecurityVulnerabilityConnectionResolvers<ContextType>;
  SecurityVulnerabilityEdge?: SecurityVulnerabilityEdgeResolvers<ContextType>;
  SetEnterpriseIdentityProviderPayload?: SetEnterpriseIdentityProviderPayloadResolvers<ContextType>;
  SetOrganizationInteractionLimitPayload?: SetOrganizationInteractionLimitPayloadResolvers<ContextType>;
  SetRepositoryInteractionLimitPayload?: SetRepositoryInteractionLimitPayloadResolvers<ContextType>;
  SetUserInteractionLimitPayload?: SetUserInteractionLimitPayloadResolvers<ContextType>;
  SmimeSignature?: SmimeSignatureResolvers<ContextType>;
  SocialAccount?: SocialAccountResolvers<ContextType>;
  SocialAccountConnection?: SocialAccountConnectionResolvers<ContextType>;
  SocialAccountEdge?: SocialAccountEdgeResolvers<ContextType>;
  Sponsor?: SponsorResolvers<ContextType>;
  SponsorConnection?: SponsorConnectionResolvers<ContextType>;
  SponsorEdge?: SponsorEdgeResolvers<ContextType>;
  Sponsorable?: SponsorableResolvers<ContextType>;
  SponsorableItem?: SponsorableItemResolvers<ContextType>;
  SponsorableItemConnection?: SponsorableItemConnectionResolvers<ContextType>;
  SponsorableItemEdge?: SponsorableItemEdgeResolvers<ContextType>;
  SponsorsActivity?: SponsorsActivityResolvers<ContextType>;
  SponsorsActivityConnection?: SponsorsActivityConnectionResolvers<ContextType>;
  SponsorsActivityEdge?: SponsorsActivityEdgeResolvers<ContextType>;
  SponsorsGoal?: SponsorsGoalResolvers<ContextType>;
  SponsorsListing?: SponsorsListingResolvers<ContextType>;
  SponsorsListingFeatureableItem?: SponsorsListingFeatureableItemResolvers<ContextType>;
  SponsorsListingFeaturedItem?: SponsorsListingFeaturedItemResolvers<ContextType>;
  SponsorsTier?: SponsorsTierResolvers<ContextType>;
  SponsorsTierAdminInfo?: SponsorsTierAdminInfoResolvers<ContextType>;
  SponsorsTierConnection?: SponsorsTierConnectionResolvers<ContextType>;
  SponsorsTierEdge?: SponsorsTierEdgeResolvers<ContextType>;
  Sponsorship?: SponsorshipResolvers<ContextType>;
  SponsorshipConnection?: SponsorshipConnectionResolvers<ContextType>;
  SponsorshipEdge?: SponsorshipEdgeResolvers<ContextType>;
  SponsorshipNewsletter?: SponsorshipNewsletterResolvers<ContextType>;
  SponsorshipNewsletterConnection?: SponsorshipNewsletterConnectionResolvers<ContextType>;
  SponsorshipNewsletterEdge?: SponsorshipNewsletterEdgeResolvers<ContextType>;
  SshSignature?: SshSignatureResolvers<ContextType>;
  StargazerConnection?: StargazerConnectionResolvers<ContextType>;
  StargazerEdge?: StargazerEdgeResolvers<ContextType>;
  Starrable?: StarrableResolvers<ContextType>;
  StarredRepositoryConnection?: StarredRepositoryConnectionResolvers<ContextType>;
  StarredRepositoryEdge?: StarredRepositoryEdgeResolvers<ContextType>;
  StartOrganizationMigrationPayload?: StartOrganizationMigrationPayloadResolvers<ContextType>;
  StartRepositoryMigrationPayload?: StartRepositoryMigrationPayloadResolvers<ContextType>;
  Status?: StatusResolvers<ContextType>;
  StatusCheckConfiguration?: StatusCheckConfigurationResolvers<ContextType>;
  StatusCheckRollup?: StatusCheckRollupResolvers<ContextType>;
  StatusCheckRollupContext?: StatusCheckRollupContextResolvers<ContextType>;
  StatusCheckRollupContextConnection?: StatusCheckRollupContextConnectionResolvers<ContextType>;
  StatusCheckRollupContextEdge?: StatusCheckRollupContextEdgeResolvers<ContextType>;
  StatusContext?: StatusContextResolvers<ContextType>;
  StatusContextStateCount?: StatusContextStateCountResolvers<ContextType>;
  StripeConnectAccount?: StripeConnectAccountResolvers<ContextType>;
  SubmitPullRequestReviewPayload?: SubmitPullRequestReviewPayloadResolvers<ContextType>;
  Submodule?: SubmoduleResolvers<ContextType>;
  SubmoduleConnection?: SubmoduleConnectionResolvers<ContextType>;
  SubmoduleEdge?: SubmoduleEdgeResolvers<ContextType>;
  Subscribable?: SubscribableResolvers<ContextType>;
  SubscribableThread?: SubscribableThreadResolvers<ContextType>;
  SubscribedEvent?: SubscribedEventResolvers<ContextType>;
  SuggestedReviewer?: SuggestedReviewerResolvers<ContextType>;
  Tag?: TagResolvers<ContextType>;
  TagNamePatternParameters?: TagNamePatternParametersResolvers<ContextType>;
  Team?: TeamResolvers<ContextType>;
  TeamAddMemberAuditEntry?: TeamAddMemberAuditEntryResolvers<ContextType>;
  TeamAddRepositoryAuditEntry?: TeamAddRepositoryAuditEntryResolvers<ContextType>;
  TeamAuditEntryData?: TeamAuditEntryDataResolvers<ContextType>;
  TeamChangeParentTeamAuditEntry?: TeamChangeParentTeamAuditEntryResolvers<ContextType>;
  TeamConnection?: TeamConnectionResolvers<ContextType>;
  TeamDiscussion?: TeamDiscussionResolvers<ContextType>;
  TeamDiscussionComment?: TeamDiscussionCommentResolvers<ContextType>;
  TeamDiscussionCommentConnection?: TeamDiscussionCommentConnectionResolvers<ContextType>;
  TeamDiscussionCommentEdge?: TeamDiscussionCommentEdgeResolvers<ContextType>;
  TeamDiscussionConnection?: TeamDiscussionConnectionResolvers<ContextType>;
  TeamDiscussionEdge?: TeamDiscussionEdgeResolvers<ContextType>;
  TeamEdge?: TeamEdgeResolvers<ContextType>;
  TeamMemberConnection?: TeamMemberConnectionResolvers<ContextType>;
  TeamMemberEdge?: TeamMemberEdgeResolvers<ContextType>;
  TeamRemoveMemberAuditEntry?: TeamRemoveMemberAuditEntryResolvers<ContextType>;
  TeamRemoveRepositoryAuditEntry?: TeamRemoveRepositoryAuditEntryResolvers<ContextType>;
  TeamRepositoryConnection?: TeamRepositoryConnectionResolvers<ContextType>;
  TeamRepositoryEdge?: TeamRepositoryEdgeResolvers<ContextType>;
  TextMatch?: TextMatchResolvers<ContextType>;
  TextMatchHighlight?: TextMatchHighlightResolvers<ContextType>;
  Topic?: TopicResolvers<ContextType>;
  TopicAuditEntryData?: TopicAuditEntryDataResolvers<ContextType>;
  TransferEnterpriseOrganizationPayload?: TransferEnterpriseOrganizationPayloadResolvers<ContextType>;
  TransferIssuePayload?: TransferIssuePayloadResolvers<ContextType>;
  TransferredEvent?: TransferredEventResolvers<ContextType>;
  Tree?: TreeResolvers<ContextType>;
  TreeEntry?: TreeEntryResolvers<ContextType>;
  URI?: GraphQLScalarType;
  UnarchiveProjectV2ItemPayload?: UnarchiveProjectV2ItemPayloadResolvers<ContextType>;
  UnarchiveRepositoryPayload?: UnarchiveRepositoryPayloadResolvers<ContextType>;
  UnassignedEvent?: UnassignedEventResolvers<ContextType>;
  UnfollowOrganizationPayload?: UnfollowOrganizationPayloadResolvers<ContextType>;
  UnfollowUserPayload?: UnfollowUserPayloadResolvers<ContextType>;
  UniformResourceLocatable?: UniformResourceLocatableResolvers<ContextType>;
  UnknownSignature?: UnknownSignatureResolvers<ContextType>;
  UnlabeledEvent?: UnlabeledEventResolvers<ContextType>;
  UnlinkProjectV2FromRepositoryPayload?: UnlinkProjectV2FromRepositoryPayloadResolvers<ContextType>;
  UnlinkProjectV2FromTeamPayload?: UnlinkProjectV2FromTeamPayloadResolvers<ContextType>;
  UnlinkRepositoryFromProjectPayload?: UnlinkRepositoryFromProjectPayloadResolvers<ContextType>;
  UnlockLockablePayload?: UnlockLockablePayloadResolvers<ContextType>;
  UnlockedEvent?: UnlockedEventResolvers<ContextType>;
  UnmarkDiscussionCommentAsAnswerPayload?: UnmarkDiscussionCommentAsAnswerPayloadResolvers<ContextType>;
  UnmarkFileAsViewedPayload?: UnmarkFileAsViewedPayloadResolvers<ContextType>;
  UnmarkIssueAsDuplicatePayload?: UnmarkIssueAsDuplicatePayloadResolvers<ContextType>;
  UnmarkProjectV2AsTemplatePayload?: UnmarkProjectV2AsTemplatePayloadResolvers<ContextType>;
  UnmarkedAsDuplicateEvent?: UnmarkedAsDuplicateEventResolvers<ContextType>;
  UnminimizeCommentPayload?: UnminimizeCommentPayloadResolvers<ContextType>;
  UnpinIssuePayload?: UnpinIssuePayloadResolvers<ContextType>;
  UnpinnedEvent?: UnpinnedEventResolvers<ContextType>;
  UnresolveReviewThreadPayload?: UnresolveReviewThreadPayloadResolvers<ContextType>;
  UnsubscribeFromNotificationsPayload?: UnsubscribeFromNotificationsPayloadResolvers<ContextType>;
  UnsubscribedEvent?: UnsubscribedEventResolvers<ContextType>;
  Updatable?: UpdatableResolvers<ContextType>;
  UpdatableComment?: UpdatableCommentResolvers<ContextType>;
  UpdateBranchProtectionRulePayload?: UpdateBranchProtectionRulePayloadResolvers<ContextType>;
  UpdateCheckRunPayload?: UpdateCheckRunPayloadResolvers<ContextType>;
  UpdateCheckSuitePreferencesPayload?: UpdateCheckSuitePreferencesPayloadResolvers<ContextType>;
  UpdateDiscussionCommentPayload?: UpdateDiscussionCommentPayloadResolvers<ContextType>;
  UpdateDiscussionPayload?: UpdateDiscussionPayloadResolvers<ContextType>;
  UpdateEnterpriseAdministratorRolePayload?: UpdateEnterpriseAdministratorRolePayloadResolvers<ContextType>;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload?: UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseDefaultRepositoryPermissionSettingPayload?: UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload?: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload?: UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanDeleteIssuesSettingPayload?: UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload?: UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload?: UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanMakePurchasesSettingPayload?: UpdateEnterpriseMembersCanMakePurchasesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload?: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload?: UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseOrganizationProjectsSettingPayload?: UpdateEnterpriseOrganizationProjectsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseOwnerOrganizationRolePayload?: UpdateEnterpriseOwnerOrganizationRolePayloadResolvers<ContextType>;
  UpdateEnterpriseProfilePayload?: UpdateEnterpriseProfilePayloadResolvers<ContextType>;
  UpdateEnterpriseRepositoryProjectsSettingPayload?: UpdateEnterpriseRepositoryProjectsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseTeamDiscussionsSettingPayload?: UpdateEnterpriseTeamDiscussionsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload?: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadResolvers<ContextType>;
  UpdateEnvironmentPayload?: UpdateEnvironmentPayloadResolvers<ContextType>;
  UpdateIpAllowListEnabledSettingPayload?: UpdateIpAllowListEnabledSettingPayloadResolvers<ContextType>;
  UpdateIpAllowListEntryPayload?: UpdateIpAllowListEntryPayloadResolvers<ContextType>;
  UpdateIpAllowListForInstalledAppsEnabledSettingPayload?: UpdateIpAllowListForInstalledAppsEnabledSettingPayloadResolvers<ContextType>;
  UpdateIssueCommentPayload?: UpdateIssueCommentPayloadResolvers<ContextType>;
  UpdateIssuePayload?: UpdateIssuePayloadResolvers<ContextType>;
  UpdateLabelPayload?: UpdateLabelPayloadResolvers<ContextType>;
  UpdateNotificationRestrictionSettingPayload?: UpdateNotificationRestrictionSettingPayloadResolvers<ContextType>;
  UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload?: UpdateOrganizationAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType>;
  UpdateOrganizationWebCommitSignoffSettingPayload?: UpdateOrganizationWebCommitSignoffSettingPayloadResolvers<ContextType>;
  UpdateParameters?: UpdateParametersResolvers<ContextType>;
  UpdatePatreonSponsorabilityPayload?: UpdatePatreonSponsorabilityPayloadResolvers<ContextType>;
  UpdateProjectCardPayload?: UpdateProjectCardPayloadResolvers<ContextType>;
  UpdateProjectColumnPayload?: UpdateProjectColumnPayloadResolvers<ContextType>;
  UpdateProjectPayload?: UpdateProjectPayloadResolvers<ContextType>;
  UpdateProjectV2CollaboratorsPayload?: UpdateProjectV2CollaboratorsPayloadResolvers<ContextType>;
  UpdateProjectV2DraftIssuePayload?: UpdateProjectV2DraftIssuePayloadResolvers<ContextType>;
  UpdateProjectV2ItemFieldValuePayload?: UpdateProjectV2ItemFieldValuePayloadResolvers<ContextType>;
  UpdateProjectV2ItemPositionPayload?: UpdateProjectV2ItemPositionPayloadResolvers<ContextType>;
  UpdateProjectV2Payload?: UpdateProjectV2PayloadResolvers<ContextType>;
  UpdatePullRequestBranchPayload?: UpdatePullRequestBranchPayloadResolvers<ContextType>;
  UpdatePullRequestPayload?: UpdatePullRequestPayloadResolvers<ContextType>;
  UpdatePullRequestReviewCommentPayload?: UpdatePullRequestReviewCommentPayloadResolvers<ContextType>;
  UpdatePullRequestReviewPayload?: UpdatePullRequestReviewPayloadResolvers<ContextType>;
  UpdateRefPayload?: UpdateRefPayloadResolvers<ContextType>;
  UpdateRefsPayload?: UpdateRefsPayloadResolvers<ContextType>;
  UpdateRepositoryPayload?: UpdateRepositoryPayloadResolvers<ContextType>;
  UpdateRepositoryRulesetPayload?: UpdateRepositoryRulesetPayloadResolvers<ContextType>;
  UpdateRepositoryWebCommitSignoffSettingPayload?: UpdateRepositoryWebCommitSignoffSettingPayloadResolvers<ContextType>;
  UpdateSponsorshipPreferencesPayload?: UpdateSponsorshipPreferencesPayloadResolvers<ContextType>;
  UpdateSubscriptionPayload?: UpdateSubscriptionPayloadResolvers<ContextType>;
  UpdateTeamDiscussionCommentPayload?: UpdateTeamDiscussionCommentPayloadResolvers<ContextType>;
  UpdateTeamDiscussionPayload?: UpdateTeamDiscussionPayloadResolvers<ContextType>;
  UpdateTeamReviewAssignmentPayload?: UpdateTeamReviewAssignmentPayloadResolvers<ContextType>;
  UpdateTeamsRepositoryPayload?: UpdateTeamsRepositoryPayloadResolvers<ContextType>;
  UpdateTopicsPayload?: UpdateTopicsPayloadResolvers<ContextType>;
  UpdateUserListPayload?: UpdateUserListPayloadResolvers<ContextType>;
  UpdateUserListsForItemPayload?: UpdateUserListsForItemPayloadResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserBlockedEvent?: UserBlockedEventResolvers<ContextType>;
  UserConnection?: UserConnectionResolvers<ContextType>;
  UserContentEdit?: UserContentEditResolvers<ContextType>;
  UserContentEditConnection?: UserContentEditConnectionResolvers<ContextType>;
  UserContentEditEdge?: UserContentEditEdgeResolvers<ContextType>;
  UserEdge?: UserEdgeResolvers<ContextType>;
  UserEmailMetadata?: UserEmailMetadataResolvers<ContextType>;
  UserList?: UserListResolvers<ContextType>;
  UserListConnection?: UserListConnectionResolvers<ContextType>;
  UserListEdge?: UserListEdgeResolvers<ContextType>;
  UserListItems?: UserListItemsResolvers<ContextType>;
  UserListItemsConnection?: UserListItemsConnectionResolvers<ContextType>;
  UserListItemsEdge?: UserListItemsEdgeResolvers<ContextType>;
  UserListSuggestion?: UserListSuggestionResolvers<ContextType>;
  UserStatus?: UserStatusResolvers<ContextType>;
  UserStatusConnection?: UserStatusConnectionResolvers<ContextType>;
  UserStatusEdge?: UserStatusEdgeResolvers<ContextType>;
  VerifiableDomain?: VerifiableDomainResolvers<ContextType>;
  VerifiableDomainConnection?: VerifiableDomainConnectionResolvers<ContextType>;
  VerifiableDomainEdge?: VerifiableDomainEdgeResolvers<ContextType>;
  VerifiableDomainOwner?: VerifiableDomainOwnerResolvers<ContextType>;
  VerifyVerifiableDomainPayload?: VerifyVerifiableDomainPayloadResolvers<ContextType>;
  ViewerHovercardContext?: ViewerHovercardContextResolvers<ContextType>;
  Votable?: VotableResolvers<ContextType>;
  Workflow?: WorkflowResolvers<ContextType>;
  WorkflowFileReference?: WorkflowFileReferenceResolvers<ContextType>;
  WorkflowRun?: WorkflowRunResolvers<ContextType>;
  WorkflowRunConnection?: WorkflowRunConnectionResolvers<ContextType>;
  WorkflowRunEdge?: WorkflowRunEdgeResolvers<ContextType>;
  WorkflowRunFile?: WorkflowRunFileResolvers<ContextType>;
  WorkflowsParameters?: WorkflowsParametersResolvers<ContextType>;
  X509Certificate?: GraphQLScalarType;
}>;

export type DirectiveResolvers<ContextType = MeshContext> = ResolversObject<{
  requiredCapabilities?: requiredCapabilitiesDirectiveResolver<any, any, ContextType>;
  preview?: previewDirectiveResolver<any, any, ContextType>;
  possibleTypes?: possibleTypesDirectiveResolver<any, any, ContextType>;
}>;

export type MeshContext = GithubTypes.Context & BaseMeshContext;


const baseDir = pathModule.join(typeof __dirname === 'string' ? __dirname : '/', '..');

const importFn: ImportFn = <T>(moduleId: string) => {
  const relativeModuleId = (pathModule.isAbsolute(moduleId) ? pathModule.relative(baseDir, moduleId) : moduleId).split('\\').join('/').replace(baseDir + '/', '');
  switch(relativeModuleId) {
    default:
      return Promise.reject(new Error(`Cannot find module '${relativeModuleId}'.`));
  }
};

const rootStore = new MeshStore('.mesh', new FsStoreStorageAdapter({
  cwd: baseDir,
  importFn,
  fileType: "ts",
}), {
  readonly: true,
  validate: false
});

export const rawServeConfig: YamlConfig.Config['serve'] = undefined as any
export async function getMeshOptions(): Promise<GetMeshOptions> {
const pubsub = new PubSub();
const sourcesStore = rootStore.child('sources');
const logger = new DefaultLogger("🕸️  Mesh");
const cache = new (MeshCache as any)({
      ...({} as any),
      importFn,
      store: rootStore.child('cache'),
      pubsub,
      logger,
    } as any)

const sources: MeshResolvedSource[] = [];
const transforms: MeshTransform[] = [];
const additionalEnvelopPlugins: MeshPlugin<any>[] = [];
const githubTransforms = [];
const additionalTypeDefs = [] as any[];
const githubHandler = new GraphqlHandler({
              name: "Github",
              config: {"endpoint":"https://api.github.com/graphql","source":"https://docs.github.com/public/schema.docs.graphql","operationHeaders":{"Authorization":"bearer {env.GITHUB_TOKEN}","User-Agent":"GraphQL Mesh"},"batch":false},
              baseDir,
              cache,
              pubsub,
              store: sourcesStore.child("Github"),
              logger: logger.child("Github"),
              importFn,
            });
sources[0] = {
          name: 'Github',
          handler: githubHandler,
          transforms: githubTransforms
        }
const additionalResolvers = [] as any[]
const merger = new(BareMerger as any)({
        cache,
        pubsub,
        logger: logger.child('bareMerger'),
        store: rootStore.child('bareMerger')
      })
const documentHashMap = {
        "ce19059f6437846ac87239b0ac2099cc185ca273f300902b548cd3eae9870dff": UserViewerDocument
      }
additionalEnvelopPlugins.push(usePersistedOperations({
        getPersistedOperation(key) {
          return documentHashMap[key];
        },
      }))

  return {
    sources,
    transforms,
    additionalTypeDefs,
    additionalResolvers,
    cache,
    pubsub,
    merger,
    logger,
    additionalEnvelopPlugins,
    get documents() {
      return [
      {
        document: UserViewerDocument,
        get rawSDL() {
          return printWithCache(UserViewerDocument);
        },
        location: 'UserViewerDocument.graphql',
        sha256Hash: 'ce19059f6437846ac87239b0ac2099cc185ca273f300902b548cd3eae9870dff'
      }
    ];
    },
    fetchFn,
  };
}

export function createBuiltMeshHTTPHandler<TServerContext = {}>(): MeshHTTPHandler<TServerContext> {
  return createMeshHTTPHandler<TServerContext>({
    baseDir,
    getBuiltMesh: getBuiltMesh,
    rawServeConfig: undefined,
  })
}


let meshInstance$: Promise<MeshInstance> | undefined;

export const pollingInterval = null;

export function getBuiltMesh(): Promise<MeshInstance> {
  if (meshInstance$ == null) {
    if (pollingInterval) {
      setInterval(() => {
        getMeshOptions()
        .then(meshOptions => getMesh(meshOptions))
        .then(newMesh =>
          meshInstance$.then(oldMesh => {
            oldMesh.destroy()
            meshInstance$ = Promise.resolve(newMesh)
          })
        ).catch(err => {
          console.error("Mesh polling failed so the existing version will be used:", err);
        });
      }, pollingInterval)
    }
    meshInstance$ = getMeshOptions().then(meshOptions => getMesh(meshOptions)).then(mesh => {
      const id = mesh.pubsub.subscribe('destroy', () => {
        meshInstance$ = undefined;
        mesh.pubsub.unsubscribe(id);
      });
      return mesh;
    });
  }
  return meshInstance$;
}

export const execute: ExecuteMeshFn = (...args) => getBuiltMesh().then(({ execute }) => execute(...args));

export const subscribe: SubscribeMeshFn = (...args) => getBuiltMesh().then(({ subscribe }) => subscribe(...args));
export function getMeshSDK<TGlobalContext = any, TOperationContext = any>(globalContext?: TGlobalContext) {
  const sdkRequester$ = getBuiltMesh().then(({ sdkRequesterFactory }) => sdkRequesterFactory(globalContext));
  return getSdk<TOperationContext, TGlobalContext>((...args) => sdkRequester$.then(sdkRequester => sdkRequester(...args)));
}
export type UserViewerQueryVariables = Exact<{ [key: string]: never; }>;


export type UserViewerQuery = { viewer: Pick<User, 'login'> };


export const UserViewerDocument = gql`
    query UserViewer {
  viewer {
    login
  }
}
    ` as unknown as DocumentNode<UserViewerQuery, UserViewerQueryVariables>;


export type Requester<C = {}, E = unknown> = <R, V>(doc: DocumentNode, vars?: V, options?: C) => Promise<R> | AsyncIterable<R>
export function getSdk<C, E>(requester: Requester<C, E>) {
  return {
    UserViewer(variables?: UserViewerQueryVariables, options?: C): Promise<UserViewerQuery> {
      return requester<UserViewerQuery, UserViewerQueryVariables>(UserViewerDocument, variables, options) as Promise<UserViewerQuery>;
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;