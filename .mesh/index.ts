// @ts-nocheck
import { GraphQLResolveInfo, SelectionSetNode, FieldNode, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
import { gql } from '@graphql-mesh/utils';

import type { GetMeshOptions } from '@graphql-mesh/runtime';
import type { YamlConfig } from '@graphql-mesh/types';
import { PubSub } from '@graphql-mesh/utils';
import { DefaultLogger } from '@graphql-mesh/utils';
import MeshCache from "@graphql-mesh/cache-localforage";
import { fetch as fetchFn } from '@whatwg-node/fetch';

import { MeshResolvedSource } from '@graphql-mesh/runtime';
import { MeshTransform, MeshPlugin } from '@graphql-mesh/types';
import GraphqlHandler from "@graphql-mesh/graphql"
import PrefixTransform from "@graphql-mesh/transform-prefix";
import EncapsulateTransform from "@graphql-mesh/transform-encapsulate";
import StitchingMerger from "@graphql-mesh/merger-stitching";
import { printWithCache } from '@graphql-mesh/utils';
import { usePersistedOperations } from '@graphql-yoga/plugin-persisted-operations';
import { createMeshHTTPHandler, MeshHTTPHandler } from '@graphql-mesh/http';
import { getMesh, ExecuteMeshFn, SubscribeMeshFn, MeshContext as BaseMeshContext, MeshInstance } from '@graphql-mesh/runtime';
import { MeshStore, FsStoreStorageAdapter } from '@graphql-mesh/store';
import { path as pathModule } from '@graphql-mesh/cross-helpers';
import { ImportFn } from '@graphql-mesh/types';
import type { HashnodeTypes } from './sources/Hashnode/types';
import type { GithubTypes } from './sources/Github/types';
import * as importedModule$0 from "./sources/Hashnode/introspectionSchema";
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };



/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** A (potentially binary) string encoded using base64. */
  gh_Base64String: { input: any; output: any; }
  /**
   * Represents non-fractional signed whole numeric values. Since the value may
   * exceed the size of a 32-bit integer, it's encoded as a string.
   */
  BigInt: { input: any; output: any; }
  /** An ISO-8601 encoded date string. */
  Date: { input: any; output: any; }
  /** A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar. */
  DateTime: { input: any; output: any; }
  /** A Git object ID. */
  gh_GitObjectID: { input: any; output: any; }
  /** A fully qualified reference name (e.g. `refs/heads/master`). */
  gh_GitRefname: { input: any; output: any; }
  /** Git SSH string */
  gh_GitSSHRemote: { input: any; output: any; }
  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
  gh_GitTimestamp: { input: any; output: any; }
  /** A string containing HTML code. */
  gh_HTML: { input: any; output: any; }
  /** An ISO-8601 encoded UTC date string with millisecond precision. */
  gh_PreciseDateTime: { input: any; output: any; }
  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
  gh_URI: { input: any; output: any; }
  /** A valid x509 certificate string */
  gh_X509Certificate: { input: any; output: any; }
  hn_ObjectId: { input: any; output: any; }
};

/** The query root of GitHub's GraphQL interface. */
export type Query = {
  Github: GithubQuery;
  Hashnode: HashnodeQuery;
};

/** The root query for implementing GraphQL mutations. */
export type Mutation = {
  Github: GithubMutation;
  Hashnode: HashnodeMutation;
};

/** Autogenerated input type of AbortQueuedMigrations */
export type gh_AbortQueuedMigrationsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that is running the migrations. */
  ownerId: Scalars['ID']['input'];
};

/** Autogenerated return type of AbortQueuedMigrations */
export type gh_AbortQueuedMigrationsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Autogenerated input type of AbortRepositoryMigration */
export type gh_AbortRepositoryMigrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the migration to be aborted. */
  migrationId: Scalars['ID']['input'];
};

/** Autogenerated return type of AbortRepositoryMigration */
export type gh_AbortRepositoryMigrationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */
export type gh_AcceptEnterpriseAdministratorInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the invitation being accepted */
  invitationId: Scalars['ID']['input'];
};

/** Autogenerated return type of AcceptEnterpriseAdministratorInvitation */
export type gh_AcceptEnterpriseAdministratorInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The invitation that was accepted. */
  invitation?: Maybe<gh_EnterpriseAdministratorInvitation>;
  /** A message confirming the result of accepting an administrator invitation. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of AcceptTopicSuggestion */
export type gh_AcceptTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The name of the suggested topic.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `name` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  name?: InputMaybe<Scalars['String']['input']>;
  /**
   * The Node ID of the repository.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `repositoryId` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of AcceptTopicSuggestion */
export type gh_AcceptTopicSuggestionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * The accepted topic.
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  topic?: Maybe<gh_Topic>;
};

/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type gh_Actor = {
  /** A URL pointing to the actor's public avatar. */
  avatarUrl: Scalars['gh_URI']['output'];
  /** The username of the actor. */
  login: Scalars['String']['output'];
  /** The HTTP path for this actor. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this actor. */
  url: Scalars['gh_URI']['output'];
};


/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type gh_ActoravatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** Location information for an actor */
export type gh_ActorLocation = {
  /** City */
  city?: Maybe<Scalars['String']['output']>;
  /** Country name */
  country?: Maybe<Scalars['String']['output']>;
  /** Country code */
  countryCode?: Maybe<Scalars['String']['output']>;
  /** Region name */
  region?: Maybe<Scalars['String']['output']>;
  /** Region or state code */
  regionCode?: Maybe<Scalars['String']['output']>;
};

/** The actor's type. */
export type gh_ActorType =
  /** Indicates a team actor. */
  | 'TEAM'
  /** Indicates a user actor. */
  | 'USER';

/** Autogenerated input type of AddAssigneesToAssignable */
export type gh_AddAssigneesToAssignableInput = {
  /** The id of the assignable object to add assignees to. */
  assignableId: Scalars['ID']['input'];
  /** The id of users to add as assignees. */
  assigneeIds: Array<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AddAssigneesToAssignable */
export type gh_AddAssigneesToAssignablePayload = {
  /** The item that was assigned. */
  assignable?: Maybe<gh_Assignable>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of AddComment */
export type gh_AddCommentInput = {
  /** The contents of the comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddComment */
export type gh_AddCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The edge from the subject's comment connection. */
  commentEdge?: Maybe<gh_IssueCommentEdge>;
  /** The subject */
  subject?: Maybe<gh_Node>;
  /** The edge from the subject's timeline connection. */
  timelineEdge?: Maybe<gh_IssueTimelineItemEdge>;
};

/** Autogenerated input type of AddDiscussionComment */
export type gh_AddDiscussionCommentInput = {
  /** The contents of the comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion to comment on. */
  discussionId: Scalars['ID']['input'];
  /** The Node ID of the discussion comment within this discussion to reply to. */
  replyToId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of AddDiscussionComment */
export type gh_AddDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created discussion comment. */
  comment?: Maybe<gh_DiscussionComment>;
};

/** Autogenerated input type of AddDiscussionPollVote */
export type gh_AddDiscussionPollVoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion poll option to vote for. */
  pollOptionId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddDiscussionPollVote */
export type gh_AddDiscussionPollVotePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The poll option that a vote was added to. */
  pollOption?: Maybe<gh_DiscussionPollOption>;
};

/** Autogenerated input type of AddEnterpriseOrganizationMember */
export type gh_AddEnterpriseOrganizationMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise which owns the organization. */
  enterpriseId: Scalars['ID']['input'];
  /** The ID of the organization the users will be added to. */
  organizationId: Scalars['ID']['input'];
  /** The role to assign the users in the organization */
  role?: InputMaybe<gh_OrganizationMemberRole>;
  /** The IDs of the enterprise members to add. */
  userIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of AddEnterpriseOrganizationMember */
export type gh_AddEnterpriseOrganizationMemberPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The users who were added to the organization. */
  users?: Maybe<Array<gh_User>>;
};

/** Autogenerated input type of AddEnterpriseSupportEntitlement */
export type gh_AddEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of a member who will receive the support entitlement. */
  login: Scalars['String']['input'];
};

/** Autogenerated return type of AddEnterpriseSupportEntitlement */
export type gh_AddEnterpriseSupportEntitlementPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of adding the support entitlement. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of AddLabelsToLabelable */
export type gh_AddLabelsToLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ids of the labels to add. */
  labelIds: Array<Scalars['ID']['input']>;
  /** The id of the labelable object to add labels to. */
  labelableId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddLabelsToLabelable */
export type gh_AddLabelsToLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was labeled. */
  labelable?: Maybe<gh_Labelable>;
};

/** Autogenerated input type of AddProjectCard */
export type gh_AddProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The content of the card. Must be a member of the ProjectCardItem union */
  contentId?: InputMaybe<Scalars['ID']['input']>;
  /** The note on the card. */
  note?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the ProjectColumn. */
  projectColumnId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddProjectCard */
export type gh_AddProjectCardPayload = {
  /** The edge from the ProjectColumn's card connection. */
  cardEdge?: Maybe<gh_ProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The ProjectColumn */
  projectColumn?: Maybe<gh_ProjectColumn>;
};

/** Autogenerated input type of AddProjectColumn */
export type gh_AddProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the column. */
  name: Scalars['String']['input'];
  /** The Node ID of the project. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddProjectColumn */
export type gh_AddProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The edge from the project's column connection. */
  columnEdge?: Maybe<gh_ProjectColumnEdge>;
  /** The project */
  project?: Maybe<gh_Project>;
};

/** Autogenerated input type of AddProjectV2DraftIssue */
export type gh_AddProjectV2DraftIssueInput = {
  /** The IDs of the assignees of the draft issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The body of the draft issue. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to add the draft issue to. */
  projectId: Scalars['ID']['input'];
  /**
   * The title of the draft issue. A project item can also be created by providing
   * the URL of an Issue or Pull Request if you have access.
   */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of AddProjectV2DraftIssue */
export type gh_AddProjectV2DraftIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The draft issue added to the project. */
  projectItem?: Maybe<gh_ProjectV2Item>;
};

/** Autogenerated input type of AddProjectV2ItemById */
export type gh_AddProjectV2ItemByIdInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the Issue or Pull Request to add. */
  contentId: Scalars['ID']['input'];
  /** The ID of the Project to add the item to. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddProjectV2ItemById */
export type gh_AddProjectV2ItemByIdPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item added to the project. */
  item?: Maybe<gh_ProjectV2Item>;
};

/** Autogenerated input type of AddPullRequestReviewComment */
export type gh_AddPullRequestReviewCommentInput = {
  /**
   * The text of the comment. This field is required
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `body` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The SHA of the commit to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `commitOID` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  commitOID?: InputMaybe<Scalars['gh_GitObjectID']['input']>;
  /**
   * The comment id to reply to.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `inReplyTo` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  inReplyTo?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The relative path of the file to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `path` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  path?: InputMaybe<Scalars['String']['input']>;
  /**
   * The line index in the diff to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `position` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  position?: InputMaybe<Scalars['Int']['input']>;
  /**
   * The node ID of the pull request reviewing
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `pullRequestId` will be removed. use
   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The Node ID of the review to modify.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `pullRequestReviewId` will be removed. use
   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of AddPullRequestReviewComment */
export type gh_AddPullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created comment. */
  comment?: Maybe<gh_PullRequestReviewComment>;
  /** The edge from the review's comment connection. */
  commentEdge?: Maybe<gh_PullRequestReviewCommentEdge>;
};

/** Autogenerated input type of AddPullRequestReview */
export type gh_AddPullRequestReviewInput = {
  /** The contents of the review body comment. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The review line comments.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `comments` will be removed. use the `threads` argument instead
   * **Reason:** We are deprecating comment fields that use diff-relative positioning
   */
  comments?: InputMaybe<Array<InputMaybe<gh_DraftPullRequestReviewComment>>>;
  /** The commit OID the review pertains to. */
  commitOID?: InputMaybe<Scalars['gh_GitObjectID']['input']>;
  /** The event to perform on the pull request review. */
  event?: InputMaybe<gh_PullRequestReviewEvent>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID']['input'];
  /** The review line comment threads. */
  threads?: InputMaybe<Array<InputMaybe<gh_DraftPullRequestReviewThread>>>;
};

/** Autogenerated return type of AddPullRequestReview */
export type gh_AddPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created pull request review. */
  pullRequestReview?: Maybe<gh_PullRequestReview>;
  /** The edge from the pull request's review connection. */
  reviewEdge?: Maybe<gh_PullRequestReviewEdge>;
};

/** Autogenerated input type of AddPullRequestReviewThread */
export type gh_AddPullRequestReviewThreadInput = {
  /** Body of the thread's first comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The line of the blob to which the thread refers, required for line-level
   * threads. The end of the line range for multi-line comments.
   */
  line?: InputMaybe<Scalars['Int']['input']>;
  /** Path to the file being commented on. */
  path: Scalars['String']['input'];
  /** The node ID of the pull request reviewing */
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  /** The Node ID of the review to modify. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: InputMaybe<gh_DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: InputMaybe<Scalars['Int']['input']>;
  /** The side of the diff on which the start line resides. */
  startSide?: InputMaybe<gh_DiffSide>;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  subjectType?: InputMaybe<gh_PullRequestReviewThreadSubjectType>;
};

/** Autogenerated return type of AddPullRequestReviewThread */
export type gh_AddPullRequestReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created thread. */
  thread?: Maybe<gh_PullRequestReviewThread>;
};

/** Autogenerated input type of AddPullRequestReviewThreadReply */
export type gh_AddPullRequestReviewThreadReplyInput = {
  /** The text of the reply. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pending review to which the reply will belong. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
  /** The Node ID of the thread to which this reply is being written. */
  pullRequestReviewThreadId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddPullRequestReviewThreadReply */
export type gh_AddPullRequestReviewThreadReplyPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created reply. */
  comment?: Maybe<gh_PullRequestReviewComment>;
};

/** Autogenerated input type of AddReaction */
export type gh_AddReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the emoji to react with. */
  content: gh_ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddReaction */
export type gh_AddReactionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The reaction object. */
  reaction?: Maybe<gh_Reaction>;
  /** The reaction groups for the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** The reactable subject. */
  subject?: Maybe<gh_Reactable>;
};

/** Autogenerated input type of AddStar */
export type gh_AddStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Starrable ID to star. */
  starrableId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddStar */
export type gh_AddStarPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The starrable. */
  starrable?: Maybe<gh_Starrable>;
};

/** Autogenerated input type of AddUpvote */
export type gh_AddUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion or comment to upvote. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddUpvote */
export type gh_AddUpvotePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The votable subject. */
  subject?: Maybe<gh_Votable>;
};

/** Autogenerated input type of AddVerifiableDomain */
export type gh_AddVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the domain */
  domain: Scalars['gh_URI']['input'];
  /** The ID of the owner to add the domain to */
  ownerId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddVerifiableDomain */
export type gh_AddVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The verifiable domain that was added. */
  domain?: Maybe<gh_VerifiableDomain>;
};

/** Represents an 'added_to_merge_queue' event on a given pull request. */
export type gh_AddedToMergeQueueEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who added this Pull Request to the merge queue */
  enqueuer?: Maybe<gh_User>;
  /** The Node ID of the AddedToMergeQueueEvent object */
  id: Scalars['ID']['output'];
  /** The merge queue where this pull request was added to. */
  mergeQueue?: Maybe<gh_MergeQueue>;
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Represents a 'added_to_project' event on a given issue or pull request. */
export type gh_AddedToProjectEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the AddedToProjectEvent object */
  id: Scalars['ID']['output'];
  /** Project referenced by event. */
  project?: Maybe<gh_Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<gh_ProjectCard>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String']['output'];
};

/** Represents an announcement banner. */
export type gh_AnnouncementBanner = {
  /** The text of the announcement */
  announcement?: Maybe<Scalars['String']['output']>;
  /** The expiration date of the announcement, if any */
  announcementExpiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether the announcement can be dismissed by the user */
  announcementUserDismissible?: Maybe<Scalars['Boolean']['output']>;
};

/** A GitHub App. */
export type gh_App = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The description of the app. */
  description?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the App object */
  id: Scalars['ID']['output'];
  /** The IP addresses of the app. */
  ipAllowListEntries: gh_IpAllowListEntryConnection;
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars['String']['output'];
  /** A URL pointing to the app's logo. */
  logoUrl: Scalars['gh_URI']['output'];
  /** The name of the app. */
  name: Scalars['String']['output'];
  /** A slug based on the name of the app for use in URLs. */
  slug: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The URL to the app's homepage. */
  url: Scalars['gh_URI']['output'];
};


/** A GitHub App. */
export type gh_AppipAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IpAllowListEntryOrder>;
};


/** A GitHub App. */
export type gh_ApplogoUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ApproveDeployments */
export type gh_ApproveDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Optional comment for approving deployments */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars['ID']['input']>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars['ID']['input'];
};

/** Autogenerated return type of ApproveDeployments */
export type gh_ApproveDeploymentsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The affected deployments. */
  deployments?: Maybe<Array<gh_Deployment>>;
};

/** Autogenerated input type of ApproveVerifiableDomain */
export type gh_ApproveVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to approve. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ApproveVerifiableDomain */
export type gh_ApproveVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The verifiable domain that was approved. */
  domain?: Maybe<gh_VerifiableDomain>;
};

/** Autogenerated input type of ArchiveProjectV2Item */
export type gh_ArchiveProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the ProjectV2Item to archive. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project to archive the item from. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ArchiveProjectV2Item */
export type gh_ArchiveProjectV2ItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item archived from the project. */
  item?: Maybe<gh_ProjectV2Item>;
};

/** Autogenerated input type of ArchiveRepository */
export type gh_ArchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to mark as archived. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of ArchiveRepository */
export type gh_ArchiveRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository that was marked as archived. */
  repository?: Maybe<gh_Repository>;
};

/** An object that can have users assigned to it. */
export type gh_Assignable = {
  /** A list of Users assigned to this object. */
  assignees: gh_UserConnection;
};


/** An object that can have users assigned to it. */
export type gh_AssignableassigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an 'assigned' event on any assignable object. */
export type gh_AssignedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the assignable associated with the event. */
  assignable: gh_Assignable;
  /** Identifies the user or mannequin that was assigned. */
  assignee?: Maybe<gh_Assignee>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the AssignedEvent object */
  id: Scalars['ID']['output'];
  /**
   * Identifies the user who was assigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  user?: Maybe<gh_User>;
};

/** Types that can be assigned to issues. */
export type gh_Assignee = gh_Bot | gh_Mannequin | gh_Organization | gh_User;

/** An entry in the audit log. */
export type gh_AuditEntry = {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Types that can initiate an audit log event. */
export type gh_AuditEntryActor = gh_Bot | gh_Organization | gh_User;

/** Ordering options for Audit Log connections. */
export type gh_AuditLogOrder = {
  /** The ordering direction. */
  direction?: InputMaybe<gh_OrderDirection>;
  /** The field to order Audit Logs by. */
  field?: InputMaybe<gh_AuditLogOrderField>;
};

/** Properties by which Audit Log connections can be ordered. */
export type gh_AuditLogOrderField =
  /** Order audit log entries by timestamp */
  | 'CREATED_AT';

/** Represents a 'auto_merge_disabled' event on a given pull request. */
export type gh_AutoMergeDisabledEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who disabled auto-merge for this Pull Request */
  disabler?: Maybe<gh_User>;
  /** The Node ID of the AutoMergeDisabledEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event */
  pullRequest?: Maybe<gh_PullRequest>;
  /** The reason auto-merge was disabled */
  reason?: Maybe<Scalars['String']['output']>;
  /** The reason_code relating to why auto-merge was disabled */
  reasonCode?: Maybe<Scalars['String']['output']>;
};

/** Represents a 'auto_merge_enabled' event on a given pull request. */
export type gh_AutoMergeEnabledEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who enabled auto-merge for this Pull Request */
  enabler?: Maybe<gh_User>;
  /** The Node ID of the AutoMergeEnabledEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Represents an auto-merge request for a pull request */
export type gh_AutoMergeRequest = {
  /** The email address of the author of this auto-merge request. */
  authorEmail?: Maybe<Scalars['String']['output']>;
  /**
   * The commit message of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging.
   */
  commitBody?: Maybe<Scalars['String']['output']>;
  /**
   * The commit title of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging
   */
  commitHeadline?: Maybe<Scalars['String']['output']>;
  /** When was this auto-merge request was enabled. */
  enabledAt?: Maybe<Scalars['DateTime']['output']>;
  /** The actor who created the auto-merge request. */
  enabledBy?: Maybe<gh_Actor>;
  /**
   * The merge method of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging.
   */
  mergeMethod: gh_PullRequestMergeMethod;
  /** The pull request that this auto-merge request is set against. */
  pullRequest: gh_PullRequest;
};

/** Represents a 'auto_rebase_enabled' event on a given pull request. */
export type gh_AutoRebaseEnabledEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who enabled auto-merge (rebase) for this Pull Request */
  enabler?: Maybe<gh_User>;
  /** The Node ID of the AutoRebaseEnabledEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Represents a 'auto_squash_enabled' event on a given pull request. */
export type gh_AutoSquashEnabledEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who enabled auto-merge (squash) for this Pull Request */
  enabler?: Maybe<gh_User>;
  /** The Node ID of the AutoSquashEnabledEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Represents a 'automatic_base_change_failed' event on a given pull request. */
export type gh_AutomaticBaseChangeFailedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the AutomaticBaseChangeFailedEvent object */
  id: Scalars['ID']['output'];
  /** The new base for this PR */
  newBase: Scalars['String']['output'];
  /** The old base for this PR */
  oldBase: Scalars['String']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
};

/** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
export type gh_AutomaticBaseChangeSucceededEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the AutomaticBaseChangeSucceededEvent object */
  id: Scalars['ID']['output'];
  /** The new base for this PR */
  newBase: Scalars['String']['output'];
  /** The old base for this PR */
  oldBase: Scalars['String']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
};

/** Represents a 'base_ref_changed' event on a given issue or pull request. */
export type gh_BaseRefChangedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the name of the base ref for the pull request after it was changed. */
  currentRefName: Scalars['String']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the BaseRefChangedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the name of the base ref for the pull request before it was changed. */
  previousRefName: Scalars['String']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
};

/** Represents a 'base_ref_deleted' event on a given pull request. */
export type gh_BaseRefDeletedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the name of the Ref associated with the `base_ref_deleted` event. */
  baseRefName?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the BaseRefDeletedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Represents a 'base_ref_force_pushed' event on a given pull request. */
export type gh_BaseRefForcePushedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */
  afterCommit?: Maybe<gh_Commit>;
  /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */
  beforeCommit?: Maybe<gh_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the BaseRefForcePushedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
  /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */
  ref?: Maybe<gh_Ref>;
};

/** Represents a Git blame. */
export type gh_Blame = {
  /** The list of ranges from a Git blame. */
  ranges: Array<gh_BlameRange>;
};

/** Represents a range of information from a Git blame. */
export type gh_BlameRange = {
  /**
   * Identifies the recency of the change, from 1 (new) to 10 (old). This is
   * calculated as a 2-quantile and determines the length of distance between the
   * median age of all the changes in the file and the recency of the current
   * range's change.
   */
  age: Scalars['Int']['output'];
  /** Identifies the line author */
  commit: gh_Commit;
  /** The ending line for the range */
  endingLine: Scalars['Int']['output'];
  /** The starting line for the range */
  startingLine: Scalars['Int']['output'];
};

/** Represents a Git blob. */
export type gh_Blob = gh_GitObject & gh_Node & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String']['output'];
  /** Byte size of Blob object */
  byteSize: Scalars['Int']['output'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['gh_URI']['output'];
  /** The Node ID of the Blob object */
  id: Scalars['ID']['output'];
  /** Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding. */
  isBinary?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the contents is truncated */
  isTruncated: Scalars['Boolean']['output'];
  /** The Git object ID */
  oid: Scalars['gh_GitObjectID']['output'];
  /** The Repository the Git object belongs to */
  repository: gh_Repository;
  /** UTF8 text data or null if the Blob is binary */
  text?: Maybe<Scalars['String']['output']>;
};

/** A special type of user which takes actions on behalf of GitHub Apps. */
export type gh_Bot = gh_Actor & gh_Node & gh_UniformResourceLocatable & {
  /** A URL pointing to the GitHub App's public avatar. */
  avatarUrl: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the Bot object */
  id: Scalars['ID']['output'];
  /** The username of the actor. */
  login: Scalars['String']['output'];
  /** The HTTP path for this bot */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this bot */
  url: Scalars['gh_URI']['output'];
};


/** A special type of user which takes actions on behalf of GitHub Apps. */
export type gh_BotavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** Types which can be actors for `BranchActorAllowance` objects. */
export type gh_BranchActorAllowanceActor = gh_App | gh_Team | gh_User;

/** Parameters to be used for the branch_name_pattern rule */
export type gh_BranchNamePatternParameters = {
  /** How this rule will appear to users. */
  name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  operator: Scalars['String']['output'];
  /** The pattern to match with. */
  pattern: Scalars['String']['output'];
};

/** Parameters to be used for the branch_name_pattern rule */
export type gh_BranchNamePatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/** A branch protection rule. */
export type gh_BranchProtectionRule = gh_Node & {
  /** Can this branch be deleted. */
  allowsDeletions: Scalars['Boolean']['output'];
  /** Are force pushes allowed on this branch. */
  allowsForcePushes: Scalars['Boolean']['output'];
  /** Is branch creation a protected operation. */
  blocksCreations: Scalars['Boolean']['output'];
  /** A list of conflicts matching branches protection rule and other branch protection rules */
  branchProtectionRuleConflicts: gh_BranchProtectionRuleConflictConnection;
  /** A list of actors able to force push for this branch protection rule. */
  bypassForcePushAllowances: gh_BypassForcePushAllowanceConnection;
  /** A list of actors able to bypass PRs for this branch protection rule. */
  bypassPullRequestAllowances: gh_BypassPullRequestAllowanceConnection;
  /** The actor who created this branch protection rule. */
  creator?: Maybe<gh_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews: Scalars['Boolean']['output'];
  /** The Node ID of the BranchProtectionRule object */
  id: Scalars['ID']['output'];
  /** Can admins override branch protection. */
  isAdminEnforced: Scalars['Boolean']['output'];
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge: Scalars['Boolean']['output'];
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch: Scalars['Boolean']['output'];
  /** Repository refs that are protected by this rule */
  matchingRefs: gh_RefConnection;
  /** Identifies the protection rule pattern. */
  pattern: Scalars['String']['output'];
  /** A list push allowances for this branch protection rule. */
  pushAllowances: gh_PushAllowanceConnection;
  /** The repository associated with this branch protection rule. */
  repository?: Maybe<gh_Repository>;
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval: Scalars['Boolean']['output'];
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']['output']>;
  /** List of required deployment environments that must be deployed successfully to update matching branches */
  requiredDeploymentEnvironments?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** List of required status checks that must pass for commits to be accepted to matching branches. */
  requiredStatusChecks?: Maybe<Array<gh_RequiredStatusCheckDescription>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews: Scalars['Boolean']['output'];
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews: Scalars['Boolean']['output'];
  /** Are commits required to be signed. */
  requiresCommitSignatures: Scalars['Boolean']['output'];
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution: Scalars['Boolean']['output'];
  /** Does this branch require deployment to specific environments before merging */
  requiresDeployments: Scalars['Boolean']['output'];
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory: Scalars['Boolean']['output'];
  /** Are status checks required to update matching branches. */
  requiresStatusChecks: Scalars['Boolean']['output'];
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks: Scalars['Boolean']['output'];
  /** Is pushing to matching branches restricted. */
  restrictsPushes: Scalars['Boolean']['output'];
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals: Scalars['Boolean']['output'];
  /** A list review dismissal allowances for this branch protection rule. */
  reviewDismissalAllowances: gh_ReviewDismissalAllowanceConnection;
};


/** A branch protection rule. */
export type gh_BranchProtectionRulebranchProtectionRuleConflictsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A branch protection rule. */
export type gh_BranchProtectionRulebypassForcePushAllowancesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A branch protection rule. */
export type gh_BranchProtectionRulebypassPullRequestAllowancesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A branch protection rule. */
export type gh_BranchProtectionRulematchingRefsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A branch protection rule. */
export type gh_BranchProtectionRulepushAllowancesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A branch protection rule. */
export type gh_BranchProtectionRulereviewDismissalAllowancesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A conflict between two branch protection rules. */
export type gh_BranchProtectionRuleConflict = {
  /** Identifies the branch protection rule. */
  branchProtectionRule?: Maybe<gh_BranchProtectionRule>;
  /** Identifies the conflicting branch protection rule. */
  conflictingBranchProtectionRule?: Maybe<gh_BranchProtectionRule>;
  /** Identifies the branch ref that has conflicting rules */
  ref?: Maybe<gh_Ref>;
};

/** The connection type for BranchProtectionRuleConflict. */
export type gh_BranchProtectionRuleConflictConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_BranchProtectionRuleConflictEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_BranchProtectionRuleConflict>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_BranchProtectionRuleConflictEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_BranchProtectionRuleConflict>;
};

/** The connection type for BranchProtectionRule. */
export type gh_BranchProtectionRuleConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_BranchProtectionRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_BranchProtectionRule>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_BranchProtectionRuleEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_BranchProtectionRule>;
};

/**
 * Information about a sponsorship to make for a user or organization with a GitHub
 * Sponsors profile, as part of sponsoring many users or organizations at once.
 */
export type gh_BulkSponsorship = {
  /** The amount to pay to the sponsorable in US dollars. Valid values: 1-12000. */
  amount: Scalars['Int']['input'];
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Types that can represent a repository ruleset bypass actor. */
export type gh_BypassActor = gh_App | gh_Team;

/** A user, team, or app who has the ability to bypass a force push requirement on a protected branch. */
export type gh_BypassForcePushAllowance = gh_Node & {
  /** The actor that can force push. */
  actor?: Maybe<gh_BranchActorAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<gh_BranchProtectionRule>;
  /** The Node ID of the BypassForcePushAllowance object */
  id: Scalars['ID']['output'];
};

/** The connection type for BypassForcePushAllowance. */
export type gh_BypassForcePushAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_BypassForcePushAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_BypassForcePushAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_BypassForcePushAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_BypassForcePushAllowance>;
};

/** A user, team, or app who has the ability to bypass a pull request requirement on a protected branch. */
export type gh_BypassPullRequestAllowance = gh_Node & {
  /** The actor that can bypass. */
  actor?: Maybe<gh_BranchActorAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<gh_BranchProtectionRule>;
  /** The Node ID of the BypassPullRequestAllowance object */
  id: Scalars['ID']['output'];
};

/** The connection type for BypassPullRequestAllowance. */
export type gh_BypassPullRequestAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_BypassPullRequestAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_BypassPullRequestAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_BypassPullRequestAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_BypassPullRequestAllowance>;
};

/** The Common Vulnerability Scoring System */
export type gh_CVSS = {
  /** The CVSS score associated with this advisory */
  score: Scalars['Float']['output'];
  /** The CVSS vector string associated with this advisory */
  vectorString?: Maybe<Scalars['String']['output']>;
};

/** A common weakness enumeration */
export type gh_CWE = gh_Node & {
  /** The id of the CWE */
  cweId: Scalars['String']['output'];
  /** A detailed description of this CWE */
  description: Scalars['String']['output'];
  /** The Node ID of the CWE object */
  id: Scalars['ID']['output'];
  /** The name of this CWE */
  name: Scalars['String']['output'];
};

/** The connection type for CWE. */
export type gh_CWEConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CWEEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_CWE>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_CWEEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_CWE>;
};

/** Autogenerated input type of CancelEnterpriseAdminInvitation */
export type gh_CancelEnterpriseAdminInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pending enterprise administrator invitation. */
  invitationId: Scalars['ID']['input'];
};

/** Autogenerated return type of CancelEnterpriseAdminInvitation */
export type gh_CancelEnterpriseAdminInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The invitation that was canceled. */
  invitation?: Maybe<gh_EnterpriseAdministratorInvitation>;
  /** A message confirming the result of canceling an administrator invitation. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CancelSponsorship */
export type gh_CancelSponsorshipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CancelSponsorship */
export type gh_CancelSponsorshipPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The tier that was being used at the time of cancellation. */
  sponsorsTier?: Maybe<gh_SponsorsTier>;
};

/** Autogenerated input type of ChangeUserStatus */
export type gh_ChangeUserStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */
  emoji?: InputMaybe<Scalars['String']['input']>;
  /** If set, the user status will not be shown after this date. */
  expiresAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */
  limitedAvailability?: InputMaybe<Scalars['Boolean']['input']>;
  /** A short description of your current status. */
  message?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the organization whose members will be allowed to see the status. If
   * omitted, the status will be publicly visible.
   */
  organizationId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of ChangeUserStatus */
export type gh_ChangeUserStatusPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Your updated status. */
  status?: Maybe<gh_UserStatus>;
};

/** A single check annotation. */
export type gh_CheckAnnotation = {
  /** The annotation's severity level. */
  annotationLevel?: Maybe<gh_CheckAnnotationLevel>;
  /** The path to the file that this annotation was made on. */
  blobUrl: Scalars['gh_URI']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The position of this annotation. */
  location: gh_CheckAnnotationSpan;
  /** The annotation's message. */
  message: Scalars['String']['output'];
  /** The path that this annotation was made on. */
  path: Scalars['String']['output'];
  /** Additional information about the annotation. */
  rawDetails?: Maybe<Scalars['String']['output']>;
  /** The annotation's title */
  title?: Maybe<Scalars['String']['output']>;
};

/** The connection type for CheckAnnotation. */
export type gh_CheckAnnotationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CheckAnnotationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_CheckAnnotation>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Information from a check run analysis to specific lines of code. */
export type gh_CheckAnnotationData = {
  /** Represents an annotation's information level */
  annotationLevel: gh_CheckAnnotationLevel;
  /** The location of the annotation */
  location: gh_CheckAnnotationRange;
  /** A short description of the feedback for these lines of code. */
  message: Scalars['String']['input'];
  /** The path of the file to add an annotation to. */
  path: Scalars['String']['input'];
  /** Details about this annotation. */
  rawDetails?: InputMaybe<Scalars['String']['input']>;
  /** The title that represents the annotation. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An edge in a connection. */
export type gh_CheckAnnotationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_CheckAnnotation>;
};

/** Represents an annotation's information level. */
export type gh_CheckAnnotationLevel =
  /** An annotation indicating an inescapable error. */
  | 'FAILURE'
  /** An annotation indicating some information. */
  | 'NOTICE'
  /** An annotation indicating an ignorable error. */
  | 'WARNING';

/** A character position in a check annotation. */
export type gh_CheckAnnotationPosition = {
  /** Column number (1 indexed). */
  column?: Maybe<Scalars['Int']['output']>;
  /** Line number (1 indexed). */
  line: Scalars['Int']['output'];
};

/** Information from a check run analysis to specific lines of code. */
export type gh_CheckAnnotationRange = {
  /** The ending column of the range. */
  endColumn?: InputMaybe<Scalars['Int']['input']>;
  /** The ending line of the range. */
  endLine: Scalars['Int']['input'];
  /** The starting column of the range. */
  startColumn?: InputMaybe<Scalars['Int']['input']>;
  /** The starting line of the range. */
  startLine: Scalars['Int']['input'];
};

/** An inclusive pair of positions for a check annotation. */
export type gh_CheckAnnotationSpan = {
  /** End position (inclusive). */
  end: gh_CheckAnnotationPosition;
  /** Start position (inclusive). */
  start: gh_CheckAnnotationPosition;
};

/** The possible states for a check suite or run conclusion. */
export type gh_CheckConclusionState =
  /** The check suite or run requires action. */
  | 'ACTION_REQUIRED'
  /** The check suite or run has been cancelled. */
  | 'CANCELLED'
  /** The check suite or run has failed. */
  | 'FAILURE'
  /** The check suite or run was neutral. */
  | 'NEUTRAL'
  /** The check suite or run was skipped. */
  | 'SKIPPED'
  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */
  | 'STALE'
  /** The check suite or run has failed at startup. */
  | 'STARTUP_FAILURE'
  /** The check suite or run has succeeded. */
  | 'SUCCESS'
  /** The check suite or run has timed out. */
  | 'TIMED_OUT';

/** A check run. */
export type gh_CheckRun = gh_Node & gh_RequirableByPullRequest & gh_UniformResourceLocatable & {
  /** The check run's annotations */
  annotations?: Maybe<gh_CheckAnnotationConnection>;
  /** The check suite that this run is a part of. */
  checkSuite: gh_CheckSuite;
  /** Identifies the date and time when the check run was completed. */
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The conclusion of the check run. */
  conclusion?: Maybe<gh_CheckConclusionState>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The corresponding deployment for this job, if any */
  deployment?: Maybe<gh_Deployment>;
  /** The URL from which to find full details of the check run on the integrator's site. */
  detailsUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** A reference for the check run on the integrator's system. */
  externalId?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the CheckRun object */
  id: Scalars['ID']['output'];
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars['Boolean']['output'];
  /** The name of the check for this check run. */
  name: Scalars['String']['output'];
  /** Information about a pending deployment, if any, in this check run */
  pendingDeploymentRequest?: Maybe<gh_DeploymentRequest>;
  /** The permalink to the check run summary. */
  permalink: Scalars['gh_URI']['output'];
  /** The repository associated with this check run. */
  repository: gh_Repository;
  /** The HTTP path for this check run. */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the check run was started. */
  startedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The current status of the check run. */
  status: gh_CheckStatusState;
  /** The check run's steps */
  steps?: Maybe<gh_CheckStepConnection>;
  /** A string representing the check run's summary */
  summary?: Maybe<Scalars['String']['output']>;
  /** A string representing the check run's text */
  text?: Maybe<Scalars['String']['output']>;
  /** A string representing the check run */
  title?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this check run. */
  url: Scalars['gh_URI']['output'];
};


/** A check run. */
export type gh_CheckRunannotationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A check run. */
export type gh_CheckRunisRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']['input']>;
};


/** A check run. */
export type gh_CheckRunstepsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
};

/** Possible further actions the integrator can perform. */
export type gh_CheckRunAction = {
  /** A short explanation of what this action would do. */
  description: Scalars['String']['input'];
  /** A reference for the action on the integrator's system. */
  identifier: Scalars['String']['input'];
  /** The text to be displayed on a button in the web UI. */
  label: Scalars['String']['input'];
};

/** The connection type for CheckRun. */
export type gh_CheckRunConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CheckRunEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_CheckRun>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_CheckRunEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_CheckRun>;
};

/** The filters that are available when fetching check runs. */
export type gh_CheckRunFilter = {
  /** Filters the check runs created by this application ID. */
  appId?: InputMaybe<Scalars['Int']['input']>;
  /** Filters the check runs by this name. */
  checkName?: InputMaybe<Scalars['String']['input']>;
  /** Filters the check runs by this type. */
  checkType?: InputMaybe<gh_CheckRunType>;
  /** Filters the check runs by these conclusions. */
  conclusions?: InputMaybe<Array<gh_CheckConclusionState>>;
  /** Filters the check runs by this status. Superceded by statuses. */
  status?: InputMaybe<gh_CheckStatusState>;
  /** Filters the check runs by this status. Overrides status. */
  statuses?: InputMaybe<Array<gh_CheckStatusState>>;
};

/** Descriptive details about the check run. */
export type gh_CheckRunOutput = {
  /** The annotations that are made as part of the check run. */
  annotations?: InputMaybe<Array<gh_CheckAnnotationData>>;
  /** Images attached to the check run output displayed in the GitHub pull request UI. */
  images?: InputMaybe<Array<gh_CheckRunOutputImage>>;
  /** The summary of the check run (supports Commonmark). */
  summary: Scalars['String']['input'];
  /** The details of the check run (supports Commonmark). */
  text?: InputMaybe<Scalars['String']['input']>;
  /** A title to provide for this check run. */
  title: Scalars['String']['input'];
};

/** Images attached to the check run output displayed in the GitHub pull request UI. */
export type gh_CheckRunOutputImage = {
  /** The alternative text for the image. */
  alt: Scalars['String']['input'];
  /** A short image description. */
  caption?: InputMaybe<Scalars['String']['input']>;
  /** The full URL of the image. */
  imageUrl: Scalars['gh_URI']['input'];
};

/** The possible states of a check run in a status rollup. */
export type gh_CheckRunState =
  /** The check run requires action. */
  | 'ACTION_REQUIRED'
  /** The check run has been cancelled. */
  | 'CANCELLED'
  /** The check run has been completed. */
  | 'COMPLETED'
  /** The check run has failed. */
  | 'FAILURE'
  /** The check run is in progress. */
  | 'IN_PROGRESS'
  /** The check run was neutral. */
  | 'NEUTRAL'
  /** The check run is in pending state. */
  | 'PENDING'
  /** The check run has been queued. */
  | 'QUEUED'
  /** The check run was skipped. */
  | 'SKIPPED'
  /** The check run was marked stale by GitHub. Only GitHub can use this conclusion. */
  | 'STALE'
  /** The check run has failed at startup. */
  | 'STARTUP_FAILURE'
  /** The check run has succeeded. */
  | 'SUCCESS'
  /** The check run has timed out. */
  | 'TIMED_OUT'
  /** The check run is in waiting state. */
  | 'WAITING';

/** Represents a count of the state of a check run. */
export type gh_CheckRunStateCount = {
  /** The number of check runs with this state. */
  count: Scalars['Int']['output'];
  /** The state of a check run. */
  state: gh_CheckRunState;
};

/** The possible types of check runs. */
export type gh_CheckRunType =
  /** Every check run available. */
  | 'ALL'
  /** The latest check run. */
  | 'LATEST';

/** The possible states for a check suite or run status. */
export type gh_CheckStatusState =
  /** The check suite or run has been completed. */
  | 'COMPLETED'
  /** The check suite or run is in progress. */
  | 'IN_PROGRESS'
  /** The check suite or run is in pending state. */
  | 'PENDING'
  /** The check suite or run has been queued. */
  | 'QUEUED'
  /** The check suite or run has been requested. */
  | 'REQUESTED'
  /** The check suite or run is in waiting state. */
  | 'WAITING';

/** A single check step. */
export type gh_CheckStep = {
  /** Identifies the date and time when the check step was completed. */
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The conclusion of the check step. */
  conclusion?: Maybe<gh_CheckConclusionState>;
  /** A reference for the check step on the integrator's system. */
  externalId?: Maybe<Scalars['String']['output']>;
  /** The step's name. */
  name: Scalars['String']['output'];
  /** The index of the step in the list of steps of the parent check run. */
  number: Scalars['Int']['output'];
  /** Number of seconds to completion. */
  secondsToCompletion?: Maybe<Scalars['Int']['output']>;
  /** Identifies the date and time when the check step was started. */
  startedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The current status of the check step. */
  status: gh_CheckStatusState;
};

/** The connection type for CheckStep. */
export type gh_CheckStepConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CheckStepEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_CheckStep>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_CheckStepEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_CheckStep>;
};

/** A check suite. */
export type gh_CheckSuite = gh_Node & {
  /** The GitHub App which created this check suite. */
  app?: Maybe<gh_App>;
  /** The name of the branch for this check suite. */
  branch?: Maybe<gh_Ref>;
  /** The check runs associated with a check suite. */
  checkRuns?: Maybe<gh_CheckRunConnection>;
  /** The commit for this check suite */
  commit: gh_Commit;
  /** The conclusion of this check suite. */
  conclusion?: Maybe<gh_CheckConclusionState>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who triggered the check suite. */
  creator?: Maybe<gh_User>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the CheckSuite object */
  id: Scalars['ID']['output'];
  /** A list of open pull requests matching the check suite. */
  matchingPullRequests?: Maybe<gh_PullRequestConnection>;
  /** The push that triggered this check suite. */
  push?: Maybe<gh_Push>;
  /** The repository associated with this check suite. */
  repository: gh_Repository;
  /** The HTTP path for this check suite */
  resourcePath: Scalars['gh_URI']['output'];
  /** The status of this check suite. */
  status: gh_CheckStatusState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this check suite */
  url: Scalars['gh_URI']['output'];
  /** The workflow run associated with this check suite. */
  workflowRun?: Maybe<gh_WorkflowRun>;
};


/** A check suite. */
export type gh_CheckSuitecheckRunsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<gh_CheckRunFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A check suite. */
export type gh_CheckSuitematchingPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueOrder>;
  states?: InputMaybe<Array<gh_PullRequestState>>;
};

/** The auto-trigger preferences that are available for check suites. */
export type gh_CheckSuiteAutoTriggerPreference = {
  /** The node ID of the application that owns the check suite. */
  appId: Scalars['ID']['input'];
  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */
  setting: Scalars['Boolean']['input'];
};

/** The connection type for CheckSuite. */
export type gh_CheckSuiteConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CheckSuiteEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_CheckSuite>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_CheckSuiteEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_CheckSuite>;
};

/** The filters that are available when fetching check suites. */
export type gh_CheckSuiteFilter = {
  /** Filters the check suites created by this application ID. */
  appId?: InputMaybe<Scalars['Int']['input']>;
  /** Filters the check suites by this name. */
  checkName?: InputMaybe<Scalars['String']['input']>;
};

/** An object which can have its data claimed or claim data from another. */
export type gh_Claimable = gh_Mannequin | gh_User;

/** Autogenerated input type of ClearLabelsFromLabelable */
export type gh_ClearLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the labelable object to clear the labels from. */
  labelableId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClearLabelsFromLabelable */
export type gh_ClearLabelsFromLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was unlabeled. */
  labelable?: Maybe<gh_Labelable>;
};

/** Autogenerated input type of ClearProjectV2ItemFieldValue */
export type gh_ClearProjectV2ItemFieldValueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the field to be cleared. */
  fieldId: Scalars['ID']['input'];
  /** The ID of the item to be cleared. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClearProjectV2ItemFieldValue */
export type gh_ClearProjectV2ItemFieldValuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated item. */
  projectV2Item?: Maybe<gh_ProjectV2Item>;
};

/** Autogenerated input type of CloneProject */
export type gh_CloneProjectInput = {
  /** The description of the project. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not to clone the source project's workflows. */
  includeWorkflows: Scalars['Boolean']['input'];
  /** The name of the project. */
  name: Scalars['String']['input'];
  /** The visibility of the project, defaults to false (private). */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  /** The source project to clone. */
  sourceId: Scalars['ID']['input'];
  /** The owner ID to create the project under. */
  targetOwnerId: Scalars['ID']['input'];
};

/** Autogenerated return type of CloneProject */
export type gh_CloneProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The id of the JobStatus for populating cloned fields. */
  jobStatusId?: Maybe<Scalars['String']['output']>;
  /** The new cloned project. */
  project?: Maybe<gh_Project>;
};

/** Autogenerated input type of CloneTemplateRepository */
export type gh_CloneTemplateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A short description of the new repository. */
  description?: InputMaybe<Scalars['String']['input']>;
  /**
   * Whether to copy all branches from the template to the new repository. Defaults
   * to copying only the default branch of the template.
   */
  includeAllBranches?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the new repository. */
  name: Scalars['String']['input'];
  /** The ID of the owner for the new repository. */
  ownerId: Scalars['ID']['input'];
  /** The Node ID of the template repository. */
  repositoryId: Scalars['ID']['input'];
  /** Indicates the repository's visibility level. */
  visibility: gh_RepositoryVisibility;
};

/** Autogenerated return type of CloneTemplateRepository */
export type gh_CloneTemplateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new repository. */
  repository?: Maybe<gh_Repository>;
};

/** An object that can be closed */
export type gh_Closable = {
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
};

/** Autogenerated input type of CloseDiscussion */
export type gh_CloseDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the discussion to be closed. */
  discussionId: Scalars['ID']['input'];
  /** The reason why the discussion is being closed. */
  reason?: InputMaybe<gh_DiscussionCloseReason>;
};

/** Autogenerated return type of CloseDiscussion */
export type gh_CloseDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that was closed. */
  discussion?: Maybe<gh_Discussion>;
};

/** Autogenerated input type of CloseIssue */
export type gh_CloseIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue to be closed. */
  issueId: Scalars['ID']['input'];
  /** The reason the issue is to be closed. */
  stateReason?: InputMaybe<gh_IssueClosedStateReason>;
};

/** Autogenerated return type of CloseIssue */
export type gh_CloseIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was closed. */
  issue?: Maybe<gh_Issue>;
};

/** Autogenerated input type of ClosePullRequest */
export type gh_ClosePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to be closed. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClosePullRequest */
export type gh_ClosePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that was closed. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Represents a 'closed' event on any `Closable`. */
export type gh_ClosedEvent = gh_Node & gh_UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Object that was closed. */
  closable: gh_Closable;
  /** Object which triggered the creation of this event. */
  closer?: Maybe<gh_Closer>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ClosedEvent object */
  id: Scalars['ID']['output'];
  /** The HTTP path for this closed event. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The reason the issue state was changed to closed. */
  stateReason?: Maybe<gh_IssueStateReason>;
  /** The HTTP URL for this closed event. */
  url: Scalars['gh_URI']['output'];
};

/** The object which triggered a `ClosedEvent`. */
export type gh_Closer = gh_Commit | gh_PullRequest;

/** The Code of Conduct for a repository */
export type gh_CodeOfConduct = gh_Node & {
  /** The body of the Code of Conduct */
  body?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the CodeOfConduct object */
  id: Scalars['ID']['output'];
  /** The key for the Code of Conduct */
  key: Scalars['String']['output'];
  /** The formal name of the Code of Conduct */
  name: Scalars['String']['output'];
  /** The HTTP path for this Code of Conduct */
  resourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for this Code of Conduct */
  url?: Maybe<Scalars['gh_URI']['output']>;
};

/** Collaborators affiliation level with a subject. */
export type gh_CollaboratorAffiliation =
  /** All collaborators the authenticated user can see. */
  | 'ALL'
  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */
  | 'DIRECT'
  /** All outside collaborators of an organization-owned subject. */
  | 'OUTSIDE';

/** Represents a comment. */
export type gh_Comment = {
  /** The actor who authored the comment. */
  author?: Maybe<gh_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: gh_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** The actor who edited the comment. */
  editor?: Maybe<gh_Actor>;
  /** The Node ID of the Comment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<gh_UserContentEditConnection>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** Represents a comment. */
export type gh_CommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A comment author association with repository. */
export type gh_CommentAuthorAssociation =
  /** Author has been invited to collaborate on the repository. */
  | 'COLLABORATOR'
  /** Author has previously committed to the repository. */
  | 'CONTRIBUTOR'
  /** Author has not previously committed to GitHub. */
  | 'FIRST_TIMER'
  /** Author has not previously committed to the repository. */
  | 'FIRST_TIME_CONTRIBUTOR'
  /** Author is a placeholder for an unclaimed user. */
  | 'MANNEQUIN'
  /** Author is a member of the organization that owns the repository. */
  | 'MEMBER'
  /** Author has no association with the repository. */
  | 'NONE'
  /** Author is the owner of the repository. */
  | 'OWNER';

/** The possible errors that will prevent a user from updating a comment. */
export type gh_CommentCannotUpdateReason =
  /** Unable to create comment because repository is archived. */
  | 'ARCHIVED'
  /** You cannot update this comment */
  | 'DENIED'
  /** You must be the author or have write access to this repository to update this comment. */
  | 'INSUFFICIENT_ACCESS'
  /** Unable to create comment because issue is locked. */
  | 'LOCKED'
  /** You must be logged in to update this comment. */
  | 'LOGIN_REQUIRED'
  /** Repository is under maintenance. */
  | 'MAINTENANCE'
  /** At least one email address must be verified to update this comment. */
  | 'VERIFIED_EMAIL_REQUIRED';

/** Represents a 'comment_deleted' event on a given issue or pull request. */
export type gh_CommentDeletedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The user who authored the deleted comment. */
  deletedCommentAuthor?: Maybe<gh_Actor>;
  /** The Node ID of the CommentDeletedEvent object */
  id: Scalars['ID']['output'];
};

/** Represents a Git commit. */
export type gh_Commit = gh_GitObject & gh_Node & gh_Subscribable & gh_UniformResourceLocatable & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String']['output'];
  /** The number of additions in this commit. */
  additions: Scalars['Int']['output'];
  /**
   * The merged Pull Request that introduced the commit to the repository. If the
   * commit is not present in the default branch, additionally returns open Pull
   * Requests associated with the commit
   */
  associatedPullRequests?: Maybe<gh_PullRequestConnection>;
  /** Authorship details of the commit. */
  author?: Maybe<gh_GitActor>;
  /** Check if the committer and the author match. */
  authoredByCommitter: Scalars['Boolean']['output'];
  /** The datetime when this commit was authored. */
  authoredDate: Scalars['DateTime']['output'];
  /**
   * The list of authors for this commit based on the git author and the Co-authored-by
   * message trailer. The git author will always be first.
   */
  authors: gh_GitActorConnection;
  /** Fetches `git blame` information. */
  blame: gh_Blame;
  /**
   * We recommend using the `changedFilesIfAvailable` field instead of
   * `changedFiles`, as `changedFiles` will cause your request to return an error
   * if GitHub is unable to calculate the number of changed files.
   * @deprecated `changedFiles` will be removed. Use `changedFilesIfAvailable` instead. Removal on 2023-01-01 UTC.
   */
  changedFiles: Scalars['Int']['output'];
  /**
   * The number of changed files in this commit. If GitHub is unable to calculate
   * the number of changed files (for example due to a timeout), this will return
   * `null`. We recommend using this field instead of `changedFiles`.
   */
  changedFilesIfAvailable?: Maybe<Scalars['Int']['output']>;
  /** The check suites associated with a commit. */
  checkSuites?: Maybe<gh_CheckSuiteConnection>;
  /** Comments made on the commit. */
  comments: gh_CommitCommentConnection;
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['gh_URI']['output'];
  /** The datetime when this commit was committed. */
  committedDate: Scalars['DateTime']['output'];
  /** Check if committed via GitHub web UI. */
  committedViaWeb: Scalars['Boolean']['output'];
  /** Committer details of the commit. */
  committer?: Maybe<gh_GitActor>;
  /** The number of deletions in this commit. */
  deletions: Scalars['Int']['output'];
  /** The deployments associated with a commit. */
  deployments?: Maybe<gh_DeploymentConnection>;
  /** The tree entry representing the file located at the given path. */
  file?: Maybe<gh_TreeEntry>;
  /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */
  history: gh_CommitHistoryConnection;
  /** The Node ID of the Commit object */
  id: Scalars['ID']['output'];
  /** The Git commit message */
  message: Scalars['String']['output'];
  /** The Git commit message body */
  messageBody: Scalars['String']['output'];
  /** The commit message body rendered to HTML. */
  messageBodyHTML: Scalars['gh_HTML']['output'];
  /** The Git commit message headline */
  messageHeadline: Scalars['String']['output'];
  /** The commit message headline rendered to HTML. */
  messageHeadlineHTML: Scalars['gh_HTML']['output'];
  /** The Git object ID */
  oid: Scalars['gh_GitObjectID']['output'];
  /** The organization this commit was made on behalf of. */
  onBehalfOf?: Maybe<gh_Organization>;
  /** The parents of a commit. */
  parents: gh_CommitConnection;
  /**
   * The datetime when this commit was pushed.
   * @deprecated `pushedDate` is no longer supported. Removal on 2023-07-01 UTC.
   */
  pushedDate?: Maybe<Scalars['DateTime']['output']>;
  /** The Repository this commit belongs to */
  repository: gh_Repository;
  /** The HTTP path for this commit */
  resourcePath: Scalars['gh_URI']['output'];
  /** Commit signing information, if present. */
  signature?: Maybe<gh_GitSignature>;
  /** Status information for this commit */
  status?: Maybe<gh_Status>;
  /** Check and Status rollup information for this commit. */
  statusCheckRollup?: Maybe<gh_StatusCheckRollup>;
  /** Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file. */
  submodules: gh_SubmoduleConnection;
  /**
   * Returns a URL to download a tarball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
   */
  tarballUrl: Scalars['gh_URI']['output'];
  /** Commit's root Tree */
  tree: gh_Tree;
  /** The HTTP path for the tree of this commit */
  treeResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for the tree of this commit */
  treeUrl: Scalars['gh_URI']['output'];
  /** The HTTP URL for this commit */
  url: Scalars['gh_URI']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<gh_SubscriptionState>;
  /**
   * Returns a URL to download a zipball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
   */
  zipballUrl: Scalars['gh_URI']['output'];
};


/** Represents a Git commit. */
export type gh_CommitassociatedPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_PullRequestOrder>;
};


/** Represents a Git commit. */
export type gh_CommitauthorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a Git commit. */
export type gh_CommitblameArgs = {
  path: Scalars['String']['input'];
};


/** Represents a Git commit. */
export type gh_CommitcheckSuitesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<gh_CheckSuiteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a Git commit. */
export type gh_CommitcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a Git commit. */
export type gh_CommitdeploymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  environments?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_DeploymentOrder>;
};


/** Represents a Git commit. */
export type gh_CommitfileArgs = {
  path: Scalars['String']['input'];
};


/** Represents a Git commit. */
export type gh_CommithistoryArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<gh_CommitAuthor>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  since?: InputMaybe<Scalars['gh_GitTimestamp']['input']>;
  until?: InputMaybe<Scalars['gh_GitTimestamp']['input']>;
};


/** Represents a Git commit. */
export type gh_CommitparentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a Git commit. */
export type gh_CommitsubmodulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Specifies an author for filtering Git commits. */
export type gh_CommitAuthor = {
  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
  emails?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * ID of a User to filter by. If non-null, only commits authored by this user
   * will be returned. This field takes precedence over emails.
   */
  id?: InputMaybe<Scalars['ID']['input']>;
};

/** Parameters to be used for the commit_author_email_pattern rule */
export type gh_CommitAuthorEmailPatternParameters = {
  /** How this rule will appear to users. */
  name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  operator: Scalars['String']['output'];
  /** The pattern to match with. */
  pattern: Scalars['String']['output'];
};

/** Parameters to be used for the commit_author_email_pattern rule */
export type gh_CommitAuthorEmailPatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/** Represents a comment on a given Commit. */
export type gh_CommitComment = gh_Comment & gh_Deletable & gh_Minimizable & gh_Node & gh_Reactable & gh_RepositoryNode & gh_Updatable & gh_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<gh_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: gh_CommentAuthorAssociation;
  /** Identifies the comment body. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the commit associated with the comment, if the commit exists. */
  commit?: Maybe<gh_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<gh_Actor>;
  /** The Node ID of the CommitComment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies the file path associated with the comment. */
  path?: Maybe<Scalars['String']['output']>;
  /** Identifies the line position associated with the comment. */
  position?: Maybe<Scalars['Int']['output']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: gh_ReactionConnection;
  /** The repository associated with this node. */
  repository: gh_Repository;
  /** The HTTP path permalink for this commit comment. */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL permalink for this commit comment. */
  url: Scalars['gh_URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<gh_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<gh_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** Represents a comment on a given Commit. */
export type gh_CommitCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<gh_ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ReactionOrder>;
};


/** Represents a comment on a given Commit. */
export type gh_CommitCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for CommitComment. */
export type gh_CommitCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CommitCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_CommitComment>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_CommitCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_CommitComment>;
};

/** A thread of comments on a commit. */
export type gh_CommitCommentThread = gh_Node & gh_RepositoryNode & {
  /** The comments that exist in this thread. */
  comments: gh_CommitCommentConnection;
  /** The commit the comments were made on. */
  commit?: Maybe<gh_Commit>;
  /** The Node ID of the CommitCommentThread object */
  id: Scalars['ID']['output'];
  /** The file the comments were made on. */
  path?: Maybe<Scalars['String']['output']>;
  /** The position in the diff for the commit that the comment was made on. */
  position?: Maybe<Scalars['Int']['output']>;
  /** The repository associated with this node. */
  repository: gh_Repository;
};


/** A thread of comments on a commit. */
export type gh_CommitCommentThreadcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Commit. */
export type gh_CommitConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Ordering options for commit contribution connections. */
export type gh_CommitContributionOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field by which to order commit contributions. */
  field: gh_CommitContributionOrderField;
};

/** Properties by which commit contribution connections can be ordered. */
export type gh_CommitContributionOrderField =
  /** Order commit contributions by how many commits they represent. */
  | 'COMMIT_COUNT'
  /** Order commit contributions by when they were made. */
  | 'OCCURRED_AT';

/** This aggregates commits made by a user within one repository. */
export type gh_CommitContributionsByRepository = {
  /** The commit contributions, each representing a day. */
  contributions: gh_CreatedCommitContributionConnection;
  /** The repository in which the commits were made. */
  repository: gh_Repository;
  /** The HTTP path for the user's commits to the repository in this time range. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for the user's commits to the repository in this time range. */
  url: Scalars['gh_URI']['output'];
};


/** This aggregates commits made by a user within one repository. */
export type gh_CommitContributionsByRepositorycontributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_CommitContributionOrder>;
};

/** An edge in a connection. */
export type gh_CommitEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Commit>;
};

/** The connection type for Commit. */
export type gh_CommitHistoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A message to include with a new commit */
export type gh_CommitMessage = {
  /** The body of the message. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** The headline of the message. */
  headline: Scalars['String']['input'];
};

/** Parameters to be used for the commit_message_pattern rule */
export type gh_CommitMessagePatternParameters = {
  /** How this rule will appear to users. */
  name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  operator: Scalars['String']['output'];
  /** The pattern to match with. */
  pattern: Scalars['String']['output'];
};

/** Parameters to be used for the commit_message_pattern rule */
export type gh_CommitMessagePatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/**
 * A git ref for a commit to be appended to.
 *
 * The ref must be a branch, i.e. its fully qualified name must start
 * with `refs/heads/` (although the input is not required to be fully
 * qualified).
 *
 * The Ref may be specified by its global node ID or by the
 * `repositoryNameWithOwner` and `branchName`.
 *
 * ### Examples
 *
 * Specify a branch using a global node ID:
 *
 *     { "id": "MDM6UmVmMTpyZWZzL2hlYWRzL21haW4=" }
 *
 * Specify a branch using `repositoryNameWithOwner` and `branchName`:
 *
 *     {
 *       "repositoryNameWithOwner": "github/graphql-client",
 *       "branchName": "main"
 *     }
 */
export type gh_CommittableBranch = {
  /** The unqualified name of the branch to append the commit to. */
  branchName?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the Ref to be updated. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The nameWithOwner of the repository to commit to. */
  repositoryNameWithOwner?: InputMaybe<Scalars['String']['input']>;
};

/** Parameters to be used for the committer_email_pattern rule */
export type gh_CommitterEmailPatternParameters = {
  /** How this rule will appear to users. */
  name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  operator: Scalars['String']['output'];
  /** The pattern to match with. */
  pattern: Scalars['String']['output'];
};

/** Parameters to be used for the committer_email_pattern rule */
export type gh_CommitterEmailPatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/** Represents a comparison between two commit revisions. */
export type gh_Comparison = gh_Node & {
  /** The number of commits ahead of the base branch. */
  aheadBy: Scalars['Int']['output'];
  /** The base revision of this comparison. */
  baseTarget: gh_GitObject;
  /** The number of commits behind the base branch. */
  behindBy: Scalars['Int']['output'];
  /** The commits which compose this comparison. */
  commits: gh_ComparisonCommitConnection;
  /** The head revision of this comparison. */
  headTarget: gh_GitObject;
  /** The Node ID of the Comparison object */
  id: Scalars['ID']['output'];
  /** The status of this comparison. */
  status: gh_ComparisonStatus;
};


/** Represents a comparison between two commit revisions. */
export type gh_ComparisoncommitsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Commit. */
export type gh_ComparisonCommitConnection = {
  /** The total count of authors and co-authors across all commits. */
  authorCount: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The status of a git comparison between two refs. */
export type gh_ComparisonStatus =
  /** The head ref is ahead of the base ref. */
  | 'AHEAD'
  /** The head ref is behind the base ref. */
  | 'BEHIND'
  /** The head ref is both ahead and behind of the base ref, indicating git history has diverged. */
  | 'DIVERGED'
  /** The head ref and base ref are identical. */
  | 'IDENTICAL';

/** Represents a 'connected' event on a given issue or pull request. */
export type gh_ConnectedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ConnectedEvent object */
  id: Scalars['ID']['output'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean']['output'];
  /** Issue or pull request that made the reference. */
  source: gh_ReferencedSubject;
  /** Issue or pull request which was connected. */
  subject: gh_ReferencedSubject;
};

/** The Contributing Guidelines for a repository. */
export type gh_ContributingGuidelines = {
  /** The body of the Contributing Guidelines. */
  body?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the Contributing Guidelines. */
  resourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the Contributing Guidelines. */
  url?: Maybe<Scalars['gh_URI']['output']>;
};

/** Represents a contribution a user made on GitHub, such as opening an issue. */
export type gh_Contribution = {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['gh_URI']['output'];
  /** The user who made this contribution. */
  user: gh_User;
};

/** A calendar of contributions made on GitHub by a user. */
export type gh_ContributionCalendar = {
  /** A list of hex color codes used in this calendar. The darker the color, the more contributions it represents. */
  colors: Array<Scalars['String']['output']>;
  /** Determine if the color set was chosen because it's currently Halloween. */
  isHalloween: Scalars['Boolean']['output'];
  /** A list of the months of contributions in this calendar. */
  months: Array<gh_ContributionCalendarMonth>;
  /** The count of total contributions in the calendar. */
  totalContributions: Scalars['Int']['output'];
  /** A list of the weeks of contributions in this calendar. */
  weeks: Array<gh_ContributionCalendarWeek>;
};

/** Represents a single day of contributions on GitHub by a user. */
export type gh_ContributionCalendarDay = {
  /** The hex color code that represents how many contributions were made on this day compared to others in the calendar. */
  color: Scalars['String']['output'];
  /** How many contributions were made by the user on this day. */
  contributionCount: Scalars['Int']['output'];
  /**
   * Indication of contributions, relative to other days. Can be used to indicate
   * which color to represent this day on a calendar.
   */
  contributionLevel: gh_ContributionLevel;
  /** The day this square represents. */
  date: Scalars['Date']['output'];
  /** A number representing which day of the week this square represents, e.g., 1 is Monday. */
  weekday: Scalars['Int']['output'];
};

/** A month of contributions in a user's contribution graph. */
export type gh_ContributionCalendarMonth = {
  /** The date of the first day of this month. */
  firstDay: Scalars['Date']['output'];
  /** The name of the month. */
  name: Scalars['String']['output'];
  /** How many weeks started in this month. */
  totalWeeks: Scalars['Int']['output'];
  /** The year the month occurred in. */
  year: Scalars['Int']['output'];
};

/** A week of contributions in a user's contribution graph. */
export type gh_ContributionCalendarWeek = {
  /** The days of contributions in this week. */
  contributionDays: Array<gh_ContributionCalendarDay>;
  /** The date of the earliest square in this week. */
  firstDay: Scalars['Date']['output'];
};

/** Varying levels of contributions from none to many. */
export type gh_ContributionLevel =
  /** Lowest 25% of days of contributions. */
  | 'FIRST_QUARTILE'
  /** Highest 25% of days of contributions. More contributions than the third quartile. */
  | 'FOURTH_QUARTILE'
  /** No contributions occurred. */
  | 'NONE'
  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */
  | 'SECOND_QUARTILE'
  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */
  | 'THIRD_QUARTILE';

/** Ordering options for contribution connections. */
export type gh_ContributionOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollection = {
  /** Commit contributions made by the user, grouped by repository. */
  commitContributionsByRepository: Array<gh_CommitContributionsByRepository>;
  /** A calendar of this user's contributions on GitHub. */
  contributionCalendar: gh_ContributionCalendar;
  /** The years the user has been making contributions with the most recent year first. */
  contributionYears: Array<Scalars['Int']['output']>;
  /** Determine if this collection's time span ends in the current month. */
  doesEndInCurrentMonth: Scalars['Boolean']['output'];
  /**
   * The date of the first restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  earliestRestrictedContributionDate?: Maybe<Scalars['Date']['output']>;
  /** The ending date and time of this collection. */
  endedAt: Scalars['DateTime']['output'];
  /**
   * The first issue the user opened on GitHub. This will be null if that issue was
   * opened outside the collection's time range and ignoreTimeRange is false. If
   * the issue is not visible but the user has opted to show private contributions,
   * a RestrictedContribution will be returned.
   */
  firstIssueContribution?: Maybe<gh_CreatedIssueOrRestrictedContribution>;
  /**
   * The first pull request the user opened on GitHub. This will be null if that
   * pull request was opened outside the collection's time range and
   * ignoreTimeRange is not true. If the pull request is not visible but the user
   * has opted to show private contributions, a RestrictedContribution will be returned.
   */
  firstPullRequestContribution?: Maybe<gh_CreatedPullRequestOrRestrictedContribution>;
  /**
   * The first repository the user created on GitHub. This will be null if that
   * first repository was created outside the collection's time range and
   * ignoreTimeRange is false. If the repository is not visible, then a
   * RestrictedContribution is returned.
   */
  firstRepositoryContribution?: Maybe<gh_CreatedRepositoryOrRestrictedContribution>;
  /** Does the user have any more activity in the timeline that occurred prior to the collection's time range? */
  hasActivityInThePast: Scalars['Boolean']['output'];
  /** Determine if there are any contributions in this collection. */
  hasAnyContributions: Scalars['Boolean']['output'];
  /**
   * Determine if the user made any contributions in this time frame whose details
   * are not visible because they were made in a private repository. Can only be
   * true if the user enabled private contribution counts.
   */
  hasAnyRestrictedContributions: Scalars['Boolean']['output'];
  /** Whether or not the collector's time span is all within the same day. */
  isSingleDay: Scalars['Boolean']['output'];
  /** A list of issues the user opened. */
  issueContributions: gh_CreatedIssueContributionConnection;
  /** Issue contributions made by the user, grouped by repository. */
  issueContributionsByRepository: Array<gh_IssueContributionsByRepository>;
  /**
   * When the user signed up for GitHub. This will be null if that sign up date
   * falls outside the collection's time range and ignoreTimeRange is false.
   */
  joinedGitHubContribution?: Maybe<gh_JoinedGitHubContribution>;
  /**
   * The date of the most recent restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  latestRestrictedContributionDate?: Maybe<Scalars['Date']['output']>;
  /**
   * When this collection's time range does not include any activity from the user, use this
   * to get a different collection from an earlier time range that does have activity.
   */
  mostRecentCollectionWithActivity?: Maybe<gh_ContributionsCollection>;
  /**
   * Returns a different contributions collection from an earlier time range than this one
   * that does not have any contributions.
   */
  mostRecentCollectionWithoutActivity?: Maybe<gh_ContributionsCollection>;
  /**
   * The issue the user opened on GitHub that received the most comments in the specified
   * time frame.
   */
  popularIssueContribution?: Maybe<gh_CreatedIssueContribution>;
  /**
   * The pull request the user opened on GitHub that received the most comments in the
   * specified time frame.
   */
  popularPullRequestContribution?: Maybe<gh_CreatedPullRequestContribution>;
  /** Pull request contributions made by the user. */
  pullRequestContributions: gh_CreatedPullRequestContributionConnection;
  /** Pull request contributions made by the user, grouped by repository. */
  pullRequestContributionsByRepository: Array<gh_PullRequestContributionsByRepository>;
  /**
   * Pull request review contributions made by the user. Returns the most recently
   * submitted review for each PR reviewed by the user.
   */
  pullRequestReviewContributions: gh_CreatedPullRequestReviewContributionConnection;
  /** Pull request review contributions made by the user, grouped by repository. */
  pullRequestReviewContributionsByRepository: Array<gh_PullRequestReviewContributionsByRepository>;
  /** A list of repositories owned by the user that the user created in this time range. */
  repositoryContributions: gh_CreatedRepositoryContributionConnection;
  /**
   * A count of contributions made by the user that the viewer cannot access. Only
   * non-zero when the user has chosen to share their private contribution counts.
   */
  restrictedContributionsCount: Scalars['Int']['output'];
  /** The beginning date and time of this collection. */
  startedAt: Scalars['DateTime']['output'];
  /** How many commits were made by the user in this time span. */
  totalCommitContributions: Scalars['Int']['output'];
  /** How many issues the user opened. */
  totalIssueContributions: Scalars['Int']['output'];
  /** How many pull requests the user opened. */
  totalPullRequestContributions: Scalars['Int']['output'];
  /** How many pull request reviews the user left. */
  totalPullRequestReviewContributions: Scalars['Int']['output'];
  /** How many different repositories the user committed to. */
  totalRepositoriesWithContributedCommits: Scalars['Int']['output'];
  /** How many different repositories the user opened issues in. */
  totalRepositoriesWithContributedIssues: Scalars['Int']['output'];
  /** How many different repositories the user left pull request reviews in. */
  totalRepositoriesWithContributedPullRequestReviews: Scalars['Int']['output'];
  /** How many different repositories the user opened pull requests in. */
  totalRepositoriesWithContributedPullRequests: Scalars['Int']['output'];
  /** How many repositories the user created. */
  totalRepositoryContributions: Scalars['Int']['output'];
  /** The user who made the contributions in this collection. */
  user: gh_User;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollectioncommitContributionsByRepositoryArgs = {
  maxRepositories?: InputMaybe<Scalars['Int']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollectionissueContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollectionissueContributionsByRepositoryArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
  maxRepositories?: InputMaybe<Scalars['Int']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollectionpullRequestContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollectionpullRequestContributionsByRepositoryArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
  maxRepositories?: InputMaybe<Scalars['Int']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollectionpullRequestReviewContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollectionpullRequestReviewContributionsByRepositoryArgs = {
  maxRepositories?: InputMaybe<Scalars['Int']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollectionrepositoryContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollectiontotalIssueContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollectiontotalPullRequestContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollectiontotalRepositoriesWithContributedIssuesArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollectiontotalRepositoriesWithContributedPullRequestsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type gh_ContributionsCollectiontotalRepositoryContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of ConvertProjectCardNoteToIssue */
export type gh_ConvertProjectCardNoteToIssueInput = {
  /** The body of the newly created issue. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ProjectCard ID to convert. */
  projectCardId: Scalars['ID']['input'];
  /** The ID of the repository to create the issue in. */
  repositoryId: Scalars['ID']['input'];
  /** The title of the newly created issue. Defaults to the card's note text. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ConvertProjectCardNoteToIssue */
export type gh_ConvertProjectCardNoteToIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated ProjectCard. */
  projectCard?: Maybe<gh_ProjectCard>;
};

/** Autogenerated input type of ConvertPullRequestToDraft */
export type gh_ConvertPullRequestToDraftInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to convert to draft */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of ConvertPullRequestToDraft */
export type gh_ConvertPullRequestToDraftPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that is now a draft. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Represents a 'convert_to_draft' event on a given pull request. */
export type gh_ConvertToDraftEvent = gh_Node & gh_UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ConvertToDraftEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
  /** The HTTP path for this convert to draft event. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this convert to draft event. */
  url: Scalars['gh_URI']['output'];
};

/** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
export type gh_ConvertedNoteToIssueEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ConvertedNoteToIssueEvent object */
  id: Scalars['ID']['output'];
  /** Project referenced by event. */
  project?: Maybe<gh_Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<gh_ProjectCard>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String']['output'];
};

/** Represents a 'converted_to_discussion' event on a given issue. */
export type gh_ConvertedToDiscussionEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The discussion that the issue was converted into. */
  discussion?: Maybe<gh_Discussion>;
  /** The Node ID of the ConvertedToDiscussionEvent object */
  id: Scalars['ID']['output'];
};

/** Autogenerated input type of CopyProjectV2 */
export type gh_CopyProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Include draft issues in the new project */
  includeDraftIssues?: InputMaybe<Scalars['Boolean']['input']>;
  /** The owner ID of the new project. */
  ownerId: Scalars['ID']['input'];
  /** The ID of the source Project to copy. */
  projectId: Scalars['ID']['input'];
  /** The title of the project. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CopyProjectV2 */
export type gh_CopyProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The copied project. */
  projectV2?: Maybe<gh_ProjectV2>;
};

/** Autogenerated input type of CreateAttributionInvitation */
export type gh_CreateAttributionInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the owner scoping the reattributable data. */
  ownerId: Scalars['ID']['input'];
  /** The Node ID of the account owning the data to reattribute. */
  sourceId: Scalars['ID']['input'];
  /** The Node ID of the account which may claim the data. */
  targetId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateAttributionInvitation */
export type gh_CreateAttributionInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The owner scoping the reattributable data. */
  owner?: Maybe<gh_Organization>;
  /** The account owning the data to reattribute. */
  source?: Maybe<gh_Claimable>;
  /** The account which may claim the data. */
  target?: Maybe<gh_Claimable>;
};

/** Autogenerated input type of CreateBranchProtectionRule */
export type gh_CreateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is branch creation a protected operation. */
  blocksCreations?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */
  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */
  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Can admins override branch protection. */
  isAdminEnforced?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch?: InputMaybe<Scalars['Boolean']['input']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern: Scalars['String']['input'];
  /** A list of User, Team, or App IDs allowed to push to matching branches. */
  pushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The global relay id of the repository in which a new branch protection rule should be created in. */
  repositoryId: Scalars['ID']['input'];
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval?: InputMaybe<Scalars['Boolean']['input']>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']['input']>;
  /** The list of required deployment environments */
  requiredDeploymentEnvironments?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The list of required status checks */
  requiredStatusChecks?: InputMaybe<Array<gh_RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are successful deployments required before merging. */
  requiresDeployments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of CreateBranchProtectionRule */
export type gh_CreateBranchProtectionRulePayload = {
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<gh_BranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateCheckRun */
export type gh_CreateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: InputMaybe<Array<gh_CheckRunAction>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The time that the check run finished. */
  completedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The final conclusion of the check. */
  conclusion?: InputMaybe<gh_CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: InputMaybe<Scalars['gh_URI']['input']>;
  /** A reference for the run on the integrator's system. */
  externalId?: InputMaybe<Scalars['String']['input']>;
  /** The SHA of the head commit. */
  headSha: Scalars['gh_GitObjectID']['input'];
  /** The name of the check. */
  name: Scalars['String']['input'];
  /** Descriptive details about the run. */
  output?: InputMaybe<gh_CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** The time that the check run began. */
  startedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The current status. */
  status?: InputMaybe<gh_RequestableCheckStatusState>;
};

/** Autogenerated return type of CreateCheckRun */
export type gh_CreateCheckRunPayload = {
  /** The newly created check run. */
  checkRun?: Maybe<gh_CheckRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateCheckSuite */
export type gh_CreateCheckSuiteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The SHA of the head commit. */
  headSha: Scalars['gh_GitObjectID']['input'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateCheckSuite */
export type gh_CreateCheckSuitePayload = {
  /** The newly created check suite. */
  checkSuite?: Maybe<gh_CheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateCommitOnBranch */
export type gh_CreateCommitOnBranchInput = {
  /** The Ref to be updated.  Must be a branch. */
  branch: gh_CommittableBranch;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The git commit oid expected at the head of the branch prior to the commit */
  expectedHeadOid: Scalars['gh_GitObjectID']['input'];
  /** A description of changes to files in this commit. */
  fileChanges?: InputMaybe<gh_FileChanges>;
  /** The commit message the be included with the commit. */
  message: gh_CommitMessage;
};

/** Autogenerated return type of CreateCommitOnBranch */
export type gh_CreateCommitOnBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new commit. */
  commit?: Maybe<gh_Commit>;
  /** The ref which has been updated to point to the new commit. */
  ref?: Maybe<gh_Ref>;
};

/** Autogenerated input type of CreateDeployment */
export type gh_CreateDeploymentInput = {
  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */
  autoMerge?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Short description of the deployment. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name for the target deployment environment. */
  environment?: InputMaybe<Scalars['String']['input']>;
  /** JSON payload with extra information about the deployment. */
  payload?: InputMaybe<Scalars['String']['input']>;
  /** The node ID of the ref to be deployed. */
  refId: Scalars['ID']['input'];
  /** The node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /**
   * The status contexts to verify against commit status checks. To bypass required
   * contexts, pass an empty array. Defaults to all unique contexts.
   */
  requiredContexts?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Specifies a task to execute. */
  task?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateDeployment */
export type gh_CreateDeploymentPayload = {
  /** True if the default branch has been auto-merged into the deployment ref. */
  autoMerged?: Maybe<Scalars['Boolean']['output']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new deployment. */
  deployment?: Maybe<gh_Deployment>;
};

/** Autogenerated input type of CreateDeploymentStatus */
export type gh_CreateDeploymentStatusInput = {
  /**
   * Adds a new inactive status to all non-transient, non-production environment
   * deployments with the same repository and environment name as the created
   * status's deployment.
   */
  autoInactive?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The node ID of the deployment. */
  deploymentId: Scalars['ID']['input'];
  /** A short description of the status. Maximum length of 140 characters. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */
  environment?: InputMaybe<Scalars['String']['input']>;
  /** Sets the URL for accessing your environment. */
  environmentUrl?: InputMaybe<Scalars['String']['input']>;
  /**
   * The log URL to associate with this status.       This URL should contain
   * output to keep the user updated while the task is running       or serve as
   * historical information for what happened in the deployment.
   */
  logUrl?: InputMaybe<Scalars['String']['input']>;
  /** The state of the deployment. */
  state: gh_DeploymentStatusState;
};

/** Autogenerated return type of CreateDeploymentStatus */
export type gh_CreateDeploymentStatusPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new deployment status. */
  deploymentStatus?: Maybe<gh_DeploymentStatus>;
};

/** Autogenerated input type of CreateDiscussion */
export type gh_CreateDiscussionInput = {
  /** The body of the discussion. */
  body: Scalars['String']['input'];
  /** The id of the discussion category to associate with this discussion. */
  categoryId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the repository on which to create the discussion. */
  repositoryId: Scalars['ID']['input'];
  /** The title of the discussion. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateDiscussion */
export type gh_CreateDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that was just created. */
  discussion?: Maybe<gh_Discussion>;
};

/** Autogenerated input type of CreateEnterpriseOrganization */
export type gh_CreateEnterpriseOrganizationInput = {
  /** The logins for the administrators of the new organization. */
  adminLogins: Array<Scalars['String']['input']>;
  /** The email used for sending billing receipts. */
  billingEmail: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise owning the new organization. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of the new organization. */
  login: Scalars['String']['input'];
  /** The profile name of the new organization. */
  profileName: Scalars['String']['input'];
};

/** Autogenerated return type of CreateEnterpriseOrganization */
export type gh_CreateEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise that owns the created organization. */
  enterprise?: Maybe<gh_Enterprise>;
  /** The organization that was created. */
  organization?: Maybe<gh_Organization>;
};

/** Autogenerated input type of CreateEnvironment */
export type gh_CreateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the environment. */
  name: Scalars['String']['input'];
  /** The node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateEnvironment */
export type gh_CreateEnvironmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new or existing environment. */
  environment?: Maybe<gh_Environment>;
};

/** Autogenerated input type of CreateIpAllowListEntry */
export type gh_CreateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean']['input'];
  /** An optional name for the IP allow list entry. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner for which to create the new IP allow list entry. */
  ownerId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateIpAllowListEntry */
export type gh_CreateIpAllowListEntryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list entry that was created. */
  ipAllowListEntry?: Maybe<gh_IpAllowListEntry>;
};

/** Autogenerated input type of CreateIssue */
export type gh_CreateIssueInput = {
  /** The Node ID for the user assignee for this issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The body for the issue description. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */
  issueTemplate?: InputMaybe<Scalars['String']['input']>;
  /** An array of Node IDs of labels for this issue. */
  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: InputMaybe<Scalars['ID']['input']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** The title for the issue. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateIssue */
export type gh_CreateIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new issue. */
  issue?: Maybe<gh_Issue>;
};

/** Autogenerated input type of CreateLabel */
export type gh_CreateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A 6 character hex code, without the leading #, identifying the color of the label. */
  color: Scalars['String']['input'];
  /** A brief description of the label, such as its purpose. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the label. */
  name: Scalars['String']['input'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateLabel */
export type gh_CreateLabelPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new label. */
  label?: Maybe<gh_Label>;
};

/** Autogenerated input type of CreateLinkedBranch */
export type gh_CreateLinkedBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue to link to. */
  issueId: Scalars['ID']['input'];
  /** The name of the new branch. Defaults to issue number and title. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The commit SHA to base the new branch on. */
  oid: Scalars['gh_GitObjectID']['input'];
  /** ID of the repository to create the branch in. Defaults to the issue repository. */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of CreateLinkedBranch */
export type gh_CreateLinkedBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was linked to. */
  issue?: Maybe<gh_Issue>;
  /** The new branch issue reference. */
  linkedBranch?: Maybe<gh_LinkedBranch>;
};

/** Autogenerated input type of CreateMigrationSource */
export type gh_CreateMigrationSourceInput = {
  /** The migration source access token. */
  accessToken?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The GitHub personal access token of the user importing to the target repository. */
  githubPat?: InputMaybe<Scalars['String']['input']>;
  /** The migration source name. */
  name: Scalars['String']['input'];
  /** The ID of the organization that will own the migration source. */
  ownerId: Scalars['ID']['input'];
  /** The migration source type. */
  type: gh_MigrationSourceType;
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateMigrationSource */
export type gh_CreateMigrationSourcePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The created migration source. */
  migrationSource?: Maybe<gh_MigrationSource>;
};

/** Autogenerated input type of CreateProject */
export type gh_CreateProjectInput = {
  /** The description of project. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of project. */
  name: Scalars['String']['input'];
  /** The owner ID to create the project under. */
  ownerId: Scalars['ID']['input'];
  /** A list of repository IDs to create as linked repositories for the project */
  repositoryIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The name of the GitHub-provided template. */
  template?: InputMaybe<gh_ProjectTemplate>;
};

/** Autogenerated return type of CreateProject */
export type gh_CreateProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new project. */
  project?: Maybe<gh_Project>;
};

/** Autogenerated input type of CreateProjectV2Field */
export type gh_CreateProjectV2FieldInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The data type of the field. */
  dataType: gh_ProjectV2CustomFieldType;
  /** The name of the field. */
  name: Scalars['String']['input'];
  /** The ID of the Project to create the field in. */
  projectId: Scalars['ID']['input'];
  /** Options for a single select field. At least one value is required if data_type is SINGLE_SELECT */
  singleSelectOptions?: InputMaybe<Array<gh_ProjectV2SingleSelectFieldOptionInput>>;
};

/** Autogenerated return type of CreateProjectV2Field */
export type gh_CreateProjectV2FieldPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new field. */
  projectV2Field?: Maybe<gh_ProjectV2FieldConfiguration>;
};

/** Autogenerated input type of CreateProjectV2 */
export type gh_CreateProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The owner ID to create the project under. */
  ownerId: Scalars['ID']['input'];
  /** The repository to link the project to. */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  /** The team to link the project to. The team will be granted read permissions. */
  teamId?: InputMaybe<Scalars['ID']['input']>;
  /** The title of the project. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateProjectV2 */
export type gh_CreateProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new project. */
  projectV2?: Maybe<gh_ProjectV2>;
};

/** Autogenerated input type of CreatePullRequest */
export type gh_CreatePullRequestInput = {
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository. You cannot update the base branch on a pull request to point
   * to another repository.
   */
  baseRefName: Scalars['String']['input'];
  /** The contents of the pull request. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether this pull request should be a draft. */
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The name of the branch where your changes are implemented. For cross-repository pull requests
   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.
   */
  headRefName: Scalars['String']['input'];
  /** The Node ID of the head repository. */
  headRepositoryId?: InputMaybe<Scalars['ID']['input']>;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** The title of the pull request. */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CreatePullRequest */
export type gh_CreatePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new pull request. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Autogenerated input type of CreateRef */
export type gh_CreateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */
  name: Scalars['String']['input'];
  /** The GitObjectID that the new Ref shall target. Must point to a commit. */
  oid: Scalars['gh_GitObjectID']['input'];
  /** The Node ID of the Repository to create the Ref in. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateRef */
export type gh_CreateRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created ref. */
  ref?: Maybe<gh_Ref>;
};

/** Autogenerated input type of CreateRepository */
export type gh_CreateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A short description of the new repository. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The URL for a web page about this repository. */
  homepageUrl?: InputMaybe<Scalars['gh_URI']['input']>;
  /** The name of the new repository. */
  name: Scalars['String']['input'];
  /** The ID of the owner for the new repository. */
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * When an organization is specified as the owner, this ID identifies the team
   * that should be granted access to the new repository.
   */
  teamId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates the repository's visibility level. */
  visibility: gh_RepositoryVisibility;
};

/** Autogenerated return type of CreateRepository */
export type gh_CreateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new repository. */
  repository?: Maybe<gh_Repository>;
};

/** Autogenerated input type of CreateRepositoryRuleset */
export type gh_CreateRepositoryRulesetInput = {
  /** A list of actors that are allowed to bypass rules in this ruleset. */
  bypassActors?: InputMaybe<Array<gh_RepositoryRulesetBypassActorInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The set of conditions for this ruleset */
  conditions: gh_RepositoryRuleConditionsInput;
  /** The enforcement level for this ruleset */
  enforcement: gh_RuleEnforcement;
  /** The name of the ruleset. */
  name: Scalars['String']['input'];
  /** The list of rules for this ruleset */
  rules?: InputMaybe<Array<gh_RepositoryRuleInput>>;
  /** The global relay id of the source in which a new ruleset should be created in. */
  sourceId: Scalars['ID']['input'];
  /** The target of the ruleset. */
  target?: InputMaybe<gh_RepositoryRulesetTarget>;
};

/** Autogenerated return type of CreateRepositoryRuleset */
export type gh_CreateRepositoryRulesetPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created Ruleset. */
  ruleset?: Maybe<gh_RepositoryRuleset>;
};

/** Autogenerated input type of CreateSponsorsListing */
export type gh_CreateSponsorsListingInput = {
  /**
   * The country or region where the sponsorable's bank account is located.
   * Required if fiscalHostLogin is not specified, ignored when fiscalHostLogin is specified.
   */
  billingCountryOrRegionCode?: InputMaybe<gh_SponsorsCountryOrRegionCode>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The email address we should use to contact you about the GitHub Sponsors
   * profile being created. This will not be shared publicly. Must be a verified
   * email address already on your GitHub account. Only relevant when the
   * sponsorable is yourself. Defaults to your primary email address on file if omitted.
   */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /**
   * The username of the supported fiscal host's GitHub organization, if you want
   * to receive sponsorship payouts through a fiscal host rather than directly to a
   * bank account. For example, 'Open-Source-Collective' for Open Source Collective
   * or 'numfocus' for numFOCUS. Case insensitive. See https://docs.github.com/sponsors/receiving-sponsorships-through-github-sponsors/using-a-fiscal-host-to-receive-github-sponsors-payouts
   * for more information.
   */
  fiscalHostLogin?: InputMaybe<Scalars['String']['input']>;
  /**
   * The URL for your profile page on the fiscal host's website, e.g.,
   * https://opencollective.com/babel or https://numfocus.org/project/bokeh.
   * Required if fiscalHostLogin is specified.
   */
  fiscallyHostedProjectProfileUrl?: InputMaybe<Scalars['String']['input']>;
  /**
   * Provide an introduction to serve as the main focus that appears on your GitHub
   * Sponsors profile. It's a great opportunity to help potential sponsors learn
   * more about you, your work, and why their sponsorship is important to you.
   * GitHub-flavored Markdown is supported.
   */
  fullDescription?: InputMaybe<Scalars['String']['input']>;
  /**
   * The country or region where the sponsorable resides. This is for tax purposes.
   * Required if the sponsorable is yourself, ignored when sponsorableLogin
   * specifies an organization.
   */
  residenceCountryOrRegionCode?: InputMaybe<gh_SponsorsCountryOrRegionCode>;
  /**
   * The username of the organization to create a GitHub Sponsors profile for, if
   * desired. Defaults to creating a GitHub Sponsors profile for the authenticated
   * user if omitted.
   */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateSponsorsListing */
export type gh_CreateSponsorsListingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new GitHub Sponsors profile. */
  sponsorsListing?: Maybe<gh_SponsorsListing>;
};

/** Autogenerated input type of CreateSponsorsTier */
export type gh_CreateSponsorsTierInput = {
  /** The value of the new tier in US dollars. Valid values: 1-12000. */
  amount: Scalars['Int']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A description of what this tier is, what perks sponsors might receive, what a sponsorship at this tier means for you, etc. */
  description: Scalars['String']['input'];
  /** Whether sponsorships using this tier should happen monthly/yearly or just once. */
  isRecurring?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether to make the tier available immediately for sponsors to choose.
   * Defaults to creating a draft tier that will not be publicly visible.
   */
  publish?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Optional ID of the private repository that sponsors at this tier should gain
   * read-only access to. Must be owned by an organization.
   */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Optional name of the private repository that sponsors at this tier should gain
   * read-only access to. Must be owned by an organization. Necessary if
   * repositoryOwnerLogin is given. Will be ignored if repositoryId is given.
   */
  repositoryName?: InputMaybe<Scalars['String']['input']>;
  /**
   * Optional login of the organization owner of the private repository that
   * sponsors at this tier should gain read-only access to. Necessary if
   * repositoryName is given. Will be ignored if repositoryId is given.
   */
  repositoryOwnerLogin?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the user or organization who owns the GitHub Sponsors profile.
   * Defaults to the current user if omitted and sponsorableLogin is not given.
   */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who owns the GitHub Sponsors profile.
   * Defaults to the current user if omitted and sponsorableId is not given.
   */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
  /** Optional message new sponsors at this tier will receive. */
  welcomeMessage?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateSponsorsTier */
export type gh_CreateSponsorsTierPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new tier. */
  sponsorsTier?: Maybe<gh_SponsorsTier>;
};

/** Autogenerated input type of CreateSponsorship */
export type gh_CreateSponsorshipInput = {
  /** The amount to pay to the sponsorable in US dollars. Required if a tierId is not specified. Valid values: 1-12000. */
  amount?: InputMaybe<Scalars['Int']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether the sponsorship should happen monthly/yearly or just this one time. Required if a tierId is not specified. */
  isRecurring?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  privacyLevel?: InputMaybe<gh_SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of one of sponsorable's existing tiers to sponsor at. Required if amount is not specified. */
  tierId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of CreateSponsorship */
export type gh_CreateSponsorshipPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The sponsorship that was started. */
  sponsorship?: Maybe<gh_Sponsorship>;
};

/** Autogenerated input type of CreateSponsorships */
export type gh_CreateSponsorshipsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorables. Public visibility still does not reveal the dollar value of
   * the sponsorship.
   */
  privacyLevel?: InputMaybe<gh_SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorables. */
  receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;
  /** The username of the user or organization who is acting as the sponsor, paying for the sponsorships. */
  sponsorLogin: Scalars['String']['input'];
  /** The list of maintainers to sponsor and for how much apiece. */
  sponsorships: Array<gh_BulkSponsorship>;
};

/** Autogenerated return type of CreateSponsorships */
export type gh_CreateSponsorshipsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The users and organizations who received a sponsorship. */
  sponsorables?: Maybe<Array<gh_Sponsorable>>;
};

/** Autogenerated input type of CreateTeamDiscussionComment */
export type gh_CreateTeamDiscussionCommentInput = {
  /**
   * The content of the comment. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `body` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the discussion to which the comment belongs. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `discussionId` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  discussionId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of CreateTeamDiscussionComment */
export type gh_CreateTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * The new comment.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  teamDiscussionComment?: Maybe<gh_TeamDiscussionComment>;
};

/** Autogenerated input type of CreateTeamDiscussion */
export type gh_CreateTeamDiscussionInput = {
  /**
   * The content of the discussion. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `body` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * If true, restricts the visibility of this discussion to team members and
   * organization owners. If false or not specified, allows any organization member
   * to view this discussion.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `private` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  private?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ID of the team to which the discussion belongs. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `teamId` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  teamId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The title of the discussion. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `title` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateTeamDiscussion */
export type gh_CreateTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * The new discussion.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  teamDiscussion?: Maybe<gh_TeamDiscussion>;
};

/** Autogenerated input type of CreateUserList */
export type gh_CreateUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A description of the list */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not the list is private */
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the new list */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of CreateUserList */
export type gh_CreateUserListPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The list that was just created */
  list?: Maybe<gh_UserList>;
  /** The user who created the list */
  viewer?: Maybe<gh_User>;
};

/** Represents the contribution a user made by committing to a repository. */
export type gh_CreatedCommitContribution = gh_Contribution & {
  /** How many commits were made on this day to this repository by the user. */
  commitCount: Scalars['Int']['output'];
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The repository the user made a commit in. */
  repository: gh_Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['gh_URI']['output'];
  /** The user who made this contribution. */
  user: gh_User;
};

/** The connection type for CreatedCommitContribution. */
export type gh_CreatedCommitContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CreatedCommitContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_CreatedCommitContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of commits across days and repositories in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_CreatedCommitContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_CreatedCommitContribution>;
};

/** Represents the contribution a user made on GitHub by opening an issue. */
export type gh_CreatedIssueContribution = gh_Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** The issue that was opened. */
  issue: gh_Issue;
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['gh_URI']['output'];
  /** The user who made this contribution. */
  user: gh_User;
};

/** The connection type for CreatedIssueContribution. */
export type gh_CreatedIssueContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CreatedIssueContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_CreatedIssueContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_CreatedIssueContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_CreatedIssueContribution>;
};

/** Represents either a issue the viewer can access or a restricted contribution. */
export type gh_CreatedIssueOrRestrictedContribution = gh_CreatedIssueContribution | gh_RestrictedContribution;

/** Represents the contribution a user made on GitHub by opening a pull request. */
export type gh_CreatedPullRequestContribution = gh_Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The pull request that was opened. */
  pullRequest: gh_PullRequest;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['gh_URI']['output'];
  /** The user who made this contribution. */
  user: gh_User;
};

/** The connection type for CreatedPullRequestContribution. */
export type gh_CreatedPullRequestContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CreatedPullRequestContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_CreatedPullRequestContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_CreatedPullRequestContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_CreatedPullRequestContribution>;
};

/** Represents either a pull request the viewer can access or a restricted contribution. */
export type gh_CreatedPullRequestOrRestrictedContribution = gh_CreatedPullRequestContribution | gh_RestrictedContribution;

/** Represents the contribution a user made by leaving a review on a pull request. */
export type gh_CreatedPullRequestReviewContribution = gh_Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The pull request the user reviewed. */
  pullRequest: gh_PullRequest;
  /** The review the user left on the pull request. */
  pullRequestReview: gh_PullRequestReview;
  /** The repository containing the pull request that the user reviewed. */
  repository: gh_Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['gh_URI']['output'];
  /** The user who made this contribution. */
  user: gh_User;
};

/** The connection type for CreatedPullRequestReviewContribution. */
export type gh_CreatedPullRequestReviewContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CreatedPullRequestReviewContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_CreatedPullRequestReviewContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_CreatedPullRequestReviewContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_CreatedPullRequestReviewContribution>;
};

/** Represents the contribution a user made on GitHub by creating a repository. */
export type gh_CreatedRepositoryContribution = gh_Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The repository that was created. */
  repository: gh_Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['gh_URI']['output'];
  /** The user who made this contribution. */
  user: gh_User;
};

/** The connection type for CreatedRepositoryContribution. */
export type gh_CreatedRepositoryContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_CreatedRepositoryContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_CreatedRepositoryContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_CreatedRepositoryContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_CreatedRepositoryContribution>;
};

/** Represents either a repository the viewer can access or a restricted contribution. */
export type gh_CreatedRepositoryOrRestrictedContribution = gh_CreatedRepositoryContribution | gh_RestrictedContribution;

/** Represents a mention made by one issue or pull request to another. */
export type gh_CrossReferencedEvent = gh_Node & gh_UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the CrossReferencedEvent object */
  id: Scalars['ID']['output'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean']['output'];
  /** Identifies when the reference was made. */
  referencedAt: Scalars['DateTime']['output'];
  /** The HTTP path for this pull request. */
  resourcePath: Scalars['gh_URI']['output'];
  /** Issue or pull request that made the reference. */
  source: gh_ReferencedSubject;
  /** Issue or pull request to which the reference was made. */
  target: gh_ReferencedSubject;
  /** The HTTP URL for this pull request. */
  url: Scalars['gh_URI']['output'];
  /** Checks if the target will be closed when the source is merged. */
  willCloseTarget: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeclineTopicSuggestion */
export type gh_DeclineTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The name of the suggested topic.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `name` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  name?: InputMaybe<Scalars['String']['input']>;
  /**
   * The reason why the suggested topic is declined.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `reason` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  reason?: InputMaybe<gh_TopicSuggestionDeclineReason>;
  /**
   * The Node ID of the repository.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `repositoryId` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of DeclineTopicSuggestion */
export type gh_DeclineTopicSuggestionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * The declined topic.
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  topic?: Maybe<gh_Topic>;
};

/** The possible base permissions for repositories. */
export type gh_DefaultRepositoryPermissionField =
  /** Can read, write, and administrate repos by default */
  | 'ADMIN'
  /** No access */
  | 'NONE'
  /** Can read repos by default */
  | 'READ'
  /** Can read and write repos by default */
  | 'WRITE';

/** Entities that can be deleted. */
export type gh_Deletable = {
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeleteBranchProtectionRule */
export type gh_DeleteBranchProtectionRuleInput = {
  /** The global relay id of the branch protection rule to be deleted. */
  branchProtectionRuleId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DeleteBranchProtectionRule */
export type gh_DeleteBranchProtectionRulePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteDeployment */
export type gh_DeleteDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the deployment to be deleted. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteDeployment */
export type gh_DeleteDeploymentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteDiscussionComment */
export type gh_DeleteDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node id of the discussion comment to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteDiscussionComment */
export type gh_DeleteDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion comment that was just deleted. */
  comment?: Maybe<gh_DiscussionComment>;
};

/** Autogenerated input type of DeleteDiscussion */
export type gh_DeleteDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the discussion to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteDiscussion */
export type gh_DeleteDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that was just deleted. */
  discussion?: Maybe<gh_Discussion>;
};

/** Autogenerated input type of DeleteEnvironment */
export type gh_DeleteEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the environment to be deleted. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteEnvironment */
export type gh_DeleteEnvironmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteIpAllowListEntry */
export type gh_DeleteIpAllowListEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the IP allow list entry to delete. */
  ipAllowListEntryId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteIpAllowListEntry */
export type gh_DeleteIpAllowListEntryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list entry that was deleted. */
  ipAllowListEntry?: Maybe<gh_IpAllowListEntry>;
};

/** Autogenerated input type of DeleteIssueComment */
export type gh_DeleteIssueCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteIssueComment */
export type gh_DeleteIssueCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteIssue */
export type gh_DeleteIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the issue to delete. */
  issueId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteIssue */
export type gh_DeleteIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository the issue belonged to */
  repository?: Maybe<gh_Repository>;
};

/** Autogenerated input type of DeleteLabel */
export type gh_DeleteLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the label to be deleted. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteLabel */
export type gh_DeleteLabelPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteLinkedBranch */
export type gh_DeleteLinkedBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the linked branch */
  linkedBranchId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteLinkedBranch */
export type gh_DeleteLinkedBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue the linked branch was unlinked from. */
  issue?: Maybe<gh_Issue>;
};

/** Autogenerated input type of DeletePackageVersion */
export type gh_DeletePackageVersionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the package version to be deleted. */
  packageVersionId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeletePackageVersion */
export type gh_DeletePackageVersionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Whether or not the operation succeeded. */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Autogenerated input type of DeleteProjectCard */
export type gh_DeleteProjectCardInput = {
  /** The id of the card to delete. */
  cardId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DeleteProjectCard */
export type gh_DeleteProjectCardPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The column the deleted card was in. */
  column?: Maybe<gh_ProjectColumn>;
  /** The deleted card ID. */
  deletedCardId?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DeleteProjectColumn */
export type gh_DeleteProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the column to delete. */
  columnId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectColumn */
export type gh_DeleteProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The deleted column ID. */
  deletedColumnId?: Maybe<Scalars['ID']['output']>;
  /** The project the deleted column was in. */
  project?: Maybe<gh_Project>;
};

/** Autogenerated input type of DeleteProject */
export type gh_DeleteProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Project ID to update. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProject */
export type gh_DeleteProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository or organization the project was removed from. */
  owner?: Maybe<gh_ProjectOwner>;
};

/** Autogenerated input type of DeleteProjectV2Field */
export type gh_DeleteProjectV2FieldInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the field to delete. */
  fieldId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectV2Field */
export type gh_DeleteProjectV2FieldPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The deleted field. */
  projectV2Field?: Maybe<gh_ProjectV2FieldConfiguration>;
};

/** Autogenerated input type of DeleteProjectV2 */
export type gh_DeleteProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to delete. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteProjectV2Item */
export type gh_DeleteProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the item to be removed. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project from which the item should be removed. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectV2Item */
export type gh_DeleteProjectV2ItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The ID of the deleted item. */
  deletedItemId?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated return type of DeleteProjectV2 */
export type gh_DeleteProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The deleted Project. */
  projectV2?: Maybe<gh_ProjectV2>;
};

/** Autogenerated input type of DeleteProjectV2Workflow */
export type gh_DeleteProjectV2WorkflowInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the workflow to be removed. */
  workflowId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectV2Workflow */
export type gh_DeleteProjectV2WorkflowPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The ID of the deleted workflow. */
  deletedWorkflowId?: Maybe<Scalars['ID']['output']>;
  /** The project the deleted workflow was in. */
  projectV2?: Maybe<gh_ProjectV2>;
};

/** Autogenerated input type of DeletePullRequestReviewComment */
export type gh_DeletePullRequestReviewCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeletePullRequestReviewComment */
export type gh_DeletePullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request review the deleted comment belonged to. */
  pullRequestReview?: Maybe<gh_PullRequestReview>;
  /** The deleted pull request review comment. */
  pullRequestReviewComment?: Maybe<gh_PullRequestReviewComment>;
};

/** Autogenerated input type of DeletePullRequestReview */
export type gh_DeletePullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pull request review to delete. */
  pullRequestReviewId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeletePullRequestReview */
export type gh_DeletePullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The deleted pull request review. */
  pullRequestReview?: Maybe<gh_PullRequestReview>;
};

/** Autogenerated input type of DeleteRef */
export type gh_DeleteRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the Ref to be deleted. */
  refId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteRef */
export type gh_DeleteRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteRepositoryRuleset */
export type gh_DeleteRepositoryRulesetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The global relay id of the repository ruleset to be deleted. */
  repositoryRulesetId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteRepositoryRuleset */
export type gh_DeleteRepositoryRulesetPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteTeamDiscussionComment */
export type gh_DeleteTeamDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteTeamDiscussionComment */
export type gh_DeleteTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteTeamDiscussion */
export type gh_DeleteTeamDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The discussion ID to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteTeamDiscussion */
export type gh_DeleteTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteUserList */
export type gh_DeleteUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the list to delete. */
  listId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteUserList */
export type gh_DeleteUserListPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The owner of the list that will be deleted */
  user?: Maybe<gh_User>;
};

/** Autogenerated input type of DeleteVerifiableDomain */
export type gh_DeleteVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteVerifiableDomain */
export type gh_DeleteVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The owning account from which the domain was deleted. */
  owner?: Maybe<gh_VerifiableDomainOwner>;
};

/** Represents a 'demilestoned' event on a given issue or pull request. */
export type gh_DemilestonedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the DemilestonedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the milestone title associated with the 'demilestoned' event. */
  milestoneTitle: Scalars['String']['output'];
  /** Object referenced by event. */
  subject: gh_MilestoneItem;
};

/** A Dependabot Update for a dependency in a repository */
export type gh_DependabotUpdate = gh_RepositoryNode & {
  /** The error from a dependency update */
  error?: Maybe<gh_DependabotUpdateError>;
  /** The associated pull request */
  pullRequest?: Maybe<gh_PullRequest>;
  /** The repository associated with this node. */
  repository: gh_Repository;
};

/** An error produced from a Dependabot Update */
export type gh_DependabotUpdateError = {
  /** The body of the error */
  body: Scalars['String']['output'];
  /** The error code */
  errorType: Scalars['String']['output'];
  /** The title of the error */
  title: Scalars['String']['output'];
};

/** A dependency manifest entry */
export type gh_DependencyGraphDependency = {
  /** Does the dependency itself have dependencies? */
  hasDependencies: Scalars['Boolean']['output'];
  /**
   * The original name of the package, as it appears in the manifest.
   * @deprecated `packageLabel` will be removed. Use normalized `packageName` field instead. Removal on 2022-10-01 UTC.
   */
  packageLabel: Scalars['String']['output'];
  /** The dependency package manager */
  packageManager?: Maybe<Scalars['String']['output']>;
  /** The name of the package in the canonical form used by the package manager. */
  packageName: Scalars['String']['output'];
  /** The repository containing the package */
  repository?: Maybe<gh_Repository>;
  /** The dependency version requirements */
  requirements: Scalars['String']['output'];
};

/** The connection type for DependencyGraphDependency. */
export type gh_DependencyGraphDependencyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_DependencyGraphDependencyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_DependencyGraphDependency>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_DependencyGraphDependencyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_DependencyGraphDependency>;
};

/** The possible ecosystems of a dependency graph package. */
export type gh_DependencyGraphEcosystem =
  /** GitHub Actions */
  | 'ACTIONS'
  /** PHP packages hosted at packagist.org */
  | 'COMPOSER'
  /** Go modules */
  | 'GO'
  /** Java artifacts hosted at the Maven central repository */
  | 'MAVEN'
  /** JavaScript packages hosted at npmjs.com */
  | 'NPM'
  /** .NET packages hosted at the NuGet Gallery */
  | 'NUGET'
  /** Python packages hosted at PyPI.org */
  | 'PIP'
  /** Dart packages hosted at pub.dev */
  | 'PUB'
  /** Ruby gems hosted at RubyGems.org */
  | 'RUBYGEMS'
  /** Rust crates */
  | 'RUST'
  /** Swift packages */
  | 'SWIFT';

/** Dependency manifest for a repository */
export type gh_DependencyGraphManifest = gh_Node & {
  /** Path to view the manifest file blob */
  blobPath: Scalars['String']['output'];
  /** A list of manifest dependencies */
  dependencies?: Maybe<gh_DependencyGraphDependencyConnection>;
  /** The number of dependencies listed in the manifest */
  dependenciesCount?: Maybe<Scalars['Int']['output']>;
  /** Is the manifest too big to parse? */
  exceedsMaxSize: Scalars['Boolean']['output'];
  /** Fully qualified manifest filename */
  filename: Scalars['String']['output'];
  /** The Node ID of the DependencyGraphManifest object */
  id: Scalars['ID']['output'];
  /** Were we able to parse the manifest? */
  parseable: Scalars['Boolean']['output'];
  /** The repository containing the manifest */
  repository: gh_Repository;
};


/** Dependency manifest for a repository */
export type gh_DependencyGraphManifestdependenciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DependencyGraphManifest. */
export type gh_DependencyGraphManifestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_DependencyGraphManifestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_DependencyGraphManifest>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_DependencyGraphManifestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_DependencyGraphManifest>;
};

/** A repository deploy key. */
export type gh_DeployKey = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the DeployKey object */
  id: Scalars['ID']['output'];
  /** The deploy key. */
  key: Scalars['String']['output'];
  /** Whether or not the deploy key is read only. */
  readOnly: Scalars['Boolean']['output'];
  /** The deploy key title. */
  title: Scalars['String']['output'];
  /** Whether or not the deploy key has been verified. */
  verified: Scalars['Boolean']['output'];
};

/** The connection type for DeployKey. */
export type gh_DeployKeyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_DeployKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_DeployKey>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_DeployKeyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_DeployKey>;
};

/** Represents a 'deployed' event on a given pull request. */
export type gh_DeployedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The deployment associated with the 'deployed' event. */
  deployment: gh_Deployment;
  /** The Node ID of the DeployedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
  /** The ref associated with the 'deployed' event. */
  ref?: Maybe<gh_Ref>;
};

/** Represents triggered deployment instance. */
export type gh_Deployment = gh_Node & {
  /** Identifies the commit sha of the deployment. */
  commit?: Maybe<gh_Commit>;
  /** Identifies the oid of the deployment commit, even if the commit has been deleted. */
  commitOid: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the actor who triggered the deployment. */
  creator: gh_Actor;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The deployment description. */
  description?: Maybe<Scalars['String']['output']>;
  /** The latest environment to which this deployment was made. */
  environment?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the Deployment object */
  id: Scalars['ID']['output'];
  /** The latest environment to which this deployment was made. */
  latestEnvironment?: Maybe<Scalars['String']['output']>;
  /** The latest status of this deployment. */
  latestStatus?: Maybe<gh_DeploymentStatus>;
  /** The original environment to which this deployment was made. */
  originalEnvironment?: Maybe<Scalars['String']['output']>;
  /** Extra information that a deployment system might need. */
  payload?: Maybe<Scalars['String']['output']>;
  /** Identifies the Ref of the deployment, if the deployment was created by ref. */
  ref?: Maybe<gh_Ref>;
  /** Identifies the repository associated with the deployment. */
  repository: gh_Repository;
  /** The current state of the deployment. */
  state?: Maybe<gh_DeploymentState>;
  /** A list of statuses associated with the deployment. */
  statuses?: Maybe<gh_DeploymentStatusConnection>;
  /** The deployment task. */
  task?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};


/** Represents triggered deployment instance. */
export type gh_DeploymentstatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Deployment. */
export type gh_DeploymentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_DeploymentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Deployment>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_DeploymentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Deployment>;
};

/** Represents a 'deployment_environment_changed' event on a given pull request. */
export type gh_DeploymentEnvironmentChangedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The deployment status that updated the deployment environment. */
  deploymentStatus: gh_DeploymentStatus;
  /** The Node ID of the DeploymentEnvironmentChangedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
};

/** Ordering options for deployment connections */
export type gh_DeploymentOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order deployments by. */
  field: gh_DeploymentOrderField;
};

/** Properties by which deployment connections can be ordered. */
export type gh_DeploymentOrderField =
  /** Order collection by creation time */
  | 'CREATED_AT';

/** A protection rule. */
export type gh_DeploymentProtectionRule = {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** Whether deployments to this environment can be approved by the user who created the deployment. */
  preventSelfReview?: Maybe<Scalars['Boolean']['output']>;
  /** The teams or users that can review the deployment */
  reviewers: gh_DeploymentReviewerConnection;
  /** The timeout in minutes for this protection rule. */
  timeout: Scalars['Int']['output'];
  /** The type of protection rule. */
  type: gh_DeploymentProtectionRuleType;
};


/** A protection rule. */
export type gh_DeploymentProtectionRulereviewersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DeploymentProtectionRule. */
export type gh_DeploymentProtectionRuleConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_DeploymentProtectionRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_DeploymentProtectionRule>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_DeploymentProtectionRuleEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_DeploymentProtectionRule>;
};

/** The possible protection rule types. */
export type gh_DeploymentProtectionRuleType =
  /** Required reviewers */
  | 'REQUIRED_REVIEWERS'
  /** Wait timer */
  | 'WAIT_TIMER';

/** A request to deploy a workflow run to an environment. */
export type gh_DeploymentRequest = {
  /** Whether or not the current user can approve the deployment */
  currentUserCanApprove: Scalars['Boolean']['output'];
  /** The target environment of the deployment */
  environment: gh_Environment;
  /** The teams or users that can review the deployment */
  reviewers: gh_DeploymentReviewerConnection;
  /** The wait timer in minutes configured in the environment */
  waitTimer: Scalars['Int']['output'];
  /** The wait timer in minutes configured in the environment */
  waitTimerStartedAt?: Maybe<Scalars['DateTime']['output']>;
};


/** A request to deploy a workflow run to an environment. */
export type gh_DeploymentRequestreviewersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DeploymentRequest. */
export type gh_DeploymentRequestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_DeploymentRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_DeploymentRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_DeploymentRequestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_DeploymentRequest>;
};

/** A deployment review. */
export type gh_DeploymentReview = gh_Node & {
  /** The comment the user left. */
  comment: Scalars['String']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The environments approved or rejected */
  environments: gh_EnvironmentConnection;
  /** The Node ID of the DeploymentReview object */
  id: Scalars['ID']['output'];
  /** The decision of the user. */
  state: gh_DeploymentReviewState;
  /** The user that reviewed the deployment. */
  user: gh_User;
};


/** A deployment review. */
export type gh_DeploymentReviewenvironmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DeploymentReview. */
export type gh_DeploymentReviewConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_DeploymentReviewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_DeploymentReview>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_DeploymentReviewEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_DeploymentReview>;
};

/** The possible states for a deployment review. */
export type gh_DeploymentReviewState =
  /** The deployment was approved. */
  | 'APPROVED'
  /** The deployment was rejected. */
  | 'REJECTED';

/** Users and teams. */
export type gh_DeploymentReviewer = gh_Team | gh_User;

/** The connection type for DeploymentReviewer. */
export type gh_DeploymentReviewerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_DeploymentReviewerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_DeploymentReviewer>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_DeploymentReviewerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_DeploymentReviewer>;
};

/** The possible states in which a deployment can be. */
export type gh_DeploymentState =
  /** The pending deployment was not updated after 30 minutes. */
  | 'ABANDONED'
  /** The deployment is currently active. */
  | 'ACTIVE'
  /** An inactive transient deployment. */
  | 'DESTROYED'
  /** The deployment experienced an error. */
  | 'ERROR'
  /** The deployment has failed. */
  | 'FAILURE'
  /** The deployment is inactive. */
  | 'INACTIVE'
  /** The deployment is in progress. */
  | 'IN_PROGRESS'
  /** The deployment is pending. */
  | 'PENDING'
  /** The deployment has queued */
  | 'QUEUED'
  /** The deployment was successful. */
  | 'SUCCESS'
  /** The deployment is waiting. */
  | 'WAITING';

/** Describes the status of a given deployment attempt. */
export type gh_DeploymentStatus = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the actor who triggered the deployment. */
  creator: gh_Actor;
  /** Identifies the deployment associated with status. */
  deployment: gh_Deployment;
  /** Identifies the description of the deployment. */
  description?: Maybe<Scalars['String']['output']>;
  /** Identifies the environment of the deployment at the time of this deployment status */
  environment?: Maybe<Scalars['String']['output']>;
  /** Identifies the environment URL of the deployment. */
  environmentUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The Node ID of the DeploymentStatus object */
  id: Scalars['ID']['output'];
  /** Identifies the log URL of the deployment. */
  logUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** Identifies the current state of the deployment. */
  state: gh_DeploymentStatusState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for DeploymentStatus. */
export type gh_DeploymentStatusConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_DeploymentStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_DeploymentStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_DeploymentStatusEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_DeploymentStatus>;
};

/** The possible states for a deployment status. */
export type gh_DeploymentStatusState =
  /** The deployment experienced an error. */
  | 'ERROR'
  /** The deployment has failed. */
  | 'FAILURE'
  /** The deployment is inactive. */
  | 'INACTIVE'
  /** The deployment is in progress. */
  | 'IN_PROGRESS'
  /** The deployment is pending. */
  | 'PENDING'
  /** The deployment is queued */
  | 'QUEUED'
  /** The deployment was successful. */
  | 'SUCCESS'
  /** The deployment is waiting. */
  | 'WAITING';

/** Autogenerated input type of DequeuePullRequest */
export type gh_DequeuePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the pull request to be dequeued. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DequeuePullRequest */
export type gh_DequeuePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The merge queue entry of the dequeued pull request. */
  mergeQueueEntry?: Maybe<gh_MergeQueueEntry>;
};

/** The possible sides of a diff. */
export type gh_DiffSide =
  /** The left side of the diff. */
  | 'LEFT'
  /** The right side of the diff. */
  | 'RIGHT';

/** Autogenerated input type of DisablePullRequestAutoMerge */
export type gh_DisablePullRequestAutoMergeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to disable auto merge on. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of DisablePullRequestAutoMerge */
export type gh_DisablePullRequestAutoMergePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request auto merge was disabled on. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Represents a 'disconnected' event on a given issue or pull request. */
export type gh_DisconnectedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the DisconnectedEvent object */
  id: Scalars['ID']['output'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean']['output'];
  /** Issue or pull request from which the issue was disconnected. */
  source: gh_ReferencedSubject;
  /** Issue or pull request which was disconnected. */
  subject: gh_ReferencedSubject;
};

/** A discussion in a repository. */
export type gh_Discussion = gh_Closable & gh_Comment & gh_Deletable & gh_Labelable & gh_Lockable & gh_Node & gh_Reactable & gh_RepositoryNode & gh_Subscribable & gh_Updatable & gh_Votable & {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<gh_LockReason>;
  /** The comment chosen as this discussion's answer, if any. */
  answer?: Maybe<gh_DiscussionComment>;
  /** The time when a user chose this discussion's answer, if answered. */
  answerChosenAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user who chose this discussion's answer, if answered. */
  answerChosenBy?: Maybe<gh_Actor>;
  /** The actor who authored the comment. */
  author?: Maybe<gh_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: gh_CommentAuthorAssociation;
  /** The main text of the discussion post. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** The category for this discussion. */
  category: gh_DiscussionCategory;
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The replies to the discussion. */
  comments: gh_DiscussionCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<gh_Actor>;
  /** The Node ID of the Discussion object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Only return answered/unanswered discussions */
  isAnswered?: Maybe<Scalars['Boolean']['output']>;
  /** A list of labels associated with the object. */
  labels?: Maybe<gh_LabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** `true` if the object is locked */
  locked: Scalars['Boolean']['output'];
  /** The number identifying this discussion within the repository. */
  number: Scalars['Int']['output'];
  /** The poll associated with this discussion, if one exists. */
  poll?: Maybe<gh_DiscussionPoll>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: gh_ReactionConnection;
  /** The repository associated with this node. */
  repository: gh_Repository;
  /** The path for this discussion. */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the reason for the discussion's state. */
  stateReason?: Maybe<gh_DiscussionStateReason>;
  /** The title of this discussion. */
  title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars['Int']['output'];
  /** The URL for this discussion. */
  url: Scalars['gh_URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<gh_UserContentEditConnection>;
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars['Boolean']['output'];
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<gh_SubscriptionState>;
};


/** A discussion in a repository. */
export type gh_DiscussioncommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A discussion in a repository. */
export type gh_DiscussionlabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_LabelOrder>;
};


/** A discussion in a repository. */
export type gh_DiscussionreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<gh_ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ReactionOrder>;
};


/** A discussion in a repository. */
export type gh_DiscussionuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A category for discussions in a repository. */
export type gh_DiscussionCategory = gh_Node & gh_RepositoryNode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** A description of this category. */
  description?: Maybe<Scalars['String']['output']>;
  /** An emoji representing this category. */
  emoji: Scalars['String']['output'];
  /** This category's emoji rendered as HTML. */
  emojiHTML: Scalars['gh_HTML']['output'];
  /** The Node ID of the DiscussionCategory object */
  id: Scalars['ID']['output'];
  /** Whether or not discussions in this category support choosing an answer with the markDiscussionCommentAsAnswer mutation. */
  isAnswerable: Scalars['Boolean']['output'];
  /** The name of this category. */
  name: Scalars['String']['output'];
  /** The repository associated with this node. */
  repository: gh_Repository;
  /** The slug of this category. */
  slug: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for DiscussionCategory. */
export type gh_DiscussionCategoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_DiscussionCategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_DiscussionCategory>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_DiscussionCategoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_DiscussionCategory>;
};

/** The possible reasons for closing a discussion. */
export type gh_DiscussionCloseReason =
  /** The discussion is a duplicate of another */
  | 'DUPLICATE'
  /** The discussion is no longer relevant */
  | 'OUTDATED'
  /** The discussion has been resolved */
  | 'RESOLVED';

/** A comment on a discussion. */
export type gh_DiscussionComment = gh_Comment & gh_Deletable & gh_Minimizable & gh_Node & gh_Reactable & gh_Updatable & gh_UpdatableComment & gh_Votable & {
  /** The actor who authored the comment. */
  author?: Maybe<gh_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: gh_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The time when this replied-to comment was deleted */
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The discussion this comment was created in */
  discussion?: Maybe<gh_Discussion>;
  /** The actor who edited the comment. */
  editor?: Maybe<gh_Actor>;
  /** The Node ID of the DiscussionComment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Has this comment been chosen as the answer of its discussion? */
  isAnswer: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: gh_ReactionConnection;
  /** The threaded replies to this comment. */
  replies: gh_DiscussionCommentConnection;
  /** The discussion comment this comment is a reply to */
  replyTo?: Maybe<gh_DiscussionComment>;
  /** The path for this discussion comment. */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars['Int']['output'];
  /** The URL for this discussion comment. */
  url: Scalars['gh_URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<gh_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Can the current user mark this comment as an answer? */
  viewerCanMarkAsAnswer: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Can the current user unmark this comment as an answer? */
  viewerCanUnmarkAsAnswer: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<gh_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars['Boolean']['output'];
};


/** A comment on a discussion. */
export type gh_DiscussionCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<gh_ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ReactionOrder>;
};


/** A comment on a discussion. */
export type gh_DiscussionCommentrepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A comment on a discussion. */
export type gh_DiscussionCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DiscussionComment. */
export type gh_DiscussionCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_DiscussionCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_DiscussionComment>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_DiscussionCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_DiscussionComment>;
};

/** The connection type for Discussion. */
export type gh_DiscussionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_DiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Discussion>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_DiscussionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Discussion>;
};

/** Ways in which lists of discussions can be ordered upon return. */
export type gh_DiscussionOrder = {
  /** The direction in which to order discussions by the specified field. */
  direction: gh_OrderDirection;
  /** The field by which to order discussions. */
  field: gh_DiscussionOrderField;
};

/** Properties by which discussion connections can be ordered. */
export type gh_DiscussionOrderField =
  /** Order discussions by creation time. */
  | 'CREATED_AT'
  /** Order discussions by most recent modification time. */
  | 'UPDATED_AT';

/** A poll for a discussion. */
export type gh_DiscussionPoll = gh_Node & {
  /** The discussion that this poll belongs to. */
  discussion?: Maybe<gh_Discussion>;
  /** The Node ID of the DiscussionPoll object */
  id: Scalars['ID']['output'];
  /** The options for this poll. */
  options?: Maybe<gh_DiscussionPollOptionConnection>;
  /** The question that is being asked by this poll. */
  question: Scalars['String']['output'];
  /** The total number of votes that have been cast for this poll. */
  totalVoteCount: Scalars['Int']['output'];
  /** Indicates if the viewer has permission to vote in this poll. */
  viewerCanVote: Scalars['Boolean']['output'];
  /** Indicates if the viewer has voted for any option in this poll. */
  viewerHasVoted: Scalars['Boolean']['output'];
};


/** A poll for a discussion. */
export type gh_DiscussionPolloptionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_DiscussionPollOptionOrder>;
};

/** An option for a discussion poll. */
export type gh_DiscussionPollOption = gh_Node & {
  /** The Node ID of the DiscussionPollOption object */
  id: Scalars['ID']['output'];
  /** The text for this option. */
  option: Scalars['String']['output'];
  /** The discussion poll that this option belongs to. */
  poll?: Maybe<gh_DiscussionPoll>;
  /** The total number of votes that have been cast for this option. */
  totalVoteCount: Scalars['Int']['output'];
  /** Indicates if the viewer has voted for this option in the poll. */
  viewerHasVoted: Scalars['Boolean']['output'];
};

/** The connection type for DiscussionPollOption. */
export type gh_DiscussionPollOptionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_DiscussionPollOptionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_DiscussionPollOption>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_DiscussionPollOptionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_DiscussionPollOption>;
};

/** Ordering options for discussion poll option connections. */
export type gh_DiscussionPollOptionOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order poll options by. */
  field: gh_DiscussionPollOptionOrderField;
};

/** Properties by which discussion poll option connections can be ordered. */
export type gh_DiscussionPollOptionOrderField =
  /** Order poll options by the order that the poll author specified when creating the poll. */
  | 'AUTHORED_ORDER'
  /** Order poll options by the number of votes it has. */
  | 'VOTE_COUNT';

/** The possible states of a discussion. */
export type gh_DiscussionState =
  /** A discussion that has been closed */
  | 'CLOSED'
  /** A discussion that is open */
  | 'OPEN';

/** The possible state reasons of a discussion. */
export type gh_DiscussionStateReason =
  /** The discussion is a duplicate of another */
  | 'DUPLICATE'
  /** The discussion is no longer relevant */
  | 'OUTDATED'
  /** The discussion was reopened */
  | 'REOPENED'
  /** The discussion has been resolved */
  | 'RESOLVED';

/** Autogenerated input type of DismissPullRequestReview */
export type gh_DismissPullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The contents of the pull request review dismissal message. */
  message: Scalars['String']['input'];
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID']['input'];
};

/** Autogenerated return type of DismissPullRequestReview */
export type gh_DismissPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The dismissed pull request review. */
  pullRequestReview?: Maybe<gh_PullRequestReview>;
};

/** The possible reasons that a Dependabot alert was dismissed. */
export type gh_DismissReason =
  /** A fix has already been started */
  | 'FIX_STARTED'
  /** This alert is inaccurate or incorrect */
  | 'INACCURATE'
  /** Vulnerable code is not actually used */
  | 'NOT_USED'
  /** No bandwidth to fix this */
  | 'NO_BANDWIDTH'
  /** Risk is tolerable to this project */
  | 'TOLERABLE_RISK';

/** Autogenerated input type of DismissRepositoryVulnerabilityAlert */
export type gh_DismissRepositoryVulnerabilityAlertInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The reason the Dependabot alert is being dismissed. */
  dismissReason: gh_DismissReason;
  /** The Dependabot alert ID to dismiss. */
  repositoryVulnerabilityAlertId: Scalars['ID']['input'];
};

/** Autogenerated return type of DismissRepositoryVulnerabilityAlert */
export type gh_DismissRepositoryVulnerabilityAlertPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The Dependabot alert that was dismissed */
  repositoryVulnerabilityAlert?: Maybe<gh_RepositoryVulnerabilityAlert>;
};

/** A draft issue within a project. */
export type gh_DraftIssue = gh_Node & {
  /** A list of users to assigned to this draft issue. */
  assignees: gh_UserConnection;
  /** The body of the draft issue. */
  body: Scalars['String']['output'];
  /** The body of the draft issue rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** The body of the draft issue rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created this draft issue. */
  creator?: Maybe<gh_Actor>;
  /** The Node ID of the DraftIssue object */
  id: Scalars['ID']['output'];
  /** List of items linked with the draft issue (currently draft issue can be linked to only one item). */
  projectV2Items: gh_ProjectV2ItemConnection;
  /** Projects that link to this draft issue (currently draft issue can be linked to only one project). */
  projectsV2: gh_ProjectV2Connection;
  /** The title of the draft issue */
  title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};


/** A draft issue within a project. */
export type gh_DraftIssueassigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A draft issue within a project. */
export type gh_DraftIssueprojectV2ItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A draft issue within a project. */
export type gh_DraftIssueprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Specifies a review comment to be left with a Pull Request Review. */
export type gh_DraftPullRequestReviewComment = {
  /** Body of the comment to leave. */
  body: Scalars['String']['input'];
  /** Path to the file being commented on. */
  path: Scalars['String']['input'];
  /** Position in the file to leave a comment on. */
  position: Scalars['Int']['input'];
};

/** Specifies a review comment thread to be left with a Pull Request Review. */
export type gh_DraftPullRequestReviewThread = {
  /** Body of the comment to leave. */
  body: Scalars['String']['input'];
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  line: Scalars['Int']['input'];
  /** Path to the file being commented on. */
  path: Scalars['String']['input'];
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: InputMaybe<gh_DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: InputMaybe<Scalars['Int']['input']>;
  /** The side of the diff on which the start line resides. */
  startSide?: InputMaybe<gh_DiffSide>;
};

/** Autogenerated input type of EnablePullRequestAutoMerge */
export type gh_EnablePullRequestAutoMergeInput = {
  /** The email address to associate with this merge. */
  authorEmail?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Commit body to use for the commit when the PR is mergable; if omitted, a
   * default message will be used. NOTE: when merging with a merge queue any input
   * value for commit message is ignored.
   */
  commitBody?: InputMaybe<Scalars['String']['input']>;
  /**
   * Commit headline to use for the commit when the PR is mergable; if omitted, a
   * default message will be used. NOTE: when merging with a merge queue any input
   * value for commit headline is ignored.
   */
  commitHeadline?: InputMaybe<Scalars['String']['input']>;
  /** The expected head OID of the pull request. */
  expectedHeadOid?: InputMaybe<Scalars['gh_GitObjectID']['input']>;
  /**
   * The merge method to use. If omitted, defaults to `MERGE`. NOTE: when merging
   * with a merge queue any input value for merge method is ignored.
   */
  mergeMethod?: InputMaybe<gh_PullRequestMergeMethod>;
  /** ID of the pull request to enable auto-merge on. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of EnablePullRequestAutoMerge */
export type gh_EnablePullRequestAutoMergePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request auto-merge was enabled on. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Autogenerated input type of EnqueuePullRequest */
export type gh_EnqueuePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The expected head OID of the pull request. */
  expectedHeadOid?: InputMaybe<Scalars['gh_GitObjectID']['input']>;
  /** Add the pull request to the front of the queue. */
  jump?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the pull request to enqueue. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of EnqueuePullRequest */
export type gh_EnqueuePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The merge queue entry for the enqueued pull request. */
  mergeQueueEntry?: Maybe<gh_MergeQueueEntry>;
};

/** An account to manage multiple organizations with consolidated policy and billing. */
export type gh_Enterprise = gh_AnnouncementBanner & gh_Node & {
  /** The text of the announcement */
  announcement?: Maybe<Scalars['String']['output']>;
  /** The expiration date of the announcement, if any */
  announcementExpiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether the announcement can be dismissed by the user */
  announcementUserDismissible?: Maybe<Scalars['Boolean']['output']>;
  /** A URL pointing to the enterprise's public avatar. */
  avatarUrl: Scalars['gh_URI']['output'];
  /** Enterprise billing information visible to enterprise billing managers. */
  billingInfo?: Maybe<gh_EnterpriseBillingInfo>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The description of the enterprise. */
  description?: Maybe<Scalars['String']['output']>;
  /** The description of the enterprise as HTML. */
  descriptionHTML: Scalars['gh_HTML']['output'];
  /** The Node ID of the Enterprise object */
  id: Scalars['ID']['output'];
  /** The location of the enterprise. */
  location?: Maybe<Scalars['String']['output']>;
  /** A list of users who are members of this enterprise. */
  members: gh_EnterpriseMemberConnection;
  /** The name of the enterprise. */
  name: Scalars['String']['output'];
  /** A list of organizations that belong to this enterprise. */
  organizations: gh_OrganizationConnection;
  /**
   * Enterprise information visible to enterprise owners or enterprise owners'
   * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
   */
  ownerInfo?: Maybe<gh_EnterpriseOwnerInfo>;
  /** The HTTP path for this enterprise. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The URL-friendly identifier for the enterprise. */
  slug: Scalars['String']['output'];
  /** The HTTP URL for this enterprise. */
  url: Scalars['gh_URI']['output'];
  /** Is the current viewer an admin of this enterprise? */
  viewerIsAdmin: Scalars['Boolean']['output'];
  /** The URL of the enterprise website. */
  websiteUrl?: Maybe<Scalars['gh_URI']['output']>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type gh_EnterpriseavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type gh_EnterprisemembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deployment?: InputMaybe<gh_EnterpriseUserDeployment>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<gh_EnterpriseUserAccountMembershipRole>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type gh_EnterpriseorganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  viewerOrganizationRole?: InputMaybe<gh_RoleInOrganization>;
};

/** The connection type for User. */
export type gh_EnterpriseAdministratorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterpriseAdministratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_User>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A User who is an administrator of an enterprise. */
export type gh_EnterpriseAdministratorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_User>;
  /** The role of the administrator. */
  role: gh_EnterpriseAdministratorRole;
};

/** An invitation for a user to become an owner or billing manager of an enterprise. */
export type gh_EnterpriseAdministratorInvitation = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The email of the person who was invited to the enterprise. */
  email?: Maybe<Scalars['String']['output']>;
  /** The enterprise the invitation is for. */
  enterprise: gh_Enterprise;
  /** The Node ID of the EnterpriseAdministratorInvitation object */
  id: Scalars['ID']['output'];
  /** The user who was invited to the enterprise. */
  invitee?: Maybe<gh_User>;
  /** The user who created the invitation. */
  inviter?: Maybe<gh_User>;
  /** The invitee's pending role in the enterprise (owner or billing_manager). */
  role: gh_EnterpriseAdministratorRole;
};

/** The connection type for EnterpriseAdministratorInvitation. */
export type gh_EnterpriseAdministratorInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterpriseAdministratorInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_EnterpriseAdministratorInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_EnterpriseAdministratorInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_EnterpriseAdministratorInvitation>;
};

/** Ordering options for enterprise administrator invitation connections */
export type gh_EnterpriseAdministratorInvitationOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order enterprise administrator invitations by. */
  field: gh_EnterpriseAdministratorInvitationOrderField;
};

/** Properties by which enterprise administrator invitation connections can be ordered. */
export type gh_EnterpriseAdministratorInvitationOrderField =
  /** Order enterprise administrator member invitations by creation time */
  | 'CREATED_AT';

/** The possible administrator roles in an enterprise account. */
export type gh_EnterpriseAdministratorRole =
  /** Represents a billing manager of the enterprise account. */
  | 'BILLING_MANAGER'
  /** Represents an owner of the enterprise account. */
  | 'OWNER';

/** The possible values for the enterprise allow private repository forking policy value. */
export type gh_EnterpriseAllowPrivateRepositoryForkingPolicyValue =
  /** Members can fork a repository to an organization within this enterprise. */
  | 'ENTERPRISE_ORGANIZATIONS'
  /** Members can fork a repository to their enterprise-managed user account or an organization inside this enterprise. */
  | 'ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS'
  /** Members can fork a repository to their user account or an organization, either inside or outside of this enterprise. */
  | 'EVERYWHERE'
  /** Members can fork a repository only within the same organization (intra-org). */
  | 'SAME_ORGANIZATION'
  /** Members can fork a repository to their user account or within the same organization. */
  | 'SAME_ORGANIZATION_USER_ACCOUNTS'
  /** Members can fork a repository to their user account. */
  | 'USER_ACCOUNTS';

/** Metadata for an audit entry containing enterprise account information. */
export type gh_EnterpriseAuditEntryData = {
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Enterprise billing information visible to enterprise billing managers and owners. */
export type gh_EnterpriseBillingInfo = {
  /** The number of licenseable users/emails across the enterprise. */
  allLicensableUsersCount: Scalars['Int']['output'];
  /** The number of data packs used by all organizations owned by the enterprise. */
  assetPacks: Scalars['Int']['output'];
  /** The bandwidth quota in GB for all organizations owned by the enterprise. */
  bandwidthQuota: Scalars['Float']['output'];
  /** The bandwidth usage in GB for all organizations owned by the enterprise. */
  bandwidthUsage: Scalars['Float']['output'];
  /** The bandwidth usage as a percentage of the bandwidth quota. */
  bandwidthUsagePercentage: Scalars['Int']['output'];
  /** The storage quota in GB for all organizations owned by the enterprise. */
  storageQuota: Scalars['Float']['output'];
  /** The storage usage in GB for all organizations owned by the enterprise. */
  storageUsage: Scalars['Float']['output'];
  /** The storage usage as a percentage of the storage quota. */
  storageUsagePercentage: Scalars['Int']['output'];
  /** The number of available licenses across all owned organizations based on the unique number of billable users. */
  totalAvailableLicenses: Scalars['Int']['output'];
  /** The total number of licenses allocated. */
  totalLicenses: Scalars['Int']['output'];
};

/** The connection type for Enterprise. */
export type gh_EnterpriseConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterpriseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Enterprise>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The possible values for the enterprise base repository permission setting. */
export type gh_EnterpriseDefaultRepositoryPermissionSettingValue =
  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */
  | 'ADMIN'
  /** Organization members will only be able to clone and pull public repositories. */
  | 'NONE'
  /** Organizations in the enterprise choose base repository permissions for their members. */
  | 'NO_POLICY'
  /** Organization members will be able to clone and pull all organization repositories. */
  | 'READ'
  /** Organization members will be able to clone, pull, and push all organization repositories. */
  | 'WRITE';

/** An edge in a connection. */
export type gh_EnterpriseEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Enterprise>;
};

/** The possible values for an enabled/disabled enterprise setting. */
export type gh_EnterpriseEnabledDisabledSettingValue =
  /** The setting is disabled for organizations in the enterprise. */
  | 'DISABLED'
  /** The setting is enabled for organizations in the enterprise. */
  | 'ENABLED'
  /** There is no policy set for organizations in the enterprise. */
  | 'NO_POLICY';

/** The possible values for an enabled/no policy enterprise setting. */
export type gh_EnterpriseEnabledSettingValue =
  /** The setting is enabled for organizations in the enterprise. */
  | 'ENABLED'
  /** There is no policy set for organizations in the enterprise. */
  | 'NO_POLICY';

/** The connection type for OrganizationInvitation. */
export type gh_EnterpriseFailedInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterpriseFailedInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /** Identifies the total count of unique users in the connection. */
  totalUniqueUserCount: Scalars['Int']['output'];
};

/** A failed invitation to be a member in an enterprise organization. */
export type gh_EnterpriseFailedInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_OrganizationInvitation>;
};

/**
 * An identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseIdentityProvider = gh_Node & {
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod?: Maybe<gh_SamlDigestAlgorithm>;
  /** The enterprise this identity provider belongs to. */
  enterprise?: Maybe<gh_Enterprise>;
  /** ExternalIdentities provisioned by this identity provider. */
  externalIdentities: gh_ExternalIdentityConnection;
  /** The Node ID of the EnterpriseIdentityProvider object */
  id: Scalars['ID']['output'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars['gh_X509Certificate']['output']>;
  /** The Issuer Entity ID for the SAML identity provider. */
  issuer?: Maybe<Scalars['String']['output']>;
  /** Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable. */
  recoveryCodes?: Maybe<Array<Scalars['String']['output']>>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod?: Maybe<gh_SamlSignatureAlgorithm>;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars['gh_URI']['output']>;
};


/**
 * An identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseIdentityProviderexternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  membersOnly?: InputMaybe<Scalars['Boolean']['input']>;
  userName?: InputMaybe<Scalars['String']['input']>;
};

/** An object that is a member of an enterprise. */
export type gh_EnterpriseMember = gh_EnterpriseUserAccount | gh_User;

/** The connection type for EnterpriseMember. */
export type gh_EnterpriseMemberConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterpriseMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_EnterpriseMember>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A User who is a member of an enterprise through one or more organizations. */
export type gh_EnterpriseMemberEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_EnterpriseMember>;
};

/** Ordering options for enterprise member connections. */
export type gh_EnterpriseMemberOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order enterprise members by. */
  field: gh_EnterpriseMemberOrderField;
};

/** Properties by which enterprise member connections can be ordered. */
export type gh_EnterpriseMemberOrderField =
  /** Order enterprise members by creation time */
  | 'CREATED_AT'
  /** Order enterprise members by login */
  | 'LOGIN';

/** The possible values for the enterprise members can create repositories setting. */
export type gh_EnterpriseMembersCanCreateRepositoriesSettingValue =
  /** Members will be able to create public and private repositories. */
  | 'ALL'
  /** Members will not be able to create public or private repositories. */
  | 'DISABLED'
  /** Organization owners choose whether to allow members to create repositories. */
  | 'NO_POLICY'
  /** Members will be able to create only private repositories. */
  | 'PRIVATE'
  /** Members will be able to create only public repositories. */
  | 'PUBLIC';

/** The possible values for the members can make purchases setting. */
export type gh_EnterpriseMembersCanMakePurchasesSettingValue =
  /** The setting is disabled for organizations in the enterprise. */
  | 'DISABLED'
  /** The setting is enabled for organizations in the enterprise. */
  | 'ENABLED';

/** The possible values we have for filtering Platform::Objects::User#enterprises. */
export type gh_EnterpriseMembershipType =
  /** Returns all enterprises in which the user is an admin. */
  | 'ADMIN'
  /** Returns all enterprises in which the user is a member, admin, or billing manager. */
  | 'ALL'
  /** Returns all enterprises in which the user is a billing manager. */
  | 'BILLING_MANAGER'
  /** Returns all enterprises in which the user is a member of an org that is owned by the enterprise. */
  | 'ORG_MEMBERSHIP';

/** Ordering options for enterprises. */
export type gh_EnterpriseOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order enterprises by. */
  field: gh_EnterpriseOrderField;
};

/** Properties by which enterprise connections can be ordered. */
export type gh_EnterpriseOrderField =
  /** Order enterprises by name */
  | 'NAME';

/** The connection type for Organization. */
export type gh_EnterpriseOrganizationMembershipConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterpriseOrganizationMembershipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Organization>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An enterprise organization that a user is a member of. */
export type gh_EnterpriseOrganizationMembershipEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Organization>;
  /** The role of the user in the enterprise membership. */
  role: gh_EnterpriseUserAccountMembershipRole;
};

/** The connection type for User. */
export type gh_EnterpriseOutsideCollaboratorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterpriseOutsideCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_User>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type gh_EnterpriseOutsideCollaboratorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_User>;
  /** The enterprise organization repositories this user is a member of. */
  repositories: gh_EnterpriseRepositoryInfoConnection;
};


/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type gh_EnterpriseOutsideCollaboratorEdgerepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_RepositoryOrder>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfo = {
  /** A list of all of the administrators for this enterprise. */
  admins: gh_EnterpriseAdministratorConnection;
  /** A list of users in the enterprise who currently have two-factor authentication disabled. */
  affiliatedUsersWithTwoFactorDisabled: gh_UserConnection;
  /** Whether or not affiliated users with two-factor authentication disabled exist in the enterprise. */
  affiliatedUsersWithTwoFactorDisabledExist: Scalars['Boolean']['output'];
  /** The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise. */
  allowPrivateRepositoryForkingSetting: gh_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided private repository forking setting value. */
  allowPrivateRepositoryForkingSettingOrganizations: gh_OrganizationConnection;
  /** The value for the allow private repository forking policy on the enterprise. */
  allowPrivateRepositoryForkingSettingPolicyValue?: Maybe<gh_EnterpriseAllowPrivateRepositoryForkingPolicyValue>;
  /** The setting value for base repository permissions for organizations in this enterprise. */
  defaultRepositoryPermissionSetting: gh_EnterpriseDefaultRepositoryPermissionSettingValue;
  /** A list of enterprise organizations configured with the provided base repository permission. */
  defaultRepositoryPermissionSettingOrganizations: gh_OrganizationConnection;
  /**
   * A list of domains owned by the enterprise. Visible to enterprise owners or
   * enterprise owners' personal access tokens (classic) with admin:enterprise scope.
   */
  domains: gh_VerifiableDomainConnection;
  /** Enterprise Server installations owned by the enterprise. */
  enterpriseServerInstallations: gh_EnterpriseServerInstallationConnection;
  /** A list of failed invitations in the enterprise. */
  failedInvitations: gh_EnterpriseFailedInvitationConnection;
  /** The setting value for whether the enterprise has an IP allow list enabled. */
  ipAllowListEnabledSetting: gh_IpAllowListEnabledSettingValue;
  /**
   * The IP addresses that are allowed to access resources owned by the enterprise.
   * Visible to enterprise owners or enterprise owners' personal access tokens
   * (classic) with admin:enterprise scope.
   */
  ipAllowListEntries: gh_IpAllowListEntryConnection;
  /** The setting value for whether the enterprise has IP allow list configuration for installed GitHub Apps enabled. */
  ipAllowListForInstalledAppsEnabledSetting: gh_IpAllowListForInstalledAppsEnabledSettingValue;
  /** Whether or not the base repository permission is currently being updated. */
  isUpdatingDefaultRepositoryPermission: Scalars['Boolean']['output'];
  /** Whether the two-factor authentication requirement is currently being enforced. */
  isUpdatingTwoFactorRequirement: Scalars['Boolean']['output'];
  /**
   * The setting value for whether organization members with admin permissions on a
   * repository can change repository visibility.
   */
  membersCanChangeRepositoryVisibilitySetting: gh_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided can change repository visibility setting value. */
  membersCanChangeRepositoryVisibilitySettingOrganizations: gh_OrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can create internal repositories. */
  membersCanCreateInternalRepositoriesSetting?: Maybe<Scalars['Boolean']['output']>;
  /** The setting value for whether members of organizations in the enterprise can create private repositories. */
  membersCanCreatePrivateRepositoriesSetting?: Maybe<Scalars['Boolean']['output']>;
  /** The setting value for whether members of organizations in the enterprise can create public repositories. */
  membersCanCreatePublicRepositoriesSetting?: Maybe<Scalars['Boolean']['output']>;
  /** The setting value for whether members of organizations in the enterprise can create repositories. */
  membersCanCreateRepositoriesSetting?: Maybe<gh_EnterpriseMembersCanCreateRepositoriesSettingValue>;
  /** A list of enterprise organizations configured with the provided repository creation setting value. */
  membersCanCreateRepositoriesSettingOrganizations: gh_OrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete issues. */
  membersCanDeleteIssuesSetting: gh_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete issues setting value. */
  membersCanDeleteIssuesSettingOrganizations: gh_OrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete or transfer repositories. */
  membersCanDeleteRepositoriesSetting: gh_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete repositories setting value. */
  membersCanDeleteRepositoriesSettingOrganizations: gh_OrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can invite outside collaborators. */
  membersCanInviteCollaboratorsSetting: gh_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can invite collaborators setting value. */
  membersCanInviteCollaboratorsSettingOrganizations: gh_OrganizationConnection;
  /** Indicates whether members of this enterprise's organizations can purchase additional services for those organizations. */
  membersCanMakePurchasesSetting: gh_EnterpriseMembersCanMakePurchasesSettingValue;
  /** The setting value for whether members with admin permissions for repositories can update protected branches. */
  membersCanUpdateProtectedBranchesSetting: gh_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can update protected branches setting value. */
  membersCanUpdateProtectedBranchesSettingOrganizations: gh_OrganizationConnection;
  /** The setting value for whether members can view dependency insights. */
  membersCanViewDependencyInsightsSetting: gh_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can view dependency insights setting value. */
  membersCanViewDependencyInsightsSettingOrganizations: gh_OrganizationConnection;
  /** Indicates if email notification delivery for this enterprise is restricted to verified or approved domains. */
  notificationDeliveryRestrictionEnabledSetting: gh_NotificationRestrictionSettingValue;
  /** The OIDC Identity Provider for the enterprise. */
  oidcProvider?: Maybe<gh_OIDCProvider>;
  /** The setting value for whether organization projects are enabled for organizations in this enterprise. */
  organizationProjectsSetting: gh_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided organization projects setting value. */
  organizationProjectsSettingOrganizations: gh_OrganizationConnection;
  /** A list of outside collaborators across the repositories in the enterprise. */
  outsideCollaborators: gh_EnterpriseOutsideCollaboratorConnection;
  /** A list of pending administrator invitations for the enterprise. */
  pendingAdminInvitations: gh_EnterpriseAdministratorInvitationConnection;
  /** A list of pending collaborator invitations across the repositories in the enterprise. */
  pendingCollaboratorInvitations: gh_RepositoryInvitationConnection;
  /** A list of pending member invitations for organizations in the enterprise. */
  pendingMemberInvitations: gh_EnterprisePendingMemberInvitationConnection;
  /** The setting value for whether repository projects are enabled in this enterprise. */
  repositoryProjectsSetting: gh_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided repository projects setting value. */
  repositoryProjectsSettingOrganizations: gh_OrganizationConnection;
  /** The SAML Identity Provider for the enterprise. */
  samlIdentityProvider?: Maybe<gh_EnterpriseIdentityProvider>;
  /** A list of enterprise organizations configured with the SAML single sign-on setting value. */
  samlIdentityProviderSettingOrganizations: gh_OrganizationConnection;
  /** A list of members with a support entitlement. */
  supportEntitlements: gh_EnterpriseMemberConnection;
  /** The setting value for whether team discussions are enabled for organizations in this enterprise. */
  teamDiscussionsSetting: gh_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided team discussions setting value. */
  teamDiscussionsSettingOrganizations: gh_OrganizationConnection;
  /** The setting value for whether the enterprise requires two-factor authentication for its organizations and users. */
  twoFactorRequiredSetting: gh_EnterpriseEnabledSettingValue;
  /** A list of enterprise organizations configured with the two-factor authentication setting value. */
  twoFactorRequiredSettingOrganizations: gh_OrganizationConnection;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfoadminsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<gh_EnterpriseAdministratorRole>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfoaffiliatedUsersWithTwoFactorDisabledArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfoallowPrivateRepositoryForkingSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfodefaultRepositoryPermissionSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: gh_DefaultRepositoryPermissionField;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfodomainsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  isApproved?: InputMaybe<Scalars['Boolean']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_VerifiableDomainOrder>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfoenterpriseServerInstallationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  connectedOnly?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_EnterpriseServerInstallationOrder>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfofailedInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfoipAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IpAllowListEntryOrder>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfomembersCanChangeRepositoryVisibilitySettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfomembersCanCreateRepositoriesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: gh_OrganizationMembersCanCreateRepositoriesSettingValue;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfomembersCanDeleteIssuesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfomembersCanDeleteRepositoriesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfomembersCanInviteCollaboratorsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfomembersCanUpdateProtectedBranchesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfomembersCanViewDependencyInsightsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfoorganizationProjectsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfooutsideCollaboratorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<gh_EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
  visibility?: InputMaybe<gh_RepositoryVisibility>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfopendingAdminInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_EnterpriseAdministratorInvitationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<gh_EnterpriseAdministratorRole>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfopendingCollaboratorInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_RepositoryInvitationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfopendingMemberInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  invitationSource?: InputMaybe<gh_OrganizationInvitationSource>;
  last?: InputMaybe<Scalars['Int']['input']>;
  organizationLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInforepositoryProjectsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfosamlIdentityProviderSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: gh_IdentityProviderConfigurationState;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfosupportEntitlementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_EnterpriseMemberOrder>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfoteamDiscussionsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_EnterpriseOwnerInfotwoFactorRequiredSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};

/** The connection type for OrganizationInvitation. */
export type gh_EnterprisePendingMemberInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterprisePendingMemberInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /** Identifies the total count of unique users in the connection. */
  totalUniqueUserCount: Scalars['Int']['output'];
};

/** An invitation to be a member in an enterprise organization. */
export type gh_EnterprisePendingMemberInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_OrganizationInvitation>;
};

/** A subset of repository information queryable from an enterprise. */
export type gh_EnterpriseRepositoryInfo = gh_Node & {
  /** The Node ID of the EnterpriseRepositoryInfo object */
  id: Scalars['ID']['output'];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars['Boolean']['output'];
  /** The repository's name. */
  name: Scalars['String']['output'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String']['output'];
};

/** The connection type for EnterpriseRepositoryInfo. */
export type gh_EnterpriseRepositoryInfoConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterpriseRepositoryInfoEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_EnterpriseRepositoryInfo>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_EnterpriseRepositoryInfoEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_EnterpriseRepositoryInfo>;
};

/** An Enterprise Server installation. */
export type gh_EnterpriseServerInstallation = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The customer name to which the Enterprise Server installation belongs. */
  customerName: Scalars['String']['output'];
  /** The host name of the Enterprise Server installation. */
  hostName: Scalars['String']['output'];
  /** The Node ID of the EnterpriseServerInstallation object */
  id: Scalars['ID']['output'];
  /** Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect. */
  isConnected: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** User accounts on this Enterprise Server installation. */
  userAccounts: gh_EnterpriseServerUserAccountConnection;
  /** User accounts uploads for the Enterprise Server installation. */
  userAccountsUploads: gh_EnterpriseServerUserAccountsUploadConnection;
};


/** An Enterprise Server installation. */
export type gh_EnterpriseServerInstallationuserAccountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_EnterpriseServerUserAccountOrder>;
};


/** An Enterprise Server installation. */
export type gh_EnterpriseServerInstallationuserAccountsUploadsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_EnterpriseServerUserAccountsUploadOrder>;
};

/** The connection type for EnterpriseServerInstallation. */
export type gh_EnterpriseServerInstallationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterpriseServerInstallationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_EnterpriseServerInstallation>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_EnterpriseServerInstallationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_EnterpriseServerInstallation>;
};

/** The connection type for EnterpriseServerInstallation. */
export type gh_EnterpriseServerInstallationMembershipConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterpriseServerInstallationMembershipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_EnterpriseServerInstallation>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An Enterprise Server installation that a user is a member of. */
export type gh_EnterpriseServerInstallationMembershipEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_EnterpriseServerInstallation>;
  /** The role of the user in the enterprise membership. */
  role: gh_EnterpriseUserAccountMembershipRole;
};

/** Ordering options for Enterprise Server installation connections. */
export type gh_EnterpriseServerInstallationOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order Enterprise Server installations by. */
  field: gh_EnterpriseServerInstallationOrderField;
};

/** Properties by which Enterprise Server installation connections can be ordered. */
export type gh_EnterpriseServerInstallationOrderField =
  /** Order Enterprise Server installations by creation time */
  | 'CREATED_AT'
  /** Order Enterprise Server installations by customer name */
  | 'CUSTOMER_NAME'
  /** Order Enterprise Server installations by host name */
  | 'HOST_NAME';

/** A user account on an Enterprise Server installation. */
export type gh_EnterpriseServerUserAccount = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** User emails belonging to this user account. */
  emails: gh_EnterpriseServerUserAccountEmailConnection;
  /** The Enterprise Server installation on which this user account exists. */
  enterpriseServerInstallation: gh_EnterpriseServerInstallation;
  /** The Node ID of the EnterpriseServerUserAccount object */
  id: Scalars['ID']['output'];
  /** Whether the user account is a site administrator on the Enterprise Server installation. */
  isSiteAdmin: Scalars['Boolean']['output'];
  /** The login of the user account on the Enterprise Server installation. */
  login: Scalars['String']['output'];
  /** The profile name of the user account on the Enterprise Server installation. */
  profileName?: Maybe<Scalars['String']['output']>;
  /** The date and time when the user account was created on the Enterprise Server installation. */
  remoteCreatedAt: Scalars['DateTime']['output'];
  /** The ID of the user account on the Enterprise Server installation. */
  remoteUserId: Scalars['Int']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};


/** A user account on an Enterprise Server installation. */
export type gh_EnterpriseServerUserAccountemailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_EnterpriseServerUserAccountEmailOrder>;
};

/** The connection type for EnterpriseServerUserAccount. */
export type gh_EnterpriseServerUserAccountConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterpriseServerUserAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_EnterpriseServerUserAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_EnterpriseServerUserAccountEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_EnterpriseServerUserAccount>;
};

/** An email belonging to a user account on an Enterprise Server installation. */
export type gh_EnterpriseServerUserAccountEmail = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The email address. */
  email: Scalars['String']['output'];
  /** The Node ID of the EnterpriseServerUserAccountEmail object */
  id: Scalars['ID']['output'];
  /** Indicates whether this is the primary email of the associated user account. */
  isPrimary: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The user account to which the email belongs. */
  userAccount: gh_EnterpriseServerUserAccount;
};

/** The connection type for EnterpriseServerUserAccountEmail. */
export type gh_EnterpriseServerUserAccountEmailConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterpriseServerUserAccountEmailEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_EnterpriseServerUserAccountEmail>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_EnterpriseServerUserAccountEmailEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_EnterpriseServerUserAccountEmail>;
};

/** Ordering options for Enterprise Server user account email connections. */
export type gh_EnterpriseServerUserAccountEmailOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order emails by. */
  field: gh_EnterpriseServerUserAccountEmailOrderField;
};

/** Properties by which Enterprise Server user account email connections can be ordered. */
export type gh_EnterpriseServerUserAccountEmailOrderField =
  /** Order emails by email */
  | 'EMAIL';

/** Ordering options for Enterprise Server user account connections. */
export type gh_EnterpriseServerUserAccountOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order user accounts by. */
  field: gh_EnterpriseServerUserAccountOrderField;
};

/** Properties by which Enterprise Server user account connections can be ordered. */
export type gh_EnterpriseServerUserAccountOrderField =
  /** Order user accounts by login */
  | 'LOGIN'
  /** Order user accounts by creation time on the Enterprise Server installation */
  | 'REMOTE_CREATED_AT';

/** A user accounts upload from an Enterprise Server installation. */
export type gh_EnterpriseServerUserAccountsUpload = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The enterprise to which this upload belongs. */
  enterprise: gh_Enterprise;
  /** The Enterprise Server installation for which this upload was generated. */
  enterpriseServerInstallation: gh_EnterpriseServerInstallation;
  /** The Node ID of the EnterpriseServerUserAccountsUpload object */
  id: Scalars['ID']['output'];
  /** The name of the file uploaded. */
  name: Scalars['String']['output'];
  /** The synchronization state of the upload */
  syncState: gh_EnterpriseServerUserAccountsUploadSyncState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for EnterpriseServerUserAccountsUpload. */
export type gh_EnterpriseServerUserAccountsUploadConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnterpriseServerUserAccountsUploadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_EnterpriseServerUserAccountsUpload>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_EnterpriseServerUserAccountsUploadEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_EnterpriseServerUserAccountsUpload>;
};

/** Ordering options for Enterprise Server user accounts upload connections. */
export type gh_EnterpriseServerUserAccountsUploadOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order user accounts uploads by. */
  field: gh_EnterpriseServerUserAccountsUploadOrderField;
};

/** Properties by which Enterprise Server user accounts upload connections can be ordered. */
export type gh_EnterpriseServerUserAccountsUploadOrderField =
  /** Order user accounts uploads by creation time */
  | 'CREATED_AT';

/** Synchronization state of the Enterprise Server user accounts upload */
export type gh_EnterpriseServerUserAccountsUploadSyncState =
  /** The synchronization of the upload failed. */
  | 'FAILURE'
  /** The synchronization of the upload is pending. */
  | 'PENDING'
  /** The synchronization of the upload succeeded. */
  | 'SUCCESS';

/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type gh_EnterpriseUserAccount = gh_Actor & gh_Node & {
  /** A URL pointing to the enterprise user account's public avatar. */
  avatarUrl: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The enterprise in which this user account exists. */
  enterprise: gh_Enterprise;
  /** A list of Enterprise Server installations this user is a member of. */
  enterpriseInstallations: gh_EnterpriseServerInstallationMembershipConnection;
  /** The Node ID of the EnterpriseUserAccount object */
  id: Scalars['ID']['output'];
  /** An identifier for the enterprise user account, a login or email address */
  login: Scalars['String']['output'];
  /** The name of the enterprise user account */
  name?: Maybe<Scalars['String']['output']>;
  /** A list of enterprise organizations this user is a member of. */
  organizations: gh_EnterpriseOrganizationMembershipConnection;
  /** The HTTP path for this user. */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this user. */
  url: Scalars['gh_URI']['output'];
  /** The user within the enterprise. */
  user?: Maybe<gh_User>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type gh_EnterpriseUserAccountavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type gh_EnterpriseUserAccountenterpriseInstallationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_EnterpriseServerInstallationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<gh_EnterpriseUserAccountMembershipRole>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type gh_EnterpriseUserAccountorganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<gh_EnterpriseUserAccountMembershipRole>;
};

/** The possible roles for enterprise membership. */
export type gh_EnterpriseUserAccountMembershipRole =
  /** The user is a member of an organization in the enterprise. */
  | 'MEMBER'
  /** The user is an owner of an organization in the enterprise. */
  | 'OWNER'
  /**
   * The user is not an owner of the enterprise, and not a member or owner of any
   * organizations in the enterprise; only for EMU-enabled enterprises.
   */
  | 'UNAFFILIATED';

/** The possible GitHub Enterprise deployments where this user can exist. */
export type gh_EnterpriseUserDeployment =
  /** The user is part of a GitHub Enterprise Cloud deployment. */
  | 'CLOUD'
  /** The user is part of a GitHub Enterprise Server deployment. */
  | 'SERVER';

/** An environment. */
export type gh_Environment = gh_Node & {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the Environment object */
  id: Scalars['ID']['output'];
  /** The name of the environment */
  name: Scalars['String']['output'];
  /** The protection rules defined for this environment */
  protectionRules: gh_DeploymentProtectionRuleConnection;
};


/** An environment. */
export type gh_EnvironmentprotectionRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Environment. */
export type gh_EnvironmentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_EnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Environment>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_EnvironmentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Environment>;
};

/** Properties by which environments connections can be ordered */
export type gh_EnvironmentOrderField =
  /** Order environments by name. */
  | 'NAME';

/** Ordering options for environments */
export type gh_Environments = {
  /** The direction in which to order environments by the specified field. */
  direction: gh_OrderDirection;
  /** The field to order environments by. */
  field: gh_EnvironmentOrderField;
};

/**
 * An external identity provisioned by SAML SSO or SCIM. If SAML is configured on
 * the organization, the external identity is visible to (1) organization owners,
 * (2) organization owners' personal access tokens (classic) with read:org or
 * admin:org scope, (3) GitHub App with an installation token with read or write
 * access to members. If SAML is configured on the enterprise, the external
 * identity is visible to (1) enterprise owners, (2) enterprise owners' personal
 * access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_ExternalIdentity = gh_Node & {
  /** The GUID for this identity */
  guid: Scalars['String']['output'];
  /** The Node ID of the ExternalIdentity object */
  id: Scalars['ID']['output'];
  /** Organization invitation for this SCIM-provisioned external identity */
  organizationInvitation?: Maybe<gh_OrganizationInvitation>;
  /** SAML Identity attributes */
  samlIdentity?: Maybe<gh_ExternalIdentitySamlAttributes>;
  /** SCIM Identity attributes */
  scimIdentity?: Maybe<gh_ExternalIdentityScimAttributes>;
  /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */
  user?: Maybe<gh_User>;
};

/** An attribute for the External Identity attributes collection */
export type gh_ExternalIdentityAttribute = {
  /** The attribute metadata as JSON */
  metadata?: Maybe<Scalars['String']['output']>;
  /** The attribute name */
  name: Scalars['String']['output'];
  /** The attribute value */
  value: Scalars['String']['output'];
};

/** The connection type for ExternalIdentity. */
export type gh_ExternalIdentityConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ExternalIdentityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ExternalIdentity>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ExternalIdentityEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ExternalIdentity>;
};

/** SAML attributes for the External Identity */
export type gh_ExternalIdentitySamlAttributes = {
  /** SAML Identity attributes */
  attributes: Array<gh_ExternalIdentityAttribute>;
  /** The emails associated with the SAML identity */
  emails?: Maybe<Array<gh_UserEmailMetadata>>;
  /** Family name of the SAML identity */
  familyName?: Maybe<Scalars['String']['output']>;
  /** Given name of the SAML identity */
  givenName?: Maybe<Scalars['String']['output']>;
  /** The groups linked to this identity in IDP */
  groups?: Maybe<Array<Scalars['String']['output']>>;
  /** The NameID of the SAML identity */
  nameId?: Maybe<Scalars['String']['output']>;
  /** The userName of the SAML identity */
  username?: Maybe<Scalars['String']['output']>;
};

/** SCIM attributes for the External Identity */
export type gh_ExternalIdentityScimAttributes = {
  /** The emails associated with the SCIM identity */
  emails?: Maybe<Array<gh_UserEmailMetadata>>;
  /** Family name of the SCIM identity */
  familyName?: Maybe<Scalars['String']['output']>;
  /** Given name of the SCIM identity */
  givenName?: Maybe<Scalars['String']['output']>;
  /** The groups linked to this identity in IDP */
  groups?: Maybe<Array<Scalars['String']['output']>>;
  /** The userName of the SCIM identity */
  username?: Maybe<Scalars['String']['output']>;
};

/**
 * A command to add a file at the given path with the given contents as part of a
 * commit.  Any existing file at that that path will be replaced.
 */
export type gh_FileAddition = {
  /** The base64 encoded contents of the file */
  contents: Scalars['gh_Base64String']['input'];
  /** The path in the repository where the file will be located */
  path: Scalars['String']['input'];
};

/**
 * A description of a set of changes to a file tree to be made as part of
 * a git commit, modeled as zero or more file `additions` and zero or more
 * file `deletions`.
 *
 * Both fields are optional; omitting both will produce a commit with no
 * file changes.
 *
 * `deletions` and `additions` describe changes to files identified
 * by their path in the git tree using unix-style path separators, i.e.
 * `/`.  The root of a git tree is an empty string, so paths are not
 * slash-prefixed.
 *
 * `path` values must be unique across all `additions` and `deletions`
 * provided.  Any duplication will result in a validation error.
 *
 * ### Encoding
 *
 * File contents must be provided in full for each `FileAddition`.
 *
 * The `contents` of a `FileAddition` must be encoded using RFC 4648
 * compliant base64, i.e. correct padding is required and no characters
 * outside the standard alphabet may be used.  Invalid base64
 * encoding will be rejected with a validation error.
 *
 * The encoded contents may be binary.
 *
 * For text files, no assumptions are made about the character encoding of
 * the file contents (after base64 decoding).  No charset transcoding or
 * line-ending normalization will be performed; it is the client's
 * responsibility to manage the character encoding of files they provide.
 * However, for maximum compatibility we recommend using UTF-8 encoding
 * and ensuring that all files in a repository use a consistent
 * line-ending convention (`\n` or `\r\n`), and that all files end
 * with a newline.
 *
 * ### Modeling file changes
 *
 * Each of the the five types of conceptual changes that can be made in a
 * git commit can be described using the `FileChanges` type as follows:
 *
 * 1. New file addition: create file `hello world\n` at path `docs/README.txt`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 * 2. Existing file modification: change existing `docs/README.txt` to have new
 *    content `new content here\n`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("new content here\n")
 *            }
 *          ]
 *        }
 *
 * 3. Existing file deletion: remove existing file `docs/README.txt`.
 *    Note that the path is required to exist -- specifying a
 *    path that does not exist on the given branch will abort the
 *    commit and return an error.
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt"
 *            }
 *          ]
 *        }
 *
 *
 * 4. File rename with no changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to the same content at
 *    `newdocs/README.txt`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 *
 * 5. File rename with changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to a file at path
 *    `newdocs/README.txt` with content `new contents\n`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("new contents\n")
 *            }
 *          ]
 *        }
 */
export type gh_FileChanges = {
  /** File to add or change. */
  additions?: InputMaybe<Array<gh_FileAddition>>;
  /** Files to delete. */
  deletions?: InputMaybe<Array<gh_FileDeletion>>;
};

/** A command to delete the file at the given path as part of a commit. */
export type gh_FileDeletion = {
  /** The path to delete */
  path: Scalars['String']['input'];
};

/** The possible viewed states of a file . */
export type gh_FileViewedState =
  /** The file has new changes since last viewed. */
  | 'DISMISSED'
  /** The file has not been marked as viewed. */
  | 'UNVIEWED'
  /** The file has been marked as viewed. */
  | 'VIEWED';

/** Autogenerated input type of FollowOrganization */
export type gh_FollowOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the organization to follow. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of FollowOrganization */
export type gh_FollowOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organization that was followed. */
  organization?: Maybe<gh_Organization>;
};

/** Autogenerated input type of FollowUser */
export type gh_FollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the user to follow. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of FollowUser */
export type gh_FollowUserPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The user that was followed. */
  user?: Maybe<gh_User>;
};

/** The connection type for User. */
export type gh_FollowerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_User>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The connection type for User. */
export type gh_FollowingConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_User>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A funding platform link for a repository. */
export type gh_FundingLink = {
  /** The funding platform this link is for. */
  platform: gh_FundingPlatform;
  /** The configured URL for this funding link. */
  url: Scalars['gh_URI']['output'];
};

/** The possible funding platforms for repository funding links. */
export type gh_FundingPlatform =
  /** Community Bridge funding platform. */
  | 'COMMUNITY_BRIDGE'
  /** Custom funding platform. */
  | 'CUSTOM'
  /** GitHub funding platform. */
  | 'GITHUB'
  /** IssueHunt funding platform. */
  | 'ISSUEHUNT'
  /** Ko-fi funding platform. */
  | 'KO_FI'
  /** LFX Crowdfunding funding platform. */
  | 'LFX_CROWDFUNDING'
  /** Liberapay funding platform. */
  | 'LIBERAPAY'
  /** Open Collective funding platform. */
  | 'OPEN_COLLECTIVE'
  /** Otechie funding platform. */
  | 'OTECHIE'
  /** Patreon funding platform. */
  | 'PATREON'
  /** Tidelift funding platform. */
  | 'TIDELIFT';

/** A generic hovercard context with a message and icon */
export type gh_GenericHovercardContext = gh_HovercardContext & {
  /** A string describing this context */
  message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  octicon: Scalars['String']['output'];
};

/** A Gist. */
export type gh_Gist = gh_Node & gh_Starrable & gh_UniformResourceLocatable & {
  /** A list of comments associated with the gist */
  comments: gh_GistCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The gist description. */
  description?: Maybe<Scalars['String']['output']>;
  /** The files in this gist. */
  files?: Maybe<Array<Maybe<gh_GistFile>>>;
  /** A list of forks associated with the gist */
  forks: gh_GistConnection;
  /** The Node ID of the Gist object */
  id: Scalars['ID']['output'];
  /** Identifies if the gist is a fork. */
  isFork: Scalars['Boolean']['output'];
  /** Whether the gist is public or not. */
  isPublic: Scalars['Boolean']['output'];
  /** The gist name. */
  name: Scalars['String']['output'];
  /** The gist owner. */
  owner?: Maybe<gh_RepositoryOwner>;
  /** Identifies when the gist was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The HTML path to this resource. */
  resourcePath: Scalars['gh_URI']['output'];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int']['output'];
  /** A list of users who have starred this starrable. */
  stargazers: gh_StargazerConnection;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this Gist. */
  url: Scalars['gh_URI']['output'];
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean']['output'];
};


/** A Gist. */
export type gh_GistcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A Gist. */
export type gh_GistfilesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  oid?: InputMaybe<Scalars['gh_GitObjectID']['input']>;
};


/** A Gist. */
export type gh_GistforksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_GistOrder>;
};


/** A Gist. */
export type gh_GiststargazersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_StarOrder>;
};

/** Represents a comment on an Gist. */
export type gh_GistComment = gh_Comment & gh_Deletable & gh_Minimizable & gh_Node & gh_Updatable & gh_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<gh_Actor>;
  /** Author's association with the gist. */
  authorAssociation: gh_CommentAuthorAssociation;
  /** Identifies the comment body. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<gh_Actor>;
  /** The associated gist. */
  gist: gh_Gist;
  /** The Node ID of the GistComment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<gh_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<gh_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** Represents a comment on an Gist. */
export type gh_GistCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for GistComment. */
export type gh_GistCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_GistCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_GistComment>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_GistCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_GistComment>;
};

/** The connection type for Gist. */
export type gh_GistConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_GistEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Gist>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_GistEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Gist>;
};

/** A file in a gist. */
export type gh_GistFile = {
  /** The file name encoded to remove characters that are invalid in URL paths. */
  encodedName?: Maybe<Scalars['String']['output']>;
  /** The gist file encoding. */
  encoding?: Maybe<Scalars['String']['output']>;
  /** The file extension from the file name. */
  extension?: Maybe<Scalars['String']['output']>;
  /** Indicates if this file is an image. */
  isImage: Scalars['Boolean']['output'];
  /** Whether the file's contents were truncated. */
  isTruncated: Scalars['Boolean']['output'];
  /** The programming language this file is written in. */
  language?: Maybe<gh_Language>;
  /** The gist file name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The gist file size in bytes. */
  size?: Maybe<Scalars['Int']['output']>;
  /** UTF8 text data or null if the file is binary */
  text?: Maybe<Scalars['String']['output']>;
};


/** A file in a gist. */
export type gh_GistFiletextArgs = {
  truncate?: InputMaybe<Scalars['Int']['input']>;
};

/** Ordering options for gist connections */
export type gh_GistOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order repositories by. */
  field: gh_GistOrderField;
};

/** Properties by which gist connections can be ordered. */
export type gh_GistOrderField =
  /** Order gists by creation time */
  | 'CREATED_AT'
  /** Order gists by push time */
  | 'PUSHED_AT'
  /** Order gists by update time */
  | 'UPDATED_AT';

/** The privacy of a Gist */
export type gh_GistPrivacy =
  /** Gists that are public and secret */
  | 'ALL'
  /** Public */
  | 'PUBLIC'
  /** Secret */
  | 'SECRET';

/** Represents an actor in a Git commit (ie. an author or committer). */
export type gh_GitActor = {
  /** A URL pointing to the author's public avatar. */
  avatarUrl: Scalars['gh_URI']['output'];
  /** The timestamp of the Git action (authoring or committing). */
  date?: Maybe<Scalars['gh_GitTimestamp']['output']>;
  /** The email in the Git commit. */
  email?: Maybe<Scalars['String']['output']>;
  /** The name in the Git commit. */
  name?: Maybe<Scalars['String']['output']>;
  /** The GitHub user corresponding to the email field. Null if no such user exists. */
  user?: Maybe<gh_User>;
};


/** Represents an actor in a Git commit (ie. an author or committer). */
export type gh_GitActoravatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for GitActor. */
export type gh_GitActorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_GitActorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_GitActor>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_GitActorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_GitActor>;
};

/** Represents information about the GitHub instance. */
export type gh_GitHubMetadata = {
  /** Returns a String that's a SHA of `github-services` */
  gitHubServicesSha: Scalars['gh_GitObjectID']['output'];
  /** IP addresses that users connect to for git operations */
  gitIpAddresses?: Maybe<Array<Scalars['String']['output']>>;
  /** IP addresses that GitHub Enterprise Importer uses for outbound connections */
  githubEnterpriseImporterIpAddresses?: Maybe<Array<Scalars['String']['output']>>;
  /** IP addresses that service hooks are sent from */
  hookIpAddresses?: Maybe<Array<Scalars['String']['output']>>;
  /** IP addresses that the importer connects from */
  importerIpAddresses?: Maybe<Array<Scalars['String']['output']>>;
  /** Whether or not users are verified */
  isPasswordAuthenticationVerifiable: Scalars['Boolean']['output'];
  /** IP addresses for GitHub Pages' A records */
  pagesIpAddresses?: Maybe<Array<Scalars['String']['output']>>;
};

/** Represents a Git object. */
export type gh_GitObject = {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String']['output'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['gh_URI']['output'];
  /** The Node ID of the GitObject object */
  id: Scalars['ID']['output'];
  /** The Git object ID */
  oid: Scalars['gh_GitObjectID']['output'];
  /** The Repository the Git object belongs to */
  repository: gh_Repository;
};

/** Information about a signature (GPG or S/MIME) on a Commit or Tag. */
export type gh_GitSignature = {
  /** Email used to sign this object. */
  email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean']['output'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<gh_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: gh_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** The state of a Git signature. */
export type gh_GitSignatureState =
  /** The signing certificate or its chain could not be verified */
  | 'BAD_CERT'
  /** Invalid email used for signing */
  | 'BAD_EMAIL'
  /** Signing key expired */
  | 'EXPIRED_KEY'
  /** Internal error - the GPG verification service misbehaved */
  | 'GPGVERIFY_ERROR'
  /** Internal error - the GPG verification service is unavailable at the moment */
  | 'GPGVERIFY_UNAVAILABLE'
  /** Invalid signature */
  | 'INVALID'
  /** Malformed signature */
  | 'MALFORMED_SIG'
  /** The usage flags for the key that signed this don't allow signing */
  | 'NOT_SIGNING_KEY'
  /** Email used for signing not known to GitHub */
  | 'NO_USER'
  /** Valid signature, though certificate revocation check failed */
  | 'OCSP_ERROR'
  /** Valid signature, pending certificate revocation checking */
  | 'OCSP_PENDING'
  /** One or more certificates in chain has been revoked */
  | 'OCSP_REVOKED'
  /** Key used for signing not known to GitHub */
  | 'UNKNOWN_KEY'
  /** Unknown signature type */
  | 'UNKNOWN_SIG_TYPE'
  /** Unsigned */
  | 'UNSIGNED'
  /** Email used for signing unverified on GitHub */
  | 'UNVERIFIED_EMAIL'
  /** Valid signature and verified by GitHub */
  | 'VALID';

/** Represents a GPG signature on a Commit or Tag. */
export type gh_GpgSignature = gh_GitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean']['output'];
  /** Hex-encoded ID of the key that signed this object. */
  keyId?: Maybe<Scalars['String']['output']>;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<gh_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: gh_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** Autogenerated input type of GrantEnterpriseOrganizationsMigratorRole */
export type gh_GrantEnterpriseOrganizationsMigratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of the user to grant the migrator role */
  login: Scalars['String']['input'];
};

/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */
export type gh_GrantEnterpriseOrganizationsMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organizations that had the migrator role applied to for the given user. */
  organizations?: Maybe<gh_OrganizationConnection>;
};


/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */
export type gh_GrantEnterpriseOrganizationsMigratorRolePayloadorganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of GrantMigratorRole */
export type gh_GrantMigratorRoleInput = {
  /** The user login or Team slug to grant the migrator role. */
  actor: Scalars['String']['input'];
  /** Specifies the type of the actor, can be either USER or TEAM. */
  actorType: gh_ActorType;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that the user/team belongs to. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of GrantMigratorRole */
export type gh_GrantMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Represents a 'head_ref_deleted' event on a given pull request. */
export type gh_HeadRefDeletedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the Ref associated with the `head_ref_deleted` event. */
  headRef?: Maybe<gh_Ref>;
  /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */
  headRefName: Scalars['String']['output'];
  /** The Node ID of the HeadRefDeletedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
};

/** Represents a 'head_ref_force_pushed' event on a given pull request. */
export type gh_HeadRefForcePushedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */
  afterCommit?: Maybe<gh_Commit>;
  /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */
  beforeCommit?: Maybe<gh_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the HeadRefForcePushedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
  /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */
  ref?: Maybe<gh_Ref>;
};

/** Represents a 'head_ref_restored' event on a given pull request. */
export type gh_HeadRefRestoredEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the HeadRefRestoredEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
};

/** Detail needed to display a hovercard for a user */
export type gh_Hovercard = {
  /** Each of the contexts for this hovercard */
  contexts: Array<gh_HovercardContext>;
};

/** An individual line of a hovercard */
export type gh_HovercardContext = {
  /** A string describing this context */
  message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  octicon: Scalars['String']['output'];
};

/** The possible states in which authentication can be configured with an identity provider. */
export type gh_IdentityProviderConfigurationState =
  /** Authentication with an identity provider is configured but not enforced. */
  | 'CONFIGURED'
  /** Authentication with an identity provider is configured and enforced. */
  | 'ENFORCED'
  /** Authentication with an identity provider is not configured. */
  | 'UNCONFIGURED';

/** Autogenerated input type of ImportProject */
export type gh_ImportProjectInput = {
  /** The description of Project. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A list of columns containing issues and pull requests. */
  columnImports: Array<gh_ProjectColumnImport>;
  /** The name of Project. */
  name: Scalars['String']['input'];
  /** The name of the Organization or User to create the Project under. */
  ownerName: Scalars['String']['input'];
  /** Whether the Project is public or not. */
  public?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of ImportProject */
export type gh_ImportProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new Project! */
  project?: Maybe<gh_Project>;
};

/** Autogenerated input type of InviteEnterpriseAdmin */
export type gh_InviteEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The email of the person to invite as an administrator. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise to which you want to invite an administrator. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of a user to invite as an administrator. */
  invitee?: InputMaybe<Scalars['String']['input']>;
  /** The role of the administrator. */
  role?: InputMaybe<gh_EnterpriseAdministratorRole>;
};

/** Autogenerated return type of InviteEnterpriseAdmin */
export type gh_InviteEnterpriseAdminPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The created enterprise administrator invitation. */
  invitation?: Maybe<gh_EnterpriseAdministratorInvitation>;
};

/** The possible values for the IP allow list enabled setting. */
export type gh_IpAllowListEnabledSettingValue =
  /** The setting is disabled for the owner. */
  | 'DISABLED'
  /** The setting is enabled for the owner. */
  | 'ENABLED';

/** An IP address or range of addresses that is allowed to access an owner's resources. */
export type gh_IpAllowListEntry = gh_Node & {
  /** A single IP address or range of IP addresses in CIDR notation. */
  allowListValue: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the IpAllowListEntry object */
  id: Scalars['ID']['output'];
  /** Whether the entry is currently active. */
  isActive: Scalars['Boolean']['output'];
  /** The name of the IP allow list entry. */
  name?: Maybe<Scalars['String']['output']>;
  /** The owner of the IP allow list entry. */
  owner: gh_IpAllowListOwner;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for IpAllowListEntry. */
export type gh_IpAllowListEntryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_IpAllowListEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_IpAllowListEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_IpAllowListEntryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_IpAllowListEntry>;
};

/** Ordering options for IP allow list entry connections. */
export type gh_IpAllowListEntryOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order IP allow list entries by. */
  field: gh_IpAllowListEntryOrderField;
};

/** Properties by which IP allow list entry connections can be ordered. */
export type gh_IpAllowListEntryOrderField =
  /** Order IP allow list entries by the allow list value. */
  | 'ALLOW_LIST_VALUE'
  /** Order IP allow list entries by creation time. */
  | 'CREATED_AT';

/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */
export type gh_IpAllowListForInstalledAppsEnabledSettingValue =
  /** The setting is disabled for the owner. */
  | 'DISABLED'
  /** The setting is enabled for the owner. */
  | 'ENABLED';

/** Types that can own an IP allow list. */
export type gh_IpAllowListOwner = gh_App | gh_Enterprise | gh_Organization;

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_Issue = gh_Assignable & gh_Closable & gh_Comment & gh_Deletable & gh_Labelable & gh_Lockable & gh_Node & gh_ProjectV2Owner & gh_Reactable & gh_RepositoryNode & gh_Subscribable & gh_SubscribableThread & gh_UniformResourceLocatable & gh_Updatable & gh_UpdatableComment & {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<gh_LockReason>;
  /** A list of Users assigned to this object. */
  assignees: gh_UserConnection;
  /** The actor who authored the comment. */
  author?: Maybe<gh_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: gh_CommentAuthorAssociation;
  /** Identifies the body of the issue. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** The http path for this issue body */
  bodyResourcePath: Scalars['gh_URI']['output'];
  /** Identifies the body of the issue rendered to text. */
  bodyText: Scalars['String']['output'];
  /** The http URL for this issue body */
  bodyUrl: Scalars['gh_URI']['output'];
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of comments associated with the Issue. */
  comments: gh_IssueCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<gh_Actor>;
  /** Identifies the primary key from the database as a BigInt. */
  fullDatabaseId?: Maybe<Scalars['BigInt']['output']>;
  /** The hovercard information for this issue */
  hovercard: gh_Hovercard;
  /** The Node ID of the Issue object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Indicates whether or not this issue is currently pinned to the repository issues list */
  isPinned?: Maybe<Scalars['Boolean']['output']>;
  /** Is this issue read by the viewer */
  isReadByViewer?: Maybe<Scalars['Boolean']['output']>;
  /** A list of labels associated with the object. */
  labels?: Maybe<gh_LabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Branches linked to this issue. */
  linkedBranches: gh_LinkedBranchConnection;
  /** `true` if the object is locked */
  locked: Scalars['Boolean']['output'];
  /** Identifies the milestone associated with the issue. */
  milestone?: Maybe<gh_Milestone>;
  /** Identifies the issue number. */
  number: Scalars['Int']['output'];
  /** A list of Users that are participating in the Issue conversation. */
  participants: gh_UserConnection;
  /** List of project cards associated with this issue. */
  projectCards: gh_ProjectCardConnection;
  /** List of project items associated with this issue. */
  projectItems: gh_ProjectV2ItemConnection;
  /** Find a project by number. */
  projectV2?: Maybe<gh_ProjectV2>;
  /** A list of projects under the owner. */
  projectsV2: gh_ProjectV2Connection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: gh_ReactionConnection;
  /** The repository associated with this node. */
  repository: gh_Repository;
  /** The HTTP path for this issue */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the state of the issue. */
  state: gh_IssueState;
  /** Identifies the reason for the issue state. */
  stateReason?: Maybe<gh_IssueStateReason>;
  /**
   * A list of events, comments, commits, etc. associated with the issue.
   * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.
   */
  timeline: gh_IssueTimelineConnection;
  /** A list of events, comments, commits, etc. associated with the issue. */
  timelineItems: gh_IssueTimelineItemsConnection;
  /** Identifies the issue title. */
  title: Scalars['String']['output'];
  /** Identifies the issue title rendered to HTML. */
  titleHTML: Scalars['String']['output'];
  /** A list of issues that track this issue */
  trackedInIssues: gh_IssueConnection;
  /** A list of issues tracked inside the current issue */
  trackedIssues: gh_IssueConnection;
  /** The number of tracked issues for this issue */
  trackedIssuesCount: Scalars['Int']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this issue */
  url: Scalars['gh_URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<gh_UserContentEditConnection>;
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<gh_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<gh_SubscriptionState>;
  /** Identifies the viewer's thread subscription form action. */
  viewerThreadSubscriptionFormAction?: Maybe<gh_ThreadSubscriptionFormAction>;
  /** Identifies the viewer's thread subscription status. */
  viewerThreadSubscriptionStatus?: Maybe<gh_ThreadSubscriptionState>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssueassigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssuecommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueCommentOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssuehovercardArgs = {
  includeNotificationContexts?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssuelabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_LabelOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssuelinkedBranchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssueparticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssueprojectCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedStates?: InputMaybe<Array<InputMaybe<gh_ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssueprojectItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssueprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssueprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssuereactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<gh_ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ReactionOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssuetimelineArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssuetimelineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  itemTypes?: InputMaybe<Array<gh_IssueTimelineItemsItemType>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssuetrackedInIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssuetrackedIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssuetrackedIssuesCountArgs = {
  states?: InputMaybe<Array<InputMaybe<gh_TrackedIssueStates>>>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type gh_IssueuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The possible state reasons of a closed issue. */
export type gh_IssueClosedStateReason =
  /** An issue that has been closed as completed */
  | 'COMPLETED'
  /** An issue that has been closed as not planned */
  | 'NOT_PLANNED';

/** Represents a comment on an Issue. */
export type gh_IssueComment = gh_Comment & gh_Deletable & gh_Minimizable & gh_Node & gh_Reactable & gh_RepositoryNode & gh_Updatable & gh_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<gh_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: gh_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<gh_Actor>;
  /** Identifies the primary key from the database as a BigInt. */
  fullDatabaseId?: Maybe<Scalars['BigInt']['output']>;
  /** The Node ID of the IssueComment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /** Identifies the issue associated with the comment. */
  issue: gh_Issue;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns the pull request associated with the comment, if this comment was made on a
   * pull request.
   */
  pullRequest?: Maybe<gh_PullRequest>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: gh_ReactionConnection;
  /** The repository associated with this node. */
  repository: gh_Repository;
  /** The HTTP path for this issue comment */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this issue comment */
  url: Scalars['gh_URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<gh_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<gh_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** Represents a comment on an Issue. */
export type gh_IssueCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<gh_ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ReactionOrder>;
};


/** Represents a comment on an Issue. */
export type gh_IssueCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for IssueComment. */
export type gh_IssueCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_IssueCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_IssueComment>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_IssueCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_IssueComment>;
};

/** Ways in which lists of issue comments can be ordered upon return. */
export type gh_IssueCommentOrder = {
  /** The direction in which to order issue comments by the specified field. */
  direction: gh_OrderDirection;
  /** The field in which to order issue comments by. */
  field: gh_IssueCommentOrderField;
};

/** Properties by which issue comment connections can be ordered. */
export type gh_IssueCommentOrderField =
  /** Order issue comments by update time */
  | 'UPDATED_AT';

/** The connection type for Issue. */
export type gh_IssueConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_IssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Issue>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** This aggregates issues opened by a user within one repository. */
export type gh_IssueContributionsByRepository = {
  /** The issue contributions. */
  contributions: gh_CreatedIssueContributionConnection;
  /** The repository in which the issues were opened. */
  repository: gh_Repository;
};


/** This aggregates issues opened by a user within one repository. */
export type gh_IssueContributionsByRepositorycontributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ContributionOrder>;
};

/** An edge in a connection. */
export type gh_IssueEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Issue>;
};

/** Ways in which to filter lists of issues. */
export type gh_IssueFilters = {
  /**
   * List issues assigned to given name. Pass in `null` for issues with no assigned
   * user, and `*` for issues assigned to any user.
   */
  assignee?: InputMaybe<Scalars['String']['input']>;
  /** List issues created by given name. */
  createdBy?: InputMaybe<Scalars['String']['input']>;
  /** List issues where the list of label names exist on the issue. */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List issues where the given name is mentioned in the issue. */
  mentioned?: InputMaybe<Scalars['String']['input']>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its database ID. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  milestone?: InputMaybe<Scalars['String']['input']>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its number field. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  milestoneNumber?: InputMaybe<Scalars['String']['input']>;
  /** List issues that have been updated at or after the given date. */
  since?: InputMaybe<Scalars['DateTime']['input']>;
  /** List issues filtered by the list of states given. */
  states?: InputMaybe<Array<gh_IssueState>>;
  /** List issues subscribed to by viewer. */
  viewerSubscribed?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Used for return value of Repository.issueOrPullRequest. */
export type gh_IssueOrPullRequest = gh_Issue | gh_PullRequest;

/** Ways in which lists of issues can be ordered upon return. */
export type gh_IssueOrder = {
  /** The direction in which to order issues by the specified field. */
  direction: gh_OrderDirection;
  /** The field in which to order issues by. */
  field: gh_IssueOrderField;
};

/** Properties by which issue connections can be ordered. */
export type gh_IssueOrderField =
  /** Order issues by comment count */
  | 'COMMENTS'
  /** Order issues by creation time */
  | 'CREATED_AT'
  /** Order issues by update time */
  | 'UPDATED_AT';

/** The possible states of an issue. */
export type gh_IssueState =
  /** An issue that has been closed */
  | 'CLOSED'
  /** An issue that is still open */
  | 'OPEN';

/** The possible state reasons of an issue. */
export type gh_IssueStateReason =
  /** An issue that has been closed as completed */
  | 'COMPLETED'
  /** An issue that has been closed as not planned */
  | 'NOT_PLANNED'
  /** An issue that has been reopened */
  | 'REOPENED';

/** A repository issue template. */
export type gh_IssueTemplate = {
  /** The template purpose. */
  about?: Maybe<Scalars['String']['output']>;
  /** The suggested assignees. */
  assignees: gh_UserConnection;
  /** The suggested issue body. */
  body?: Maybe<Scalars['String']['output']>;
  /** The template filename. */
  filename: Scalars['String']['output'];
  /** The suggested issue labels */
  labels?: Maybe<gh_LabelConnection>;
  /** The template name. */
  name: Scalars['String']['output'];
  /** The suggested issue title. */
  title?: Maybe<Scalars['String']['output']>;
};


/** A repository issue template. */
export type gh_IssueTemplateassigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository issue template. */
export type gh_IssueTemplatelabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_LabelOrder>;
};

/** The connection type for IssueTimelineItem. */
export type gh_IssueTimelineConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_IssueTimelineItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_IssueTimelineItem>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An item in an issue timeline */
export type gh_IssueTimelineItem = gh_AssignedEvent | gh_ClosedEvent | gh_Commit | gh_CrossReferencedEvent | gh_DemilestonedEvent | gh_IssueComment | gh_LabeledEvent | gh_LockedEvent | gh_MilestonedEvent | gh_ReferencedEvent | gh_RenamedTitleEvent | gh_ReopenedEvent | gh_SubscribedEvent | gh_TransferredEvent | gh_UnassignedEvent | gh_UnlabeledEvent | gh_UnlockedEvent | gh_UnsubscribedEvent | gh_UserBlockedEvent;

/** An edge in a connection. */
export type gh_IssueTimelineItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_IssueTimelineItem>;
};

/** An item in an issue timeline */
export type gh_IssueTimelineItems = gh_AddedToProjectEvent | gh_AssignedEvent | gh_ClosedEvent | gh_CommentDeletedEvent | gh_ConnectedEvent | gh_ConvertedNoteToIssueEvent | gh_ConvertedToDiscussionEvent | gh_CrossReferencedEvent | gh_DemilestonedEvent | gh_DisconnectedEvent | gh_IssueComment | gh_LabeledEvent | gh_LockedEvent | gh_MarkedAsDuplicateEvent | gh_MentionedEvent | gh_MilestonedEvent | gh_MovedColumnsInProjectEvent | gh_PinnedEvent | gh_ReferencedEvent | gh_RemovedFromProjectEvent | gh_RenamedTitleEvent | gh_ReopenedEvent | gh_SubscribedEvent | gh_TransferredEvent | gh_UnassignedEvent | gh_UnlabeledEvent | gh_UnlockedEvent | gh_UnmarkedAsDuplicateEvent | gh_UnpinnedEvent | gh_UnsubscribedEvent | gh_UserBlockedEvent;

/** The connection type for IssueTimelineItems. */
export type gh_IssueTimelineItemsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_IssueTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars['Int']['output'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_IssueTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars['Int']['output'];
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** An edge in a connection. */
export type gh_IssueTimelineItemsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_IssueTimelineItems>;
};

/** The possible item types found in a timeline. */
export type gh_IssueTimelineItemsItemType =
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  | 'ADDED_TO_PROJECT_EVENT'
  /** Represents an 'assigned' event on any assignable object. */
  | 'ASSIGNED_EVENT'
  /** Represents a 'closed' event on any `Closable`. */
  | 'CLOSED_EVENT'
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  | 'COMMENT_DELETED_EVENT'
  /** Represents a 'connected' event on a given issue or pull request. */
  | 'CONNECTED_EVENT'
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  | 'CONVERTED_NOTE_TO_ISSUE_EVENT'
  /** Represents a 'converted_to_discussion' event on a given issue. */
  | 'CONVERTED_TO_DISCUSSION_EVENT'
  /** Represents a mention made by one issue or pull request to another. */
  | 'CROSS_REFERENCED_EVENT'
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  | 'DEMILESTONED_EVENT'
  /** Represents a 'disconnected' event on a given issue or pull request. */
  | 'DISCONNECTED_EVENT'
  /** Represents a comment on an Issue. */
  | 'ISSUE_COMMENT'
  /** Represents a 'labeled' event on a given issue or pull request. */
  | 'LABELED_EVENT'
  /** Represents a 'locked' event on a given issue or pull request. */
  | 'LOCKED_EVENT'
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  | 'MARKED_AS_DUPLICATE_EVENT'
  /** Represents a 'mentioned' event on a given issue or pull request. */
  | 'MENTIONED_EVENT'
  /** Represents a 'milestoned' event on a given issue or pull request. */
  | 'MILESTONED_EVENT'
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  | 'MOVED_COLUMNS_IN_PROJECT_EVENT'
  /** Represents a 'pinned' event on a given issue or pull request. */
  | 'PINNED_EVENT'
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  | 'REFERENCED_EVENT'
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  | 'REMOVED_FROM_PROJECT_EVENT'
  /** Represents a 'renamed' event on a given issue or pull request */
  | 'RENAMED_TITLE_EVENT'
  /** Represents a 'reopened' event on any `Closable`. */
  | 'REOPENED_EVENT'
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  | 'SUBSCRIBED_EVENT'
  /** Represents a 'transferred' event on a given issue or pull request. */
  | 'TRANSFERRED_EVENT'
  /** Represents an 'unassigned' event on any assignable object. */
  | 'UNASSIGNED_EVENT'
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  | 'UNLABELED_EVENT'
  /** Represents an 'unlocked' event on a given issue or pull request. */
  | 'UNLOCKED_EVENT'
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  | 'UNMARKED_AS_DUPLICATE_EVENT'
  /** Represents an 'unpinned' event on a given issue or pull request. */
  | 'UNPINNED_EVENT'
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  | 'UNSUBSCRIBED_EVENT'
  /** Represents a 'user_blocked' event on a given user. */
  | 'USER_BLOCKED_EVENT';

/** Represents a user signing up for a GitHub account. */
export type gh_JoinedGitHubContribution = gh_Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['gh_URI']['output'];
  /** The user who made this contribution. */
  user: gh_User;
};

/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type gh_Label = gh_Node & {
  /** Identifies the label color. */
  color: Scalars['String']['output'];
  /** Identifies the date and time when the label was created. */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** A brief description of this label. */
  description?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the Label object */
  id: Scalars['ID']['output'];
  /** Indicates whether or not this is a default label. */
  isDefault: Scalars['Boolean']['output'];
  /** A list of issues associated with this label. */
  issues: gh_IssueConnection;
  /** Identifies the label name. */
  name: Scalars['String']['output'];
  /** A list of pull requests associated with this label. */
  pullRequests: gh_PullRequestConnection;
  /** The repository associated with this label. */
  repository: gh_Repository;
  /** The HTTP path for this label. */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the label was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The HTTP URL for this label. */
  url: Scalars['gh_URI']['output'];
};


/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type gh_LabelissuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<gh_IssueFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueOrder>;
  states?: InputMaybe<Array<gh_IssueState>>;
};


/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type gh_LabelpullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueOrder>;
  states?: InputMaybe<Array<gh_PullRequestState>>;
};

/** The connection type for Label. */
export type gh_LabelConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_LabelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Label>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_LabelEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Label>;
};

/** Ways in which lists of labels can be ordered upon return. */
export type gh_LabelOrder = {
  /** The direction in which to order labels by the specified field. */
  direction: gh_OrderDirection;
  /** The field in which to order labels by. */
  field: gh_LabelOrderField;
};

/** Properties by which label connections can be ordered. */
export type gh_LabelOrderField =
  /** Order labels by creation time */
  | 'CREATED_AT'
  /** Order labels by name */
  | 'NAME';

/** An object that can have labels assigned to it. */
export type gh_Labelable = {
  /** A list of labels associated with the object. */
  labels?: Maybe<gh_LabelConnection>;
};


/** An object that can have labels assigned to it. */
export type gh_LabelablelabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_LabelOrder>;
};

/** Represents a 'labeled' event on a given issue or pull request. */
export type gh_LabeledEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the LabeledEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the label associated with the 'labeled' event. */
  label: gh_Label;
  /** Identifies the `Labelable` associated with the event. */
  labelable: gh_Labelable;
};

/** Represents a given language found in repositories. */
export type gh_Language = gh_Node & {
  /** The color defined for the current language. */
  color?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the Language object */
  id: Scalars['ID']['output'];
  /** The name of the current language. */
  name: Scalars['String']['output'];
};

/** A list of languages associated with the parent. */
export type gh_LanguageConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_LanguageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Language>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /** The total size in bytes of files written in that language. */
  totalSize: Scalars['Int']['output'];
};

/** Represents the language of a repository. */
export type gh_LanguageEdge = {
  cursor: Scalars['String']['output'];
  node: gh_Language;
  /** The number of bytes of code written in the language. */
  size: Scalars['Int']['output'];
};

/** Ordering options for language connections. */
export type gh_LanguageOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order languages by. */
  field: gh_LanguageOrderField;
};

/** Properties by which language connections can be ordered. */
export type gh_LanguageOrderField =
  /** Order languages by the size of all files containing the language */
  | 'SIZE';

/** A repository's open source license */
export type gh_License = gh_Node & {
  /** The full text of the license */
  body: Scalars['String']['output'];
  /** The conditions set by the license */
  conditions: Array<Maybe<gh_LicenseRule>>;
  /** A human-readable description of the license */
  description?: Maybe<Scalars['String']['output']>;
  /** Whether the license should be featured */
  featured: Scalars['Boolean']['output'];
  /** Whether the license should be displayed in license pickers */
  hidden: Scalars['Boolean']['output'];
  /** The Node ID of the License object */
  id: Scalars['ID']['output'];
  /** Instructions on how to implement the license */
  implementation?: Maybe<Scalars['String']['output']>;
  /** The lowercased SPDX ID of the license */
  key: Scalars['String']['output'];
  /** The limitations set by the license */
  limitations: Array<Maybe<gh_LicenseRule>>;
  /** The license full name specified by <https://spdx.org/licenses> */
  name: Scalars['String']['output'];
  /** Customary short name if applicable (e.g, GPLv3) */
  nickname?: Maybe<Scalars['String']['output']>;
  /** The permissions set by the license */
  permissions: Array<Maybe<gh_LicenseRule>>;
  /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */
  pseudoLicense: Scalars['Boolean']['output'];
  /** Short identifier specified by <https://spdx.org/licenses> */
  spdxId?: Maybe<Scalars['String']['output']>;
  /** URL to the license on <https://choosealicense.com> */
  url?: Maybe<Scalars['gh_URI']['output']>;
};

/** Describes a License's conditions, permissions, and limitations */
export type gh_LicenseRule = {
  /** A description of the rule */
  description: Scalars['String']['output'];
  /** The machine-readable rule key */
  key: Scalars['String']['output'];
  /** The human-readable rule label */
  label: Scalars['String']['output'];
};

/** Autogenerated input type of LinkProjectV2ToRepository */
export type gh_LinkProjectV2ToRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to link to the repository. */
  projectId: Scalars['ID']['input'];
  /** The ID of the repository to link to the project. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of LinkProjectV2ToRepository */
export type gh_LinkProjectV2ToRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository the project is linked to. */
  repository?: Maybe<gh_Repository>;
};

/** Autogenerated input type of LinkProjectV2ToTeam */
export type gh_LinkProjectV2ToTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to link to the team. */
  projectId: Scalars['ID']['input'];
  /** The ID of the team to link to the project. */
  teamId: Scalars['ID']['input'];
};

/** Autogenerated return type of LinkProjectV2ToTeam */
export type gh_LinkProjectV2ToTeamPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The team the project is linked to */
  team?: Maybe<gh_Team>;
};

/** Autogenerated input type of LinkRepositoryToProject */
export type gh_LinkRepositoryToProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to link to a Repository */
  projectId: Scalars['ID']['input'];
  /** The ID of the Repository to link to a Project. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of LinkRepositoryToProject */
export type gh_LinkRepositoryToProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The linked Project. */
  project?: Maybe<gh_Project>;
  /** The linked Repository. */
  repository?: Maybe<gh_Repository>;
};

/** A branch linked to an issue. */
export type gh_LinkedBranch = gh_Node & {
  /** The Node ID of the LinkedBranch object */
  id: Scalars['ID']['output'];
  /** The branch's ref. */
  ref?: Maybe<gh_Ref>;
};

/** The connection type for LinkedBranch. */
export type gh_LinkedBranchConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_LinkedBranchEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_LinkedBranch>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_LinkedBranchEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_LinkedBranch>;
};

/** Autogenerated input type of LockLockable */
export type gh_LockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A reason for why the item will be locked. */
  lockReason?: InputMaybe<gh_LockReason>;
  /** ID of the item to be locked. */
  lockableId: Scalars['ID']['input'];
};

/** Autogenerated return type of LockLockable */
export type gh_LockLockablePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was locked. */
  lockedRecord?: Maybe<gh_Lockable>;
};

/** The possible reasons that an issue or pull request was locked. */
export type gh_LockReason =
  /** The issue or pull request was locked because the conversation was off-topic. */
  | 'OFF_TOPIC'
  /** The issue or pull request was locked because the conversation was resolved. */
  | 'RESOLVED'
  /** The issue or pull request was locked because the conversation was spam. */
  | 'SPAM'
  /** The issue or pull request was locked because the conversation was too heated. */
  | 'TOO_HEATED';

/** An object that can be locked. */
export type gh_Lockable = {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<gh_LockReason>;
  /** `true` if the object is locked */
  locked: Scalars['Boolean']['output'];
};

/** Represents a 'locked' event on a given issue or pull request. */
export type gh_LockedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the LockedEvent object */
  id: Scalars['ID']['output'];
  /** Reason that the conversation was locked (optional). */
  lockReason?: Maybe<gh_LockReason>;
  /** Object that was locked. */
  lockable: gh_Lockable;
};

/** A placeholder user for attribution of imported data on GitHub. */
export type gh_Mannequin = gh_Actor & gh_Node & gh_UniformResourceLocatable & {
  /** A URL pointing to the GitHub App's public avatar. */
  avatarUrl: Scalars['gh_URI']['output'];
  /** The user that has claimed the data attributed to this mannequin. */
  claimant?: Maybe<gh_User>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The mannequin's email on the source instance. */
  email?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the Mannequin object */
  id: Scalars['ID']['output'];
  /** The username of the actor. */
  login: Scalars['String']['output'];
  /** The HTML path to this resource. */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The URL to this resource. */
  url: Scalars['gh_URI']['output'];
};


/** A placeholder user for attribution of imported data on GitHub. */
export type gh_MannequinavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Mannequin. */
export type gh_MannequinConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_MannequinEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Mannequin>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a mannequin. */
export type gh_MannequinEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Mannequin>;
};

/** Ordering options for mannequins. */
export type gh_MannequinOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order mannequins by. */
  field: gh_MannequinOrderField;
};

/** Properties by which mannequins can be ordered. */
export type gh_MannequinOrderField =
  /** Order mannequins why when they were created. */
  | 'CREATED_AT'
  /** Order mannequins alphabetically by their source login. */
  | 'LOGIN';

/** Autogenerated input type of MarkDiscussionCommentAsAnswer */
export type gh_MarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion comment to mark as an answer. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of MarkDiscussionCommentAsAnswer */
export type gh_MarkDiscussionCommentAsAnswerPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that includes the chosen comment. */
  discussion?: Maybe<gh_Discussion>;
};

/** Autogenerated input type of MarkFileAsViewed */
export type gh_MarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The path of the file to mark as viewed */
  path: Scalars['String']['input'];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of MarkFileAsViewed */
export type gh_MarkFileAsViewedPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Autogenerated input type of MarkProjectV2AsTemplate */
export type gh_MarkProjectV2AsTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to mark as a template. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of MarkProjectV2AsTemplate */
export type gh_MarkProjectV2AsTemplatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The project. */
  projectV2?: Maybe<gh_ProjectV2>;
};

/** Autogenerated input type of MarkPullRequestReadyForReview */
export type gh_MarkPullRequestReadyForReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to be marked as ready for review. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of MarkPullRequestReadyForReview */
export type gh_MarkPullRequestReadyForReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that is ready for review. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
export type gh_MarkedAsDuplicateEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** The authoritative issue or pull request which has been duplicated by another. */
  canonical?: Maybe<gh_IssueOrPullRequest>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The issue or pull request which has been marked as a duplicate of another. */
  duplicate?: Maybe<gh_IssueOrPullRequest>;
  /** The Node ID of the MarkedAsDuplicateEvent object */
  id: Scalars['ID']['output'];
  /** Canonical and duplicate belong to different repositories. */
  isCrossRepository: Scalars['Boolean']['output'];
};

/** A public description of a Marketplace category. */
export type gh_MarketplaceCategory = gh_Node & {
  /** The category's description. */
  description?: Maybe<Scalars['String']['output']>;
  /** The technical description of how apps listed in this category work with GitHub. */
  howItWorks?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the MarketplaceCategory object */
  id: Scalars['ID']['output'];
  /** The category's name. */
  name: Scalars['String']['output'];
  /** How many Marketplace listings have this as their primary category. */
  primaryListingCount: Scalars['Int']['output'];
  /** The HTTP path for this Marketplace category. */
  resourcePath: Scalars['gh_URI']['output'];
  /** How many Marketplace listings have this as their secondary category. */
  secondaryListingCount: Scalars['Int']['output'];
  /** The short name of the category used in its URL. */
  slug: Scalars['String']['output'];
  /** The HTTP URL for this Marketplace category. */
  url: Scalars['gh_URI']['output'];
};

/** A listing in the GitHub integration marketplace. */
export type gh_MarketplaceListing = gh_Node & {
  /** The GitHub App this listing represents. */
  app?: Maybe<gh_App>;
  /** URL to the listing owner's company site. */
  companyUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP path for configuring access to the listing's integration or OAuth app */
  configurationResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for configuring access to the listing's integration or OAuth app */
  configurationUrl: Scalars['gh_URI']['output'];
  /** URL to the listing's documentation. */
  documentationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The listing's detailed description. */
  extendedDescription?: Maybe<Scalars['String']['output']>;
  /** The listing's detailed description rendered to HTML. */
  extendedDescriptionHTML: Scalars['gh_HTML']['output'];
  /** The listing's introductory description. */
  fullDescription: Scalars['String']['output'];
  /** The listing's introductory description rendered to HTML. */
  fullDescriptionHTML: Scalars['gh_HTML']['output'];
  /** Does this listing have any plans with a free trial? */
  hasPublishedFreeTrialPlans: Scalars['Boolean']['output'];
  /** Does this listing have a terms of service link? */
  hasTermsOfService: Scalars['Boolean']['output'];
  /** Whether the creator of the app is a verified org */
  hasVerifiedOwner: Scalars['Boolean']['output'];
  /** A technical description of how this app works with GitHub. */
  howItWorks?: Maybe<Scalars['String']['output']>;
  /** The listing's technical description rendered to HTML. */
  howItWorksHTML: Scalars['gh_HTML']['output'];
  /** The Node ID of the MarketplaceListing object */
  id: Scalars['ID']['output'];
  /** URL to install the product to the viewer's account or organization. */
  installationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** Whether this listing's app has been installed for the current viewer */
  installedForViewer: Scalars['Boolean']['output'];
  /** Whether this listing has been removed from the Marketplace. */
  isArchived: Scalars['Boolean']['output'];
  /**
   * Whether this listing is still an editable draft that has not been submitted
   * for review and is not publicly visible in the Marketplace.
   */
  isDraft: Scalars['Boolean']['output'];
  /** Whether the product this listing represents is available as part of a paid plan. */
  isPaid: Scalars['Boolean']['output'];
  /** Whether this listing has been approved for display in the Marketplace. */
  isPublic: Scalars['Boolean']['output'];
  /** Whether this listing has been rejected by GitHub for display in the Marketplace. */
  isRejected: Scalars['Boolean']['output'];
  /** Whether this listing has been approved for unverified display in the Marketplace. */
  isUnverified: Scalars['Boolean']['output'];
  /** Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace. */
  isUnverifiedPending: Scalars['Boolean']['output'];
  /** Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromDraft: Scalars['Boolean']['output'];
  /** Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromUnverified: Scalars['Boolean']['output'];
  /** Whether this listing has been approved for verified display in the Marketplace. */
  isVerified: Scalars['Boolean']['output'];
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars['String']['output'];
  /** URL for the listing's logo image. */
  logoUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The listing's full name. */
  name: Scalars['String']['output'];
  /** The listing's very short description without a trailing period or ampersands. */
  normalizedShortDescription: Scalars['String']['output'];
  /** URL to the listing's detailed pricing. */
  pricingUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The category that best describes the listing. */
  primaryCategory: gh_MarketplaceCategory;
  /** URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL. */
  privacyPolicyUrl: Scalars['gh_URI']['output'];
  /** The HTTP path for the Marketplace listing. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The URLs for the listing's screenshots. */
  screenshotUrls: Array<Maybe<Scalars['String']['output']>>;
  /** An alternate category that describes the listing. */
  secondaryCategory?: Maybe<gh_MarketplaceCategory>;
  /** The listing's very short description. */
  shortDescription: Scalars['String']['output'];
  /** The short name of the listing used in its URL. */
  slug: Scalars['String']['output'];
  /** URL to the listing's status page. */
  statusUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** An email address for support for this listing's app. */
  supportEmail?: Maybe<Scalars['String']['output']>;
  /**
   * Either a URL or an email address for support for this listing's app, may
   * return an empty string for listings that do not require a support URL.
   */
  supportUrl: Scalars['gh_URI']['output'];
  /** URL to the listing's terms of service. */
  termsOfServiceUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the Marketplace listing. */
  url: Scalars['gh_URI']['output'];
  /** Can the current viewer add plans for this Marketplace listing. */
  viewerCanAddPlans: Scalars['Boolean']['output'];
  /** Can the current viewer approve this Marketplace listing. */
  viewerCanApprove: Scalars['Boolean']['output'];
  /** Can the current viewer delist this Marketplace listing. */
  viewerCanDelist: Scalars['Boolean']['output'];
  /** Can the current viewer edit this Marketplace listing. */
  viewerCanEdit: Scalars['Boolean']['output'];
  /**
   * Can the current viewer edit the primary and secondary category of this
   * Marketplace listing.
   */
  viewerCanEditCategories: Scalars['Boolean']['output'];
  /** Can the current viewer edit the plans for this Marketplace listing. */
  viewerCanEditPlans: Scalars['Boolean']['output'];
  /**
   * Can the current viewer return this Marketplace listing to draft state
   * so it becomes editable again.
   */
  viewerCanRedraft: Scalars['Boolean']['output'];
  /**
   * Can the current viewer reject this Marketplace listing by returning it to
   * an editable draft state or rejecting it entirely.
   */
  viewerCanReject: Scalars['Boolean']['output'];
  /**
   * Can the current viewer request this listing be reviewed for display in
   * the Marketplace as verified.
   */
  viewerCanRequestApproval: Scalars['Boolean']['output'];
  /** Indicates whether the current user has an active subscription to this Marketplace listing. */
  viewerHasPurchased: Scalars['Boolean']['output'];
  /**
   * Indicates if the current user has purchased a subscription to this Marketplace listing
   * for all of the organizations the user owns.
   */
  viewerHasPurchasedForAllOrganizations: Scalars['Boolean']['output'];
  /** Does the current viewer role allow them to administer this Marketplace listing. */
  viewerIsListingAdmin: Scalars['Boolean']['output'];
};


/** A listing in the GitHub integration marketplace. */
export type gh_MarketplaceListinglogoUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** Look up Marketplace Listings */
export type gh_MarketplaceListingConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_MarketplaceListingEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_MarketplaceListing>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_MarketplaceListingEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_MarketplaceListing>;
};

/** Represents a member feature request notification */
export type gh_MemberFeatureRequestNotification = gh_Node & {
  /** Represents member feature request body containing organization name and the number of feature requests */
  body: Scalars['String']['output'];
  /** The Node ID of the MemberFeatureRequestNotification object */
  id: Scalars['ID']['output'];
  /** Represents member feature request notification title */
  title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** Entities that have members who can set status messages. */
export type gh_MemberStatusable = {
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: gh_UserStatusConnection;
};


/** Entities that have members who can set status messages. */
export type gh_MemberStatusablememberStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_UserStatusOrder>;
};

/** Audit log entry for a members_can_delete_repos.clear event. */
export type gh_MembersCanDeleteReposClearAuditEntry = gh_AuditEntry & gh_EnterpriseAuditEntryData & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The Node ID of the MembersCanDeleteReposClearAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a members_can_delete_repos.disable event. */
export type gh_MembersCanDeleteReposDisableAuditEntry = gh_AuditEntry & gh_EnterpriseAuditEntryData & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The Node ID of the MembersCanDeleteReposDisableAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a members_can_delete_repos.enable event. */
export type gh_MembersCanDeleteReposEnableAuditEntry = gh_AuditEntry & gh_EnterpriseAuditEntryData & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The Node ID of the MembersCanDeleteReposEnableAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Represents a 'mentioned' event on a given issue or pull request. */
export type gh_MentionedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the MentionedEvent object */
  id: Scalars['ID']['output'];
};

/** Autogenerated input type of MergeBranch */
export type gh_MergeBranchInput = {
  /** The email address to associate with this commit. */
  authorEmail?: InputMaybe<Scalars['String']['input']>;
  /** The name of the base branch that the provided head will be merged into. */
  base: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Message to use for the merge commit. If omitted, a default will be used. */
  commitMessage?: InputMaybe<Scalars['String']['input']>;
  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */
  head: Scalars['String']['input'];
  /** The Node ID of the Repository containing the base branch that will be modified. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of MergeBranch */
export type gh_MergeBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The resulting merge Commit. */
  mergeCommit?: Maybe<gh_Commit>;
};

/** The possible default commit messages for merges. */
export type gh_MergeCommitMessage =
  /** Default to a blank commit message. */
  | 'BLANK'
  /** Default to the pull request's body. */
  | 'PR_BODY'
  /** Default to the pull request's title. */
  | 'PR_TITLE';

/** The possible default commit titles for merges. */
export type gh_MergeCommitTitle =
  /** Default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name). */
  | 'MERGE_MESSAGE'
  /** Default to the pull request's title. */
  | 'PR_TITLE';

/** Autogenerated input type of MergePullRequest */
export type gh_MergePullRequestInput = {
  /** The email address to associate with this merge. */
  authorEmail?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Commit body to use for the merge commit; if omitted, a default message will be used */
  commitBody?: InputMaybe<Scalars['String']['input']>;
  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */
  commitHeadline?: InputMaybe<Scalars['String']['input']>;
  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */
  expectedHeadOid?: InputMaybe<Scalars['gh_GitObjectID']['input']>;
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  mergeMethod?: InputMaybe<gh_PullRequestMergeMethod>;
  /** ID of the pull request to be merged. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of MergePullRequest */
export type gh_MergePullRequestPayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that was merged. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** The queue of pull request entries to be merged into a protected branch in a repository. */
export type gh_MergeQueue = gh_Node & {
  /** The configuration for this merge queue */
  configuration?: Maybe<gh_MergeQueueConfiguration>;
  /** The entries in the queue */
  entries?: Maybe<gh_MergeQueueEntryConnection>;
  /** The Node ID of the MergeQueue object */
  id: Scalars['ID']['output'];
  /** The estimated time in seconds until a newly added entry would be merged */
  nextEntryEstimatedTimeToMerge?: Maybe<Scalars['Int']['output']>;
  /** The repository this merge queue belongs to */
  repository?: Maybe<gh_Repository>;
  /** The HTTP path for this merge queue */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this merge queue */
  url: Scalars['gh_URI']['output'];
};


/** The queue of pull request entries to be merged into a protected branch in a repository. */
export type gh_MergeQueueentriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Configuration for a MergeQueue */
export type gh_MergeQueueConfiguration = {
  /** The amount of time in minutes to wait for a check response before considering it a failure. */
  checkResponseTimeout?: Maybe<Scalars['Int']['output']>;
  /** The maximum number of entries to build at once. */
  maximumEntriesToBuild?: Maybe<Scalars['Int']['output']>;
  /** The maximum number of entries to merge at once. */
  maximumEntriesToMerge?: Maybe<Scalars['Int']['output']>;
  /** The merge method to use for this queue. */
  mergeMethod?: Maybe<gh_PullRequestMergeMethod>;
  /** The strategy to use when merging entries. */
  mergingStrategy?: Maybe<gh_MergeQueueMergingStrategy>;
  /** The minimum number of entries required to merge at once. */
  minimumEntriesToMerge?: Maybe<Scalars['Int']['output']>;
  /**
   * The amount of time in minutes to wait before ignoring the minumum number of
   * entries in the queue requirement and merging a collection of entries
   */
  minimumEntriesToMergeWaitTime?: Maybe<Scalars['Int']['output']>;
};

/** Entries in a MergeQueue */
export type gh_MergeQueueEntry = gh_Node & {
  /** The base commit for this entry */
  baseCommit?: Maybe<gh_Commit>;
  /** The date and time this entry was added to the merge queue */
  enqueuedAt: Scalars['DateTime']['output'];
  /** The actor that enqueued this entry */
  enqueuer: gh_Actor;
  /** The estimated time in seconds until this entry will be merged */
  estimatedTimeToMerge?: Maybe<Scalars['Int']['output']>;
  /** The head commit for this entry */
  headCommit?: Maybe<gh_Commit>;
  /** The Node ID of the MergeQueueEntry object */
  id: Scalars['ID']['output'];
  /** Whether this pull request should jump the queue */
  jump: Scalars['Boolean']['output'];
  /** The merge queue that this entry belongs to */
  mergeQueue?: Maybe<gh_MergeQueue>;
  /** The position of this entry in the queue */
  position: Scalars['Int']['output'];
  /** The pull request that will be added to a merge group */
  pullRequest?: Maybe<gh_PullRequest>;
  /** Does this pull request need to be deployed on its own */
  solo: Scalars['Boolean']['output'];
  /** The state of this entry in the queue */
  state: gh_MergeQueueEntryState;
};

/** The connection type for MergeQueueEntry. */
export type gh_MergeQueueEntryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_MergeQueueEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_MergeQueueEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_MergeQueueEntryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_MergeQueueEntry>;
};

/** The possible states for a merge queue entry. */
export type gh_MergeQueueEntryState =
  /** The entry is currently waiting for checks to pass. */
  | 'AWAITING_CHECKS'
  /** The entry is currently locked. */
  | 'LOCKED'
  /** The entry is currently mergeable. */
  | 'MERGEABLE'
  /** The entry is currently queued. */
  | 'QUEUED'
  /** The entry is currently unmergeable. */
  | 'UNMERGEABLE';

/** The possible merging strategies for a merge queue. */
export type gh_MergeQueueMergingStrategy =
  /** Entries only allowed to merge if they are passing. */
  | 'ALLGREEN'
  /** Failing Entires are allowed to merge if they are with a passing entry. */
  | 'HEADGREEN';

/** Detailed status information about a pull request merge. */
export type gh_MergeStateStatus =
  /** The head ref is out of date. */
  | 'BEHIND'
  /** The merge is blocked. */
  | 'BLOCKED'
  /** Mergeable and passing commit status. */
  | 'CLEAN'
  /** The merge commit cannot be cleanly created. */
  | 'DIRTY'
  /** The merge is blocked due to the pull request being a draft. */
  | 'DRAFT'
  /** Mergeable with passing commit status and pre-receive hooks. */
  | 'HAS_HOOKS'
  /** The state cannot currently be determined. */
  | 'UNKNOWN'
  /** Mergeable with non-passing commit status. */
  | 'UNSTABLE';

/** Whether or not a PullRequest can be merged. */
export type gh_MergeableState =
  /** The pull request cannot be merged due to merge conflicts. */
  | 'CONFLICTING'
  /** The pull request can be merged. */
  | 'MERGEABLE'
  /** The mergeability of the pull request is still being calculated. */
  | 'UNKNOWN';

/** Represents a 'merged' event on a given pull request. */
export type gh_MergedEvent = gh_Node & gh_UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the commit associated with the `merge` event. */
  commit?: Maybe<gh_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the MergedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the Ref associated with the `merge` event. */
  mergeRef?: Maybe<gh_Ref>;
  /** Identifies the name of the Ref associated with the `merge` event. */
  mergeRefName: Scalars['String']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
  /** The HTTP path for this merged event. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this merged event. */
  url: Scalars['gh_URI']['output'];
};

/** Represents a GitHub Enterprise Importer (GEI) migration. */
export type gh_Migration = {
  /** The migration flag to continue on error. */
  continueOnError: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['String']['output']>;
  /** The reason the migration failed. */
  failureReason?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the Migration object */
  id: Scalars['ID']['output'];
  /** The URL for the migration log (expires 1 day after migration completes). */
  migrationLogUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The migration source. */
  migrationSource: gh_MigrationSource;
  /** The target repository name. */
  repositoryName: Scalars['String']['output'];
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  sourceUrl: Scalars['gh_URI']['output'];
  /** The migration state. */
  state: gh_MigrationState;
  /**
   * The number of warnings encountered for this migration. To review the warnings,
   * check the [Migration Log](https://docs.github.com/en/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).
   */
  warningsCount: Scalars['Int']['output'];
};

/** A GitHub Enterprise Importer (GEI) migration source. */
export type gh_MigrationSource = gh_Node & {
  /** The Node ID of the MigrationSource object */
  id: Scalars['ID']['output'];
  /** The migration source name. */
  name: Scalars['String']['output'];
  /** The migration source type. */
  type: gh_MigrationSourceType;
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  url: Scalars['gh_URI']['output'];
};

/** Represents the different GitHub Enterprise Importer (GEI) migration sources. */
export type gh_MigrationSourceType =
  /** An Azure DevOps migration source. */
  | 'AZURE_DEVOPS'
  /** A Bitbucket Server migration source. */
  | 'BITBUCKET_SERVER'
  /** A GitHub Migration API source. */
  | 'GITHUB_ARCHIVE';

/** The GitHub Enterprise Importer (GEI) migration state. */
export type gh_MigrationState =
  /** The migration has failed. */
  | 'FAILED'
  /** The migration has invalid credentials. */
  | 'FAILED_VALIDATION'
  /** The migration is in progress. */
  | 'IN_PROGRESS'
  /** The migration has not started. */
  | 'NOT_STARTED'
  /** The migration needs to have its credentials validated. */
  | 'PENDING_VALIDATION'
  /** The migration has been queued. */
  | 'QUEUED'
  /** The migration has succeeded. */
  | 'SUCCEEDED';

/** Represents a Milestone object on a given repository. */
export type gh_Milestone = gh_Closable & gh_Node & gh_UniformResourceLocatable & {
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the actor who created the milestone. */
  creator?: Maybe<gh_Actor>;
  /** Identifies the description of the milestone. */
  description?: Maybe<Scalars['String']['output']>;
  /** Identifies the due date of the milestone. */
  dueOn?: Maybe<Scalars['DateTime']['output']>;
  /** The Node ID of the Milestone object */
  id: Scalars['ID']['output'];
  /** A list of issues associated with the milestone. */
  issues: gh_IssueConnection;
  /** Identifies the number of the milestone. */
  number: Scalars['Int']['output'];
  /** Identifies the percentage complete for the milestone */
  progressPercentage: Scalars['Float']['output'];
  /** A list of pull requests associated with the milestone. */
  pullRequests: gh_PullRequestConnection;
  /** The repository associated with this milestone. */
  repository: gh_Repository;
  /** The HTTP path for this milestone */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the state of the milestone. */
  state: gh_MilestoneState;
  /** Identifies the title of the milestone. */
  title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this milestone */
  url: Scalars['gh_URI']['output'];
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
};


/** Represents a Milestone object on a given repository. */
export type gh_MilestoneissuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<gh_IssueFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueOrder>;
  states?: InputMaybe<Array<gh_IssueState>>;
};


/** Represents a Milestone object on a given repository. */
export type gh_MilestonepullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueOrder>;
  states?: InputMaybe<Array<gh_PullRequestState>>;
};

/** The connection type for Milestone. */
export type gh_MilestoneConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_MilestoneEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Milestone>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_MilestoneEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Milestone>;
};

/** Types that can be inside a Milestone. */
export type gh_MilestoneItem = gh_Issue | gh_PullRequest;

/** Ordering options for milestone connections. */
export type gh_MilestoneOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order milestones by. */
  field: gh_MilestoneOrderField;
};

/** Properties by which milestone connections can be ordered. */
export type gh_MilestoneOrderField =
  /** Order milestones by when they were created. */
  | 'CREATED_AT'
  /** Order milestones by when they are due. */
  | 'DUE_DATE'
  /** Order milestones by their number. */
  | 'NUMBER'
  /** Order milestones by when they were last updated. */
  | 'UPDATED_AT';

/** The possible states of a milestone. */
export type gh_MilestoneState =
  /** A milestone that has been closed. */
  | 'CLOSED'
  /** A milestone that is still open. */
  | 'OPEN';

/** Represents a 'milestoned' event on a given issue or pull request. */
export type gh_MilestonedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the MilestonedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the milestone title associated with the 'milestoned' event. */
  milestoneTitle: Scalars['String']['output'];
  /** Object referenced by event. */
  subject: gh_MilestoneItem;
};

/** Entities that can be minimized. */
export type gh_Minimizable = {
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
};

/** Autogenerated input type of MinimizeComment */
export type gh_MinimizeCommentInput = {
  /** The classification of comment */
  classifier: gh_ReportedContentClassifiers;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of MinimizeComment */
export type gh_MinimizeCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The comment that was minimized. */
  minimizedComment?: Maybe<gh_Minimizable>;
};

/** Autogenerated input type of MoveProjectCard */
export type gh_MoveProjectCardInput = {
  /** Place the new card after the card with this id. Pass null to place it at the top. */
  afterCardId?: InputMaybe<Scalars['ID']['input']>;
  /** The id of the card to move. */
  cardId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the column to move it into. */
  columnId: Scalars['ID']['input'];
};

/** Autogenerated return type of MoveProjectCard */
export type gh_MoveProjectCardPayload = {
  /** The new edge of the moved card. */
  cardEdge?: Maybe<gh_ProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of MoveProjectColumn */
export type gh_MoveProjectColumnInput = {
  /** Place the new column after the column with this id. Pass null to place it at the front. */
  afterColumnId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the column to move. */
  columnId: Scalars['ID']['input'];
};

/** Autogenerated return type of MoveProjectColumn */
export type gh_MoveProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new edge of the moved column. */
  columnEdge?: Maybe<gh_ProjectColumnEdge>;
};

/** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
export type gh_MovedColumnsInProjectEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the MovedColumnsInProjectEvent object */
  id: Scalars['ID']['output'];
  /** Column name the issue or pull request was moved from. */
  previousProjectColumnName: Scalars['String']['output'];
  /** Project referenced by event. */
  project?: Maybe<gh_Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<gh_ProjectCard>;
  /** Column name the issue or pull request was moved to. */
  projectColumnName: Scalars['String']['output'];
};

/** An object with an ID. */
export type gh_Node = {
  /** ID of the object. */
  id: Scalars['ID']['output'];
};

/** The possible values for the notification restriction setting. */
export type gh_NotificationRestrictionSettingValue =
  /** The setting is disabled for the owner. */
  | 'DISABLED'
  /** The setting is enabled for the owner. */
  | 'ENABLED';

/**
 * An OIDC identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_OIDCProvider = gh_Node & {
  /** The enterprise this identity provider belongs to. */
  enterprise?: Maybe<gh_Enterprise>;
  /** ExternalIdentities provisioned by this identity provider. */
  externalIdentities: gh_ExternalIdentityConnection;
  /** The Node ID of the OIDCProvider object */
  id: Scalars['ID']['output'];
  /** The OIDC identity provider type */
  providerType: gh_OIDCProviderType;
  /** The id of the tenant this provider is attached to */
  tenantId: Scalars['String']['output'];
};


/**
 * An OIDC identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
export type gh_OIDCProviderexternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  membersOnly?: InputMaybe<Scalars['Boolean']['input']>;
  userName?: InputMaybe<Scalars['String']['input']>;
};

/** The OIDC identity provider type */
export type gh_OIDCProviderType =
  /** Azure Active Directory */
  | 'AAD';

/** Metadata for an audit entry with action oauth_application.* */
export type gh_OauthApplicationAuditEntryData = {
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a oauth_application.create event. */
export type gh_OauthApplicationCreateAuditEntry = gh_AuditEntry & gh_Node & gh_OauthApplicationAuditEntryData & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The application URL of the OAuth application. */
  applicationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The callback URL of the OAuth application. */
  callbackUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OauthApplicationCreateAuditEntry object */
  id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The rate limit of the OAuth application. */
  rateLimit?: Maybe<Scalars['Int']['output']>;
  /** The state of the OAuth application. */
  state?: Maybe<gh_OauthApplicationCreateAuditEntryState>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** The state of an OAuth application when it was created. */
export type gh_OauthApplicationCreateAuditEntryState =
  /** The OAuth application was active and allowed to have OAuth Accesses. */
  | 'ACTIVE'
  /** The OAuth application was in the process of being deleted. */
  | 'PENDING_DELETION'
  /** The OAuth application was suspended from generating OAuth Accesses due to abuse or security concerns. */
  | 'SUSPENDED';

/** The corresponding operation type for the action */
export type gh_OperationType =
  /** An existing resource was accessed */
  | 'ACCESS'
  /** A resource performed an authentication event */
  | 'AUTHENTICATION'
  /** A new resource was created */
  | 'CREATE'
  /** An existing resource was modified */
  | 'MODIFY'
  /** An existing resource was removed */
  | 'REMOVE'
  /** An existing resource was restored */
  | 'RESTORE'
  /** An existing resource was transferred between multiple resources */
  | 'TRANSFER';

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export type gh_OrderDirection =
  /** Specifies an ascending order for a given `orderBy` argument. */
  | 'ASC'
  /** Specifies a descending order for a given `orderBy` argument. */
  | 'DESC';

/** Audit log entry for a org.add_billing_manager */
export type gh_OrgAddBillingManagerAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgAddBillingManagerAuditEntry object */
  id: Scalars['ID']['output'];
  /** The email address used to invite a billing manager for the organization. */
  invitationEmail?: Maybe<Scalars['String']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.add_member */
export type gh_OrgAddMemberAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgAddMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The permission level of the member added to the organization. */
  permission?: Maybe<gh_OrgAddMemberAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** The permissions available to members on an Organization. */
export type gh_OrgAddMemberAuditEntryPermission =
  /** Can read, clone, push, and add collaborators to repositories. */
  | 'ADMIN'
  /** Can read and clone repositories. */
  | 'READ';

/** Audit log entry for a org.block_user */
export type gh_OrgBlockUserAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The blocked user. */
  blockedUser?: Maybe<gh_User>;
  /** The username of the blocked user. */
  blockedUserName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the blocked user. */
  blockedUserResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the blocked user. */
  blockedUserUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgBlockUserAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.config.disable_collaborators_only event. */
export type gh_OrgConfigDisableCollaboratorsOnlyAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgConfigDisableCollaboratorsOnlyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.config.enable_collaborators_only event. */
export type gh_OrgConfigEnableCollaboratorsOnlyAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgConfigEnableCollaboratorsOnlyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.create event. */
export type gh_OrgCreateAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The billing plan for the Organization. */
  billingPlan?: Maybe<gh_OrgCreateAuditEntryBillingPlan>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgCreateAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** The billing plans available for organizations. */
export type gh_OrgCreateAuditEntryBillingPlan =
  /** Team Plan */
  | 'BUSINESS'
  /** Enterprise Cloud Plan */
  | 'BUSINESS_PLUS'
  /** Free Plan */
  | 'FREE'
  /** Tiered Per Seat Plan */
  | 'TIERED_PER_SEAT'
  /** Legacy Unlimited Plan */
  | 'UNLIMITED';

/** Audit log entry for a org.disable_oauth_app_restrictions event. */
export type gh_OrgDisableOauthAppRestrictionsAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgDisableOauthAppRestrictionsAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.disable_saml event. */
export type gh_OrgDisableSamlAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The SAML provider's digest algorithm URL. */
  digestMethodUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The Node ID of the OrgDisableSamlAuditEntry object */
  id: Scalars['ID']['output'];
  /** The SAML provider's issuer URL. */
  issuerUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The SAML provider's signature algorithm URL. */
  signatureMethodUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The SAML provider's single sign-on URL. */
  singleSignOnUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.disable_two_factor_requirement event. */
export type gh_OrgDisableTwoFactorRequirementAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgDisableTwoFactorRequirementAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.enable_oauth_app_restrictions event. */
export type gh_OrgEnableOauthAppRestrictionsAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgEnableOauthAppRestrictionsAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.enable_saml event. */
export type gh_OrgEnableSamlAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The SAML provider's digest algorithm URL. */
  digestMethodUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The Node ID of the OrgEnableSamlAuditEntry object */
  id: Scalars['ID']['output'];
  /** The SAML provider's issuer URL. */
  issuerUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The SAML provider's signature algorithm URL. */
  signatureMethodUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The SAML provider's single sign-on URL. */
  singleSignOnUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.enable_two_factor_requirement event. */
export type gh_OrgEnableTwoFactorRequirementAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgEnableTwoFactorRequirementAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Ordering options for an organization's enterprise owner connections. */
export type gh_OrgEnterpriseOwnerOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order enterprise owners by. */
  field: gh_OrgEnterpriseOwnerOrderField;
};

/** Properties by which enterprise owners can be ordered. */
export type gh_OrgEnterpriseOwnerOrderField =
  /** Order enterprise owners by login. */
  | 'LOGIN';

/** Audit log entry for a org.invite_member event. */
export type gh_OrgInviteMemberAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The email address of the organization invitation. */
  email?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the OrgInviteMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The organization invitation. */
  organizationInvitation?: Maybe<gh_OrganizationInvitation>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.invite_to_business event. */
export type gh_OrgInviteToBusinessAuditEntry = gh_AuditEntry & gh_EnterpriseAuditEntryData & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The Node ID of the OrgInviteToBusinessAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_approved event. */
export type gh_OrgOauthAppAccessApprovedAuditEntry = gh_AuditEntry & gh_Node & gh_OauthApplicationAuditEntryData & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgOauthAppAccessApprovedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_blocked event. */
export type gh_OrgOauthAppAccessBlockedAuditEntry = gh_AuditEntry & gh_Node & gh_OauthApplicationAuditEntryData & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgOauthAppAccessBlockedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_denied event. */
export type gh_OrgOauthAppAccessDeniedAuditEntry = gh_AuditEntry & gh_Node & gh_OauthApplicationAuditEntryData & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgOauthAppAccessDeniedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_requested event. */
export type gh_OrgOauthAppAccessRequestedAuditEntry = gh_AuditEntry & gh_Node & gh_OauthApplicationAuditEntryData & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgOauthAppAccessRequestedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_unblocked event. */
export type gh_OrgOauthAppAccessUnblockedAuditEntry = gh_AuditEntry & gh_Node & gh_OauthApplicationAuditEntryData & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgOauthAppAccessUnblockedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  oauthApplicationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the OAuth application */
  oauthApplicationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.remove_billing_manager event. */
export type gh_OrgRemoveBillingManagerAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgRemoveBillingManagerAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The reason for the billing manager being removed. */
  reason?: Maybe<gh_OrgRemoveBillingManagerAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** The reason a billing manager was removed from an Organization. */
export type gh_OrgRemoveBillingManagerAuditEntryReason =
  /** SAML external identity missing */
  | 'SAML_EXTERNAL_IDENTITY_MISSING'
  /** SAML SSO enforcement requires an external identity */
  | 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY'
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  | 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';

/** Audit log entry for a org.remove_member event. */
export type gh_OrgRemoveMemberAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgRemoveMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The types of membership the member has with the organization. */
  membershipTypes?: Maybe<Array<gh_OrgRemoveMemberAuditEntryMembershipType>>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The reason for the member being removed. */
  reason?: Maybe<gh_OrgRemoveMemberAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** The type of membership a user has with an Organization. */
export type gh_OrgRemoveMemberAuditEntryMembershipType =
  /**
   * Organization owners have full access and can change several settings,
   * including the names of repositories that belong to the Organization and Owners
   * team membership. In addition, organization owners can delete the organization
   * and all of its repositories.
   */
  | 'ADMIN'
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  | 'BILLING_MANAGER'
  /** A direct member is a user that is a member of the Organization. */
  | 'DIRECT_MEMBER'
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  | 'OUTSIDE_COLLABORATOR'
  /** A suspended member. */
  | 'SUSPENDED'
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the Organization.
   */
  | 'UNAFFILIATED';

/** The reason a member was removed from an Organization. */
export type gh_OrgRemoveMemberAuditEntryReason =
  /** SAML external identity missing */
  | 'SAML_EXTERNAL_IDENTITY_MISSING'
  /** SAML SSO enforcement requires an external identity */
  | 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY'
  /** User was removed from organization during account recovery */
  | 'TWO_FACTOR_ACCOUNT_RECOVERY'
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  | 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'
  /** User account has been deleted */
  | 'USER_ACCOUNT_DELETED';

/** Audit log entry for a org.remove_outside_collaborator event. */
export type gh_OrgRemoveOutsideCollaboratorAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgRemoveOutsideCollaboratorAuditEntry object */
  id: Scalars['ID']['output'];
  /** The types of membership the outside collaborator has with the organization. */
  membershipTypes?: Maybe<Array<gh_OrgRemoveOutsideCollaboratorAuditEntryMembershipType>>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The reason for the outside collaborator being removed from the Organization. */
  reason?: Maybe<gh_OrgRemoveOutsideCollaboratorAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** The type of membership a user has with an Organization. */
export type gh_OrgRemoveOutsideCollaboratorAuditEntryMembershipType =
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  | 'BILLING_MANAGER'
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  | 'OUTSIDE_COLLABORATOR'
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the organization.
   */
  | 'UNAFFILIATED';

/** The reason an outside collaborator was removed from an Organization. */
export type gh_OrgRemoveOutsideCollaboratorAuditEntryReason =
  /** SAML external identity missing */
  | 'SAML_EXTERNAL_IDENTITY_MISSING'
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  | 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';

/** Audit log entry for a org.restore_member event. */
export type gh_OrgRestoreMemberAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgRestoreMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The number of custom email routings for the restored member. */
  restoredCustomEmailRoutingsCount?: Maybe<Scalars['Int']['output']>;
  /** The number of issue assignments for the restored member. */
  restoredIssueAssignmentsCount?: Maybe<Scalars['Int']['output']>;
  /** Restored organization membership objects. */
  restoredMemberships?: Maybe<Array<gh_OrgRestoreMemberAuditEntryMembership>>;
  /** The number of restored memberships. */
  restoredMembershipsCount?: Maybe<Scalars['Int']['output']>;
  /** The number of repositories of the restored member. */
  restoredRepositoriesCount?: Maybe<Scalars['Int']['output']>;
  /** The number of starred repositories for the restored member. */
  restoredRepositoryStarsCount?: Maybe<Scalars['Int']['output']>;
  /** The number of watched repositories for the restored member. */
  restoredRepositoryWatchesCount?: Maybe<Scalars['Int']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Types of memberships that can be restored for an Organization member. */
export type gh_OrgRestoreMemberAuditEntryMembership = gh_OrgRestoreMemberMembershipOrganizationAuditEntryData | gh_OrgRestoreMemberMembershipRepositoryAuditEntryData | gh_OrgRestoreMemberMembershipTeamAuditEntryData;

/** Metadata for an organization membership for org.restore_member actions */
export type gh_OrgRestoreMemberMembershipOrganizationAuditEntryData = gh_OrganizationAuditEntryData & {
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Metadata for a repository membership for org.restore_member actions */
export type gh_OrgRestoreMemberMembershipRepositoryAuditEntryData = gh_RepositoryAuditEntryData & {
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Metadata for a team membership for org.restore_member actions */
export type gh_OrgRestoreMemberMembershipTeamAuditEntryData = gh_TeamAuditEntryData & {
  /** The team associated with the action */
  team?: Maybe<gh_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.unblock_user */
export type gh_OrgUnblockUserAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user being unblocked by the organization. */
  blockedUser?: Maybe<gh_User>;
  /** The username of the blocked user. */
  blockedUserName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the blocked user. */
  blockedUserResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the blocked user. */
  blockedUserUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgUnblockUserAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a org.update_default_repository_permission */
export type gh_OrgUpdateDefaultRepositoryPermissionAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgUpdateDefaultRepositoryPermissionAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The new base repository permission level for the organization. */
  permission?: Maybe<gh_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
  /** The former base repository permission level for the organization. */
  permissionWas?: Maybe<gh_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** The default permission a repository can have in an Organization. */
export type gh_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission =
  /** Can read, clone, push, and add collaborators to repositories. */
  | 'ADMIN'
  /** No default permission value. */
  | 'NONE'
  /** Can read and clone repositories. */
  | 'READ'
  /** Can read, clone and push to repositories. */
  | 'WRITE';

/** Audit log entry for a org.update_member event. */
export type gh_OrgUpdateMemberAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgUpdateMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The new member permission level for the organization. */
  permission?: Maybe<gh_OrgUpdateMemberAuditEntryPermission>;
  /** The former member permission level for the organization. */
  permissionWas?: Maybe<gh_OrgUpdateMemberAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** The permissions available to members on an Organization. */
export type gh_OrgUpdateMemberAuditEntryPermission =
  /** Can read, clone, push, and add collaborators to repositories. */
  | 'ADMIN'
  /** Can read and clone repositories. */
  | 'READ';

/** Audit log entry for a org.update_member_repository_creation_permission event. */
export type gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** Can members create repositories in the organization. */
  canCreateRepositories?: Maybe<Scalars['Boolean']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgUpdateMemberRepositoryCreationPermissionAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The permission for visibility level of repositories for this organization. */
  visibility?: Maybe<gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility>;
};

/** The permissions available for repository creation on an Organization. */
export type gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility =
  /** All organization members are restricted from creating any repositories. */
  | 'ALL'
  /** All organization members are restricted from creating internal repositories. */
  | 'INTERNAL'
  /** All organization members are allowed to create any repositories. */
  | 'NONE'
  /** All organization members are restricted from creating private repositories. */
  | 'PRIVATE'
  /** All organization members are restricted from creating private or internal repositories. */
  | 'PRIVATE_INTERNAL'
  /** All organization members are restricted from creating public repositories. */
  | 'PUBLIC'
  /** All organization members are restricted from creating public or internal repositories. */
  | 'PUBLIC_INTERNAL'
  /** All organization members are restricted from creating public or private repositories. */
  | 'PUBLIC_PRIVATE';

/** Audit log entry for a org.update_member_repository_invitation_permission event. */
export type gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** Can outside collaborators be invited to repositories in the organization. */
  canInviteOutsideCollaboratorsToRepositories?: Maybe<Scalars['Boolean']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the OrgUpdateMemberRepositoryInvitationPermissionAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_Organization = gh_Actor & gh_AnnouncementBanner & gh_MemberStatusable & gh_Node & gh_PackageOwner & gh_ProfileOwner & gh_ProjectOwner & gh_ProjectV2Owner & gh_ProjectV2Recent & gh_RepositoryDiscussionAuthor & gh_RepositoryDiscussionCommentAuthor & gh_RepositoryOwner & gh_Sponsorable & gh_UniformResourceLocatable & {
  /** The text of the announcement */
  announcement?: Maybe<Scalars['String']['output']>;
  /** The expiration date of the announcement, if any */
  announcementExpiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether the announcement can be dismissed by the user */
  announcementUserDismissible?: Maybe<Scalars['Boolean']['output']>;
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean']['output'];
  /** Identifies the date and time when the organization was archived. */
  archivedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Audit log entries of the organization */
  auditLog: gh_OrganizationAuditEntryConnection;
  /** A URL pointing to the organization's public avatar. */
  avatarUrl: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The organization's public profile description. */
  description?: Maybe<Scalars['String']['output']>;
  /** The organization's public profile description rendered to HTML. */
  descriptionHTML?: Maybe<Scalars['String']['output']>;
  /** A list of domains owned by the organization. */
  domains?: Maybe<gh_VerifiableDomainConnection>;
  /** The organization's public email. */
  email?: Maybe<Scalars['String']['output']>;
  /** A list of owners of the organization's enterprise account. */
  enterpriseOwners: gh_OrganizationEnterpriseOwnerConnection;
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars['Int']['output'];
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars['Boolean']['output'];
  /** The Node ID of the Organization object */
  id: Scalars['ID']['output'];
  /** The interaction ability settings for this organization. */
  interactionAbility?: Maybe<gh_RepositoryInteractionAbility>;
  /** The setting value for whether the organization has an IP allow list enabled. */
  ipAllowListEnabledSetting: gh_IpAllowListEnabledSettingValue;
  /** The IP addresses that are allowed to access resources owned by the organization. */
  ipAllowListEntries: gh_IpAllowListEntryConnection;
  /** The setting value for whether the organization has IP allow list configuration for installed GitHub Apps enabled. */
  ipAllowListForInstalledAppsEnabledSetting: gh_IpAllowListForInstalledAppsEnabledSettingValue;
  /** Whether the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars['Boolean']['output'];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars['Boolean']['output'];
  /** Whether the organization has verified its profile email and website. */
  isVerified: Scalars['Boolean']['output'];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: gh_ProfileItemShowcase;
  /** The organization's public profile location. */
  location?: Maybe<Scalars['String']['output']>;
  /** The organization's login name. */
  login: Scalars['String']['output'];
  /** A list of all mannequins for this organization. */
  mannequins: gh_MannequinConnection;
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: gh_UserStatusConnection;
  /** Members can fork private repositories in this organization */
  membersCanForkPrivateRepositories: Scalars['Boolean']['output'];
  /** A list of users who are members of this organization. */
  membersWithRole: gh_OrganizationMemberConnection;
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']['output'];
  /** The organization's public profile name. */
  name?: Maybe<Scalars['String']['output']>;
  /** The HTTP path creating a new team */
  newTeamResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL creating a new team */
  newTeamUrl: Scalars['gh_URI']['output'];
  /** Indicates if email notification delivery for this organization is restricted to verified or approved domains. */
  notificationDeliveryRestrictionEnabledSetting: gh_NotificationRestrictionSettingValue;
  /** The billing email for the organization. */
  organizationBillingEmail?: Maybe<Scalars['String']['output']>;
  /** A list of packages under the owner. */
  packages: gh_PackageConnection;
  /** A list of users who have been invited to join this organization. */
  pendingMembers: gh_UserConnection;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: gh_PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: gh_PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int']['output'];
  /** Find project by number. */
  project?: Maybe<gh_Project>;
  /** Find a project by number. */
  projectV2?: Maybe<gh_ProjectV2>;
  /** A list of projects under the owner. */
  projects: gh_ProjectConnection;
  /** The HTTP path listing organization's projects */
  projectsResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL listing organization's projects */
  projectsUrl: Scalars['gh_URI']['output'];
  /** A list of projects under the owner. */
  projectsV2: gh_ProjectV2Connection;
  /** Recent projects that this user has modified in the context of the owner. */
  recentProjects: gh_ProjectV2Connection;
  /** A list of repositories that the user owns. */
  repositories: gh_RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<gh_Repository>;
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: gh_DiscussionCommentConnection;
  /** Discussions this user has started. */
  repositoryDiscussions: gh_DiscussionConnection;
  /** A list of all repository migrations for this organization. */
  repositoryMigrations: gh_RepositoryMigrationConnection;
  /**
   * When true the organization requires all members, billing managers, and outside
   * collaborators to enable two-factor authentication.
   */
  requiresTwoFactorAuthentication?: Maybe<Scalars['Boolean']['output']>;
  /** The HTTP path for this organization. */
  resourcePath: Scalars['gh_URI']['output'];
  /** Returns a single ruleset from the current organization by ID. */
  ruleset?: Maybe<gh_RepositoryRuleset>;
  /** A list of rulesets for this organization. */
  rulesets?: Maybe<gh_RepositoryRulesetConnection>;
  /**
   * The Organization's SAML identity provider. Visible to (1) organization owners,
   * (2) organization owners' personal access tokens (classic) with read:org or
   * admin:org scope, (3) GitHub App with an installation token with read or write
   * access to members.
   */
  samlIdentityProvider?: Maybe<gh_OrganizationIdentityProvider>;
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: gh_SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: gh_SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: gh_SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<gh_SponsorsListing>;
  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
  sponsorshipForViewerAsSponsor?: Maybe<gh_Sponsorship>;
  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
  sponsorshipForViewerAsSponsorable?: Maybe<gh_Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: gh_SponsorshipNewsletterConnection;
  /** The sponsorships where this user or organization is the maintainer receiving the funds. */
  sponsorshipsAsMaintainer: gh_SponsorshipConnection;
  /** The sponsorships where this user or organization is the funder. */
  sponsorshipsAsSponsor: gh_SponsorshipConnection;
  /** Find an organization's team by its slug. */
  team?: Maybe<gh_Team>;
  /** A list of teams in this organization. */
  teams: gh_TeamConnection;
  /** The HTTP path listing organization's teams */
  teamsResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL listing organization's teams */
  teamsUrl: Scalars['gh_URI']['output'];
  /**
   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
   * user themselves or by a user who can manage sponsorships for the requested organization.
   */
  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']['output']>;
  /** The organization's Twitter username. */
  twitterUsername?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this organization. */
  url: Scalars['gh_URI']['output'];
  /** Organization is adminable by the viewer. */
  viewerCanAdminister: Scalars['Boolean']['output'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean']['output'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean']['output'];
  /** Viewer can create repositories on this organization */
  viewerCanCreateRepositories: Scalars['Boolean']['output'];
  /** Viewer can create teams on this organization. */
  viewerCanCreateTeams: Scalars['Boolean']['output'];
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars['Boolean']['output'];
  /** Viewer is an active member of this organization. */
  viewerIsAMember: Scalars['Boolean']['output'];
  /** Whether or not this Organization is followed by the viewer. */
  viewerIsFollowing: Scalars['Boolean']['output'];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars['Boolean']['output'];
  /** Whether contributors are required to sign off on web-based commits for repositories in this organization. */
  webCommitSignoffRequired: Scalars['Boolean']['output'];
  /** The organization's public profile URL. */
  websiteUrl?: Maybe<Scalars['gh_URI']['output']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationanyPinnableItemsArgs = {
  type?: InputMaybe<gh_PinnableItemType>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationauditLogArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_AuditLogOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationdomainsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  isApproved?: InputMaybe<Scalars['Boolean']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_VerifiableDomainOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationenterpriseOwnersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrgEnterpriseOwnerOrder>;
  organizationRole?: InputMaybe<gh_RoleInOrganization>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationipAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IpAllowListEntryOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationisSponsoredByArgs = {
  accountLogin: Scalars['String']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationmannequinsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<gh_MannequinOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationmemberStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_UserStatusOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationmembersWithRoleArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationpackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<gh_PackageOrder>;
  packageType?: InputMaybe<gh_PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationpendingMembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationpinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<gh_PinnableItemType>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationpinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<gh_PinnableItemType>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationprojectArgs = {
  number: Scalars['Int']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationprojectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<gh_ProjectState>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationrecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationrepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<gh_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  isFork?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<gh_RepositoryAffiliation>>>;
  privacy?: InputMaybe<gh_RepositoryPrivacy>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationrepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationrepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']['input']>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationrepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  answered?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  states?: InputMaybe<Array<gh_DiscussionState>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationrepositoryMigrationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_RepositoryMigrationOrder>;
  repositoryName?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<gh_MigrationState>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationrulesetArgs = {
  databaseId: Scalars['Int']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationrulesetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeParents?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationsponsoringArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationsponsorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationsponsorsActivitiesArgs = {
  actions?: InputMaybe<Array<gh_SponsorsActivityAction>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAsSponsor?: InputMaybe<Scalars['Boolean']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorsActivityOrder>;
  period?: InputMaybe<gh_SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationsponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationsponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationsponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorshipNewsletterOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationsponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorshipOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationsponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  maintainerLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  orderBy?: InputMaybe<gh_SponsorshipOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationteamArgs = {
  slug: Scalars['String']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationteamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  ldapMapped?: InputMaybe<Scalars['Boolean']['input']>;
  notificationSetting?: InputMaybe<gh_TeamNotificationSetting>;
  orderBy?: InputMaybe<gh_TeamOrder>;
  privacy?: InputMaybe<gh_TeamPrivacy>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<gh_TeamRole>;
  rootTeamsOnly?: InputMaybe<Scalars['Boolean']['input']>;
  userLogins?: InputMaybe<Array<Scalars['String']['input']>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type gh_OrganizationtotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars['DateTime']['input']>;
  sponsorableLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};

/** An audit entry in an organization audit log. */
export type gh_OrganizationAuditEntry = gh_MembersCanDeleteReposClearAuditEntry | gh_MembersCanDeleteReposDisableAuditEntry | gh_MembersCanDeleteReposEnableAuditEntry | gh_OauthApplicationCreateAuditEntry | gh_OrgAddBillingManagerAuditEntry | gh_OrgAddMemberAuditEntry | gh_OrgBlockUserAuditEntry | gh_OrgConfigDisableCollaboratorsOnlyAuditEntry | gh_OrgConfigEnableCollaboratorsOnlyAuditEntry | gh_OrgCreateAuditEntry | gh_OrgDisableOauthAppRestrictionsAuditEntry | gh_OrgDisableSamlAuditEntry | gh_OrgDisableTwoFactorRequirementAuditEntry | gh_OrgEnableOauthAppRestrictionsAuditEntry | gh_OrgEnableSamlAuditEntry | gh_OrgEnableTwoFactorRequirementAuditEntry | gh_OrgInviteMemberAuditEntry | gh_OrgInviteToBusinessAuditEntry | gh_OrgOauthAppAccessApprovedAuditEntry | gh_OrgOauthAppAccessBlockedAuditEntry | gh_OrgOauthAppAccessDeniedAuditEntry | gh_OrgOauthAppAccessRequestedAuditEntry | gh_OrgOauthAppAccessUnblockedAuditEntry | gh_OrgRemoveBillingManagerAuditEntry | gh_OrgRemoveMemberAuditEntry | gh_OrgRemoveOutsideCollaboratorAuditEntry | gh_OrgRestoreMemberAuditEntry | gh_OrgUnblockUserAuditEntry | gh_OrgUpdateDefaultRepositoryPermissionAuditEntry | gh_OrgUpdateMemberAuditEntry | gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry | gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry | gh_PrivateRepositoryForkingDisableAuditEntry | gh_PrivateRepositoryForkingEnableAuditEntry | gh_RepoAccessAuditEntry | gh_RepoAddMemberAuditEntry | gh_RepoAddTopicAuditEntry | gh_RepoArchivedAuditEntry | gh_RepoChangeMergeSettingAuditEntry | gh_RepoConfigDisableAnonymousGitAccessAuditEntry | gh_RepoConfigDisableCollaboratorsOnlyAuditEntry | gh_RepoConfigDisableContributorsOnlyAuditEntry | gh_RepoConfigDisableSockpuppetDisallowedAuditEntry | gh_RepoConfigEnableAnonymousGitAccessAuditEntry | gh_RepoConfigEnableCollaboratorsOnlyAuditEntry | gh_RepoConfigEnableContributorsOnlyAuditEntry | gh_RepoConfigEnableSockpuppetDisallowedAuditEntry | gh_RepoConfigLockAnonymousGitAccessAuditEntry | gh_RepoConfigUnlockAnonymousGitAccessAuditEntry | gh_RepoCreateAuditEntry | gh_RepoDestroyAuditEntry | gh_RepoRemoveMemberAuditEntry | gh_RepoRemoveTopicAuditEntry | gh_RepositoryVisibilityChangeDisableAuditEntry | gh_RepositoryVisibilityChangeEnableAuditEntry | gh_TeamAddMemberAuditEntry | gh_TeamAddRepositoryAuditEntry | gh_TeamChangeParentTeamAuditEntry | gh_TeamRemoveMemberAuditEntry | gh_TeamRemoveRepositoryAuditEntry;

/** The connection type for OrganizationAuditEntry. */
export type gh_OrganizationAuditEntryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_OrganizationAuditEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_OrganizationAuditEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Metadata for an audit entry with action org.* */
export type gh_OrganizationAuditEntryData = {
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** An edge in a connection. */
export type gh_OrganizationAuditEntryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_OrganizationAuditEntry>;
};

/** A list of organizations managed by an enterprise. */
export type gh_OrganizationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_OrganizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Organization>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_OrganizationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Organization>;
};

/** The connection type for User. */
export type gh_OrganizationEnterpriseOwnerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_OrganizationEnterpriseOwnerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_User>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An enterprise owner in the context of an organization that is part of the enterprise. */
export type gh_OrganizationEnterpriseOwnerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_User>;
  /** The role of the owner with respect to the organization. */
  organizationRole: gh_RoleInOrganization;
};

/**
 * An Identity Provider configured to provision SAML and SCIM identities for
 * Organizations. Visible to (1) organization owners, (2) organization owners'
 * personal access tokens (classic) with read:org or admin:org scope, (3) GitHub
 * App with an installation token with read or write access to members.
 */
export type gh_OrganizationIdentityProvider = gh_Node & {
  /** The digest algorithm used to sign SAML requests for the Identity Provider. */
  digestMethod?: Maybe<Scalars['gh_URI']['output']>;
  /** External Identities provisioned by this Identity Provider */
  externalIdentities: gh_ExternalIdentityConnection;
  /** The Node ID of the OrganizationIdentityProvider object */
  id: Scalars['ID']['output'];
  /** The x509 certificate used by the Identity Provider to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars['gh_X509Certificate']['output']>;
  /** The Issuer Entity ID for the SAML Identity Provider */
  issuer?: Maybe<Scalars['String']['output']>;
  /** Organization this Identity Provider belongs to */
  organization?: Maybe<gh_Organization>;
  /** The signature algorithm used to sign SAML requests for the Identity Provider. */
  signatureMethod?: Maybe<Scalars['gh_URI']['output']>;
  /** The URL endpoint for the Identity Provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars['gh_URI']['output']>;
};


/**
 * An Identity Provider configured to provision SAML and SCIM identities for
 * Organizations. Visible to (1) organization owners, (2) organization owners'
 * personal access tokens (classic) with read:org or admin:org scope, (3) GitHub
 * App with an installation token with read or write access to members.
 */
export type gh_OrganizationIdentityProviderexternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  membersOnly?: InputMaybe<Scalars['Boolean']['input']>;
  userName?: InputMaybe<Scalars['String']['input']>;
};

/** An Invitation for a user to an organization. */
export type gh_OrganizationInvitation = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The email address of the user invited to the organization. */
  email?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the OrganizationInvitation object */
  id: Scalars['ID']['output'];
  /** The source of the invitation. */
  invitationSource: gh_OrganizationInvitationSource;
  /** The type of invitation that was sent (e.g. email, user). */
  invitationType: gh_OrganizationInvitationType;
  /** The user who was invited to the organization. */
  invitee?: Maybe<gh_User>;
  /** The user who created the invitation. */
  inviter: gh_User;
  /** The organization the invite is for */
  organization: gh_Organization;
  /** The user's pending role in the organization (e.g. member, owner). */
  role: gh_OrganizationInvitationRole;
};

/** The connection type for OrganizationInvitation. */
export type gh_OrganizationInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_OrganizationInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_OrganizationInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_OrganizationInvitation>;
};

/** The possible organization invitation roles. */
export type gh_OrganizationInvitationRole =
  /** The user is invited to be an admin of the organization. */
  | 'ADMIN'
  /** The user is invited to be a billing manager of the organization. */
  | 'BILLING_MANAGER'
  /** The user is invited to be a direct member of the organization. */
  | 'DIRECT_MEMBER'
  /** The user's previous role will be reinstated. */
  | 'REINSTATE';

/** The possible organization invitation sources. */
export type gh_OrganizationInvitationSource =
  /** The invitation was created from the web interface or from API */
  | 'MEMBER'
  /** The invitation was created from SCIM */
  | 'SCIM'
  /** The invitation was sent before this feature was added */
  | 'UNKNOWN';

/** The possible organization invitation types. */
export type gh_OrganizationInvitationType =
  /** The invitation was to an email address. */
  | 'EMAIL'
  /** The invitation was to an existing user. */
  | 'USER';

/** The connection type for User. */
export type gh_OrganizationMemberConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_OrganizationMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_User>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a user within an organization. */
export type gh_OrganizationMemberEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer. */
  hasTwoFactorEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** The item at the end of the edge. */
  node?: Maybe<gh_User>;
  /** The role this user has in the organization. */
  role?: Maybe<gh_OrganizationMemberRole>;
};

/** The possible roles within an organization for its members. */
export type gh_OrganizationMemberRole =
  /** The user is an administrator of the organization. */
  | 'ADMIN'
  /** The user is a member of the organization. */
  | 'MEMBER';

/** The possible values for the members can create repositories setting on an organization. */
export type gh_OrganizationMembersCanCreateRepositoriesSettingValue =
  /** Members will be able to create public and private repositories. */
  | 'ALL'
  /** Members will not be able to create public or private repositories. */
  | 'DISABLED'
  /** Members will be able to create only internal repositories. */
  | 'INTERNAL'
  /** Members will be able to create only private repositories. */
  | 'PRIVATE';

/** A GitHub Enterprise Importer (GEI) organization migration. */
export type gh_OrganizationMigration = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['String']['output']>;
  /** The reason the organization migration failed. */
  failureReason?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the OrganizationMigration object */
  id: Scalars['ID']['output'];
  /** The remaining amount of repos to be migrated. */
  remainingRepositoriesCount?: Maybe<Scalars['Int']['output']>;
  /** The name of the source organization to be migrated. */
  sourceOrgName: Scalars['String']['output'];
  /** The URL of the source organization to migrate. */
  sourceOrgUrl: Scalars['gh_URI']['output'];
  /** The migration state. */
  state: gh_OrganizationMigrationState;
  /** The name of the target organization. */
  targetOrgName: Scalars['String']['output'];
  /** The total amount of repositories to be migrated. */
  totalRepositoriesCount?: Maybe<Scalars['Int']['output']>;
};

/** The Octoshift Organization migration state. */
export type gh_OrganizationMigrationState =
  /** The Octoshift migration has failed. */
  | 'FAILED'
  /** The Octoshift migration has invalid credentials. */
  | 'FAILED_VALIDATION'
  /** The Octoshift migration is in progress. */
  | 'IN_PROGRESS'
  /** The Octoshift migration has not started. */
  | 'NOT_STARTED'
  /** The Octoshift migration needs to have its credentials validated. */
  | 'PENDING_VALIDATION'
  /** The Octoshift migration is performing post repository migrations. */
  | 'POST_REPO_MIGRATION'
  /** The Octoshift migration is performing pre repository migrations. */
  | 'PRE_REPO_MIGRATION'
  /** The Octoshift migration has been queued. */
  | 'QUEUED'
  /** The Octoshift org migration is performing repository migrations. */
  | 'REPO_MIGRATION'
  /** The Octoshift migration has succeeded. */
  | 'SUCCEEDED';

/** Used for argument of CreateProjectV2 mutation. */
export type gh_OrganizationOrUser = gh_Organization | gh_User;

/** Ordering options for organization connections. */
export type gh_OrganizationOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order organizations by. */
  field: gh_OrganizationOrderField;
};

/** Properties by which organization connections can be ordered. */
export type gh_OrganizationOrderField =
  /** Order organizations by creation time */
  | 'CREATED_AT'
  /** Order organizations by login */
  | 'LOGIN';

/** An organization teams hovercard context */
export type gh_OrganizationTeamsHovercardContext = gh_HovercardContext & {
  /** A string describing this context */
  message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  octicon: Scalars['String']['output'];
  /** Teams in this organization the user is a member of that are relevant */
  relevantTeams: gh_TeamConnection;
  /** The path for the full team list for this user */
  teamsResourcePath: Scalars['gh_URI']['output'];
  /** The URL for the full team list for this user */
  teamsUrl: Scalars['gh_URI']['output'];
  /** The total number of teams the user is on in the organization */
  totalTeamCount: Scalars['Int']['output'];
};


/** An organization teams hovercard context */
export type gh_OrganizationTeamsHovercardContextrelevantTeamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** An organization list hovercard context */
export type gh_OrganizationsHovercardContext = gh_HovercardContext & {
  /** A string describing this context */
  message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  octicon: Scalars['String']['output'];
  /** Organizations this user is a member of that are relevant */
  relevantOrganizations: gh_OrganizationConnection;
  /** The total number of organizations this user is in */
  totalOrganizationCount: Scalars['Int']['output'];
};


/** An organization list hovercard context */
export type gh_OrganizationsHovercardContextrelevantOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
};

/** Information for an uploaded package. */
export type gh_Package = gh_Node & {
  /** The Node ID of the Package object */
  id: Scalars['ID']['output'];
  /** Find the latest version for the package. */
  latestVersion?: Maybe<gh_PackageVersion>;
  /** Identifies the name of the package. */
  name: Scalars['String']['output'];
  /** Identifies the type of the package. */
  packageType: gh_PackageType;
  /** The repository this package belongs to. */
  repository?: Maybe<gh_Repository>;
  /** Statistics about package activity. */
  statistics?: Maybe<gh_PackageStatistics>;
  /** Find package version by version string. */
  version?: Maybe<gh_PackageVersion>;
  /** list of versions for this package */
  versions: gh_PackageVersionConnection;
};


/** Information for an uploaded package. */
export type gh_PackageversionArgs = {
  version: Scalars['String']['input'];
};


/** Information for an uploaded package. */
export type gh_PackageversionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_PackageVersionOrder>;
};

/** The connection type for Package. */
export type gh_PackageConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PackageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Package>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_PackageEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Package>;
};

/** A file in a package version. */
export type gh_PackageFile = gh_Node & {
  /** The Node ID of the PackageFile object */
  id: Scalars['ID']['output'];
  /** MD5 hash of the file. */
  md5?: Maybe<Scalars['String']['output']>;
  /** Name of the file. */
  name: Scalars['String']['output'];
  /** The package version this file belongs to. */
  packageVersion?: Maybe<gh_PackageVersion>;
  /** SHA1 hash of the file. */
  sha1?: Maybe<Scalars['String']['output']>;
  /** SHA256 hash of the file. */
  sha256?: Maybe<Scalars['String']['output']>;
  /** Size of the file in bytes. */
  size?: Maybe<Scalars['Int']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** URL to download the asset. */
  url?: Maybe<Scalars['gh_URI']['output']>;
};

/** The connection type for PackageFile. */
export type gh_PackageFileConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PackageFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PackageFile>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_PackageFileEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PackageFile>;
};

/** Ways in which lists of package files can be ordered upon return. */
export type gh_PackageFileOrder = {
  /** The direction in which to order package files by the specified field. */
  direction?: InputMaybe<gh_OrderDirection>;
  /** The field in which to order package files by. */
  field?: InputMaybe<gh_PackageFileOrderField>;
};

/** Properties by which package file connections can be ordered. */
export type gh_PackageFileOrderField =
  /** Order package files by creation time */
  | 'CREATED_AT';

/** Ways in which lists of packages can be ordered upon return. */
export type gh_PackageOrder = {
  /** The direction in which to order packages by the specified field. */
  direction?: InputMaybe<gh_OrderDirection>;
  /** The field in which to order packages by. */
  field?: InputMaybe<gh_PackageOrderField>;
};

/** Properties by which package connections can be ordered. */
export type gh_PackageOrderField =
  /** Order packages by creation time */
  | 'CREATED_AT';

/** Represents an owner of a package. */
export type gh_PackageOwner = {
  /** The Node ID of the PackageOwner object */
  id: Scalars['ID']['output'];
  /** A list of packages under the owner. */
  packages: gh_PackageConnection;
};


/** Represents an owner of a package. */
export type gh_PackageOwnerpackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<gh_PackageOrder>;
  packageType?: InputMaybe<gh_PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** Represents a object that contains package activity statistics such as downloads. */
export type gh_PackageStatistics = {
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars['Int']['output'];
};

/** A version tag contains the mapping between a tag name and a version. */
export type gh_PackageTag = gh_Node & {
  /** The Node ID of the PackageTag object */
  id: Scalars['ID']['output'];
  /** Identifies the tag name of the version. */
  name: Scalars['String']['output'];
  /** Version that the tag is associated with. */
  version?: Maybe<gh_PackageVersion>;
};

/** The possible types of a package. */
export type gh_PackageType =
  /** A debian package. */
  | 'DEBIAN'
  /** A docker image. */
  | 'DOCKER'
  /** A maven package. */
  | 'MAVEN'
  /** An npm package. */
  | 'NPM'
  /** A nuget package. */
  | 'NUGET'
  /** A python package. */
  | 'PYPI'
  /** A rubygems package. */
  | 'RUBYGEMS';

/** Information about a specific package version. */
export type gh_PackageVersion = gh_Node & {
  /** List of files associated with this package version */
  files: gh_PackageFileConnection;
  /** The Node ID of the PackageVersion object */
  id: Scalars['ID']['output'];
  /** The package associated with this version. */
  package?: Maybe<gh_Package>;
  /** The platform this version was built for. */
  platform?: Maybe<Scalars['String']['output']>;
  /** Whether or not this version is a pre-release. */
  preRelease: Scalars['Boolean']['output'];
  /** The README of this package version. */
  readme?: Maybe<Scalars['String']['output']>;
  /** The release associated with this package version. */
  release?: Maybe<gh_Release>;
  /** Statistics about package activity. */
  statistics?: Maybe<gh_PackageVersionStatistics>;
  /** The package version summary. */
  summary?: Maybe<Scalars['String']['output']>;
  /** The version string. */
  version: Scalars['String']['output'];
};


/** Information about a specific package version. */
export type gh_PackageVersionfilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_PackageFileOrder>;
};

/** The connection type for PackageVersion. */
export type gh_PackageVersionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PackageVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PackageVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_PackageVersionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PackageVersion>;
};

/** Ways in which lists of package versions can be ordered upon return. */
export type gh_PackageVersionOrder = {
  /** The direction in which to order package versions by the specified field. */
  direction?: InputMaybe<gh_OrderDirection>;
  /** The field in which to order package versions by. */
  field?: InputMaybe<gh_PackageVersionOrderField>;
};

/** Properties by which package version connections can be ordered. */
export type gh_PackageVersionOrderField =
  /** Order package versions by creation time */
  | 'CREATED_AT';

/** Represents a object that contains package version activity statistics such as downloads. */
export type gh_PackageVersionStatistics = {
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars['Int']['output'];
};

/** Information about pagination in a connection. */
export type gh_PageInfo = {
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']['output']>;
};

/** The possible types of patch statuses. */
export type gh_PatchStatus =
  /** The file was added. Git status 'A'. */
  | 'ADDED'
  /** The file's type was changed. Git status 'T'. */
  | 'CHANGED'
  /** The file was copied. Git status 'C'. */
  | 'COPIED'
  /** The file was deleted. Git status 'D'. */
  | 'DELETED'
  /** The file's contents were changed. Git status 'M'. */
  | 'MODIFIED'
  /** The file was renamed. Git status 'R'. */
  | 'RENAMED';

/** Types that can grant permissions on a repository to a user */
export type gh_PermissionGranter = gh_Organization | gh_Repository | gh_Team;

/** A level of permission and source for a user's access to a repository. */
export type gh_PermissionSource = {
  /** The organization the repository belongs to. */
  organization: gh_Organization;
  /** The level of access this source has granted to the user. */
  permission: gh_DefaultRepositoryPermissionField;
  /** The name of the role this source has granted to the user. */
  roleName?: Maybe<Scalars['String']['output']>;
  /** The source of this permission. */
  source: gh_PermissionGranter;
};

/** Autogenerated input type of PinIssue */
export type gh_PinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the issue to be pinned */
  issueId: Scalars['ID']['input'];
};

/** Autogenerated return type of PinIssue */
export type gh_PinIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was pinned */
  issue?: Maybe<gh_Issue>;
};

/** Types that can be pinned to a profile page. */
export type gh_PinnableItem = gh_Gist | gh_Repository;

/** The connection type for PinnableItem. */
export type gh_PinnableItemConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PinnableItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PinnableItem>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_PinnableItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PinnableItem>;
};

/** Represents items that can be pinned to a profile page or dashboard. */
export type gh_PinnableItemType =
  /** A gist. */
  | 'GIST'
  /** An issue. */
  | 'ISSUE'
  /** An organization. */
  | 'ORGANIZATION'
  /** A project. */
  | 'PROJECT'
  /** A pull request. */
  | 'PULL_REQUEST'
  /** A repository. */
  | 'REPOSITORY'
  /** A team. */
  | 'TEAM'
  /** A user. */
  | 'USER';

/** A Pinned Discussion is a discussion pinned to a repository's index page. */
export type gh_PinnedDiscussion = gh_Node & gh_RepositoryNode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The discussion that was pinned. */
  discussion: gh_Discussion;
  /** Color stops of the chosen gradient */
  gradientStopColors: Array<Scalars['String']['output']>;
  /** The Node ID of the PinnedDiscussion object */
  id: Scalars['ID']['output'];
  /** Background texture pattern */
  pattern: gh_PinnedDiscussionPattern;
  /** The actor that pinned this discussion. */
  pinnedBy: gh_Actor;
  /** Preconfigured background gradient option */
  preconfiguredGradient?: Maybe<gh_PinnedDiscussionGradient>;
  /** The repository associated with this node. */
  repository: gh_Repository;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for PinnedDiscussion. */
export type gh_PinnedDiscussionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PinnedDiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PinnedDiscussion>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_PinnedDiscussionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PinnedDiscussion>;
};

/** Preconfigured gradients that may be used to style discussions pinned within a repository. */
export type gh_PinnedDiscussionGradient =
  /** A gradient of blue to mint */
  | 'BLUE_MINT'
  /** A gradient of blue to purple */
  | 'BLUE_PURPLE'
  /** A gradient of pink to blue */
  | 'PINK_BLUE'
  /** A gradient of purple to coral */
  | 'PURPLE_CORAL'
  /** A gradient of red to orange */
  | 'RED_ORANGE';

/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */
export type gh_PinnedDiscussionPattern =
  /** An upward-facing chevron pattern */
  | 'CHEVRON_UP'
  /** A hollow dot pattern */
  | 'DOT'
  /** A solid dot pattern */
  | 'DOT_FILL'
  /** A heart pattern */
  | 'HEART_FILL'
  /** A plus sign pattern */
  | 'PLUS'
  /** A lightning bolt pattern */
  | 'ZAP';

/** Represents a 'pinned' event on a given issue or pull request. */
export type gh_PinnedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the PinnedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the issue associated with the event. */
  issue: gh_Issue;
};

/** A Pinned Issue is a issue pinned to a repository's index page. */
export type gh_PinnedIssue = gh_Node & {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** Identifies the primary key from the database as a BigInt. */
  fullDatabaseId?: Maybe<Scalars['BigInt']['output']>;
  /** The Node ID of the PinnedIssue object */
  id: Scalars['ID']['output'];
  /** The issue that was pinned. */
  issue: gh_Issue;
  /** The actor that pinned this issue. */
  pinnedBy: gh_Actor;
  /** The repository that this issue was pinned to. */
  repository: gh_Repository;
};

/** The connection type for PinnedIssue. */
export type gh_PinnedIssueConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PinnedIssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PinnedIssue>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_PinnedIssueEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PinnedIssue>;
};

/** Audit log entry for a private_repository_forking.disable event. */
export type gh_PrivateRepositoryForkingDisableAuditEntry = gh_AuditEntry & gh_EnterpriseAuditEntryData & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The Node ID of the PrivateRepositoryForkingDisableAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a private_repository_forking.enable event. */
export type gh_PrivateRepositoryForkingEnableAuditEntry = gh_AuditEntry & gh_EnterpriseAuditEntryData & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The Node ID of the PrivateRepositoryForkingEnableAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
export type gh_ProfileItemShowcase = {
  /** Whether or not the owner has pinned any repositories or gists. */
  hasPinnedItems: Scalars['Boolean']['output'];
  /**
   * The repositories and gists in the showcase. If the profile owner has any
   * pinned items, those will be returned. Otherwise, the profile owner's popular
   * repositories will be returned.
   */
  items: gh_PinnableItemConnection;
};


/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
export type gh_ProfileItemShowcaseitemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents any entity on GitHub that has a profile page. */
export type gh_ProfileOwner = {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean']['output'];
  /** The public profile email. */
  email?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the ProfileOwner object */
  id: Scalars['ID']['output'];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: gh_ProfileItemShowcase;
  /** The public profile location. */
  location?: Maybe<Scalars['String']['output']>;
  /** The username used to login. */
  login: Scalars['String']['output'];
  /** The public profile name. */
  name?: Maybe<Scalars['String']['output']>;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: gh_PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: gh_PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int']['output'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean']['output'];
  /** The public profile website URL. */
  websiteUrl?: Maybe<Scalars['gh_URI']['output']>;
};


/** Represents any entity on GitHub that has a profile page. */
export type gh_ProfileOwneranyPinnableItemsArgs = {
  type?: InputMaybe<gh_PinnableItemType>;
};


/** Represents any entity on GitHub that has a profile page. */
export type gh_ProfileOwnerpinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<gh_PinnableItemType>>;
};


/** Represents any entity on GitHub that has a profile page. */
export type gh_ProfileOwnerpinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<gh_PinnableItemType>>;
};

/** Projects manage issues, pull requests and notes within a project owner. */
export type gh_Project = gh_Closable & gh_Node & gh_Updatable & {
  /** The project's description body. */
  body?: Maybe<Scalars['String']['output']>;
  /** The projects description body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** List of columns in the project */
  columns: gh_ProjectColumnConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who originally created the project. */
  creator?: Maybe<gh_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the Project object */
  id: Scalars['ID']['output'];
  /** The project's name. */
  name: Scalars['String']['output'];
  /** The project's number. */
  number: Scalars['Int']['output'];
  /** The project's owner. Currently limited to repositories, organizations, and users. */
  owner: gh_ProjectOwner;
  /** List of pending cards in this project */
  pendingCards: gh_ProjectCardConnection;
  /** Project progress details. */
  progress: gh_ProjectProgress;
  /** The HTTP path for this project */
  resourcePath: Scalars['gh_URI']['output'];
  /** Whether the project is open or closed. */
  state: gh_ProjectState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this project */
  url: Scalars['gh_URI']['output'];
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
};


/** Projects manage issues, pull requests and notes within a project owner. */
export type gh_ProjectcolumnsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Projects manage issues, pull requests and notes within a project owner. */
export type gh_ProjectpendingCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedStates?: InputMaybe<Array<InputMaybe<gh_ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A card in a project. */
export type gh_ProjectCard = gh_Node & {
  /**
   * The project column this card is associated under. A card may only belong to one
   * project column at a time. The column field will be null if the card is created
   * in a pending state and has yet to be associated with a column. Once cards are
   * associated with a column, they will not become pending in the future.
   */
  column?: Maybe<gh_ProjectColumn>;
  /** The card content item */
  content?: Maybe<gh_ProjectCardItem>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created this card */
  creator?: Maybe<gh_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ProjectCard object */
  id: Scalars['ID']['output'];
  /** Whether the card is archived */
  isArchived: Scalars['Boolean']['output'];
  /** The card note */
  note?: Maybe<Scalars['String']['output']>;
  /** The project that contains this card. */
  project: gh_Project;
  /** The HTTP path for this card */
  resourcePath: Scalars['gh_URI']['output'];
  /** The state of ProjectCard */
  state?: Maybe<gh_ProjectCardState>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this card */
  url: Scalars['gh_URI']['output'];
};

/** The possible archived states of a project card. */
export type gh_ProjectCardArchivedState =
  /** A project card that is archived */
  | 'ARCHIVED'
  /** A project card that is not archived */
  | 'NOT_ARCHIVED';

/** The connection type for ProjectCard. */
export type gh_ProjectCardConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ProjectCardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ProjectCard>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ProjectCardEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ProjectCard>;
};

/** An issue or PR and its owning repository to be used in a project card. */
export type gh_ProjectCardImport = {
  /** The issue or pull request number. */
  number: Scalars['Int']['input'];
  /** Repository name with owner (owner/repository). */
  repository: Scalars['String']['input'];
};

/** Types that can be inside Project Cards. */
export type gh_ProjectCardItem = gh_Issue | gh_PullRequest;

/** Various content states of a ProjectCard */
export type gh_ProjectCardState =
  /** The card has content only. */
  | 'CONTENT_ONLY'
  /** The card has a note only. */
  | 'NOTE_ONLY'
  /** The card is redacted. */
  | 'REDACTED';

/** A column inside a project. */
export type gh_ProjectColumn = gh_Node & {
  /** List of cards in the column */
  cards: gh_ProjectCardConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ProjectColumn object */
  id: Scalars['ID']['output'];
  /** The project column's name. */
  name: Scalars['String']['output'];
  /** The project that contains this column. */
  project: gh_Project;
  /** The semantic purpose of the column */
  purpose?: Maybe<gh_ProjectColumnPurpose>;
  /** The HTTP path for this project column */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this project column */
  url: Scalars['gh_URI']['output'];
};


/** A column inside a project. */
export type gh_ProjectColumncardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedStates?: InputMaybe<Array<InputMaybe<gh_ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ProjectColumn. */
export type gh_ProjectColumnConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ProjectColumnEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ProjectColumn>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ProjectColumnEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ProjectColumn>;
};

/** A project column and a list of its issues and PRs. */
export type gh_ProjectColumnImport = {
  /** The name of the column. */
  columnName: Scalars['String']['input'];
  /** A list of issues and pull requests in the column. */
  issues?: InputMaybe<Array<gh_ProjectCardImport>>;
  /** The position of the column, starting from 0. */
  position: Scalars['Int']['input'];
};

/** The semantic purpose of the column - todo, in progress, or done. */
export type gh_ProjectColumnPurpose =
  /** The column contains cards which are complete */
  | 'DONE'
  /** The column contains cards which are currently being worked on */
  | 'IN_PROGRESS'
  /** The column contains cards still to be worked on */
  | 'TODO';

/** A list of projects associated with the owner. */
export type gh_ProjectConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Project>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ProjectEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Project>;
};

/** Ways in which lists of projects can be ordered upon return. */
export type gh_ProjectOrder = {
  /** The direction in which to order projects by the specified field. */
  direction: gh_OrderDirection;
  /** The field in which to order projects by. */
  field: gh_ProjectOrderField;
};

/** Properties by which project connections can be ordered. */
export type gh_ProjectOrderField =
  /** Order projects by creation time */
  | 'CREATED_AT'
  /** Order projects by name */
  | 'NAME'
  /** Order projects by update time */
  | 'UPDATED_AT';

/** Represents an owner of a Project. */
export type gh_ProjectOwner = {
  /** The Node ID of the ProjectOwner object */
  id: Scalars['ID']['output'];
  /** Find project by number. */
  project?: Maybe<gh_Project>;
  /** A list of projects under the owner. */
  projects: gh_ProjectConnection;
  /** The HTTP path listing owners projects */
  projectsResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL listing owners projects */
  projectsUrl: Scalars['gh_URI']['output'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean']['output'];
};


/** Represents an owner of a Project. */
export type gh_ProjectOwnerprojectArgs = {
  number: Scalars['Int']['input'];
};


/** Represents an owner of a Project. */
export type gh_ProjectOwnerprojectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<gh_ProjectState>>;
};

/** Project progress stats. */
export type gh_ProjectProgress = {
  /** The number of done cards. */
  doneCount: Scalars['Int']['output'];
  /** The percentage of done cards. */
  donePercentage: Scalars['Float']['output'];
  /** Whether progress tracking is enabled and cards with purpose exist for this project */
  enabled: Scalars['Boolean']['output'];
  /** The number of in-progress cards. */
  inProgressCount: Scalars['Int']['output'];
  /** The percentage of in-progress cards. */
  inProgressPercentage: Scalars['Float']['output'];
  /** The number of to do cards. */
  todoCount: Scalars['Int']['output'];
  /** The percentage of to do cards. */
  todoPercentage: Scalars['Float']['output'];
};

/** State of the project; either 'open' or 'closed' */
export type gh_ProjectState =
  /** The project is closed. */
  | 'CLOSED'
  /** The project is open. */
  | 'OPEN';

/** GitHub-provided templates for Projects */
export type gh_ProjectTemplate =
  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */
  | 'AUTOMATED_KANBAN_V2'
  /** Create a board with triggers to automatically move cards across columns with review automation. */
  | 'AUTOMATED_REVIEWS_KANBAN'
  /** Create a board with columns for To do, In progress and Done. */
  | 'BASIC_KANBAN'
  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */
  | 'BUG_TRIAGE';

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type gh_ProjectV2 = gh_Closable & gh_Node & gh_Updatable & {
  /** Returns true if the project is closed. */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who originally created the project. */
  creator?: Maybe<gh_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** A field of the project */
  field?: Maybe<gh_ProjectV2FieldConfiguration>;
  /** List of fields and their constraints in the project */
  fields: gh_ProjectV2FieldConfigurationConnection;
  /** The Node ID of the ProjectV2 object */
  id: Scalars['ID']['output'];
  /** List of items in the project */
  items: gh_ProjectV2ItemConnection;
  /** The project's number. */
  number: Scalars['Int']['output'];
  /** The project's owner. Currently limited to organizations and users. */
  owner: gh_ProjectV2Owner;
  /** Returns true if the project is public. */
  public: Scalars['Boolean']['output'];
  /** The project's readme. */
  readme?: Maybe<Scalars['String']['output']>;
  /** The repositories the project is linked to. */
  repositories: gh_RepositoryConnection;
  /** The HTTP path for this project */
  resourcePath: Scalars['gh_URI']['output'];
  /** The project's short description. */
  shortDescription?: Maybe<Scalars['String']['output']>;
  /** The teams the project is linked to. */
  teams: gh_TeamConnection;
  /** Returns true if this project is a template. */
  template: Scalars['Boolean']['output'];
  /** The project's name. */
  title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this project */
  url: Scalars['gh_URI']['output'];
  /** A view of the project */
  view?: Maybe<gh_ProjectV2View>;
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** List of views in the project */
  views: gh_ProjectV2ViewConnection;
  /** A workflow of the project */
  workflow?: Maybe<gh_ProjectV2Workflow>;
  /** List of the workflows in the project */
  workflows: gh_ProjectV2WorkflowConnection;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type gh_ProjectV2fieldArgs = {
  name: Scalars['String']['input'];
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type gh_ProjectV2fieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2FieldOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type gh_ProjectV2itemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2ItemOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type gh_ProjectV2repositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_RepositoryOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type gh_ProjectV2teamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_TeamOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type gh_ProjectV2viewArgs = {
  number: Scalars['Int']['input'];
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type gh_ProjectV2viewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2ViewOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type gh_ProjectV2workflowArgs = {
  number: Scalars['Int']['input'];
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type gh_ProjectV2workflowsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2WorkflowOrder>;
};

/** Possible collaborators for a project. */
export type gh_ProjectV2Actor = gh_Team | gh_User;

/** The connection type for ProjectV2Actor. */
export type gh_ProjectV2ActorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ProjectV2ActorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ProjectV2Actor>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ProjectV2ActorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ProjectV2Actor>;
};

/** A collaborator to update on a project. Only one of the userId or teamId should be provided. */
export type gh_ProjectV2Collaborator = {
  /** The role to grant the collaborator */
  role: gh_ProjectV2Roles;
  /** The ID of the team as a collaborator. */
  teamId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the user as a collaborator. */
  userId?: InputMaybe<Scalars['ID']['input']>;
};

/** The connection type for ProjectV2. */
export type gh_ProjectV2Connection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ProjectV2Edge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ProjectV2>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The type of a project field. */
export type gh_ProjectV2CustomFieldType =
  /** Date */
  | 'DATE'
  /** Number */
  | 'NUMBER'
  /** Single Select */
  | 'SINGLE_SELECT'
  /** Text */
  | 'TEXT';

/** An edge in a connection. */
export type gh_ProjectV2Edge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ProjectV2>;
};

/** A field inside a project. */
export type gh_ProjectV2Field = gh_Node & gh_ProjectV2FieldCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The field's type. */
  dataType: gh_ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ProjectV2Field object */
  id: Scalars['ID']['output'];
  /** The project field's name. */
  name: Scalars['String']['output'];
  /** The project that contains this field. */
  project: gh_ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** Common fields across different project field types */
export type gh_ProjectV2FieldCommon = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The field's type. */
  dataType: gh_ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ProjectV2FieldCommon object */
  id: Scalars['ID']['output'];
  /** The project field's name. */
  name: Scalars['String']['output'];
  /** The project that contains this field. */
  project: gh_ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** Configurations for project fields. */
export type gh_ProjectV2FieldConfiguration = gh_ProjectV2Field | gh_ProjectV2IterationField | gh_ProjectV2SingleSelectField;

/** The connection type for ProjectV2FieldConfiguration. */
export type gh_ProjectV2FieldConfigurationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ProjectV2FieldConfigurationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ProjectV2FieldConfiguration>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ProjectV2FieldConfigurationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ProjectV2FieldConfiguration>;
};

/** The connection type for ProjectV2Field. */
export type gh_ProjectV2FieldConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ProjectV2FieldEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ProjectV2Field>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ProjectV2FieldEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ProjectV2Field>;
};

/** Ordering options for project v2 field connections */
export type gh_ProjectV2FieldOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order the project v2 fields by. */
  field: gh_ProjectV2FieldOrderField;
};

/** Properties by which project v2 field connections can be ordered. */
export type gh_ProjectV2FieldOrderField =
  /** Order project v2 fields by creation time */
  | 'CREATED_AT'
  /** Order project v2 fields by name */
  | 'NAME'
  /** Order project v2 fields by position */
  | 'POSITION';

/** The type of a project field. */
export type gh_ProjectV2FieldType =
  /** Assignees */
  | 'ASSIGNEES'
  /** Date */
  | 'DATE'
  /** Iteration */
  | 'ITERATION'
  /** Labels */
  | 'LABELS'
  /** Linked Pull Requests */
  | 'LINKED_PULL_REQUESTS'
  /** Milestone */
  | 'MILESTONE'
  /** Number */
  | 'NUMBER'
  /** Repository */
  | 'REPOSITORY'
  /** Reviewers */
  | 'REVIEWERS'
  /** Single Select */
  | 'SINGLE_SELECT'
  /** Text */
  | 'TEXT'
  /** Title */
  | 'TITLE'
  /** Tracked by */
  | 'TRACKED_BY'
  /** Tracks */
  | 'TRACKS';

/** The values that can be used to update a field of an item inside a Project. Only 1 value can be updated at a time. */
export type gh_ProjectV2FieldValue = {
  /** The ISO 8601 date to set on the field. */
  date?: InputMaybe<Scalars['Date']['input']>;
  /** The id of the iteration to set on the field. */
  iterationId?: InputMaybe<Scalars['String']['input']>;
  /** The number to set on the field. */
  number?: InputMaybe<Scalars['Float']['input']>;
  /** The id of the single select option to set on the field. */
  singleSelectOptionId?: InputMaybe<Scalars['String']['input']>;
  /** The text to set on the field. */
  text?: InputMaybe<Scalars['String']['input']>;
};

/** Ways in which to filter lists of projects. */
export type gh_ProjectV2Filters = {
  /** List project v2 filtered by the state given. */
  state?: InputMaybe<gh_ProjectV2State>;
};

/** An item within a Project. */
export type gh_ProjectV2Item = gh_Node & {
  /** The content of the referenced draft issue, issue, or pull request */
  content?: Maybe<gh_ProjectV2ItemContent>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<gh_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The field value of the first project field which matches the 'name' argument that is set on the item. */
  fieldValueByName?: Maybe<gh_ProjectV2ItemFieldValue>;
  /** The field values that are set on the item. */
  fieldValues: gh_ProjectV2ItemFieldValueConnection;
  /** The Node ID of the ProjectV2Item object */
  id: Scalars['ID']['output'];
  /** Whether the item is archived. */
  isArchived: Scalars['Boolean']['output'];
  /** The project that contains this item. */
  project: gh_ProjectV2;
  /** The type of the item. */
  type: gh_ProjectV2ItemType;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};


/** An item within a Project. */
export type gh_ProjectV2ItemfieldValueByNameArgs = {
  name: Scalars['String']['input'];
};


/** An item within a Project. */
export type gh_ProjectV2ItemfieldValuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2ItemFieldValueOrder>;
};

/** The connection type for ProjectV2Item. */
export type gh_ProjectV2ItemConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ProjectV2ItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ProjectV2Item>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Types that can be inside Project Items. */
export type gh_ProjectV2ItemContent = gh_DraftIssue | gh_Issue | gh_PullRequest;

/** An edge in a connection. */
export type gh_ProjectV2ItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ProjectV2Item>;
};

/** The value of a date field in a Project item. */
export type gh_ProjectV2ItemFieldDateValue = gh_Node & gh_ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<gh_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** Date value for the field */
  date?: Maybe<Scalars['Date']['output']>;
  /** The project field that contains this value. */
  field: gh_ProjectV2FieldConfiguration;
  /** The Node ID of the ProjectV2ItemFieldDateValue object */
  id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  item: gh_ProjectV2Item;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The value of an iteration field in a Project item. */
export type gh_ProjectV2ItemFieldIterationValue = gh_Node & gh_ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<gh_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The duration of the iteration in days. */
  duration: Scalars['Int']['output'];
  /** The project field that contains this value. */
  field: gh_ProjectV2FieldConfiguration;
  /** The Node ID of the ProjectV2ItemFieldIterationValue object */
  id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  item: gh_ProjectV2Item;
  /** The ID of the iteration. */
  iterationId: Scalars['String']['output'];
  /** The start date of the iteration. */
  startDate: Scalars['Date']['output'];
  /** The title of the iteration. */
  title: Scalars['String']['output'];
  /** The title of the iteration, with HTML. */
  titleHTML: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The value of the labels field in a Project item. */
export type gh_ProjectV2ItemFieldLabelValue = {
  /** The field that contains this value. */
  field: gh_ProjectV2FieldConfiguration;
  /** Labels value of a field */
  labels?: Maybe<gh_LabelConnection>;
};


/** The value of the labels field in a Project item. */
export type gh_ProjectV2ItemFieldLabelValuelabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The value of a milestone field in a Project item. */
export type gh_ProjectV2ItemFieldMilestoneValue = {
  /** The field that contains this value. */
  field: gh_ProjectV2FieldConfiguration;
  /** Milestone value of a field */
  milestone?: Maybe<gh_Milestone>;
};

/** The value of a number field in a Project item. */
export type gh_ProjectV2ItemFieldNumberValue = gh_Node & gh_ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<gh_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The project field that contains this value. */
  field: gh_ProjectV2FieldConfiguration;
  /** The Node ID of the ProjectV2ItemFieldNumberValue object */
  id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  item: gh_ProjectV2Item;
  /** Number as a float(8) */
  number?: Maybe<Scalars['Float']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The value of a pull request field in a Project item. */
export type gh_ProjectV2ItemFieldPullRequestValue = {
  /** The field that contains this value. */
  field: gh_ProjectV2FieldConfiguration;
  /** The pull requests for this field */
  pullRequests?: Maybe<gh_PullRequestConnection>;
};


/** The value of a pull request field in a Project item. */
export type gh_ProjectV2ItemFieldPullRequestValuepullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_PullRequestOrder>;
};

/** The value of a repository field in a Project item. */
export type gh_ProjectV2ItemFieldRepositoryValue = {
  /** The field that contains this value. */
  field: gh_ProjectV2FieldConfiguration;
  /** The repository for this field. */
  repository?: Maybe<gh_Repository>;
};

/** The value of a reviewers field in a Project item. */
export type gh_ProjectV2ItemFieldReviewerValue = {
  /** The field that contains this value. */
  field: gh_ProjectV2FieldConfiguration;
  /** The reviewers for this field. */
  reviewers?: Maybe<gh_RequestedReviewerConnection>;
};


/** The value of a reviewers field in a Project item. */
export type gh_ProjectV2ItemFieldReviewerValuereviewersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The value of a single select field in a Project item. */
export type gh_ProjectV2ItemFieldSingleSelectValue = gh_Node & gh_ProjectV2ItemFieldValueCommon & {
  /** The color applied to the selected single-select option. */
  color: gh_ProjectV2SingleSelectFieldOptionColor;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<gh_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** A plain-text description of the selected single-select option, such as what the option means. */
  description?: Maybe<Scalars['String']['output']>;
  /** The description of the selected single-select option, including HTML tags. */
  descriptionHTML?: Maybe<Scalars['String']['output']>;
  /** The project field that contains this value. */
  field: gh_ProjectV2FieldConfiguration;
  /** The Node ID of the ProjectV2ItemFieldSingleSelectValue object */
  id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  item: gh_ProjectV2Item;
  /** The name of the selected single select option. */
  name?: Maybe<Scalars['String']['output']>;
  /** The html name of the selected single select option. */
  nameHTML?: Maybe<Scalars['String']['output']>;
  /** The id of the selected single select option. */
  optionId?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The value of a text field in a Project item. */
export type gh_ProjectV2ItemFieldTextValue = gh_Node & gh_ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<gh_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The project field that contains this value. */
  field: gh_ProjectV2FieldConfiguration;
  /** The Node ID of the ProjectV2ItemFieldTextValue object */
  id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  item: gh_ProjectV2Item;
  /** Text value of a field */
  text?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The value of a user field in a Project item. */
export type gh_ProjectV2ItemFieldUserValue = {
  /** The field that contains this value. */
  field: gh_ProjectV2FieldConfiguration;
  /** The users for this field */
  users?: Maybe<gh_UserConnection>;
};


/** The value of a user field in a Project item. */
export type gh_ProjectV2ItemFieldUserValueusersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Project field values */
export type gh_ProjectV2ItemFieldValue = gh_ProjectV2ItemFieldDateValue | gh_ProjectV2ItemFieldIterationValue | gh_ProjectV2ItemFieldLabelValue | gh_ProjectV2ItemFieldMilestoneValue | gh_ProjectV2ItemFieldNumberValue | gh_ProjectV2ItemFieldPullRequestValue | gh_ProjectV2ItemFieldRepositoryValue | gh_ProjectV2ItemFieldReviewerValue | gh_ProjectV2ItemFieldSingleSelectValue | gh_ProjectV2ItemFieldTextValue | gh_ProjectV2ItemFieldUserValue;

/** Common fields across different project field value types */
export type gh_ProjectV2ItemFieldValueCommon = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  creator?: Maybe<gh_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The project field that contains this value. */
  field: gh_ProjectV2FieldConfiguration;
  /** The Node ID of the ProjectV2ItemFieldValueCommon object */
  id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  item: gh_ProjectV2Item;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for ProjectV2ItemFieldValue. */
export type gh_ProjectV2ItemFieldValueConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ProjectV2ItemFieldValueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ProjectV2ItemFieldValue>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ProjectV2ItemFieldValueEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ProjectV2ItemFieldValue>;
};

/** Ordering options for project v2 item field value connections */
export type gh_ProjectV2ItemFieldValueOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order the project v2 item field values by. */
  field: gh_ProjectV2ItemFieldValueOrderField;
};

/** Properties by which project v2 item field value connections can be ordered. */
export type gh_ProjectV2ItemFieldValueOrderField =
  /** Order project v2 item field values by the their position in the project */
  | 'POSITION';

/** Ordering options for project v2 item connections */
export type gh_ProjectV2ItemOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order the project v2 items by. */
  field: gh_ProjectV2ItemOrderField;
};

/** Properties by which project v2 item connections can be ordered. */
export type gh_ProjectV2ItemOrderField =
  /** Order project v2 items by the their position in the project */
  | 'POSITION';

/** The type of a project item. */
export type gh_ProjectV2ItemType =
  /** Draft Issue */
  | 'DRAFT_ISSUE'
  /** Issue */
  | 'ISSUE'
  /** Pull Request */
  | 'PULL_REQUEST'
  /** Redacted Item */
  | 'REDACTED';

/** An iteration field inside a project. */
export type gh_ProjectV2IterationField = gh_Node & gh_ProjectV2FieldCommon & {
  /** Iteration configuration settings */
  configuration: gh_ProjectV2IterationFieldConfiguration;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The field's type. */
  dataType: gh_ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ProjectV2IterationField object */
  id: Scalars['ID']['output'];
  /** The project field's name. */
  name: Scalars['String']['output'];
  /** The project that contains this field. */
  project: gh_ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** Iteration field configuration for a project. */
export type gh_ProjectV2IterationFieldConfiguration = {
  /** The iteration's completed iterations */
  completedIterations: Array<gh_ProjectV2IterationFieldIteration>;
  /** The iteration's duration in days */
  duration: Scalars['Int']['output'];
  /** The iteration's iterations */
  iterations: Array<gh_ProjectV2IterationFieldIteration>;
  /** The iteration's start day of the week */
  startDay: Scalars['Int']['output'];
};

/** Iteration field iteration settings for a project. */
export type gh_ProjectV2IterationFieldIteration = {
  /** The iteration's duration in days */
  duration: Scalars['Int']['output'];
  /** The iteration's ID. */
  id: Scalars['String']['output'];
  /** The iteration's start date */
  startDate: Scalars['Date']['output'];
  /** The iteration's title. */
  title: Scalars['String']['output'];
  /** The iteration's html title. */
  titleHTML: Scalars['String']['output'];
};

/** Ways in which lists of projects can be ordered upon return. */
export type gh_ProjectV2Order = {
  /** The direction in which to order projects by the specified field. */
  direction: gh_OrderDirection;
  /** The field in which to order projects by. */
  field: gh_ProjectV2OrderField;
};

/** Properties by which projects can be ordered. */
export type gh_ProjectV2OrderField =
  /** The project's date and time of creation */
  | 'CREATED_AT'
  /** The project's number */
  | 'NUMBER'
  /** The project's title */
  | 'TITLE'
  /** The project's date and time of update */
  | 'UPDATED_AT';

/** Represents an owner of a project. */
export type gh_ProjectV2Owner = {
  /** The Node ID of the ProjectV2Owner object */
  id: Scalars['ID']['output'];
  /** Find a project by number. */
  projectV2?: Maybe<gh_ProjectV2>;
  /** A list of projects under the owner. */
  projectsV2: gh_ProjectV2Connection;
};


/** Represents an owner of a project. */
export type gh_ProjectV2OwnerprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** Represents an owner of a project. */
export type gh_ProjectV2OwnerprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};

/** Recent projects for the owner. */
export type gh_ProjectV2Recent = {
  /** Recent projects that this user has modified in the context of the owner. */
  recentProjects: gh_ProjectV2Connection;
};


/** Recent projects for the owner. */
export type gh_ProjectV2RecentrecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The possible roles of a collaborator on a project. */
export type gh_ProjectV2Roles =
  /** The collaborator can view, edit, and maange the settings of the project */
  | 'ADMIN'
  /** The collaborator has no direct access to the project */
  | 'NONE'
  /** The collaborator can view the project */
  | 'READER'
  /** The collaborator can view and edit the project */
  | 'WRITER';

/** A single select field inside a project. */
export type gh_ProjectV2SingleSelectField = gh_Node & gh_ProjectV2FieldCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The field's type. */
  dataType: gh_ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ProjectV2SingleSelectField object */
  id: Scalars['ID']['output'];
  /** The project field's name. */
  name: Scalars['String']['output'];
  /** Options for the single select field */
  options: Array<gh_ProjectV2SingleSelectFieldOption>;
  /** The project that contains this field. */
  project: gh_ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};


/** A single select field inside a project. */
export type gh_ProjectV2SingleSelectFieldoptionsArgs = {
  names?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Single select field option for a configuration for a project. */
export type gh_ProjectV2SingleSelectFieldOption = {
  /** The option's display color. */
  color: gh_ProjectV2SingleSelectFieldOptionColor;
  /** The option's plain-text description. */
  description: Scalars['String']['output'];
  /** The option's description, possibly containing HTML. */
  descriptionHTML: Scalars['String']['output'];
  /** The option's ID. */
  id: Scalars['String']['output'];
  /** The option's name. */
  name: Scalars['String']['output'];
  /** The option's html name. */
  nameHTML: Scalars['String']['output'];
};

/** The display color of a single-select field option. */
export type gh_ProjectV2SingleSelectFieldOptionColor =
  /** BLUE */
  | 'BLUE'
  /** GRAY */
  | 'GRAY'
  /** GREEN */
  | 'GREEN'
  /** ORANGE */
  | 'ORANGE'
  /** PINK */
  | 'PINK'
  /** PURPLE */
  | 'PURPLE'
  /** RED */
  | 'RED'
  /** YELLOW */
  | 'YELLOW';

/** Represents a single select field option */
export type gh_ProjectV2SingleSelectFieldOptionInput = {
  /** The display color of the option */
  color: gh_ProjectV2SingleSelectFieldOptionColor;
  /** The description text of the option */
  description: Scalars['String']['input'];
  /** The name of the option */
  name: Scalars['String']['input'];
};

/** Represents a sort by field and direction. */
export type gh_ProjectV2SortBy = {
  /** The direction of the sorting. Possible values are ASC and DESC. */
  direction: gh_OrderDirection;
  /** The field by which items are sorted. */
  field: gh_ProjectV2Field;
};

/** The connection type for ProjectV2SortBy. */
export type gh_ProjectV2SortByConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ProjectV2SortByEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ProjectV2SortBy>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ProjectV2SortByEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ProjectV2SortBy>;
};

/** Represents a sort by field and direction. */
export type gh_ProjectV2SortByField = {
  /** The direction of the sorting. Possible values are ASC and DESC. */
  direction: gh_OrderDirection;
  /** The field by which items are sorted. */
  field: gh_ProjectV2FieldConfiguration;
};

/** The connection type for ProjectV2SortByField. */
export type gh_ProjectV2SortByFieldConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ProjectV2SortByFieldEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ProjectV2SortByField>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ProjectV2SortByFieldEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ProjectV2SortByField>;
};

/** The possible states of a project v2. */
export type gh_ProjectV2State =
  /** A project v2 that has been closed */
  | 'CLOSED'
  /** A project v2 that is still open */
  | 'OPEN';

/** A view within a ProjectV2. */
export type gh_ProjectV2View = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The view's visible fields. */
  fields?: Maybe<gh_ProjectV2FieldConfigurationConnection>;
  /** The project view's filter. */
  filter?: Maybe<Scalars['String']['output']>;
  /**
   * The view's group-by field.
   * @deprecated The `ProjectV2View#order_by` API is deprecated in favour of the more capable `ProjectV2View#group_by_field` API. Check out the `ProjectV2View#group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  groupBy?: Maybe<gh_ProjectV2FieldConnection>;
  /** The view's group-by field. */
  groupByFields?: Maybe<gh_ProjectV2FieldConfigurationConnection>;
  /** The Node ID of the ProjectV2View object */
  id: Scalars['ID']['output'];
  /** The project view's layout. */
  layout: gh_ProjectV2ViewLayout;
  /** The project view's name. */
  name: Scalars['String']['output'];
  /** The project view's number. */
  number: Scalars['Int']['output'];
  /** The project that contains this view. */
  project: gh_ProjectV2;
  /**
   * The view's sort-by config.
   * @deprecated The `ProjectV2View#sort_by` API is deprecated in favour of the more capable `ProjectV2View#sort_by_fields` API. Check out the `ProjectV2View#sort_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  sortBy?: Maybe<gh_ProjectV2SortByConnection>;
  /** The view's sort-by config. */
  sortByFields?: Maybe<gh_ProjectV2SortByFieldConnection>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /**
   * The view's vertical-group-by field.
   * @deprecated The `ProjectV2View#vertical_group_by` API is deprecated in favour of the more capable `ProjectV2View#vertical_group_by_fields` API. Check out the `ProjectV2View#vertical_group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  verticalGroupBy?: Maybe<gh_ProjectV2FieldConnection>;
  /** The view's vertical-group-by field. */
  verticalGroupByFields?: Maybe<gh_ProjectV2FieldConfigurationConnection>;
  /**
   * The view's visible fields.
   * @deprecated The `ProjectV2View#visibleFields` API is deprecated in favour of the more capable `ProjectV2View#fields` API. Check out the `ProjectV2View#fields` API as an example for the more capable alternative. Removal on 2023-01-01 UTC.
   */
  visibleFields?: Maybe<gh_ProjectV2FieldConnection>;
};


/** A view within a ProjectV2. */
export type gh_ProjectV2ViewfieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type gh_ProjectV2ViewgroupByArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type gh_ProjectV2ViewgroupByFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type gh_ProjectV2ViewsortByArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A view within a ProjectV2. */
export type gh_ProjectV2ViewsortByFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A view within a ProjectV2. */
export type gh_ProjectV2ViewverticalGroupByArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type gh_ProjectV2ViewverticalGroupByFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type gh_ProjectV2ViewvisibleFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2FieldOrder>;
};

/** The connection type for ProjectV2View. */
export type gh_ProjectV2ViewConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ProjectV2ViewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ProjectV2View>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ProjectV2ViewEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ProjectV2View>;
};

/** The layout of a project v2 view. */
export type gh_ProjectV2ViewLayout =
  /** Board layout */
  | 'BOARD_LAYOUT'
  /** Roadmap layout */
  | 'ROADMAP_LAYOUT'
  /** Table layout */
  | 'TABLE_LAYOUT';

/** Ordering options for project v2 view connections */
export type gh_ProjectV2ViewOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order the project v2 views by. */
  field: gh_ProjectV2ViewOrderField;
};

/** Properties by which project v2 view connections can be ordered. */
export type gh_ProjectV2ViewOrderField =
  /** Order project v2 views by creation time */
  | 'CREATED_AT'
  /** Order project v2 views by name */
  | 'NAME'
  /** Order project v2 views by position */
  | 'POSITION';

/** A workflow inside a project. */
export type gh_ProjectV2Workflow = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** Whether the workflow is enabled. */
  enabled: Scalars['Boolean']['output'];
  /** The Node ID of the ProjectV2Workflow object */
  id: Scalars['ID']['output'];
  /** The name of the workflow. */
  name: Scalars['String']['output'];
  /** The number of the workflow. */
  number: Scalars['Int']['output'];
  /** The project that contains this workflow. */
  project: gh_ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for ProjectV2Workflow. */
export type gh_ProjectV2WorkflowConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ProjectV2WorkflowEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ProjectV2Workflow>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ProjectV2WorkflowEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ProjectV2Workflow>;
};

/** Ordering options for project v2 workflows connections */
export type gh_ProjectV2WorkflowOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order the project v2 workflows by. */
  field: gh_ProjectV2WorkflowsOrderField;
};

/** Properties by which project workflows can be ordered. */
export type gh_ProjectV2WorkflowsOrderField =
  /** The date and time of the workflow creation */
  | 'CREATED_AT'
  /** The name of the workflow */
  | 'NAME'
  /** The number of the workflow */
  | 'NUMBER'
  /** The date and time of the workflow update */
  | 'UPDATED_AT';

/** A user's public key. */
export type gh_PublicKey = gh_Node & {
  /** The last time this authorization was used to perform an action. Values will be null for keys not owned by the user. */
  accessedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Identifies the date and time when the key was created. Keys created before
   * March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.
   */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** The fingerprint for this PublicKey. */
  fingerprint: Scalars['String']['output'];
  /** The Node ID of the PublicKey object */
  id: Scalars['ID']['output'];
  /** Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user. */
  isReadOnly?: Maybe<Scalars['Boolean']['output']>;
  /** The public key string. */
  key: Scalars['String']['output'];
  /**
   * Identifies the date and time when the key was updated. Keys created before
   * March 5th, 2014 may have inaccurate values. Values will be null for keys not
   * owned by the user.
   */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** The connection type for PublicKey. */
export type gh_PublicKeyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PublicKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PublicKey>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_PublicKeyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PublicKey>;
};

/** Autogenerated input type of PublishSponsorsTier */
export type gh_PublishSponsorsTierInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the draft tier to publish. */
  tierId: Scalars['ID']['input'];
};

/** Autogenerated return type of PublishSponsorsTier */
export type gh_PublishSponsorsTierPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The tier that was published. */
  sponsorsTier?: Maybe<gh_SponsorsTier>;
};

/** A repository pull request. */
export type gh_PullRequest = gh_Assignable & gh_Closable & gh_Comment & gh_Labelable & gh_Lockable & gh_Node & gh_ProjectV2Owner & gh_Reactable & gh_RepositoryNode & gh_Subscribable & gh_UniformResourceLocatable & gh_Updatable & gh_UpdatableComment & {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<gh_LockReason>;
  /** The number of additions in this pull request. */
  additions: Scalars['Int']['output'];
  /** A list of Users assigned to this object. */
  assignees: gh_UserConnection;
  /** The actor who authored the comment. */
  author?: Maybe<gh_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: gh_CommentAuthorAssociation;
  /** Returns the auto-merge request object if one exists for this pull request. */
  autoMergeRequest?: Maybe<gh_AutoMergeRequest>;
  /** Identifies the base Ref associated with the pull request. */
  baseRef?: Maybe<gh_Ref>;
  /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */
  baseRefName: Scalars['String']['output'];
  /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */
  baseRefOid: Scalars['gh_GitObjectID']['output'];
  /** The repository associated with this pull request's base Ref. */
  baseRepository?: Maybe<gh_Repository>;
  /** The body as Markdown. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /** Whether or not the pull request is rebaseable. */
  canBeRebased: Scalars['Boolean']['output'];
  /** The number of changed files in this pull request. */
  changedFiles: Scalars['Int']['output'];
  /** The HTTP path for the checks of this pull request. */
  checksResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for the checks of this pull request. */
  checksUrl: Scalars['gh_URI']['output'];
  /** `true` if the pull request is closed */
  closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** List of issues that were may be closed by this pull request */
  closingIssuesReferences?: Maybe<gh_IssueConnection>;
  /** A list of comments associated with the pull request. */
  comments: gh_IssueCommentConnection;
  /** A list of commits present in this pull request's head branch not present in the base branch. */
  commits: gh_PullRequestCommitConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The number of deletions in this pull request. */
  deletions: Scalars['Int']['output'];
  /** The actor who edited this pull request's body. */
  editor?: Maybe<gh_Actor>;
  /** Lists the files changed within this pull request. */
  files?: Maybe<gh_PullRequestChangedFileConnection>;
  /** Identifies the head Ref associated with the pull request. */
  headRef?: Maybe<gh_Ref>;
  /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */
  headRefName: Scalars['String']['output'];
  /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */
  headRefOid: Scalars['gh_GitObjectID']['output'];
  /** The repository associated with this pull request's head Ref. */
  headRepository?: Maybe<gh_Repository>;
  /** The owner of the repository associated with this pull request's head Ref. */
  headRepositoryOwner?: Maybe<gh_RepositoryOwner>;
  /** The hovercard information for this issue */
  hovercard: gh_Hovercard;
  /** The Node ID of the PullRequest object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** The head and base repositories are different. */
  isCrossRepository: Scalars['Boolean']['output'];
  /** Identifies if the pull request is a draft. */
  isDraft: Scalars['Boolean']['output'];
  /** Is this pull request read by the viewer */
  isReadByViewer?: Maybe<Scalars['Boolean']['output']>;
  /** A list of labels associated with the object. */
  labels?: Maybe<gh_LabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of latest reviews per user associated with the pull request. */
  latestOpinionatedReviews?: Maybe<gh_PullRequestReviewConnection>;
  /** A list of latest reviews per user associated with the pull request that are not also pending review. */
  latestReviews?: Maybe<gh_PullRequestReviewConnection>;
  /** `true` if the pull request is locked */
  locked: Scalars['Boolean']['output'];
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify: Scalars['Boolean']['output'];
  /** The commit that was created when this pull request was merged. */
  mergeCommit?: Maybe<gh_Commit>;
  /** The merge queue entry of the pull request in the base branch's merge queue */
  mergeQueueEntry?: Maybe<gh_MergeQueueEntry>;
  /** Detailed information about the current pull request merge state status. */
  mergeStateStatus: gh_MergeStateStatus;
  /** Whether or not the pull request can be merged based on the existence of merge conflicts. */
  mergeable: gh_MergeableState;
  /** Whether or not the pull request was merged. */
  merged: Scalars['Boolean']['output'];
  /** The date and time that the pull request was merged. */
  mergedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The actor who merged the pull request. */
  mergedBy?: Maybe<gh_Actor>;
  /** Identifies the milestone associated with the pull request. */
  milestone?: Maybe<gh_Milestone>;
  /** Identifies the pull request number. */
  number: Scalars['Int']['output'];
  /** A list of Users that are participating in the Pull Request conversation. */
  participants: gh_UserConnection;
  /** The permalink to the pull request. */
  permalink: Scalars['gh_URI']['output'];
  /**
   * The commit that GitHub automatically generated to test if this pull request
   * could be merged. This field will not return a value if the pull request is
   * merged, or if the test merge commit is still being generated. See the
   * `mergeable` field for more details on the mergeability of the pull request.
   */
  potentialMergeCommit?: Maybe<gh_Commit>;
  /** List of project cards associated with this pull request. */
  projectCards: gh_ProjectCardConnection;
  /** List of project items associated with this pull request. */
  projectItems: gh_ProjectV2ItemConnection;
  /** Find a project by number. */
  projectV2?: Maybe<gh_ProjectV2>;
  /** A list of projects under the owner. */
  projectsV2: gh_ProjectV2Connection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: gh_ReactionConnection;
  /** The repository associated with this node. */
  repository: gh_Repository;
  /** The HTTP path for this pull request. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP path for reverting this pull request. */
  revertResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for reverting this pull request. */
  revertUrl: Scalars['gh_URI']['output'];
  /** The current status of this pull request with respect to code review. */
  reviewDecision?: Maybe<gh_PullRequestReviewDecision>;
  /** A list of review requests associated with the pull request. */
  reviewRequests?: Maybe<gh_ReviewRequestConnection>;
  /** The list of all review threads for this pull request. */
  reviewThreads: gh_PullRequestReviewThreadConnection;
  /** A list of reviews associated with the pull request. */
  reviews?: Maybe<gh_PullRequestReviewConnection>;
  /** Identifies the state of the pull request. */
  state: gh_PullRequestState;
  /** A list of reviewer suggestions based on commit history and past review comments. */
  suggestedReviewers: Array<Maybe<gh_SuggestedReviewer>>;
  /**
   * A list of events, comments, commits, etc. associated with the pull request.
   * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.
   */
  timeline: gh_PullRequestTimelineConnection;
  /** A list of events, comments, commits, etc. associated with the pull request. */
  timelineItems: gh_PullRequestTimelineItemsConnection;
  /** Identifies the pull request title. */
  title: Scalars['String']['output'];
  /** Identifies the pull request title rendered to HTML. */
  titleHTML: Scalars['gh_HTML']['output'];
  /** Returns a count of how many comments this pull request has received. */
  totalCommentsCount?: Maybe<Scalars['Int']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this pull request. */
  url: Scalars['gh_URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<gh_UserContentEditConnection>;
  /** Whether or not the viewer can apply suggestion. */
  viewerCanApplySuggestion: Scalars['Boolean']['output'];
  /** Indicates if the object can be closed by the viewer. */
  viewerCanClose: Scalars['Boolean']['output'];
  /** Check if the viewer can restore the deleted head ref. */
  viewerCanDeleteHeadRef: Scalars['Boolean']['output'];
  /** Whether or not the viewer can disable auto-merge */
  viewerCanDisableAutoMerge: Scalars['Boolean']['output'];
  /** Can the viewer edit files within this pull request. */
  viewerCanEditFiles: Scalars['Boolean']['output'];
  /** Whether or not the viewer can enable auto-merge */
  viewerCanEnableAutoMerge: Scalars['Boolean']['output'];
  /** Indicates whether the viewer can bypass branch protections and merge the pull request immediately */
  viewerCanMergeAsAdmin: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /**
   * Whether or not the viewer can update the head ref of this PR, by merging or rebasing the base ref.
   * If the head ref is up to date or unable to be updated by this user, this will return false.
   */
  viewerCanUpdateBranch: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<gh_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
  /** The latest review given from the viewer. */
  viewerLatestReview?: Maybe<gh_PullRequestReview>;
  /** The person who has requested the viewer for review on this pull request. */
  viewerLatestReviewRequest?: Maybe<gh_ReviewRequest>;
  /** The merge body text for the viewer and method. */
  viewerMergeBodyText: Scalars['String']['output'];
  /** The merge headline text for the viewer and method. */
  viewerMergeHeadlineText: Scalars['String']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<gh_SubscriptionState>;
};


/** A repository pull request. */
export type gh_PullRequestassigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestclosingIssuesReferencesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueOrder>;
  userLinkedOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueCommentOrder>;
};


/** A repository pull request. */
export type gh_PullRequestcommitsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestfilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type gh_PullRequesthovercardArgs = {
  includeNotificationContexts?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestlabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_LabelOrder>;
};


/** A repository pull request. */
export type gh_PullRequestlatestOpinionatedReviewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  writersOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestlatestReviewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestparticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestprojectCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedStates?: InputMaybe<Array<InputMaybe<gh_ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestprojectItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** A repository pull request. */
export type gh_PullRequestprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<gh_ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ReactionOrder>;
};


/** A repository pull request. */
export type gh_PullRequestreviewRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestreviewThreadsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestreviewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  states?: InputMaybe<Array<gh_PullRequestReviewState>>;
};


/** A repository pull request. */
export type gh_PullRequesttimelineArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A repository pull request. */
export type gh_PullRequesttimelineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  itemTypes?: InputMaybe<Array<gh_PullRequestTimelineItemsItemType>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
export type gh_PullRequestviewerMergeBodyTextArgs = {
  mergeType?: InputMaybe<gh_PullRequestMergeMethod>;
};


/** A repository pull request. */
export type gh_PullRequestviewerMergeHeadlineTextArgs = {
  mergeType?: InputMaybe<gh_PullRequestMergeMethod>;
};

/** The possible methods for updating a pull request's head branch with the base branch. */
export type gh_PullRequestBranchUpdateMethod =
  /** Update branch via merge */
  | 'MERGE'
  /** Update branch via rebase */
  | 'REBASE';

/** A file changed in a pull request. */
export type gh_PullRequestChangedFile = {
  /** The number of additions to the file. */
  additions: Scalars['Int']['output'];
  /** How the file was changed in this PullRequest */
  changeType: gh_PatchStatus;
  /** The number of deletions to the file. */
  deletions: Scalars['Int']['output'];
  /** The path of the file. */
  path: Scalars['String']['output'];
  /** The state of the file for the viewer. */
  viewerViewedState: gh_FileViewedState;
};

/** The connection type for PullRequestChangedFile. */
export type gh_PullRequestChangedFileConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PullRequestChangedFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PullRequestChangedFile>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_PullRequestChangedFileEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PullRequestChangedFile>;
};

/** Represents a Git commit part of a pull request. */
export type gh_PullRequestCommit = gh_Node & gh_UniformResourceLocatable & {
  /** The Git commit object */
  commit: gh_Commit;
  /** The Node ID of the PullRequestCommit object */
  id: Scalars['ID']['output'];
  /** The pull request this commit belongs to */
  pullRequest: gh_PullRequest;
  /** The HTTP path for this pull request commit */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this pull request commit */
  url: Scalars['gh_URI']['output'];
};

/** Represents a commit comment thread part of a pull request. */
export type gh_PullRequestCommitCommentThread = gh_Node & gh_RepositoryNode & {
  /** The comments that exist in this thread. */
  comments: gh_CommitCommentConnection;
  /** The commit the comments were made on. */
  commit: gh_Commit;
  /** The Node ID of the PullRequestCommitCommentThread object */
  id: Scalars['ID']['output'];
  /** The file the comments were made on. */
  path?: Maybe<Scalars['String']['output']>;
  /** The position in the diff for the commit that the comment was made on. */
  position?: Maybe<Scalars['Int']['output']>;
  /** The pull request this commit comment thread belongs to */
  pullRequest: gh_PullRequest;
  /** The repository associated with this node. */
  repository: gh_Repository;
};


/** Represents a commit comment thread part of a pull request. */
export type gh_PullRequestCommitCommentThreadcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PullRequestCommit. */
export type gh_PullRequestCommitConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PullRequestCommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PullRequestCommit>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_PullRequestCommitEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PullRequestCommit>;
};

/** The connection type for PullRequest. */
export type gh_PullRequestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PullRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PullRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** This aggregates pull requests opened by a user within one repository. */
export type gh_PullRequestContributionsByRepository = {
  /** The pull request contributions. */
  contributions: gh_CreatedPullRequestContributionConnection;
  /** The repository in which the pull requests were opened. */
  repository: gh_Repository;
};


/** This aggregates pull requests opened by a user within one repository. */
export type gh_PullRequestContributionsByRepositorycontributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ContributionOrder>;
};

/** An edge in a connection. */
export type gh_PullRequestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PullRequest>;
};

/** Represents available types of methods to use when merging a pull request. */
export type gh_PullRequestMergeMethod =
  /** Add all commits from the head branch to the base branch with a merge commit. */
  | 'MERGE'
  /** Add all commits from the head branch onto the base branch individually. */
  | 'REBASE'
  /** Combine all commits from the head branch into a single commit in the base branch. */
  | 'SQUASH';

/** Ways in which lists of issues can be ordered upon return. */
export type gh_PullRequestOrder = {
  /** The direction in which to order pull requests by the specified field. */
  direction: gh_OrderDirection;
  /** The field in which to order pull requests by. */
  field: gh_PullRequestOrderField;
};

/** Properties by which pull_requests connections can be ordered. */
export type gh_PullRequestOrderField =
  /** Order pull_requests by creation time */
  | 'CREATED_AT'
  /** Order pull_requests by update time */
  | 'UPDATED_AT';

/** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
export type gh_PullRequestParameters = {
  /** New, reviewable commits pushed will dismiss previous pull request review approvals. */
  dismissStaleReviewsOnPush: Scalars['Boolean']['output'];
  /** Require an approving review in pull requests that modify files that have a designated code owner. */
  requireCodeOwnerReview: Scalars['Boolean']['output'];
  /** Whether the most recent reviewable push must be approved by someone other than the person who pushed it. */
  requireLastPushApproval: Scalars['Boolean']['output'];
  /** The number of approving reviews that are required before a pull request can be merged. */
  requiredApprovingReviewCount: Scalars['Int']['output'];
  /** All conversations on code must be resolved before a pull request can be merged. */
  requiredReviewThreadResolution: Scalars['Boolean']['output'];
};

/** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
export type gh_PullRequestParametersInput = {
  /** New, reviewable commits pushed will dismiss previous pull request review approvals. */
  dismissStaleReviewsOnPush: Scalars['Boolean']['input'];
  /** Require an approving review in pull requests that modify files that have a designated code owner. */
  requireCodeOwnerReview: Scalars['Boolean']['input'];
  /** Whether the most recent reviewable push must be approved by someone other than the person who pushed it. */
  requireLastPushApproval: Scalars['Boolean']['input'];
  /** The number of approving reviews that are required before a pull request can be merged. */
  requiredApprovingReviewCount: Scalars['Int']['input'];
  /** All conversations on code must be resolved before a pull request can be merged. */
  requiredReviewThreadResolution: Scalars['Boolean']['input'];
};

/** A review object for a given pull request. */
export type gh_PullRequestReview = gh_Comment & gh_Deletable & gh_Minimizable & gh_Node & gh_Reactable & gh_RepositoryNode & gh_Updatable & gh_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<gh_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: gh_CommentAuthorAssociation;
  /** Indicates whether the author of this review has push access to the repository. */
  authorCanPushToRepository: Scalars['Boolean']['output'];
  /** Identifies the pull request review body. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** The body of this review rendered as plain text. */
  bodyText: Scalars['String']['output'];
  /** A list of review comments for the current pull request review. */
  comments: gh_PullRequestReviewCommentConnection;
  /** Identifies the commit associated with this pull request review. */
  commit?: Maybe<gh_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<gh_Actor>;
  /** The Node ID of the PullRequestReview object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** A list of teams that this review was made on behalf of. */
  onBehalfOf: gh_TeamConnection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the pull request associated with this pull request review. */
  pullRequest: gh_PullRequest;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: gh_ReactionConnection;
  /** The repository associated with this node. */
  repository: gh_Repository;
  /** The HTTP path permalink for this PullRequestReview. */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the current state of the pull request review. */
  state: gh_PullRequestReviewState;
  /** Identifies when the Pull Request Review was submitted */
  submittedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL permalink for this PullRequestReview. */
  url: Scalars['gh_URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<gh_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<gh_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** A review object for a given pull request. */
export type gh_PullRequestReviewcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A review object for a given pull request. */
export type gh_PullRequestReviewonBehalfOfArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A review object for a given pull request. */
export type gh_PullRequestReviewreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<gh_ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ReactionOrder>;
};


/** A review object for a given pull request. */
export type gh_PullRequestReviewuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A review comment associated with a given repository pull request. */
export type gh_PullRequestReviewComment = gh_Comment & gh_Deletable & gh_Minimizable & gh_Node & gh_Reactable & gh_RepositoryNode & gh_Updatable & gh_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<gh_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: gh_CommentAuthorAssociation;
  /** The comment body of this review comment. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** The comment body of this review comment rendered as plain text. */
  bodyText: Scalars['String']['output'];
  /** Identifies the commit associated with the comment. */
  commit?: Maybe<gh_Commit>;
  /** Identifies when the comment was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The diff hunk to which the comment applies. */
  diffHunk: Scalars['String']['output'];
  /** Identifies when the comment was created in a draft state. */
  draftedAt: Scalars['DateTime']['output'];
  /** The actor who edited the comment. */
  editor?: Maybe<gh_Actor>;
  /** The Node ID of the PullRequestReviewComment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The end line number on the file to which the comment applies */
  line?: Maybe<Scalars['Int']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies the original commit associated with the comment. */
  originalCommit?: Maybe<gh_Commit>;
  /** The end line number on the file to which the comment applied when it was first created */
  originalLine?: Maybe<Scalars['Int']['output']>;
  /**
   * The original line index in the diff to which the comment applies.
   * @deprecated We are phasing out diff-relative positioning for PR comments Removal on 2023-10-01 UTC.
   */
  originalPosition: Scalars['Int']['output'];
  /** The start line number on the file to which the comment applied when it was first created */
  originalStartLine?: Maybe<Scalars['Int']['output']>;
  /** Identifies when the comment body is outdated */
  outdated: Scalars['Boolean']['output'];
  /** The path to which the comment applies. */
  path: Scalars['String']['output'];
  /**
   * The line index in the diff to which the comment applies.
   * @deprecated We are phasing out diff-relative positioning for PR comments Use the `line` and `startLine` fields instead, which are file line numbers instead of diff line numbers Removal on 2023-10-01 UTC.
   */
  position?: Maybe<Scalars['Int']['output']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The pull request associated with this review comment. */
  pullRequest: gh_PullRequest;
  /** The pull request review associated with this review comment. */
  pullRequestReview?: Maybe<gh_PullRequestReview>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: gh_ReactionConnection;
  /** The comment this is a reply to. */
  replyTo?: Maybe<gh_PullRequestReviewComment>;
  /** The repository associated with this node. */
  repository: gh_Repository;
  /** The HTTP path permalink for this review comment. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The start line number on the file to which the comment applies */
  startLine?: Maybe<Scalars['Int']['output']>;
  /** Identifies the state of the comment. */
  state: gh_PullRequestReviewCommentState;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  subjectType: gh_PullRequestReviewThreadSubjectType;
  /** Identifies when the comment was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL permalink for this review comment. */
  url: Scalars['gh_URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<gh_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<gh_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** A review comment associated with a given repository pull request. */
export type gh_PullRequestReviewCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<gh_ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ReactionOrder>;
};


/** A review comment associated with a given repository pull request. */
export type gh_PullRequestReviewCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PullRequestReviewComment. */
export type gh_PullRequestReviewCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PullRequestReviewCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PullRequestReviewComment>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_PullRequestReviewCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PullRequestReviewComment>;
};

/** The possible states of a pull request review comment. */
export type gh_PullRequestReviewCommentState =
  /** A comment that is part of a pending review */
  | 'PENDING'
  /** A comment that is part of a submitted review */
  | 'SUBMITTED';

/** The connection type for PullRequestReview. */
export type gh_PullRequestReviewConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PullRequestReviewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PullRequestReview>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** This aggregates pull request reviews made by a user within one repository. */
export type gh_PullRequestReviewContributionsByRepository = {
  /** The pull request review contributions. */
  contributions: gh_CreatedPullRequestReviewContributionConnection;
  /** The repository in which the pull request reviews were made. */
  repository: gh_Repository;
};


/** This aggregates pull request reviews made by a user within one repository. */
export type gh_PullRequestReviewContributionsByRepositorycontributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ContributionOrder>;
};

/** The review status of a pull request. */
export type gh_PullRequestReviewDecision =
  /** The pull request has received an approving review. */
  | 'APPROVED'
  /** Changes have been requested on the pull request. */
  | 'CHANGES_REQUESTED'
  /** A review is required before the pull request can be merged. */
  | 'REVIEW_REQUIRED';

/** An edge in a connection. */
export type gh_PullRequestReviewEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PullRequestReview>;
};

/** The possible events to perform on a pull request review. */
export type gh_PullRequestReviewEvent =
  /** Submit feedback and approve merging these changes. */
  | 'APPROVE'
  /** Submit general feedback without explicit approval. */
  | 'COMMENT'
  /** Dismiss review so it now longer effects merging. */
  | 'DISMISS'
  /** Submit feedback that must be addressed before merging. */
  | 'REQUEST_CHANGES';

/** The possible states of a pull request review. */
export type gh_PullRequestReviewState =
  /** A review allowing the pull request to merge. */
  | 'APPROVED'
  /** A review blocking the pull request from merging. */
  | 'CHANGES_REQUESTED'
  /** An informational review. */
  | 'COMMENTED'
  /** A review that has been dismissed. */
  | 'DISMISSED'
  /** A review that has not yet been submitted. */
  | 'PENDING';

/** A threaded list of comments for a given pull request. */
export type gh_PullRequestReviewThread = gh_Node & {
  /** A list of pull request comments associated with the thread. */
  comments: gh_PullRequestReviewCommentConnection;
  /** The side of the diff on which this thread was placed. */
  diffSide: gh_DiffSide;
  /** The Node ID of the PullRequestReviewThread object */
  id: Scalars['ID']['output'];
  /** Whether or not the thread has been collapsed (resolved) */
  isCollapsed: Scalars['Boolean']['output'];
  /** Indicates whether this thread was outdated by newer changes. */
  isOutdated: Scalars['Boolean']['output'];
  /** Whether this thread has been resolved */
  isResolved: Scalars['Boolean']['output'];
  /** The line in the file to which this thread refers */
  line?: Maybe<Scalars['Int']['output']>;
  /** The original line in the file to which this thread refers. */
  originalLine?: Maybe<Scalars['Int']['output']>;
  /** The original start line in the file to which this thread refers (multi-line only). */
  originalStartLine?: Maybe<Scalars['Int']['output']>;
  /** Identifies the file path of this thread. */
  path: Scalars['String']['output'];
  /** Identifies the pull request associated with this thread. */
  pullRequest: gh_PullRequest;
  /** Identifies the repository associated with this thread. */
  repository: gh_Repository;
  /** The user who resolved this thread */
  resolvedBy?: Maybe<gh_User>;
  /** The side of the diff that the first line of the thread starts on (multi-line only) */
  startDiffSide?: Maybe<gh_DiffSide>;
  /** The start line in the file to which this thread refers (multi-line only) */
  startLine?: Maybe<Scalars['Int']['output']>;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  subjectType: gh_PullRequestReviewThreadSubjectType;
  /** Indicates whether the current viewer can reply to this thread. */
  viewerCanReply: Scalars['Boolean']['output'];
  /** Whether or not the viewer can resolve this thread */
  viewerCanResolve: Scalars['Boolean']['output'];
  /** Whether or not the viewer can unresolve this thread */
  viewerCanUnresolve: Scalars['Boolean']['output'];
};


/** A threaded list of comments for a given pull request. */
export type gh_PullRequestReviewThreadcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
};

/** Review comment threads for a pull request review. */
export type gh_PullRequestReviewThreadConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PullRequestReviewThreadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PullRequestReviewThread>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_PullRequestReviewThreadEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PullRequestReviewThread>;
};

/** The possible subject types of a pull request review comment. */
export type gh_PullRequestReviewThreadSubjectType =
  /** A comment that has been made against the file of a pull request */
  | 'FILE'
  /** A comment that has been made against the line of a pull request */
  | 'LINE';

/** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
export type gh_PullRequestRevisionMarker = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The last commit the viewer has seen. */
  lastSeenCommit: gh_Commit;
  /** The pull request to which the marker belongs. */
  pullRequest: gh_PullRequest;
};

/** The possible states of a pull request. */
export type gh_PullRequestState =
  /** A pull request that has been closed without being merged. */
  | 'CLOSED'
  /** A pull request that has been closed by being merged. */
  | 'MERGED'
  /** A pull request that is still open. */
  | 'OPEN';

/** A repository pull request template. */
export type gh_PullRequestTemplate = {
  /** The body of the template */
  body?: Maybe<Scalars['String']['output']>;
  /** The filename of the template */
  filename?: Maybe<Scalars['String']['output']>;
  /** The repository the template belongs to */
  repository: gh_Repository;
};

/** A threaded list of comments for a given pull request. */
export type gh_PullRequestThread = gh_Node & {
  /** A list of pull request comments associated with the thread. */
  comments: gh_PullRequestReviewCommentConnection;
  /** The side of the diff on which this thread was placed. */
  diffSide: gh_DiffSide;
  /** The Node ID of the PullRequestThread object */
  id: Scalars['ID']['output'];
  /** Whether or not the thread has been collapsed (resolved) */
  isCollapsed: Scalars['Boolean']['output'];
  /** Indicates whether this thread was outdated by newer changes. */
  isOutdated: Scalars['Boolean']['output'];
  /** Whether this thread has been resolved */
  isResolved: Scalars['Boolean']['output'];
  /** The line in the file to which this thread refers */
  line?: Maybe<Scalars['Int']['output']>;
  /** Identifies the file path of this thread. */
  path: Scalars['String']['output'];
  /** Identifies the pull request associated with this thread. */
  pullRequest: gh_PullRequest;
  /** Identifies the repository associated with this thread. */
  repository: gh_Repository;
  /** The user who resolved this thread */
  resolvedBy?: Maybe<gh_User>;
  /** The side of the diff that the first line of the thread starts on (multi-line only) */
  startDiffSide?: Maybe<gh_DiffSide>;
  /** The line of the first file diff in the thread. */
  startLine?: Maybe<Scalars['Int']['output']>;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  subjectType: gh_PullRequestReviewThreadSubjectType;
  /** Indicates whether the current viewer can reply to this thread. */
  viewerCanReply: Scalars['Boolean']['output'];
  /** Whether or not the viewer can resolve this thread */
  viewerCanResolve: Scalars['Boolean']['output'];
  /** Whether or not the viewer can unresolve this thread */
  viewerCanUnresolve: Scalars['Boolean']['output'];
};


/** A threaded list of comments for a given pull request. */
export type gh_PullRequestThreadcommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PullRequestTimelineItem. */
export type gh_PullRequestTimelineConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PullRequestTimelineItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PullRequestTimelineItem>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An item in a pull request timeline */
export type gh_PullRequestTimelineItem = gh_AssignedEvent | gh_BaseRefDeletedEvent | gh_BaseRefForcePushedEvent | gh_ClosedEvent | gh_Commit | gh_CommitCommentThread | gh_CrossReferencedEvent | gh_DemilestonedEvent | gh_DeployedEvent | gh_DeploymentEnvironmentChangedEvent | gh_HeadRefDeletedEvent | gh_HeadRefForcePushedEvent | gh_HeadRefRestoredEvent | gh_IssueComment | gh_LabeledEvent | gh_LockedEvent | gh_MergedEvent | gh_MilestonedEvent | gh_PullRequestReview | gh_PullRequestReviewComment | gh_PullRequestReviewThread | gh_ReferencedEvent | gh_RenamedTitleEvent | gh_ReopenedEvent | gh_ReviewDismissedEvent | gh_ReviewRequestRemovedEvent | gh_ReviewRequestedEvent | gh_SubscribedEvent | gh_UnassignedEvent | gh_UnlabeledEvent | gh_UnlockedEvent | gh_UnsubscribedEvent | gh_UserBlockedEvent;

/** An edge in a connection. */
export type gh_PullRequestTimelineItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PullRequestTimelineItem>;
};

/** An item in a pull request timeline */
export type gh_PullRequestTimelineItems = gh_AddedToMergeQueueEvent | gh_AddedToProjectEvent | gh_AssignedEvent | gh_AutoMergeDisabledEvent | gh_AutoMergeEnabledEvent | gh_AutoRebaseEnabledEvent | gh_AutoSquashEnabledEvent | gh_AutomaticBaseChangeFailedEvent | gh_AutomaticBaseChangeSucceededEvent | gh_BaseRefChangedEvent | gh_BaseRefDeletedEvent | gh_BaseRefForcePushedEvent | gh_ClosedEvent | gh_CommentDeletedEvent | gh_ConnectedEvent | gh_ConvertToDraftEvent | gh_ConvertedNoteToIssueEvent | gh_ConvertedToDiscussionEvent | gh_CrossReferencedEvent | gh_DemilestonedEvent | gh_DeployedEvent | gh_DeploymentEnvironmentChangedEvent | gh_DisconnectedEvent | gh_HeadRefDeletedEvent | gh_HeadRefForcePushedEvent | gh_HeadRefRestoredEvent | gh_IssueComment | gh_LabeledEvent | gh_LockedEvent | gh_MarkedAsDuplicateEvent | gh_MentionedEvent | gh_MergedEvent | gh_MilestonedEvent | gh_MovedColumnsInProjectEvent | gh_PinnedEvent | gh_PullRequestCommit | gh_PullRequestCommitCommentThread | gh_PullRequestReview | gh_PullRequestReviewThread | gh_PullRequestRevisionMarker | gh_ReadyForReviewEvent | gh_ReferencedEvent | gh_RemovedFromMergeQueueEvent | gh_RemovedFromProjectEvent | gh_RenamedTitleEvent | gh_ReopenedEvent | gh_ReviewDismissedEvent | gh_ReviewRequestRemovedEvent | gh_ReviewRequestedEvent | gh_SubscribedEvent | gh_TransferredEvent | gh_UnassignedEvent | gh_UnlabeledEvent | gh_UnlockedEvent | gh_UnmarkedAsDuplicateEvent | gh_UnpinnedEvent | gh_UnsubscribedEvent | gh_UserBlockedEvent;

/** The connection type for PullRequestTimelineItems. */
export type gh_PullRequestTimelineItemsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PullRequestTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars['Int']['output'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PullRequestTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars['Int']['output'];
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** An edge in a connection. */
export type gh_PullRequestTimelineItemsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PullRequestTimelineItems>;
};

/** The possible item types found in a timeline. */
export type gh_PullRequestTimelineItemsItemType =
  /** Represents an 'added_to_merge_queue' event on a given pull request. */
  | 'ADDED_TO_MERGE_QUEUE_EVENT'
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  | 'ADDED_TO_PROJECT_EVENT'
  /** Represents an 'assigned' event on any assignable object. */
  | 'ASSIGNED_EVENT'
  /** Represents a 'automatic_base_change_failed' event on a given pull request. */
  | 'AUTOMATIC_BASE_CHANGE_FAILED_EVENT'
  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
  | 'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT'
  /** Represents a 'auto_merge_disabled' event on a given pull request. */
  | 'AUTO_MERGE_DISABLED_EVENT'
  /** Represents a 'auto_merge_enabled' event on a given pull request. */
  | 'AUTO_MERGE_ENABLED_EVENT'
  /** Represents a 'auto_rebase_enabled' event on a given pull request. */
  | 'AUTO_REBASE_ENABLED_EVENT'
  /** Represents a 'auto_squash_enabled' event on a given pull request. */
  | 'AUTO_SQUASH_ENABLED_EVENT'
  /** Represents a 'base_ref_changed' event on a given issue or pull request. */
  | 'BASE_REF_CHANGED_EVENT'
  /** Represents a 'base_ref_deleted' event on a given pull request. */
  | 'BASE_REF_DELETED_EVENT'
  /** Represents a 'base_ref_force_pushed' event on a given pull request. */
  | 'BASE_REF_FORCE_PUSHED_EVENT'
  /** Represents a 'closed' event on any `Closable`. */
  | 'CLOSED_EVENT'
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  | 'COMMENT_DELETED_EVENT'
  /** Represents a 'connected' event on a given issue or pull request. */
  | 'CONNECTED_EVENT'
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  | 'CONVERTED_NOTE_TO_ISSUE_EVENT'
  /** Represents a 'converted_to_discussion' event on a given issue. */
  | 'CONVERTED_TO_DISCUSSION_EVENT'
  /** Represents a 'convert_to_draft' event on a given pull request. */
  | 'CONVERT_TO_DRAFT_EVENT'
  /** Represents a mention made by one issue or pull request to another. */
  | 'CROSS_REFERENCED_EVENT'
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  | 'DEMILESTONED_EVENT'
  /** Represents a 'deployed' event on a given pull request. */
  | 'DEPLOYED_EVENT'
  /** Represents a 'deployment_environment_changed' event on a given pull request. */
  | 'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT'
  /** Represents a 'disconnected' event on a given issue or pull request. */
  | 'DISCONNECTED_EVENT'
  /** Represents a 'head_ref_deleted' event on a given pull request. */
  | 'HEAD_REF_DELETED_EVENT'
  /** Represents a 'head_ref_force_pushed' event on a given pull request. */
  | 'HEAD_REF_FORCE_PUSHED_EVENT'
  /** Represents a 'head_ref_restored' event on a given pull request. */
  | 'HEAD_REF_RESTORED_EVENT'
  /** Represents a comment on an Issue. */
  | 'ISSUE_COMMENT'
  /** Represents a 'labeled' event on a given issue or pull request. */
  | 'LABELED_EVENT'
  /** Represents a 'locked' event on a given issue or pull request. */
  | 'LOCKED_EVENT'
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  | 'MARKED_AS_DUPLICATE_EVENT'
  /** Represents a 'mentioned' event on a given issue or pull request. */
  | 'MENTIONED_EVENT'
  /** Represents a 'merged' event on a given pull request. */
  | 'MERGED_EVENT'
  /** Represents a 'milestoned' event on a given issue or pull request. */
  | 'MILESTONED_EVENT'
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  | 'MOVED_COLUMNS_IN_PROJECT_EVENT'
  /** Represents a 'pinned' event on a given issue or pull request. */
  | 'PINNED_EVENT'
  /** Represents a Git commit part of a pull request. */
  | 'PULL_REQUEST_COMMIT'
  /** Represents a commit comment thread part of a pull request. */
  | 'PULL_REQUEST_COMMIT_COMMENT_THREAD'
  /** A review object for a given pull request. */
  | 'PULL_REQUEST_REVIEW'
  /** A threaded list of comments for a given pull request. */
  | 'PULL_REQUEST_REVIEW_THREAD'
  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
  | 'PULL_REQUEST_REVISION_MARKER'
  /** Represents a 'ready_for_review' event on a given pull request. */
  | 'READY_FOR_REVIEW_EVENT'
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  | 'REFERENCED_EVENT'
  /** Represents a 'removed_from_merge_queue' event on a given pull request. */
  | 'REMOVED_FROM_MERGE_QUEUE_EVENT'
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  | 'REMOVED_FROM_PROJECT_EVENT'
  /** Represents a 'renamed' event on a given issue or pull request */
  | 'RENAMED_TITLE_EVENT'
  /** Represents a 'reopened' event on any `Closable`. */
  | 'REOPENED_EVENT'
  /** Represents a 'review_dismissed' event on a given issue or pull request. */
  | 'REVIEW_DISMISSED_EVENT'
  /** Represents an 'review_requested' event on a given pull request. */
  | 'REVIEW_REQUESTED_EVENT'
  /** Represents an 'review_request_removed' event on a given pull request. */
  | 'REVIEW_REQUEST_REMOVED_EVENT'
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  | 'SUBSCRIBED_EVENT'
  /** Represents a 'transferred' event on a given issue or pull request. */
  | 'TRANSFERRED_EVENT'
  /** Represents an 'unassigned' event on any assignable object. */
  | 'UNASSIGNED_EVENT'
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  | 'UNLABELED_EVENT'
  /** Represents an 'unlocked' event on a given issue or pull request. */
  | 'UNLOCKED_EVENT'
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  | 'UNMARKED_AS_DUPLICATE_EVENT'
  /** Represents an 'unpinned' event on a given issue or pull request. */
  | 'UNPINNED_EVENT'
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  | 'UNSUBSCRIBED_EVENT'
  /** Represents a 'user_blocked' event on a given user. */
  | 'USER_BLOCKED_EVENT';

/** The possible target states when updating a pull request. */
export type gh_PullRequestUpdateState =
  /** A pull request that has been closed without being merged. */
  | 'CLOSED'
  /** A pull request that is still open. */
  | 'OPEN';

/** A Git push. */
export type gh_Push = gh_Node & {
  /** The Node ID of the Push object */
  id: Scalars['ID']['output'];
  /** The SHA after the push */
  nextSha?: Maybe<Scalars['gh_GitObjectID']['output']>;
  /** The permalink for this push. */
  permalink: Scalars['gh_URI']['output'];
  /** The SHA before the push */
  previousSha?: Maybe<Scalars['gh_GitObjectID']['output']>;
  /** The actor who pushed */
  pusher: gh_Actor;
  /** The repository that was pushed to */
  repository: gh_Repository;
};

/** A team, user, or app who has the ability to push to a protected branch. */
export type gh_PushAllowance = gh_Node & {
  /** The actor that can push. */
  actor?: Maybe<gh_PushAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<gh_BranchProtectionRule>;
  /** The Node ID of the PushAllowance object */
  id: Scalars['ID']['output'];
};

/** Types that can be an actor. */
export type gh_PushAllowanceActor = gh_App | gh_Team | gh_User;

/** The connection type for PushAllowance. */
export type gh_PushAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_PushAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_PushAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_PushAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_PushAllowance>;
};

/** Represents the client's rate limit. */
export type gh_RateLimit = {
  /** The point cost for the current query counting against the rate limit. */
  cost: Scalars['Int']['output'];
  /** The maximum number of points the client is permitted to consume in a 60 minute window. */
  limit: Scalars['Int']['output'];
  /** The maximum number of nodes this query may return */
  nodeCount: Scalars['Int']['output'];
  /** The number of points remaining in the current rate limit window. */
  remaining: Scalars['Int']['output'];
  /** The time at which the current rate limit window resets in UTC epoch seconds. */
  resetAt: Scalars['DateTime']['output'];
  /** The number of points used in the current rate limit window. */
  used: Scalars['Int']['output'];
};

/** Represents a subject that can be reacted on. */
export type gh_Reactable = {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the Reactable object */
  id: Scalars['ID']['output'];
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: gh_ReactionConnection;
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
};


/** Represents a subject that can be reacted on. */
export type gh_ReactablereactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<gh_ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ReactionOrder>;
};

/** The connection type for User. */
export type gh_ReactingUserConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ReactingUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_User>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a user that's made a reaction. */
export type gh_ReactingUserEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  node: gh_User;
  /** The moment when the user made the reaction. */
  reactedAt: Scalars['DateTime']['output'];
};

/** An emoji reaction to a particular piece of content. */
export type gh_Reaction = gh_Node & {
  /** Identifies the emoji reaction. */
  content: gh_ReactionContent;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the Reaction object */
  id: Scalars['ID']['output'];
  /** The reactable piece of content */
  reactable: gh_Reactable;
  /** Identifies the user who created this reaction. */
  user?: Maybe<gh_User>;
};

/** A list of reactions that have been left on the subject. */
export type gh_ReactionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ReactionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Reaction>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars['Boolean']['output'];
};

/** Emojis that can be attached to Issues, Pull Requests and Comments. */
export type gh_ReactionContent =
  /** Represents the `:confused:` emoji. */
  | 'CONFUSED'
  /** Represents the `:eyes:` emoji. */
  | 'EYES'
  /** Represents the `:heart:` emoji. */
  | 'HEART'
  /** Represents the `:hooray:` emoji. */
  | 'HOORAY'
  /** Represents the `:laugh:` emoji. */
  | 'LAUGH'
  /** Represents the `:rocket:` emoji. */
  | 'ROCKET'
  /** Represents the `:-1:` emoji. */
  | 'THUMBS_DOWN'
  /** Represents the `:+1:` emoji. */
  | 'THUMBS_UP';

/** An edge in a connection. */
export type gh_ReactionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Reaction>;
};

/** A group of emoji reactions to a particular piece of content. */
export type gh_ReactionGroup = {
  /** Identifies the emoji reaction. */
  content: gh_ReactionContent;
  /** Identifies when the reaction was created. */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Reactors to the reaction subject with the emotion represented by this reaction group. */
  reactors: gh_ReactorConnection;
  /** The subject that was reacted to. */
  subject: gh_Reactable;
  /**
   * Users who have reacted to the reaction subject with the emotion represented by this reaction group
   * @deprecated Reactors can now be mannequins, bots, and organizations. Use the `reactors` field instead. Removal on 2021-10-01 UTC.
   */
  users: gh_ReactingUserConnection;
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars['Boolean']['output'];
};


/** A group of emoji reactions to a particular piece of content. */
export type gh_ReactionGroupreactorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A group of emoji reactions to a particular piece of content. */
export type gh_ReactionGroupusersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Ways in which lists of reactions can be ordered upon return. */
export type gh_ReactionOrder = {
  /** The direction in which to order reactions by the specified field. */
  direction: gh_OrderDirection;
  /** The field in which to order reactions by. */
  field: gh_ReactionOrderField;
};

/** A list of fields that reactions can be ordered by. */
export type gh_ReactionOrderField =
  /** Allows ordering a list of reactions by when they were created. */
  | 'CREATED_AT';

/** Types that can be assigned to reactions. */
export type gh_Reactor = gh_Bot | gh_Mannequin | gh_Organization | gh_User;

/** The connection type for Reactor. */
export type gh_ReactorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ReactorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Reactor>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents an author of a reaction. */
export type gh_ReactorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The author of the reaction. */
  node: gh_Reactor;
  /** The moment when the user made the reaction. */
  reactedAt: Scalars['DateTime']['output'];
};

/** Represents a 'ready_for_review' event on a given pull request. */
export type gh_ReadyForReviewEvent = gh_Node & gh_UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ReadyForReviewEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
  /** The HTTP path for this ready for review event. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this ready for review event. */
  url: Scalars['gh_URI']['output'];
};

/** Represents a Git reference. */
export type gh_Ref = gh_Node & {
  /** A list of pull requests with this ref as the head ref. */
  associatedPullRequests: gh_PullRequestConnection;
  /** Branch protection rules for this ref */
  branchProtectionRule?: Maybe<gh_BranchProtectionRule>;
  /** Compares the current ref as a base ref to another head ref, if the comparison can be made. */
  compare?: Maybe<gh_Comparison>;
  /** The Node ID of the Ref object */
  id: Scalars['ID']['output'];
  /** The ref name. */
  name: Scalars['String']['output'];
  /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */
  prefix: Scalars['String']['output'];
  /** Branch protection rules that are viewable by non-admins */
  refUpdateRule?: Maybe<gh_RefUpdateRule>;
  /** The repository the ref belongs to. */
  repository: gh_Repository;
  /** The object the ref points to. Returns null when object does not exist. */
  target?: Maybe<gh_GitObject>;
};


/** Represents a Git reference. */
export type gh_RefassociatedPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueOrder>;
  states?: InputMaybe<Array<gh_PullRequestState>>;
};


/** Represents a Git reference. */
export type gh_RefcompareArgs = {
  headRef: Scalars['String']['input'];
};

/** The connection type for Ref. */
export type gh_RefConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_RefEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Ref>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_RefEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Ref>;
};

/** Parameters to be used for the ref_name condition */
export type gh_RefNameConditionTarget = {
  /** Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars['String']['output']>;
  /**
   * Array of ref names or patterns to include. One of these patterns must match
   * for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the
   * default branch or `~ALL` to include all branches.
   */
  include: Array<Scalars['String']['output']>;
};

/** Parameters to be used for the ref_name condition */
export type gh_RefNameConditionTargetInput = {
  /** Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars['String']['input']>;
  /**
   * Array of ref names or patterns to include. One of these patterns must match
   * for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the
   * default branch or `~ALL` to include all branches.
   */
  include: Array<Scalars['String']['input']>;
};

/** Ways in which lists of git refs can be ordered upon return. */
export type gh_RefOrder = {
  /** The direction in which to order refs by the specified field. */
  direction: gh_OrderDirection;
  /** The field in which to order refs by. */
  field: gh_RefOrderField;
};

/** Properties by which ref connections can be ordered. */
export type gh_RefOrderField =
  /** Order refs by their alphanumeric name */
  | 'ALPHABETICAL'
  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */
  | 'TAG_COMMIT_DATE';

/** A ref update */
export type gh_RefUpdate = {
  /** The value this ref should be updated to. */
  afterOid: Scalars['gh_GitObjectID']['input'];
  /** The value this ref needs to point to before the update. */
  beforeOid?: InputMaybe<Scalars['gh_GitObjectID']['input']>;
  /** Force a non fast-forward update. */
  force?: InputMaybe<Scalars['Boolean']['input']>;
  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */
  name: Scalars['gh_GitRefname']['input'];
};

/** Branch protection rules that are enforced on the viewer. */
export type gh_RefUpdateRule = {
  /** Can this branch be deleted. */
  allowsDeletions: Scalars['Boolean']['output'];
  /** Are force pushes allowed on this branch. */
  allowsForcePushes: Scalars['Boolean']['output'];
  /** Can matching branches be created. */
  blocksCreations: Scalars['Boolean']['output'];
  /** Identifies the protection rule pattern. */
  pattern: Scalars['String']['output'];
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']['output']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews: Scalars['Boolean']['output'];
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution: Scalars['Boolean']['output'];
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory: Scalars['Boolean']['output'];
  /** Are commits required to be signed. */
  requiresSignatures: Scalars['Boolean']['output'];
  /** Is the viewer allowed to dismiss reviews. */
  viewerAllowedToDismissReviews: Scalars['Boolean']['output'];
  /** Can the viewer push to the branch */
  viewerCanPush: Scalars['Boolean']['output'];
};

/** Represents a 'referenced' event on a given `ReferencedSubject`. */
export type gh_ReferencedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the commit associated with the 'referenced' event. */
  commit?: Maybe<gh_Commit>;
  /** Identifies the repository associated with the 'referenced' event. */
  commitRepository: gh_Repository;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ReferencedEvent object */
  id: Scalars['ID']['output'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean']['output'];
  /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */
  isDirectReference: Scalars['Boolean']['output'];
  /** Object referenced by event. */
  subject: gh_ReferencedSubject;
};

/** Any referencable object */
export type gh_ReferencedSubject = gh_Issue | gh_PullRequest;

/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type gh_RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID']['input'];
};

/** Autogenerated return type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type gh_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The identity provider for the enterprise. */
  identityProvider?: Maybe<gh_EnterpriseIdentityProvider>;
};

/** Autogenerated input type of RegenerateVerifiableDomainToken */
export type gh_RegenerateVerifiableDomainTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to regenerate the verification token of. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RegenerateVerifiableDomainToken */
export type gh_RegenerateVerifiableDomainTokenPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The verification token that was generated. */
  verificationToken?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RejectDeployments */
export type gh_RejectDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Optional comment for rejecting deployments */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars['ID']['input']>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars['ID']['input'];
};

/** Autogenerated return type of RejectDeployments */
export type gh_RejectDeploymentsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The affected deployments. */
  deployments?: Maybe<Array<gh_Deployment>>;
};

/** A release contains the content for a release. */
export type gh_Release = gh_Node & gh_Reactable & gh_UniformResourceLocatable & {
  /** The author of the release */
  author?: Maybe<gh_User>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The description of the release. */
  description?: Maybe<Scalars['String']['output']>;
  /** The description of this release rendered to HTML. */
  descriptionHTML?: Maybe<Scalars['gh_HTML']['output']>;
  /** The Node ID of the Release object */
  id: Scalars['ID']['output'];
  /** Whether or not the release is a draft */
  isDraft: Scalars['Boolean']['output'];
  /** Whether or not the release is the latest releast */
  isLatest: Scalars['Boolean']['output'];
  /** Whether or not the release is a prerelease */
  isPrerelease: Scalars['Boolean']['output'];
  /** A list of users mentioned in the release description */
  mentions?: Maybe<gh_UserConnection>;
  /** The title of the release. */
  name?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the release was created. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: gh_ReactionConnection;
  /** List of releases assets which are dependent on this release. */
  releaseAssets: gh_ReleaseAssetConnection;
  /** The repository that the release belongs to. */
  repository: gh_Repository;
  /** The HTTP path for this issue */
  resourcePath: Scalars['gh_URI']['output'];
  /** A description of the release, rendered to HTML without any links in it. */
  shortDescriptionHTML?: Maybe<Scalars['gh_HTML']['output']>;
  /** The Git tag the release points to */
  tag?: Maybe<gh_Ref>;
  /** The tag commit for this release. */
  tagCommit?: Maybe<gh_Commit>;
  /** The name of the release's Git tag */
  tagName: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this issue */
  url: Scalars['gh_URI']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
};


/** A release contains the content for a release. */
export type gh_ReleasementionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A release contains the content for a release. */
export type gh_ReleasereactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<gh_ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ReactionOrder>;
};


/** A release contains the content for a release. */
export type gh_ReleasereleaseAssetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


/** A release contains the content for a release. */
export type gh_ReleaseshortDescriptionHTMLArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** A release asset contains the content for a release asset. */
export type gh_ReleaseAsset = gh_Node & {
  /** The asset's content-type */
  contentType: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The number of times this asset was downloaded */
  downloadCount: Scalars['Int']['output'];
  /** Identifies the URL where you can download the release asset via the browser. */
  downloadUrl: Scalars['gh_URI']['output'];
  /** The Node ID of the ReleaseAsset object */
  id: Scalars['ID']['output'];
  /** Identifies the title of the release asset. */
  name: Scalars['String']['output'];
  /** Release that the asset is associated with */
  release?: Maybe<gh_Release>;
  /** The size (in bytes) of the asset */
  size: Scalars['Int']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The user that performed the upload */
  uploadedBy: gh_User;
  /** Identifies the URL of the release asset. */
  url: Scalars['gh_URI']['output'];
};

/** The connection type for ReleaseAsset. */
export type gh_ReleaseAssetConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ReleaseAssetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ReleaseAsset>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ReleaseAssetEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ReleaseAsset>;
};

/** The connection type for Release. */
export type gh_ReleaseConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ReleaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Release>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ReleaseEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Release>;
};

/** Ways in which lists of releases can be ordered upon return. */
export type gh_ReleaseOrder = {
  /** The direction in which to order releases by the specified field. */
  direction: gh_OrderDirection;
  /** The field in which to order releases by. */
  field: gh_ReleaseOrderField;
};

/** Properties by which release connections can be ordered. */
export type gh_ReleaseOrderField =
  /** Order releases by creation time */
  | 'CREATED_AT'
  /** Order releases alphabetically by name */
  | 'NAME';

/** Autogenerated input type of RemoveAssigneesFromAssignable */
export type gh_RemoveAssigneesFromAssignableInput = {
  /** The id of the assignable object to remove assignees from. */
  assignableId: Scalars['ID']['input'];
  /** The id of users to remove as assignees. */
  assigneeIds: Array<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of RemoveAssigneesFromAssignable */
export type gh_RemoveAssigneesFromAssignablePayload = {
  /** The item that was unassigned. */
  assignable?: Maybe<gh_Assignable>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RemoveEnterpriseAdmin */
export type gh_RemoveEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Enterprise ID from which to remove the administrator. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of the user to remove as an administrator. */
  login: Scalars['String']['input'];
};

/** Autogenerated return type of RemoveEnterpriseAdmin */
export type gh_RemoveEnterpriseAdminPayload = {
  /** The user who was removed as an administrator. */
  admin?: Maybe<gh_User>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated enterprise. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of removing an administrator. */
  message?: Maybe<Scalars['String']['output']>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<gh_User>;
};

/** Autogenerated input type of RemoveEnterpriseIdentityProvider */
export type gh_RemoveEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise from which to remove the identity provider. */
  enterpriseId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveEnterpriseIdentityProvider */
export type gh_RemoveEnterpriseIdentityProviderPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The identity provider that was removed from the enterprise. */
  identityProvider?: Maybe<gh_EnterpriseIdentityProvider>;
};

/** Autogenerated input type of RemoveEnterpriseMember */
export type gh_RemoveEnterpriseMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise from which the user should be removed. */
  enterpriseId: Scalars['ID']['input'];
  /** The ID of the user to remove from the enterprise. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveEnterpriseMember */
export type gh_RemoveEnterpriseMemberPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated enterprise. */
  enterprise?: Maybe<gh_Enterprise>;
  /** The user that was removed from the enterprise. */
  user?: Maybe<gh_User>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<gh_User>;
};

/** Autogenerated input type of RemoveEnterpriseOrganization */
export type gh_RemoveEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise from which the organization should be removed. */
  enterpriseId: Scalars['ID']['input'];
  /** The ID of the organization to remove from the enterprise. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveEnterpriseOrganization */
export type gh_RemoveEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated enterprise. */
  enterprise?: Maybe<gh_Enterprise>;
  /** The organization that was removed from the enterprise. */
  organization?: Maybe<gh_Organization>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<gh_User>;
};

/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */
export type gh_RemoveEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of a member who will lose the support entitlement. */
  login: Scalars['String']['input'];
};

/** Autogenerated return type of RemoveEnterpriseSupportEntitlement */
export type gh_RemoveEnterpriseSupportEntitlementPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of removing the support entitlement. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RemoveLabelsFromLabelable */
export type gh_RemoveLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ids of labels to remove. */
  labelIds: Array<Scalars['ID']['input']>;
  /** The id of the Labelable to remove labels from. */
  labelableId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveLabelsFromLabelable */
export type gh_RemoveLabelsFromLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The Labelable the labels were removed from. */
  labelable?: Maybe<gh_Labelable>;
};

/** Autogenerated input type of RemoveOutsideCollaborator */
export type gh_RemoveOutsideCollaboratorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization to remove the outside collaborator from. */
  organizationId: Scalars['ID']['input'];
  /** The ID of the outside collaborator to remove. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveOutsideCollaborator */
export type gh_RemoveOutsideCollaboratorPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The user that was removed as an outside collaborator. */
  removedUser?: Maybe<gh_User>;
};

/** Autogenerated input type of RemoveReaction */
export type gh_RemoveReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the emoji reaction to remove. */
  content: gh_ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveReaction */
export type gh_RemoveReactionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The reaction object. */
  reaction?: Maybe<gh_Reaction>;
  /** The reaction groups for the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** The reactable subject. */
  subject?: Maybe<gh_Reactable>;
};

/** Autogenerated input type of RemoveStar */
export type gh_RemoveStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Starrable ID to unstar. */
  starrableId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveStar */
export type gh_RemoveStarPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The starrable. */
  starrable?: Maybe<gh_Starrable>;
};

/** Autogenerated input type of RemoveUpvote */
export type gh_RemoveUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion or comment to remove upvote. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveUpvote */
export type gh_RemoveUpvotePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The votable subject. */
  subject?: Maybe<gh_Votable>;
};

/** Represents a 'removed_from_merge_queue' event on a given pull request. */
export type gh_RemovedFromMergeQueueEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the before commit SHA for the 'removed_from_merge_queue' event. */
  beforeCommit?: Maybe<gh_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The user who removed this Pull Request from the merge queue */
  enqueuer?: Maybe<gh_User>;
  /** The Node ID of the RemovedFromMergeQueueEvent object */
  id: Scalars['ID']['output'];
  /** The merge queue where this pull request was removed from. */
  mergeQueue?: Maybe<gh_MergeQueue>;
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<gh_PullRequest>;
  /** The reason this pull request was removed from the queue. */
  reason?: Maybe<Scalars['String']['output']>;
};

/** Represents a 'removed_from_project' event on a given issue or pull request. */
export type gh_RemovedFromProjectEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the RemovedFromProjectEvent object */
  id: Scalars['ID']['output'];
  /** Project referenced by event. */
  project?: Maybe<gh_Project>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String']['output'];
};

/** Represents a 'renamed' event on a given issue or pull request */
export type gh_RenamedTitleEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the current title of the issue or pull request. */
  currentTitle: Scalars['String']['output'];
  /** The Node ID of the RenamedTitleEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the previous title of the issue or pull request. */
  previousTitle: Scalars['String']['output'];
  /** Subject that was renamed. */
  subject: gh_RenamedTitleSubject;
};

/** An object which has a renamable title */
export type gh_RenamedTitleSubject = gh_Issue | gh_PullRequest;

/** Autogenerated input type of ReopenDiscussion */
export type gh_ReopenDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the discussion to be reopened. */
  discussionId: Scalars['ID']['input'];
};

/** Autogenerated return type of ReopenDiscussion */
export type gh_ReopenDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that was reopened. */
  discussion?: Maybe<gh_Discussion>;
};

/** Autogenerated input type of ReopenIssue */
export type gh_ReopenIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue to be opened. */
  issueId: Scalars['ID']['input'];
};

/** Autogenerated return type of ReopenIssue */
export type gh_ReopenIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was opened. */
  issue?: Maybe<gh_Issue>;
};

/** Autogenerated input type of ReopenPullRequest */
export type gh_ReopenPullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to be reopened. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of ReopenPullRequest */
export type gh_ReopenPullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that was reopened. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Represents a 'reopened' event on any `Closable`. */
export type gh_ReopenedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Object that was reopened. */
  closable: gh_Closable;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ReopenedEvent object */
  id: Scalars['ID']['output'];
  /** The reason the issue state was changed to open. */
  stateReason?: Maybe<gh_IssueStateReason>;
};

/** Audit log entry for a repo.access event. */
export type gh_RepoAccessAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoAccessAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The visibility of the repository */
  visibility?: Maybe<gh_RepoAccessAuditEntryVisibility>;
};

/** The privacy of a repository */
export type gh_RepoAccessAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.add_member event. */
export type gh_RepoAddMemberAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoAddMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The visibility of the repository */
  visibility?: Maybe<gh_RepoAddMemberAuditEntryVisibility>;
};

/** The privacy of a repository */
export type gh_RepoAddMemberAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.add_topic event. */
export type gh_RepoAddTopicAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & gh_TopicAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoAddTopicAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The name of the topic added to the repository */
  topic?: Maybe<gh_Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a repo.archived event. */
export type gh_RepoArchivedAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoArchivedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The visibility of the repository */
  visibility?: Maybe<gh_RepoArchivedAuditEntryVisibility>;
};

/** The privacy of a repository */
export type gh_RepoArchivedAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.change_merge_setting event. */
export type gh_RepoChangeMergeSettingAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoChangeMergeSettingAuditEntry object */
  id: Scalars['ID']['output'];
  /** Whether the change was to enable (true) or disable (false) the merge type */
  isEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** The merge method affected by the change */
  mergeType?: Maybe<gh_RepoChangeMergeSettingAuditEntryMergeType>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** The merge options available for pull requests to this repository. */
export type gh_RepoChangeMergeSettingAuditEntryMergeType =
  /** The pull request is added to the base branch in a merge commit. */
  | 'MERGE'
  /** Commits from the pull request are added onto the base branch individually without a merge commit. */
  | 'REBASE'
  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */
  | 'SQUASH';

/** Audit log entry for a repo.config.disable_anonymous_git_access event. */
export type gh_RepoConfigDisableAnonymousGitAccessAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigDisableAnonymousGitAccessAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a repo.config.disable_collaborators_only event. */
export type gh_RepoConfigDisableCollaboratorsOnlyAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigDisableCollaboratorsOnlyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a repo.config.disable_contributors_only event. */
export type gh_RepoConfigDisableContributorsOnlyAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigDisableContributorsOnlyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a repo.config.disable_sockpuppet_disallowed event. */
export type gh_RepoConfigDisableSockpuppetDisallowedAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigDisableSockpuppetDisallowedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a repo.config.enable_anonymous_git_access event. */
export type gh_RepoConfigEnableAnonymousGitAccessAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigEnableAnonymousGitAccessAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a repo.config.enable_collaborators_only event. */
export type gh_RepoConfigEnableCollaboratorsOnlyAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigEnableCollaboratorsOnlyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a repo.config.enable_contributors_only event. */
export type gh_RepoConfigEnableContributorsOnlyAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigEnableContributorsOnlyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a repo.config.enable_sockpuppet_disallowed event. */
export type gh_RepoConfigEnableSockpuppetDisallowedAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigEnableSockpuppetDisallowedAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a repo.config.lock_anonymous_git_access event. */
export type gh_RepoConfigLockAnonymousGitAccessAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigLockAnonymousGitAccessAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a repo.config.unlock_anonymous_git_access event. */
export type gh_RepoConfigUnlockAnonymousGitAccessAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoConfigUnlockAnonymousGitAccessAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a repo.create event. */
export type gh_RepoCreateAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The name of the parent repository for this forked repository. */
  forkParentName?: Maybe<Scalars['String']['output']>;
  /** The name of the root repository for this network. */
  forkSourceName?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the RepoCreateAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The visibility of the repository */
  visibility?: Maybe<gh_RepoCreateAuditEntryVisibility>;
};

/** The privacy of a repository */
export type gh_RepoCreateAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.destroy event. */
export type gh_RepoDestroyAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoDestroyAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The visibility of the repository */
  visibility?: Maybe<gh_RepoDestroyAuditEntryVisibility>;
};

/** The privacy of a repository */
export type gh_RepoDestroyAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.remove_member event. */
export type gh_RepoRemoveMemberAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoRemoveMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The visibility of the repository */
  visibility?: Maybe<gh_RepoRemoveMemberAuditEntryVisibility>;
};

/** The privacy of a repository */
export type gh_RepoRemoveMemberAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.remove_topic event. */
export type gh_RepoRemoveTopicAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & gh_TopicAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the RepoRemoveTopicAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The name of the topic added to the repository */
  topic?: Maybe<gh_Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** The reasons a piece of content can be reported or minimized. */
export type gh_ReportedContentClassifiers =
  /** An abusive or harassing piece of content */
  | 'ABUSE'
  /** A duplicated piece of content */
  | 'DUPLICATE'
  /** An irrelevant piece of content */
  | 'OFF_TOPIC'
  /** An outdated piece of content */
  | 'OUTDATED'
  /** The content has been resolved */
  | 'RESOLVED'
  /** A spammy piece of content */
  | 'SPAM';

/** A repository contains the content for a project. */
export type gh_Repository = gh_Node & gh_PackageOwner & gh_ProjectOwner & gh_ProjectV2Recent & gh_RepositoryInfo & gh_Starrable & gh_Subscribable & gh_UniformResourceLocatable & {
  /**
   * Whether or not a pull request head branch that is behind its base branch can
   * always be updated even if it is not required to be up to date before merging.
   */
  allowUpdateBranch: Scalars['Boolean']['output'];
  /** Identifies the date and time when the repository was archived. */
  archivedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of users that can be assigned to issues in this repository. */
  assignableUsers: gh_UserConnection;
  /** Whether or not Auto-merge can be enabled on pull requests in this repository. */
  autoMergeAllowed: Scalars['Boolean']['output'];
  /** A list of branch protection rules for this repository. */
  branchProtectionRules: gh_BranchProtectionRuleConnection;
  /** Returns the code of conduct for this repository */
  codeOfConduct?: Maybe<gh_CodeOfConduct>;
  /** Information extracted from the repository's `CODEOWNERS` file. */
  codeowners?: Maybe<gh_RepositoryCodeowners>;
  /** A list of collaborators associated with the repository. */
  collaborators?: Maybe<gh_RepositoryCollaboratorConnection>;
  /** A list of commit comments associated with the repository. */
  commitComments: gh_CommitCommentConnection;
  /** Returns a list of contact links associated to the repository */
  contactLinks?: Maybe<Array<gh_RepositoryContactLink>>;
  /** Returns the contributing guidelines for this repository. */
  contributingGuidelines?: Maybe<gh_ContributingGuidelines>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Ref associated with the repository's default branch. */
  defaultBranchRef?: Maybe<gh_Ref>;
  /** Whether or not branches are automatically deleted when merged in this repository. */
  deleteBranchOnMerge: Scalars['Boolean']['output'];
  /** A list of dependency manifests contained in the repository */
  dependencyGraphManifests?: Maybe<gh_DependencyGraphManifestConnection>;
  /** A list of deploy keys that are on this repository. */
  deployKeys: gh_DeployKeyConnection;
  /** Deployments associated with the repository */
  deployments: gh_DeploymentConnection;
  /** The description of the repository. */
  description?: Maybe<Scalars['String']['output']>;
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars['gh_HTML']['output'];
  /** Returns a single discussion from the current repository by number. */
  discussion?: Maybe<gh_Discussion>;
  /** A list of discussion categories that are available in the repository. */
  discussionCategories: gh_DiscussionCategoryConnection;
  /** A discussion category by slug. */
  discussionCategory?: Maybe<gh_DiscussionCategory>;
  /** A list of discussions that have been opened in the repository. */
  discussions: gh_DiscussionConnection;
  /** The number of kilobytes this repository occupies on disk. */
  diskUsage?: Maybe<Scalars['Int']['output']>;
  /** Returns a single active environment from the current repository by name. */
  environment?: Maybe<gh_Environment>;
  /** A list of environments that are in this repository. */
  environments: gh_EnvironmentConnection;
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars['Int']['output'];
  /** Whether this repository allows forks. */
  forkingAllowed: Scalars['Boolean']['output'];
  /** A list of direct forked repositories. */
  forks: gh_RepositoryConnection;
  /** The funding links for this repository */
  fundingLinks: Array<gh_FundingLink>;
  /** Indicates if the repository has the Discussions feature enabled. */
  hasDiscussionsEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has the Projects feature enabled. */
  hasProjectsEnabled: Scalars['Boolean']['output'];
  /** Whether vulnerability alerts are enabled for the repository. */
  hasVulnerabilityAlertsEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars['Boolean']['output'];
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The Node ID of the Repository object */
  id: Scalars['ID']['output'];
  /** The interaction ability settings for this repository. */
  interactionAbility?: Maybe<gh_RepositoryInteractionAbility>;
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars['Boolean']['output'];
  /** Returns true if blank issue creation is allowed */
  isBlankIssuesEnabled: Scalars['Boolean']['output'];
  /** Returns whether or not this repository disabled. */
  isDisabled: Scalars['Boolean']['output'];
  /** Returns whether or not this repository is empty. */
  isEmpty: Scalars['Boolean']['output'];
  /** Identifies if the repository is a fork. */
  isFork: Scalars['Boolean']['output'];
  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */
  isInOrganization: Scalars['Boolean']['output'];
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars['Boolean']['output'];
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars['Boolean']['output'];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars['Boolean']['output'];
  /** Returns true if this repository has a security policy */
  isSecurityPolicyEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars['Boolean']['output'];
  /** Is this repository a user configuration repository? */
  isUserConfigurationRepository: Scalars['Boolean']['output'];
  /** Returns a single issue from the current repository by number. */
  issue?: Maybe<gh_Issue>;
  /** Returns a single issue-like object from the current repository by number. */
  issueOrPullRequest?: Maybe<gh_IssueOrPullRequest>;
  /** Returns a list of issue templates associated to the repository */
  issueTemplates?: Maybe<Array<gh_IssueTemplate>>;
  /** A list of issues that have been opened in the repository. */
  issues: gh_IssueConnection;
  /** Returns a single label by name */
  label?: Maybe<gh_Label>;
  /** A list of labels associated with the repository. */
  labels?: Maybe<gh_LabelConnection>;
  /** A list containing a breakdown of the language composition of the repository. */
  languages?: Maybe<gh_LanguageConnection>;
  /** Get the latest release for the repository if one exists. */
  latestRelease?: Maybe<gh_Release>;
  /** The license associated with the repository */
  licenseInfo?: Maybe<gh_License>;
  /** The reason the repository has been locked. */
  lockReason?: Maybe<gh_RepositoryLockReason>;
  /** A list of Users that can be mentioned in the context of the repository. */
  mentionableUsers: gh_UserConnection;
  /** Whether or not PRs are merged with a merge commit on this repository. */
  mergeCommitAllowed: Scalars['Boolean']['output'];
  /** How the default commit message will be generated when merging a pull request. */
  mergeCommitMessage: gh_MergeCommitMessage;
  /** How the default commit title will be generated when merging a pull request. */
  mergeCommitTitle: gh_MergeCommitTitle;
  /** The merge queue for a specified branch, otherwise the default branch if not provided. */
  mergeQueue?: Maybe<gh_MergeQueue>;
  /** Returns a single milestone from the current repository by number. */
  milestone?: Maybe<gh_Milestone>;
  /** A list of milestones associated with the repository. */
  milestones?: Maybe<gh_MilestoneConnection>;
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The name of the repository. */
  name: Scalars['String']['output'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String']['output'];
  /** A Git object in the repository */
  object?: Maybe<gh_GitObject>;
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars['gh_URI']['output'];
  /** The User owner of the repository. */
  owner: gh_RepositoryOwner;
  /** A list of packages under the owner. */
  packages: gh_PackageConnection;
  /** The repository parent, if this is a fork. */
  parent?: Maybe<gh_Repository>;
  /** A list of discussions that have been pinned in this repository. */
  pinnedDiscussions: gh_PinnedDiscussionConnection;
  /** A list of pinned issues for this repository. */
  pinnedIssues?: Maybe<gh_PinnedIssueConnection>;
  /** The primary language of the repository's code. */
  primaryLanguage?: Maybe<gh_Language>;
  /** Find project by number. */
  project?: Maybe<gh_Project>;
  /** Finds and returns the Project according to the provided Project number. */
  projectV2?: Maybe<gh_ProjectV2>;
  /** A list of projects under the owner. */
  projects: gh_ProjectConnection;
  /** The HTTP path listing the repository's projects */
  projectsResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL listing the repository's projects */
  projectsUrl: Scalars['gh_URI']['output'];
  /** List of projects linked to this repository. */
  projectsV2: gh_ProjectV2Connection;
  /** Returns a single pull request from the current repository by number. */
  pullRequest?: Maybe<gh_PullRequest>;
  /** Returns a list of pull request templates associated to the repository */
  pullRequestTemplates?: Maybe<Array<gh_PullRequestTemplate>>;
  /** A list of pull requests that have been opened in the repository. */
  pullRequests: gh_PullRequestConnection;
  /** Identifies the date and time when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether or not rebase-merging is enabled on this repository. */
  rebaseMergeAllowed: Scalars['Boolean']['output'];
  /** Recent projects that this user has modified in the context of the owner. */
  recentProjects: gh_ProjectV2Connection;
  /** Fetch a given ref from the repository */
  ref?: Maybe<gh_Ref>;
  /** Fetch a list of refs from the repository */
  refs?: Maybe<gh_RefConnection>;
  /** Lookup a single release given various criteria. */
  release?: Maybe<gh_Release>;
  /** List of releases which are dependent on this repository. */
  releases: gh_ReleaseConnection;
  /** A list of applied repository-topic associations for this repository. */
  repositoryTopics: gh_RepositoryTopicConnection;
  /** The HTTP path for this repository */
  resourcePath: Scalars['gh_URI']['output'];
  /** Returns a single ruleset from the current repository by ID. */
  ruleset?: Maybe<gh_RepositoryRuleset>;
  /** A list of rulesets for this repository. */
  rulesets?: Maybe<gh_RepositoryRulesetConnection>;
  /** The security policy URL. */
  securityPolicyUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars['gh_HTML']['output'];
  /** Whether or not squash-merging is enabled on this repository. */
  squashMergeAllowed: Scalars['Boolean']['output'];
  /** How the default commit message will be generated when squash merging a pull request. */
  squashMergeCommitMessage: gh_SquashMergeCommitMessage;
  /** How the default commit title will be generated when squash merging a pull request. */
  squashMergeCommitTitle: gh_SquashMergeCommitTitle;
  /**
   * Whether a squash merge commit can use the pull request title as default.
   * @deprecated `squashPrTitleUsedAsDefault` will be removed. Use `Repository.squashMergeCommitTitle` instead. Removal on 2023-04-01 UTC.
   */
  squashPrTitleUsedAsDefault: Scalars['Boolean']['output'];
  /** The SSH URL to clone this repository */
  sshUrl: Scalars['gh_GitSSHRemote']['output'];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int']['output'];
  /** A list of users who have starred this starrable. */
  stargazers: gh_StargazerConnection;
  /**
   * Returns a list of all submodules in this repository parsed from the
   * .gitmodules file as of the default branch's HEAD commit.
   */
  submodules: gh_SubmoduleConnection;
  /** Temporary authentication token for cloning this repository. */
  tempCloneToken?: Maybe<Scalars['String']['output']>;
  /** The repository from which this repository was generated, if any. */
  templateRepository?: Maybe<gh_Repository>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this repository */
  url: Scalars['gh_URI']['output'];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars['Boolean']['output'];
  /** Indicates whether the viewer has admin permissions on this repository. */
  viewerCanAdminister: Scalars['Boolean']['output'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Indicates whether the viewer can update the topics of this repository. */
  viewerCanUpdateTopics: Scalars['Boolean']['output'];
  /** The last commit email for the viewer. */
  viewerDefaultCommitEmail?: Maybe<Scalars['String']['output']>;
  /** The last used merge method by the viewer or the default for the repository. */
  viewerDefaultMergeMethod: gh_PullRequestMergeMethod;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean']['output'];
  /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */
  viewerPermission?: Maybe<gh_RepositoryPermission>;
  /** A list of emails this viewer can commit with. */
  viewerPossibleCommitEmails?: Maybe<Array<Scalars['String']['output']>>;
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<gh_SubscriptionState>;
  /** Indicates the repository's visibility level. */
  visibility: gh_RepositoryVisibility;
  /** Returns a single vulnerability alert from the current repository by number. */
  vulnerabilityAlert?: Maybe<gh_RepositoryVulnerabilityAlert>;
  /** A list of vulnerability alerts that are on this repository. */
  vulnerabilityAlerts?: Maybe<gh_RepositoryVulnerabilityAlertConnection>;
  /** A list of users watching the repository. */
  watchers: gh_UserConnection;
  /** Whether contributors are required to sign off on web-based commits in this repository. */
  webCommitSignoffRequired: Scalars['Boolean']['output'];
};


/** A repository contains the content for a project. */
export type gh_RepositoryassignableUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorybranchProtectionRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorycodeownersArgs = {
  refName?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorycollaboratorsArgs = {
  affiliation?: InputMaybe<gh_CollaboratorAffiliation>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorycommitCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorydependencyGraphManifestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  dependenciesAfter?: InputMaybe<Scalars['String']['input']>;
  dependenciesFirst?: InputMaybe<Scalars['Int']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  withDependencies?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorydeployKeysArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorydeploymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  environments?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_DeploymentOrder>;
};


/** A repository contains the content for a project. */
export type gh_RepositorydiscussionArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositorydiscussionCategoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterByAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorydiscussionCategoryArgs = {
  slug: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositorydiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  answered?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_DiscussionOrder>;
  states?: InputMaybe<Array<gh_DiscussionState>>;
};


/** A repository contains the content for a project. */
export type gh_RepositoryenvironmentArgs = {
  name: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositoryenvironmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_Environments>;
};


/** A repository contains the content for a project. */
export type gh_RepositoryforksArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<gh_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<gh_RepositoryAffiliation>>>;
  privacy?: InputMaybe<gh_RepositoryPrivacy>;
};


/** A repository contains the content for a project. */
export type gh_RepositoryissueArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositoryissueOrPullRequestArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositoryissuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<gh_IssueFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueOrder>;
  states?: InputMaybe<Array<gh_IssueState>>;
};


/** A repository contains the content for a project. */
export type gh_RepositorylabelArgs = {
  name: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositorylabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_LabelOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorylanguagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_LanguageOrder>;
};


/** A repository contains the content for a project. */
export type gh_RepositorymentionableUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorymergeQueueArgs = {
  branch?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorymilestoneArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositorymilestonesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_MilestoneOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<gh_MilestoneState>>;
};


/** A repository contains the content for a project. */
export type gh_RepositoryobjectArgs = {
  expression?: InputMaybe<Scalars['String']['input']>;
  oid?: InputMaybe<Scalars['gh_GitObjectID']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorypackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<gh_PackageOrder>;
  packageType?: InputMaybe<gh_PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorypinnedDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorypinnedIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositoryprojectArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositoryprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositoryprojectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<gh_ProjectState>>;
};


/** A repository contains the content for a project. */
export type gh_RepositoryprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorypullRequestArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositorypullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueOrder>;
  states?: InputMaybe<Array<gh_PullRequestState>>;
};


/** A repository contains the content for a project. */
export type gh_RepositoryrecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositoryrefArgs = {
  qualifiedName: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositoryrefsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  direction?: InputMaybe<gh_OrderDirection>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_RefOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  refPrefix: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositoryreleaseArgs = {
  tagName: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositoryreleasesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ReleaseOrder>;
};


/** A repository contains the content for a project. */
export type gh_RepositoryrepositoryTopicsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositoryrulesetArgs = {
  databaseId: Scalars['Int']['input'];
  includeParents?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositoryrulesetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeParents?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositoryshortDescriptionHTMLArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositorystargazersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_StarOrder>;
};


/** A repository contains the content for a project. */
export type gh_RepositorysubmodulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
export type gh_RepositoryvulnerabilityAlertArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
export type gh_RepositoryvulnerabilityAlertsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  dependencyScopes?: InputMaybe<Array<gh_RepositoryVulnerabilityAlertDependencyScope>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  states?: InputMaybe<Array<gh_RepositoryVulnerabilityAlertState>>;
};


/** A repository contains the content for a project. */
export type gh_RepositorywatchersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The affiliation of a user to a repository */
export type gh_RepositoryAffiliation =
  /** Repositories that the user has been added to as a collaborator. */
  | 'COLLABORATOR'
  /**
   * Repositories that the user has access to through being a member of an
   * organization. This includes every repository on every team that the user is on.
   */
  | 'ORGANIZATION_MEMBER'
  /** Repositories that are owned by the authenticated user. */
  | 'OWNER';

/** Metadata for an audit entry with action repo.* */
export type gh_RepositoryAuditEntryData = {
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Information extracted from a repository's `CODEOWNERS` file. */
export type gh_RepositoryCodeowners = {
  /** Any problems that were encountered while parsing the `CODEOWNERS` file. */
  errors: Array<gh_RepositoryCodeownersError>;
};

/** An error in a `CODEOWNERS` file. */
export type gh_RepositoryCodeownersError = {
  /** The column number where the error occurs. */
  column: Scalars['Int']['output'];
  /** A short string describing the type of error. */
  kind: Scalars['String']['output'];
  /** The line number where the error occurs. */
  line: Scalars['Int']['output'];
  /** A complete description of the error, combining information from other fields. */
  message: Scalars['String']['output'];
  /** The path to the file when the error occurs. */
  path: Scalars['String']['output'];
  /** The content of the line where the error occurs. */
  source: Scalars['String']['output'];
  /** A suggestion of how to fix the error. */
  suggestion?: Maybe<Scalars['String']['output']>;
};

/** The connection type for User. */
export type gh_RepositoryCollaboratorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_RepositoryCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_User>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a user who is a collaborator of a repository. */
export type gh_RepositoryCollaboratorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  node: gh_User;
  /** The permission the user has on the repository. */
  permission: gh_RepositoryPermission;
  /** A list of sources for the user's access to the repository. */
  permissionSources?: Maybe<Array<gh_PermissionSource>>;
};

/** A list of repositories owned by the subject. */
export type gh_RepositoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_RepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /**
   * The total size in kilobytes of all repositories in the connection. Value will
   * never be larger than max 32-bit signed integer.
   */
  totalDiskUsage: Scalars['Int']['output'];
};

/** A repository contact link. */
export type gh_RepositoryContactLink = {
  /** The contact link purpose. */
  about: Scalars['String']['output'];
  /** The contact link name. */
  name: Scalars['String']['output'];
  /** The contact link URL. */
  url: Scalars['gh_URI']['output'];
};

/** The reason a repository is listed as 'contributed'. */
export type gh_RepositoryContributionType =
  /** Created a commit */
  | 'COMMIT'
  /** Created an issue */
  | 'ISSUE'
  /** Created a pull request */
  | 'PULL_REQUEST'
  /** Reviewed a pull request */
  | 'PULL_REQUEST_REVIEW'
  /** Created the repository */
  | 'REPOSITORY';

/** Represents an author of discussions in repositories. */
export type gh_RepositoryDiscussionAuthor = {
  /** Discussions this user has started. */
  repositoryDiscussions: gh_DiscussionConnection;
};


/** Represents an author of discussions in repositories. */
export type gh_RepositoryDiscussionAuthorrepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  answered?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  states?: InputMaybe<Array<gh_DiscussionState>>;
};

/** Represents an author of discussion comments in repositories. */
export type gh_RepositoryDiscussionCommentAuthor = {
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: gh_DiscussionCommentConnection;
};


/** Represents an author of discussion comments in repositories. */
export type gh_RepositoryDiscussionCommentAuthorrepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']['input']>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** An edge in a connection. */
export type gh_RepositoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Repository>;
};

/** Parameters to be used for the repository_id condition */
export type gh_RepositoryIdConditionTarget = {
  /** One of these repo IDs must match the repo. */
  repositoryIds: Array<Scalars['ID']['output']>;
};

/** Parameters to be used for the repository_id condition */
export type gh_RepositoryIdConditionTargetInput = {
  /** One of these repo IDs must match the repo. */
  repositoryIds: Array<Scalars['ID']['input']>;
};

/** A subset of repository info. */
export type gh_RepositoryInfo = {
  /** Identifies the date and time when the repository was archived. */
  archivedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The description of the repository. */
  description?: Maybe<Scalars['String']['output']>;
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars['gh_HTML']['output'];
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars['Int']['output'];
  /** Indicates if the repository has the Discussions feature enabled. */
  hasDiscussionsEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has the Projects feature enabled. */
  hasProjectsEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars['Boolean']['output'];
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars['Boolean']['output'];
  /** Identifies if the repository is a fork. */
  isFork: Scalars['Boolean']['output'];
  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */
  isInOrganization: Scalars['Boolean']['output'];
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars['Boolean']['output'];
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars['Boolean']['output'];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars['Boolean']['output'];
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars['Boolean']['output'];
  /** The license associated with the repository */
  licenseInfo?: Maybe<gh_License>;
  /** The reason the repository has been locked. */
  lockReason?: Maybe<gh_RepositoryLockReason>;
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The name of the repository. */
  name: Scalars['String']['output'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String']['output'];
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars['gh_URI']['output'];
  /** The User owner of the repository. */
  owner: gh_RepositoryOwner;
  /** Identifies the date and time when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The HTTP path for this repository */
  resourcePath: Scalars['gh_URI']['output'];
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars['gh_HTML']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this repository */
  url: Scalars['gh_URI']['output'];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars['Boolean']['output'];
  /** Indicates the repository's visibility level. */
  visibility: gh_RepositoryVisibility;
};


/** A subset of repository info. */
export type gh_RepositoryInfoshortDescriptionHTMLArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Repository interaction limit that applies to this object. */
export type gh_RepositoryInteractionAbility = {
  /** The time the currently active limit expires. */
  expiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** The current limit that is enabled on this object. */
  limit: gh_RepositoryInteractionLimit;
  /** The origin of the currently active interaction limit. */
  origin: gh_RepositoryInteractionLimitOrigin;
};

/** A repository interaction limit. */
export type gh_RepositoryInteractionLimit =
  /** Users that are not collaborators will not be able to interact with the repository. */
  | 'COLLABORATORS_ONLY'
  /** Users that have not previously committed to a repository’s default branch will be unable to interact with the repository. */
  | 'CONTRIBUTORS_ONLY'
  /** Users that have recently created their account will be unable to interact with the repository. */
  | 'EXISTING_USERS'
  /** No interaction limits are enabled. */
  | 'NO_LIMIT';

/** The length for a repository interaction limit to be enabled for. */
export type gh_RepositoryInteractionLimitExpiry =
  /** The interaction limit will expire after 1 day. */
  | 'ONE_DAY'
  /** The interaction limit will expire after 1 month. */
  | 'ONE_MONTH'
  /** The interaction limit will expire after 1 week. */
  | 'ONE_WEEK'
  /** The interaction limit will expire after 6 months. */
  | 'SIX_MONTHS'
  /** The interaction limit will expire after 3 days. */
  | 'THREE_DAYS';

/** Indicates where an interaction limit is configured. */
export type gh_RepositoryInteractionLimitOrigin =
  /** A limit that is configured at the organization level. */
  | 'ORGANIZATION'
  /** A limit that is configured at the repository level. */
  | 'REPOSITORY'
  /** A limit that is configured at the user-wide level. */
  | 'USER';

/** An invitation for a user to be added to a repository. */
export type gh_RepositoryInvitation = gh_Node & {
  /** The email address that received the invitation. */
  email?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the RepositoryInvitation object */
  id: Scalars['ID']['output'];
  /** The user who received the invitation. */
  invitee?: Maybe<gh_User>;
  /** The user who created the invitation. */
  inviter: gh_User;
  /** The permalink for this repository invitation. */
  permalink: Scalars['gh_URI']['output'];
  /** The permission granted on this repository by this invitation. */
  permission: gh_RepositoryPermission;
  /** The Repository the user is invited to. */
  repository?: Maybe<gh_RepositoryInfo>;
};

/** A list of repository invitations. */
export type gh_RepositoryInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_RepositoryInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_RepositoryInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_RepositoryInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_RepositoryInvitation>;
};

/** Ordering options for repository invitation connections. */
export type gh_RepositoryInvitationOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order repository invitations by. */
  field: gh_RepositoryInvitationOrderField;
};

/** Properties by which repository invitation connections can be ordered. */
export type gh_RepositoryInvitationOrderField =
  /** Order repository invitations by creation time */
  | 'CREATED_AT';

/** The possible reasons a given repository could be in a locked state. */
export type gh_RepositoryLockReason =
  /** The repository is locked due to a billing related reason. */
  | 'BILLING'
  /** The repository is locked due to a migration. */
  | 'MIGRATING'
  /** The repository is locked due to a move. */
  | 'MOVING'
  /** The repository is locked due to a rename. */
  | 'RENAME'
  /** The repository is locked due to a trade controls related reason. */
  | 'TRADE_RESTRICTION'
  /** The repository is locked due to an ownership transfer. */
  | 'TRANSFERRING_OWNERSHIP';

/** A GitHub Enterprise Importer (GEI) repository migration. */
export type gh_RepositoryMigration = gh_Migration & gh_Node & {
  /** The migration flag to continue on error. */
  continueOnError: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['String']['output']>;
  /** The reason the migration failed. */
  failureReason?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the RepositoryMigration object */
  id: Scalars['ID']['output'];
  /** The URL for the migration log (expires 1 day after migration completes). */
  migrationLogUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The migration source. */
  migrationSource: gh_MigrationSource;
  /** The target repository name. */
  repositoryName: Scalars['String']['output'];
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  sourceUrl: Scalars['gh_URI']['output'];
  /** The migration state. */
  state: gh_MigrationState;
  /**
   * The number of warnings encountered for this migration. To review the warnings,
   * check the [Migration Log](https://docs.github.com/en/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).
   */
  warningsCount: Scalars['Int']['output'];
};

/** The connection type for RepositoryMigration. */
export type gh_RepositoryMigrationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_RepositoryMigrationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_RepositoryMigration>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a repository migration. */
export type gh_RepositoryMigrationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_RepositoryMigration>;
};

/** Ordering options for repository migrations. */
export type gh_RepositoryMigrationOrder = {
  /** The ordering direction. */
  direction: gh_RepositoryMigrationOrderDirection;
  /** The field to order repository migrations by. */
  field: gh_RepositoryMigrationOrderField;
};

/** Possible directions in which to order a list of repository migrations when provided an `orderBy` argument. */
export type gh_RepositoryMigrationOrderDirection =
  /** Specifies an ascending order for a given `orderBy` argument. */
  | 'ASC'
  /** Specifies a descending order for a given `orderBy` argument. */
  | 'DESC';

/** Properties by which repository migrations can be ordered. */
export type gh_RepositoryMigrationOrderField =
  /** Order mannequins why when they were created. */
  | 'CREATED_AT';

/** Parameters to be used for the repository_name condition */
export type gh_RepositoryNameConditionTarget = {
  /** Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars['String']['output']>;
  /**
   * Array of repository names or patterns to include. One of these patterns must
   * match for the condition to pass. Also accepts `~ALL` to include all repositories.
   */
  include: Array<Scalars['String']['output']>;
  /** Target changes that match these patterns will be prevented except by those with bypass permissions. */
  protected: Scalars['Boolean']['output'];
};

/** Parameters to be used for the repository_name condition */
export type gh_RepositoryNameConditionTargetInput = {
  /** Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars['String']['input']>;
  /**
   * Array of repository names or patterns to include. One of these patterns must
   * match for the condition to pass. Also accepts `~ALL` to include all repositories.
   */
  include: Array<Scalars['String']['input']>;
  /** Target changes that match these patterns will be prevented except by those with bypass permissions. */
  protected?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents a object that belongs to a repository. */
export type gh_RepositoryNode = {
  /** The repository associated with this node. */
  repository: gh_Repository;
};

/** Ordering options for repository connections */
export type gh_RepositoryOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order repositories by. */
  field: gh_RepositoryOrderField;
};

/** Properties by which repository connections can be ordered. */
export type gh_RepositoryOrderField =
  /** Order repositories by creation time */
  | 'CREATED_AT'
  /** Order repositories by name */
  | 'NAME'
  /** Order repositories by push time */
  | 'PUSHED_AT'
  /** Order repositories by number of stargazers */
  | 'STARGAZERS'
  /** Order repositories by update time */
  | 'UPDATED_AT';

/** Represents an owner of a Repository. */
export type gh_RepositoryOwner = {
  /** A URL pointing to the owner's public avatar. */
  avatarUrl: Scalars['gh_URI']['output'];
  /** The Node ID of the RepositoryOwner object */
  id: Scalars['ID']['output'];
  /** The username used to login. */
  login: Scalars['String']['output'];
  /** A list of repositories that the user owns. */
  repositories: gh_RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<gh_Repository>;
  /** The HTTP URL for the owner. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for the owner. */
  url: Scalars['gh_URI']['output'];
};


/** Represents an owner of a Repository. */
export type gh_RepositoryOwneravatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an owner of a Repository. */
export type gh_RepositoryOwnerrepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<gh_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  isFork?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<gh_RepositoryAffiliation>>>;
  privacy?: InputMaybe<gh_RepositoryPrivacy>;
};


/** Represents an owner of a Repository. */
export type gh_RepositoryOwnerrepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
};

/** The access level to a repository */
export type gh_RepositoryPermission =
  /**
   * Can read, clone, and push to this repository. Can also manage issues, pull
   * requests, and repository settings, including adding collaborators
   */
  | 'ADMIN'
  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */
  | 'MAINTAIN'
  /** Can read and clone this repository. Can also open and comment on issues and pull requests */
  | 'READ'
  /** Can read and clone this repository. Can also manage issues and pull requests */
  | 'TRIAGE'
  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */
  | 'WRITE';

/** The privacy of a repository */
export type gh_RepositoryPrivacy =
  /** Private */
  | 'PRIVATE'
  /** Public */
  | 'PUBLIC';

/** A repository rule. */
export type gh_RepositoryRule = gh_Node & {
  /** The Node ID of the RepositoryRule object */
  id: Scalars['ID']['output'];
  /** The parameters for this rule. */
  parameters?: Maybe<gh_RuleParameters>;
  /** The repository ruleset associated with this rule configuration */
  repositoryRuleset?: Maybe<gh_RepositoryRuleset>;
  /** The type of rule. */
  type: gh_RepositoryRuleType;
};

/** Set of conditions that determine if a ruleset will evaluate */
export type gh_RepositoryRuleConditions = {
  /** Configuration for the ref_name condition */
  refName?: Maybe<gh_RefNameConditionTarget>;
  /** Configuration for the repository_id condition */
  repositoryId?: Maybe<gh_RepositoryIdConditionTarget>;
  /** Configuration for the repository_name condition */
  repositoryName?: Maybe<gh_RepositoryNameConditionTarget>;
};

/** Specifies the conditions required for a ruleset to evaluate */
export type gh_RepositoryRuleConditionsInput = {
  /** Configuration for the ref_name condition */
  refName?: InputMaybe<gh_RefNameConditionTargetInput>;
  /** Configuration for the repository_id condition */
  repositoryId?: InputMaybe<gh_RepositoryIdConditionTargetInput>;
  /** Configuration for the repository_name condition */
  repositoryName?: InputMaybe<gh_RepositoryNameConditionTargetInput>;
};

/** The connection type for RepositoryRule. */
export type gh_RepositoryRuleConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_RepositoryRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_RepositoryRule>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_RepositoryRuleEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_RepositoryRule>;
};

/** Specifies the attributes for a new or updated rule. */
export type gh_RepositoryRuleInput = {
  /** Optional ID of this rule when updating */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The parameters for the rule. */
  parameters?: InputMaybe<gh_RuleParametersInput>;
  /** The type of rule to create. */
  type: gh_RepositoryRuleType;
};

/** The rule types supported in rulesets */
export type gh_RepositoryRuleType =
  /** Authorization */
  | 'AUTHORIZATION'
  /** Branch name pattern */
  | 'BRANCH_NAME_PATTERN'
  /** Committer email pattern */
  | 'COMMITTER_EMAIL_PATTERN'
  /** Commit author email pattern */
  | 'COMMIT_AUTHOR_EMAIL_PATTERN'
  /** Commit message pattern */
  | 'COMMIT_MESSAGE_PATTERN'
  /** Only allow users with bypass permission to create matching refs. */
  | 'CREATION'
  /** Only allow users with bypass permissions to delete matching refs. */
  | 'DELETION'
  /** Branch is read-only. Users cannot push to the branch. */
  | 'LOCK_BRANCH'
  /** Max ref updates */
  | 'MAX_REF_UPDATES'
  /** Merges must be performed via a merge queue. */
  | 'MERGE_QUEUE'
  /** Merge queue locked ref */
  | 'MERGE_QUEUE_LOCKED_REF'
  /** Prevent users with push access from force pushing to refs. */
  | 'NON_FAST_FORWARD'
  /** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
  | 'PULL_REQUEST'
  /** Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule. */
  | 'REQUIRED_DEPLOYMENTS'
  /** Prevent merge commits from being pushed to matching refs. */
  | 'REQUIRED_LINEAR_HISTORY'
  /**
   * When enabled, all conversations on code must be resolved before a pull request
   * can be merged into a branch that matches this rule.
   */
  | 'REQUIRED_REVIEW_THREAD_RESOLUTION'
  /** Commits pushed to matching refs must have verified signatures. */
  | 'REQUIRED_SIGNATURES'
  /**
   * Choose which status checks must pass before the ref is updated. When enabled,
   * commits must first be pushed to another ref where the checks pass.
   */
  | 'REQUIRED_STATUS_CHECKS'
  /**
   * Require all commits be made to a non-target branch and submitted via a pull
   * request and required workflow checks to pass before they can be merged.
   */
  | 'REQUIRED_WORKFLOW_STATUS_CHECKS'
  /** Commits pushed to matching refs must have verified signatures. */
  | 'RULESET_REQUIRED_SIGNATURES'
  /** Secret scanning */
  | 'SECRET_SCANNING'
  /** Tag */
  | 'TAG'
  /** Tag name pattern */
  | 'TAG_NAME_PATTERN'
  /** Only allow users with bypass permission to update matching refs. */
  | 'UPDATE'
  /** Require all changes made to a targeted branch to pass the specified workflows before they can be merged. */
  | 'WORKFLOWS'
  /** Workflow files cannot be modified. */
  | 'WORKFLOW_UPDATES';

/** A repository ruleset. */
export type gh_RepositoryRuleset = gh_Node & {
  /** The actors that can bypass this ruleset */
  bypassActors?: Maybe<gh_RepositoryRulesetBypassActorConnection>;
  /** The set of conditions that must evaluate to true for this ruleset to apply */
  conditions: gh_RepositoryRuleConditions;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The enforcement level of this ruleset */
  enforcement: gh_RuleEnforcement;
  /** The Node ID of the RepositoryRuleset object */
  id: Scalars['ID']['output'];
  /** Name of the ruleset. */
  name: Scalars['String']['output'];
  /** List of rules. */
  rules?: Maybe<gh_RepositoryRuleConnection>;
  /** Source of ruleset. */
  source: gh_RuleSource;
  /** Target of the ruleset. */
  target?: Maybe<gh_RepositoryRulesetTarget>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};


/** A repository ruleset. */
export type gh_RepositoryRulesetbypassActorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository ruleset. */
export type gh_RepositoryRulesetrulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<gh_RepositoryRuleType>;
};

/** A team or app that has the ability to bypass a rules defined on a ruleset */
export type gh_RepositoryRulesetBypassActor = gh_Node & {
  /** The actor that can bypass rules. */
  actor?: Maybe<gh_BypassActor>;
  /** The mode for the bypass actor */
  bypassMode?: Maybe<gh_RepositoryRulesetBypassActorBypassMode>;
  /** The Node ID of the RepositoryRulesetBypassActor object */
  id: Scalars['ID']['output'];
  /** This actor represents the ability for an organization owner to bypass */
  organizationAdmin: Scalars['Boolean']['output'];
  /** If the actor is a repository role, the repository role's ID that can bypass */
  repositoryRoleDatabaseId?: Maybe<Scalars['Int']['output']>;
  /** If the actor is a repository role, the repository role's name that can bypass */
  repositoryRoleName?: Maybe<Scalars['String']['output']>;
  /** Identifies the ruleset associated with the allowed actor */
  repositoryRuleset?: Maybe<gh_RepositoryRuleset>;
};

/** The bypass mode for a specific actor on a ruleset. */
export type gh_RepositoryRulesetBypassActorBypassMode =
  /** The actor can always bypass rules */
  | 'ALWAYS'
  /** The actor can only bypass rules via a pull request */
  | 'PULL_REQUEST';

/** The connection type for RepositoryRulesetBypassActor. */
export type gh_RepositoryRulesetBypassActorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_RepositoryRulesetBypassActorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_RepositoryRulesetBypassActor>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_RepositoryRulesetBypassActorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_RepositoryRulesetBypassActor>;
};

/**
 * Specifies the attributes for a new or updated ruleset bypass actor. Only one of
 * `actor_id`, `repository_role_database_id`, or `organization_admin` should be specified.
 */
export type gh_RepositoryRulesetBypassActorInput = {
  /** For Team and Integration bypasses, the Team or Integration ID */
  actorId?: InputMaybe<Scalars['ID']['input']>;
  /** The bypass mode for this actor. */
  bypassMode: gh_RepositoryRulesetBypassActorBypassMode;
  /** For organization owner bypasses, true */
  organizationAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  /** For role bypasses, the role database ID */
  repositoryRoleDatabaseId?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for RepositoryRuleset. */
export type gh_RepositoryRulesetConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_RepositoryRulesetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_RepositoryRuleset>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_RepositoryRulesetEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_RepositoryRuleset>;
};

/** The targets supported for rulesets */
export type gh_RepositoryRulesetTarget =
  /** Branch */
  | 'BRANCH'
  /** Tag */
  | 'TAG';

/** A repository-topic connects a repository to a topic. */
export type gh_RepositoryTopic = gh_Node & gh_UniformResourceLocatable & {
  /** The Node ID of the RepositoryTopic object */
  id: Scalars['ID']['output'];
  /** The HTTP path for this repository-topic. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The topic. */
  topic: gh_Topic;
  /** The HTTP URL for this repository-topic. */
  url: Scalars['gh_URI']['output'];
};

/** The connection type for RepositoryTopic. */
export type gh_RepositoryTopicConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_RepositoryTopicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_RepositoryTopic>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_RepositoryTopicEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_RepositoryTopic>;
};

/** The repository's visibility level. */
export type gh_RepositoryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repository_visibility_change.disable event. */
export type gh_RepositoryVisibilityChangeDisableAuditEntry = gh_AuditEntry & gh_EnterpriseAuditEntryData & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The Node ID of the RepositoryVisibilityChangeDisableAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a repository_visibility_change.enable event. */
export type gh_RepositoryVisibilityChangeEnableAuditEntry = gh_AuditEntry & gh_EnterpriseAuditEntryData & gh_Node & gh_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The Node ID of the RepositoryVisibilityChangeEnableAuditEntry object */
  id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** A Dependabot alert for a repository with a dependency affected by a security vulnerability. */
export type gh_RepositoryVulnerabilityAlert = gh_Node & gh_RepositoryNode & {
  /** When was the alert auto-dismissed? */
  autoDismissedAt?: Maybe<Scalars['DateTime']['output']>;
  /** When was the alert created? */
  createdAt: Scalars['DateTime']['output'];
  /** The associated Dependabot update */
  dependabotUpdate?: Maybe<gh_DependabotUpdate>;
  /** The scope of an alert's dependency */
  dependencyScope?: Maybe<gh_RepositoryVulnerabilityAlertDependencyScope>;
  /** Comment explaining the reason the alert was dismissed */
  dismissComment?: Maybe<Scalars['String']['output']>;
  /** The reason the alert was dismissed */
  dismissReason?: Maybe<Scalars['String']['output']>;
  /** When was the alert dismissed? */
  dismissedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user who dismissed the alert */
  dismisser?: Maybe<gh_User>;
  /** When was the alert fixed? */
  fixedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The Node ID of the RepositoryVulnerabilityAlert object */
  id: Scalars['ID']['output'];
  /** Identifies the alert number. */
  number: Scalars['Int']['output'];
  /** The associated repository */
  repository: gh_Repository;
  /** The associated security advisory */
  securityAdvisory?: Maybe<gh_SecurityAdvisory>;
  /** The associated security vulnerability */
  securityVulnerability?: Maybe<gh_SecurityVulnerability>;
  /** Identifies the state of the alert. */
  state: gh_RepositoryVulnerabilityAlertState;
  /** The vulnerable manifest filename */
  vulnerableManifestFilename: Scalars['String']['output'];
  /** The vulnerable manifest path */
  vulnerableManifestPath: Scalars['String']['output'];
  /** The vulnerable requirements */
  vulnerableRequirements?: Maybe<Scalars['String']['output']>;
};

/** The connection type for RepositoryVulnerabilityAlert. */
export type gh_RepositoryVulnerabilityAlertConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_RepositoryVulnerabilityAlertEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_RepositoryVulnerabilityAlert>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The possible scopes of an alert's dependency. */
export type gh_RepositoryVulnerabilityAlertDependencyScope =
  /** A dependency that is only used in development */
  | 'DEVELOPMENT'
  /** A dependency that is leveraged during application runtime */
  | 'RUNTIME';

/** An edge in a connection. */
export type gh_RepositoryVulnerabilityAlertEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_RepositoryVulnerabilityAlert>;
};

/** The possible states of an alert */
export type gh_RepositoryVulnerabilityAlertState =
  /** An alert that has been automatically closed by Dependabot. */
  | 'AUTO_DISMISSED'
  /** An alert that has been manually closed by a user. */
  | 'DISMISSED'
  /** An alert that has been resolved by a code change. */
  | 'FIXED'
  /** An alert that is still open. */
  | 'OPEN';

/** Autogenerated input type of RequestReviews */
export type gh_RequestReviewsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID']['input'];
  /** The Node IDs of the team to request. */
  teamIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Add users to the set rather than replace. */
  union?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node IDs of the user to request. */
  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of RequestReviews */
export type gh_RequestReviewsPayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that is getting requests. */
  pullRequest?: Maybe<gh_PullRequest>;
  /** The edge from the pull request to the requested reviewers. */
  requestedReviewersEdge?: Maybe<gh_UserEdge>;
};

/** The possible states that can be requested when creating a check run. */
export type gh_RequestableCheckStatusState =
  /** The check suite or run has been completed. */
  | 'COMPLETED'
  /** The check suite or run is in progress. */
  | 'IN_PROGRESS'
  /** The check suite or run is in pending state. */
  | 'PENDING'
  /** The check suite or run has been queued. */
  | 'QUEUED'
  /** The check suite or run is in waiting state. */
  | 'WAITING';

/** Types that can be requested reviewers. */
export type gh_RequestedReviewer = gh_Bot | gh_Mannequin | gh_Team | gh_User;

/** The connection type for RequestedReviewer. */
export type gh_RequestedReviewerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_RequestedReviewerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_RequestedReviewer>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_RequestedReviewerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_RequestedReviewer>;
};

/** Represents a type that can be required by a pull request for merging. */
export type gh_RequirableByPullRequest = {
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars['Boolean']['output'];
};


/** Represents a type that can be required by a pull request for merging. */
export type gh_RequirableByPullRequestisRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule. */
export type gh_RequiredDeploymentsParameters = {
  /** The environments that must be successfully deployed to before branches can be merged. */
  requiredDeploymentEnvironments: Array<Scalars['String']['output']>;
};

/** Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule. */
export type gh_RequiredDeploymentsParametersInput = {
  /** The environments that must be successfully deployed to before branches can be merged. */
  requiredDeploymentEnvironments: Array<Scalars['String']['input']>;
};

/** Represents a required status check for a protected branch, but not any specific run of that check. */
export type gh_RequiredStatusCheckDescription = {
  /** The App that must provide this status in order for it to be accepted. */
  app?: Maybe<gh_App>;
  /** The name of this status. */
  context: Scalars['String']['output'];
};

/** Specifies the attributes for a new or updated required status check. */
export type gh_RequiredStatusCheckInput = {
  /**
   * The ID of the App that must set the status in order for it to be accepted.
   * Omit this value to use whichever app has recently been setting this status, or
   * use "any" to allow any app to set the status.
   */
  appId?: InputMaybe<Scalars['ID']['input']>;
  /** Status check context that must pass for commits to be accepted to the matching branch. */
  context: Scalars['String']['input'];
};

/**
 * Choose which status checks must pass before the ref is updated. When enabled,
 * commits must first be pushed to another ref where the checks pass.
 */
export type gh_RequiredStatusChecksParameters = {
  /** Status checks that are required. */
  requiredStatusChecks: Array<gh_StatusCheckConfiguration>;
  /**
   * Whether pull requests targeting a matching branch must be tested with the
   * latest code. This setting will not take effect unless at least one status
   * check is enabled.
   */
  strictRequiredStatusChecksPolicy: Scalars['Boolean']['output'];
};

/**
 * Choose which status checks must pass before the ref is updated. When enabled,
 * commits must first be pushed to another ref where the checks pass.
 */
export type gh_RequiredStatusChecksParametersInput = {
  /** Status checks that are required. */
  requiredStatusChecks: Array<gh_StatusCheckConfigurationInput>;
  /**
   * Whether pull requests targeting a matching branch must be tested with the
   * latest code. This setting will not take effect unless at least one status
   * check is enabled.
   */
  strictRequiredStatusChecksPolicy: Scalars['Boolean']['input'];
};

/** Autogenerated input type of RerequestCheckSuite */
export type gh_RerequestCheckSuiteInput = {
  /** The Node ID of the check suite. */
  checkSuiteId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of RerequestCheckSuite */
export type gh_RerequestCheckSuitePayload = {
  /** The requested check suite. */
  checkSuite?: Maybe<gh_CheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ResolveReviewThread */
export type gh_ResolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the thread to resolve */
  threadId: Scalars['ID']['input'];
};

/** Autogenerated return type of ResolveReviewThread */
export type gh_ResolveReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The thread to resolve. */
  thread?: Maybe<gh_PullRequestReviewThread>;
};

/** Represents a private contribution a user made on GitHub. */
export type gh_RestrictedContribution = gh_Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime']['output'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this contribution. */
  url: Scalars['gh_URI']['output'];
  /** The user who made this contribution. */
  user: gh_User;
};

/** Autogenerated input type of RetireSponsorsTier */
export type gh_RetireSponsorsTierInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the published tier to retire. */
  tierId: Scalars['ID']['input'];
};

/** Autogenerated return type of RetireSponsorsTier */
export type gh_RetireSponsorsTierPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The tier that was retired. */
  sponsorsTier?: Maybe<gh_SponsorsTier>;
};

/** Autogenerated input type of RevertPullRequest */
export type gh_RevertPullRequestInput = {
  /** The description of the revert pull request. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether the revert pull request should be a draft. */
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the pull request to revert. */
  pullRequestId: Scalars['ID']['input'];
  /** The title of the revert pull request. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of RevertPullRequest */
export type gh_RevertPullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that was reverted. */
  pullRequest?: Maybe<gh_PullRequest>;
  /** The new pull request that reverts the input pull request. */
  revertPullRequest?: Maybe<gh_PullRequest>;
};

/** A user, team, or app who has the ability to dismiss a review on a protected branch. */
export type gh_ReviewDismissalAllowance = gh_Node & {
  /** The actor that can dismiss. */
  actor?: Maybe<gh_ReviewDismissalAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<gh_BranchProtectionRule>;
  /** The Node ID of the ReviewDismissalAllowance object */
  id: Scalars['ID']['output'];
};

/** Types that can be an actor. */
export type gh_ReviewDismissalAllowanceActor = gh_App | gh_Team | gh_User;

/** The connection type for ReviewDismissalAllowance. */
export type gh_ReviewDismissalAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ReviewDismissalAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ReviewDismissalAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ReviewDismissalAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ReviewDismissalAllowance>;
};

/** Represents a 'review_dismissed' event on a given issue or pull request. */
export type gh_ReviewDismissedEvent = gh_Node & gh_UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** Identifies the optional message associated with the 'review_dismissed' event. */
  dismissalMessage?: Maybe<Scalars['String']['output']>;
  /** Identifies the optional message associated with the event, rendered to HTML. */
  dismissalMessageHTML?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the ReviewDismissedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the previous state of the review with the 'review_dismissed' event. */
  previousReviewState: gh_PullRequestReviewState;
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
  /** Identifies the commit which caused the review to become stale. */
  pullRequestCommit?: Maybe<gh_PullRequestCommit>;
  /** The HTTP path for this review dismissed event. */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the review associated with the 'review_dismissed' event. */
  review?: Maybe<gh_PullRequestReview>;
  /** The HTTP URL for this review dismissed event. */
  url: Scalars['gh_URI']['output'];
};

/** A request for a user to review a pull request. */
export type gh_ReviewRequest = gh_Node & {
  /** Whether this request was created for a code owner */
  asCodeOwner: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the ReviewRequest object */
  id: Scalars['ID']['output'];
  /** Identifies the pull request associated with this review request. */
  pullRequest: gh_PullRequest;
  /** The reviewer that is requested. */
  requestedReviewer?: Maybe<gh_RequestedReviewer>;
};

/** The connection type for ReviewRequest. */
export type gh_ReviewRequestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_ReviewRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_ReviewRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_ReviewRequestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_ReviewRequest>;
};

/** Represents an 'review_request_removed' event on a given pull request. */
export type gh_ReviewRequestRemovedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ReviewRequestRemovedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
  /** Identifies the reviewer whose review request was removed. */
  requestedReviewer?: Maybe<gh_RequestedReviewer>;
};

/** Represents an 'review_requested' event on a given pull request. */
export type gh_ReviewRequestedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the ReviewRequestedEvent object */
  id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  pullRequest: gh_PullRequest;
  /** Identifies the reviewer whose review was requested. */
  requestedReviewer?: Maybe<gh_RequestedReviewer>;
};

/**
 * A hovercard context with a message describing the current code review state of the pull
 * request.
 */
export type gh_ReviewStatusHovercardContext = gh_HovercardContext & {
  /** A string describing this context */
  message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  octicon: Scalars['String']['output'];
  /** The current status of the pull request with respect to code review. */
  reviewDecision?: Maybe<gh_PullRequestReviewDecision>;
};

/** Autogenerated input type of RevokeEnterpriseOrganizationsMigratorRole */
export type gh_RevokeEnterpriseOrganizationsMigratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of the user to revoke the migrator role */
  login: Scalars['String']['input'];
};

/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */
export type gh_RevokeEnterpriseOrganizationsMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organizations that had the migrator role revoked for the given user. */
  organizations?: Maybe<gh_OrganizationConnection>;
};


/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */
export type gh_RevokeEnterpriseOrganizationsMigratorRolePayloadorganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of RevokeMigratorRole */
export type gh_RevokeMigratorRoleInput = {
  /** The user login or Team slug to revoke the migrator role from. */
  actor: Scalars['String']['input'];
  /** Specifies the type of the actor, can be either USER or TEAM. */
  actorType: gh_ActorType;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that the user/team belongs to. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of RevokeMigratorRole */
export type gh_RevokeMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Possible roles a user may have in relation to an organization. */
export type gh_RoleInOrganization =
  /** A user who is a direct member of the organization. */
  | 'DIRECT_MEMBER'
  /** A user with full administrative access to the organization. */
  | 'OWNER'
  /** A user who is unaffiliated with the organization. */
  | 'UNAFFILIATED';

/** The level of enforcement for a rule or ruleset. */
export type gh_RuleEnforcement =
  /** Rules will be enforced */
  | 'ACTIVE'
  /** Do not evaluate or enforce rules */
  | 'DISABLED'
  /**
   * Allow admins to test rules before enforcing them. Admins can view insights on
   * the Rule Insights page (`evaluate` is only available with GitHub Enterprise).
   */
  | 'EVALUATE';

/** Types which can be parameters for `RepositoryRule` objects. */
export type gh_RuleParameters = gh_BranchNamePatternParameters | gh_CommitAuthorEmailPatternParameters | gh_CommitMessagePatternParameters | gh_CommitterEmailPatternParameters | gh_PullRequestParameters | gh_RequiredDeploymentsParameters | gh_RequiredStatusChecksParameters | gh_TagNamePatternParameters | gh_UpdateParameters | gh_WorkflowsParameters;

/** Specifies the parameters for a `RepositoryRule` object. Only one of the fields should be specified. */
export type gh_RuleParametersInput = {
  /** Parameters used for the `branch_name_pattern` rule type */
  branchNamePattern?: InputMaybe<gh_BranchNamePatternParametersInput>;
  /** Parameters used for the `commit_author_email_pattern` rule type */
  commitAuthorEmailPattern?: InputMaybe<gh_CommitAuthorEmailPatternParametersInput>;
  /** Parameters used for the `commit_message_pattern` rule type */
  commitMessagePattern?: InputMaybe<gh_CommitMessagePatternParametersInput>;
  /** Parameters used for the `committer_email_pattern` rule type */
  committerEmailPattern?: InputMaybe<gh_CommitterEmailPatternParametersInput>;
  /** Parameters used for the `pull_request` rule type */
  pullRequest?: InputMaybe<gh_PullRequestParametersInput>;
  /** Parameters used for the `required_deployments` rule type */
  requiredDeployments?: InputMaybe<gh_RequiredDeploymentsParametersInput>;
  /** Parameters used for the `required_status_checks` rule type */
  requiredStatusChecks?: InputMaybe<gh_RequiredStatusChecksParametersInput>;
  /** Parameters used for the `tag_name_pattern` rule type */
  tagNamePattern?: InputMaybe<gh_TagNamePatternParametersInput>;
  /** Parameters used for the `update` rule type */
  update?: InputMaybe<gh_UpdateParametersInput>;
  /** Parameters used for the `workflows` rule type */
  workflows?: InputMaybe<gh_WorkflowsParametersInput>;
};

/** Types which can have `RepositoryRule` objects. */
export type gh_RuleSource = gh_Organization | gh_Repository;

/** The possible digest algorithms used to sign SAML requests for an identity provider. */
export type gh_SamlDigestAlgorithm =
  /** SHA1 */
  | 'SHA1'
  /** SHA256 */
  | 'SHA256'
  /** SHA384 */
  | 'SHA384'
  /** SHA512 */
  | 'SHA512';

/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */
export type gh_SamlSignatureAlgorithm =
  /** RSA-SHA1 */
  | 'RSA_SHA1'
  /** RSA-SHA256 */
  | 'RSA_SHA256'
  /** RSA-SHA384 */
  | 'RSA_SHA384'
  /** RSA-SHA512 */
  | 'RSA_SHA512';

/** A Saved Reply is text a user can use to reply quickly. */
export type gh_SavedReply = gh_Node & {
  /** The body of the saved reply. */
  body: Scalars['String']['output'];
  /** The saved reply body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the SavedReply object */
  id: Scalars['ID']['output'];
  /** The title of the saved reply. */
  title: Scalars['String']['output'];
  /** The user that saved this reply. */
  user?: Maybe<gh_Actor>;
};

/** The connection type for SavedReply. */
export type gh_SavedReplyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_SavedReplyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_SavedReply>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_SavedReplyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_SavedReply>;
};

/** Ordering options for saved reply connections. */
export type gh_SavedReplyOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order saved replies by. */
  field: gh_SavedReplyOrderField;
};

/** Properties by which saved reply connections can be ordered. */
export type gh_SavedReplyOrderField =
  /** Order saved reply by when they were updated. */
  | 'UPDATED_AT';

/** The results of a search. */
export type gh_SearchResultItem = gh_App | gh_Discussion | gh_Issue | gh_MarketplaceListing | gh_Organization | gh_PullRequest | gh_Repository | gh_User;

/**
 * A list of results that matched against a search query. Regardless of the number
 * of matches, a maximum of 1,000 results will be available across all types,
 * potentially split across many pages.
 */
export type gh_SearchResultItemConnection = {
  /**
   * The total number of pieces of code that matched the search query. Regardless
   * of the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  codeCount: Scalars['Int']['output'];
  /**
   * The total number of discussions that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  discussionCount: Scalars['Int']['output'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_SearchResultItemEdge>>>;
  /**
   * The total number of issues that matched the search query. Regardless of the
   * total number of matches, a maximum of 1,000 results will be available across all types.
   */
  issueCount: Scalars['Int']['output'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_SearchResultItem>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /**
   * The total number of repositories that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  repositoryCount: Scalars['Int']['output'];
  /**
   * The total number of users that matched the search query. Regardless of the
   * total number of matches, a maximum of 1,000 results will be available across all types.
   */
  userCount: Scalars['Int']['output'];
  /**
   * The total number of wiki pages that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  wikiCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_SearchResultItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_SearchResultItem>;
  /** Text matches on the result found. */
  textMatches?: Maybe<Array<Maybe<gh_TextMatch>>>;
};

/** Represents the individual results of a search. */
export type gh_SearchType =
  /** Returns matching discussions in repositories. */
  | 'DISCUSSION'
  /** Returns results matching issues in repositories. */
  | 'ISSUE'
  /** Returns results matching repositories. */
  | 'REPOSITORY'
  /** Returns results matching users and organizations on GitHub. */
  | 'USER';

/** A GitHub Security Advisory */
export type gh_SecurityAdvisory = gh_Node & {
  /** The classification of the advisory */
  classification: gh_SecurityAdvisoryClassification;
  /** The CVSS associated with this advisory */
  cvss: gh_CVSS;
  /** CWEs associated with this Advisory */
  cwes: gh_CWEConnection;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** This is a long plaintext description of the advisory */
  description: Scalars['String']['output'];
  /** The GitHub Security Advisory ID */
  ghsaId: Scalars['String']['output'];
  /** The Node ID of the SecurityAdvisory object */
  id: Scalars['ID']['output'];
  /** A list of identifiers for this advisory */
  identifiers: Array<gh_SecurityAdvisoryIdentifier>;
  /** The permalink for the advisory's dependabot alerts page */
  notificationsPermalink?: Maybe<Scalars['gh_URI']['output']>;
  /** The organization that originated the advisory */
  origin: Scalars['String']['output'];
  /** The permalink for the advisory */
  permalink?: Maybe<Scalars['gh_URI']['output']>;
  /** When the advisory was published */
  publishedAt: Scalars['DateTime']['output'];
  /** A list of references for this advisory */
  references: Array<gh_SecurityAdvisoryReference>;
  /** The severity of the advisory */
  severity: gh_SecurityAdvisorySeverity;
  /** A short plaintext summary of the advisory */
  summary: Scalars['String']['output'];
  /** When the advisory was last updated */
  updatedAt: Scalars['DateTime']['output'];
  /** Vulnerabilities associated with this Advisory */
  vulnerabilities: gh_SecurityVulnerabilityConnection;
  /** When the advisory was withdrawn, if it has been withdrawn */
  withdrawnAt?: Maybe<Scalars['DateTime']['output']>;
};


/** A GitHub Security Advisory */
export type gh_SecurityAdvisorycwesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A GitHub Security Advisory */
export type gh_SecurityAdvisoryvulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  classifications?: InputMaybe<Array<gh_SecurityAdvisoryClassification>>;
  ecosystem?: InputMaybe<gh_SecurityAdvisoryEcosystem>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SecurityVulnerabilityOrder>;
  package?: InputMaybe<Scalars['String']['input']>;
  severities?: InputMaybe<Array<gh_SecurityAdvisorySeverity>>;
};

/** Classification of the advisory. */
export type gh_SecurityAdvisoryClassification =
  /** Classification of general advisories. */
  | 'GENERAL'
  /** Classification of malware advisories. */
  | 'MALWARE';

/** The connection type for SecurityAdvisory. */
export type gh_SecurityAdvisoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_SecurityAdvisoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_SecurityAdvisory>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The possible ecosystems of a security vulnerability's package. */
export type gh_SecurityAdvisoryEcosystem =
  /** GitHub Actions */
  | 'ACTIONS'
  /** PHP packages hosted at packagist.org */
  | 'COMPOSER'
  /** Erlang/Elixir packages hosted at hex.pm */
  | 'ERLANG'
  /** Go modules */
  | 'GO'
  /** Java artifacts hosted at the Maven central repository */
  | 'MAVEN'
  /** JavaScript packages hosted at npmjs.com */
  | 'NPM'
  /** .NET packages hosted at the NuGet Gallery */
  | 'NUGET'
  /** Python packages hosted at PyPI.org */
  | 'PIP'
  /** Dart packages hosted at pub.dev */
  | 'PUB'
  /** Ruby gems hosted at RubyGems.org */
  | 'RUBYGEMS'
  /** Rust crates */
  | 'RUST'
  /** Swift packages */
  | 'SWIFT';

/** An edge in a connection. */
export type gh_SecurityAdvisoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_SecurityAdvisory>;
};

/** A GitHub Security Advisory Identifier */
export type gh_SecurityAdvisoryIdentifier = {
  /** The identifier type, e.g. GHSA, CVE */
  type: Scalars['String']['output'];
  /** The identifier */
  value: Scalars['String']['output'];
};

/** An advisory identifier to filter results on. */
export type gh_SecurityAdvisoryIdentifierFilter = {
  /** The identifier type. */
  type: gh_SecurityAdvisoryIdentifierType;
  /** The identifier string. Supports exact or partial matching. */
  value: Scalars['String']['input'];
};

/** Identifier formats available for advisories. */
export type gh_SecurityAdvisoryIdentifierType =
  /** Common Vulnerabilities and Exposures Identifier. */
  | 'CVE'
  /** GitHub Security Advisory ID. */
  | 'GHSA';

/** Ordering options for security advisory connections */
export type gh_SecurityAdvisoryOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order security advisories by. */
  field: gh_SecurityAdvisoryOrderField;
};

/** Properties by which security advisory connections can be ordered. */
export type gh_SecurityAdvisoryOrderField =
  /** Order advisories by publication time */
  | 'PUBLISHED_AT'
  /** Order advisories by update time */
  | 'UPDATED_AT';

/** An individual package */
export type gh_SecurityAdvisoryPackage = {
  /** The ecosystem the package belongs to, e.g. RUBYGEMS, NPM */
  ecosystem: gh_SecurityAdvisoryEcosystem;
  /** The package name */
  name: Scalars['String']['output'];
};

/** An individual package version */
export type gh_SecurityAdvisoryPackageVersion = {
  /** The package name or version */
  identifier: Scalars['String']['output'];
};

/** A GitHub Security Advisory Reference */
export type gh_SecurityAdvisoryReference = {
  /** A publicly accessible reference */
  url: Scalars['gh_URI']['output'];
};

/** Severity of the vulnerability. */
export type gh_SecurityAdvisorySeverity =
  /** Critical. */
  | 'CRITICAL'
  /** High. */
  | 'HIGH'
  /** Low. */
  | 'LOW'
  /** Moderate. */
  | 'MODERATE';

/** An individual vulnerability within an Advisory */
export type gh_SecurityVulnerability = {
  /** The Advisory associated with this Vulnerability */
  advisory: gh_SecurityAdvisory;
  /** The first version containing a fix for the vulnerability */
  firstPatchedVersion?: Maybe<gh_SecurityAdvisoryPackageVersion>;
  /** A description of the vulnerable package */
  package: gh_SecurityAdvisoryPackage;
  /** The severity of the vulnerability within this package */
  severity: gh_SecurityAdvisorySeverity;
  /** When the vulnerability was last updated */
  updatedAt: Scalars['DateTime']['output'];
  /**
   * A string that describes the vulnerable package versions.
   * This string follows a basic syntax with a few forms.
   * + `= 0.2.0` denotes a single vulnerable version.
   * + `<= 1.0.8` denotes a version range up to and including the specified version
   * + `< 0.1.11` denotes a version range up to, but excluding, the specified version
   * + `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.
   * + `>= 0.0.1` denotes a version range with a known minimum, but no known maximum
   */
  vulnerableVersionRange: Scalars['String']['output'];
};

/** The connection type for SecurityVulnerability. */
export type gh_SecurityVulnerabilityConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_SecurityVulnerabilityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_SecurityVulnerability>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_SecurityVulnerabilityEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_SecurityVulnerability>;
};

/** Ordering options for security vulnerability connections */
export type gh_SecurityVulnerabilityOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order security vulnerabilities by. */
  field: gh_SecurityVulnerabilityOrderField;
};

/** Properties by which security vulnerability connections can be ordered. */
export type gh_SecurityVulnerabilityOrderField =
  /** Order vulnerability by update time */
  | 'UPDATED_AT';

/** Autogenerated input type of SetEnterpriseIdentityProvider */
export type gh_SetEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod: gh_SamlDigestAlgorithm;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID']['input'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate: Scalars['String']['input'];
  /** The Issuer Entity ID for the SAML identity provider */
  issuer?: InputMaybe<Scalars['String']['input']>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod: gh_SamlSignatureAlgorithm;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl: Scalars['gh_URI']['input'];
};

/** Autogenerated return type of SetEnterpriseIdentityProvider */
export type gh_SetEnterpriseIdentityProviderPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The identity provider for the enterprise. */
  identityProvider?: Maybe<gh_EnterpriseIdentityProvider>;
};

/** Autogenerated input type of SetOrganizationInteractionLimit */
export type gh_SetOrganizationInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<gh_RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: gh_RepositoryInteractionLimit;
  /** The ID of the organization to set a limit for. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of SetOrganizationInteractionLimit */
export type gh_SetOrganizationInteractionLimitPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organization that the interaction limit was set for. */
  organization?: Maybe<gh_Organization>;
};

/** Autogenerated input type of SetRepositoryInteractionLimit */
export type gh_SetRepositoryInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<gh_RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: gh_RepositoryInteractionLimit;
  /** The ID of the repository to set a limit for. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of SetRepositoryInteractionLimit */
export type gh_SetRepositoryInteractionLimitPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository that the interaction limit was set for. */
  repository?: Maybe<gh_Repository>;
};

/** Autogenerated input type of SetUserInteractionLimit */
export type gh_SetUserInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<gh_RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: gh_RepositoryInteractionLimit;
  /** The ID of the user to set a limit for. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of SetUserInteractionLimit */
export type gh_SetUserInteractionLimitPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The user that the interaction limit was set for. */
  user?: Maybe<gh_User>;
};

/** Represents an S/MIME signature on a Commit or Tag. */
export type gh_SmimeSignature = gh_GitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean']['output'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<gh_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: gh_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** Social media profile associated with a user. */
export type gh_SocialAccount = {
  /** Name of the social media account as it appears on the profile. */
  displayName: Scalars['String']['output'];
  /** Software or company that hosts the social media account. */
  provider: gh_SocialAccountProvider;
  /** URL of the social media account. */
  url: Scalars['gh_URI']['output'];
};

/** The connection type for SocialAccount. */
export type gh_SocialAccountConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_SocialAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_SocialAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_SocialAccountEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_SocialAccount>;
};

/** Software or company that hosts social media accounts. */
export type gh_SocialAccountProvider =
  /** Social media and networking website. */
  | 'FACEBOOK'
  /** Catch-all for social media providers that do not yet have specific handling. */
  | 'GENERIC'
  /** Fork of Mastodon with a greater focus on local posting. */
  | 'HOMETOWN'
  /** Social media website with a focus on photo and video sharing. */
  | 'INSTAGRAM'
  /** Professional networking website. */
  | 'LINKEDIN'
  /** Open-source federated microblogging service. */
  | 'MASTODON'
  /** JavaScript package registry. */
  | 'NPM'
  /** Social news aggregation and discussion website. */
  | 'REDDIT'
  /** Live-streaming service. */
  | 'TWITCH'
  /** Microblogging website. */
  | 'TWITTER'
  /** Online video platform. */
  | 'YOUTUBE';

/** Entities that can sponsor others via GitHub Sponsors */
export type gh_Sponsor = gh_Organization | gh_User;

/** The connection type for Sponsor. */
export type gh_SponsorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_SponsorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Sponsor>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a user or organization who is sponsoring someone in GitHub Sponsors. */
export type gh_SponsorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Sponsor>;
};

/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */
export type gh_SponsorOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order sponsor entities by. */
  field: gh_SponsorOrderField;
};

/** Properties by which sponsor connections can be ordered. */
export type gh_SponsorOrderField =
  /** Order sponsorable entities by login (username). */
  | 'LOGIN'
  /** Order sponsors by their relevance to the viewer. */
  | 'RELEVANCE';

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type gh_Sponsorable = {
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars['Int']['output'];
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars['Boolean']['output'];
  /** Whether the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars['Boolean']['output'];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars['Boolean']['output'];
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']['output'];
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: gh_SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: gh_SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: gh_SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<gh_SponsorsListing>;
  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
  sponsorshipForViewerAsSponsor?: Maybe<gh_Sponsorship>;
  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
  sponsorshipForViewerAsSponsorable?: Maybe<gh_Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: gh_SponsorshipNewsletterConnection;
  /** The sponsorships where this user or organization is the maintainer receiving the funds. */
  sponsorshipsAsMaintainer: gh_SponsorshipConnection;
  /** The sponsorships where this user or organization is the funder. */
  sponsorshipsAsSponsor: gh_SponsorshipConnection;
  /**
   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
   * user themselves or by a user who can manage sponsorships for the requested organization.
   */
  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']['output']>;
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars['Boolean']['output'];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars['Boolean']['output'];
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type gh_SponsorableisSponsoredByArgs = {
  accountLogin: Scalars['String']['input'];
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type gh_SponsorablesponsoringArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type gh_SponsorablesponsorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']['input']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type gh_SponsorablesponsorsActivitiesArgs = {
  actions?: InputMaybe<Array<gh_SponsorsActivityAction>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAsSponsor?: InputMaybe<Scalars['Boolean']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorsActivityOrder>;
  period?: InputMaybe<gh_SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type gh_SponsorablesponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type gh_SponsorablesponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type gh_SponsorablesponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorshipNewsletterOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type gh_SponsorablesponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorshipOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type gh_SponsorablesponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  maintainerLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  orderBy?: InputMaybe<gh_SponsorshipOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type gh_SponsorabletotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars['DateTime']['input']>;
  sponsorableLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Entities that can be sponsored via GitHub Sponsors */
export type gh_SponsorableItem = gh_Organization | gh_User;

/** The connection type for SponsorableItem. */
export type gh_SponsorableItemConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_SponsorableItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_SponsorableItem>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_SponsorableItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_SponsorableItem>;
};

/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */
export type gh_SponsorableOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order sponsorable entities by. */
  field: gh_SponsorableOrderField;
};

/** Properties by which sponsorable connections can be ordered. */
export type gh_SponsorableOrderField =
  /** Order sponsorable entities by login (username). */
  | 'LOGIN';

/** An event related to sponsorship activity. */
export type gh_SponsorsActivity = gh_Node & {
  /** What action this activity indicates took place. */
  action: gh_SponsorsActivityAction;
  /** The sponsor's current privacy level. */
  currentPrivacyLevel?: Maybe<gh_SponsorshipPrivacy>;
  /** The Node ID of the SponsorsActivity object */
  id: Scalars['ID']['output'];
  /** The platform that was used to pay for the sponsorship. */
  paymentSource?: Maybe<gh_SponsorshipPaymentSource>;
  /** The tier that the sponsorship used to use, for tier change events. */
  previousSponsorsTier?: Maybe<gh_SponsorsTier>;
  /** The user or organization who triggered this activity and was/is sponsoring the sponsorable. */
  sponsor?: Maybe<gh_Sponsor>;
  /** The user or organization that is being sponsored, the maintainer. */
  sponsorable: gh_Sponsorable;
  /** The associated sponsorship tier. */
  sponsorsTier?: Maybe<gh_SponsorsTier>;
  /** The timestamp of this event. */
  timestamp?: Maybe<Scalars['DateTime']['output']>;
  /** Was this sponsorship made alongside other sponsorships at the same time from the same sponsor? */
  viaBulkSponsorship: Scalars['Boolean']['output'];
};

/** The possible actions that GitHub Sponsors activities can represent. */
export type gh_SponsorsActivityAction =
  /** The activity was cancelling a sponsorship. */
  | 'CANCELLED_SPONSORSHIP'
  /** The activity was starting a sponsorship. */
  | 'NEW_SPONSORSHIP'
  /** The activity was scheduling a downgrade or cancellation. */
  | 'PENDING_CHANGE'
  /** The activity was funds being refunded to the sponsor or GitHub. */
  | 'REFUND'
  /** The activity was disabling matching for a previously matched sponsorship. */
  | 'SPONSOR_MATCH_DISABLED'
  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */
  | 'TIER_CHANGE';

/** The connection type for SponsorsActivity. */
export type gh_SponsorsActivityConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_SponsorsActivityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_SponsorsActivity>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_SponsorsActivityEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_SponsorsActivity>;
};

/** Ordering options for GitHub Sponsors activity connections. */
export type gh_SponsorsActivityOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order activity by. */
  field: gh_SponsorsActivityOrderField;
};

/** Properties by which GitHub Sponsors activity connections can be ordered. */
export type gh_SponsorsActivityOrderField =
  /** Order activities by when they happened. */
  | 'TIMESTAMP';

/** The possible time periods for which Sponsors activities can be requested. */
export type gh_SponsorsActivityPeriod =
  /** Don't restrict the activity to any date range, include all activity. */
  | 'ALL'
  /** The previous calendar day. */
  | 'DAY'
  /** The previous thirty days. */
  | 'MONTH'
  /** The previous seven days. */
  | 'WEEK';

/** Represents countries or regions for billing and residence for a GitHub Sponsors profile. */
export type gh_SponsorsCountryOrRegionCode =
  /** Andorra */
  | 'AD'
  /** United Arab Emirates */
  | 'AE'
  /** Afghanistan */
  | 'AF'
  /** Antigua and Barbuda */
  | 'AG'
  /** Anguilla */
  | 'AI'
  /** Albania */
  | 'AL'
  /** Armenia */
  | 'AM'
  /** Angola */
  | 'AO'
  /** Antarctica */
  | 'AQ'
  /** Argentina */
  | 'AR'
  /** American Samoa */
  | 'AS'
  /** Austria */
  | 'AT'
  /** Australia */
  | 'AU'
  /** Aruba */
  | 'AW'
  /** Åland */
  | 'AX'
  /** Azerbaijan */
  | 'AZ'
  /** Bosnia and Herzegovina */
  | 'BA'
  /** Barbados */
  | 'BB'
  /** Bangladesh */
  | 'BD'
  /** Belgium */
  | 'BE'
  /** Burkina Faso */
  | 'BF'
  /** Bulgaria */
  | 'BG'
  /** Bahrain */
  | 'BH'
  /** Burundi */
  | 'BI'
  /** Benin */
  | 'BJ'
  /** Saint Barthélemy */
  | 'BL'
  /** Bermuda */
  | 'BM'
  /** Brunei Darussalam */
  | 'BN'
  /** Bolivia */
  | 'BO'
  /** Bonaire, Sint Eustatius and Saba */
  | 'BQ'
  /** Brazil */
  | 'BR'
  /** Bahamas */
  | 'BS'
  /** Bhutan */
  | 'BT'
  /** Bouvet Island */
  | 'BV'
  /** Botswana */
  | 'BW'
  /** Belarus */
  | 'BY'
  /** Belize */
  | 'BZ'
  /** Canada */
  | 'CA'
  /** Cocos (Keeling) Islands */
  | 'CC'
  /** Congo (Kinshasa) */
  | 'CD'
  /** Central African Republic */
  | 'CF'
  /** Congo (Brazzaville) */
  | 'CG'
  /** Switzerland */
  | 'CH'
  /** Côte d'Ivoire */
  | 'CI'
  /** Cook Islands */
  | 'CK'
  /** Chile */
  | 'CL'
  /** Cameroon */
  | 'CM'
  /** China */
  | 'CN'
  /** Colombia */
  | 'CO'
  /** Costa Rica */
  | 'CR'
  /** Cape Verde */
  | 'CV'
  /** Curaçao */
  | 'CW'
  /** Christmas Island */
  | 'CX'
  /** Cyprus */
  | 'CY'
  /** Czech Republic */
  | 'CZ'
  /** Germany */
  | 'DE'
  /** Djibouti */
  | 'DJ'
  /** Denmark */
  | 'DK'
  /** Dominica */
  | 'DM'
  /** Dominican Republic */
  | 'DO'
  /** Algeria */
  | 'DZ'
  /** Ecuador */
  | 'EC'
  /** Estonia */
  | 'EE'
  /** Egypt */
  | 'EG'
  /** Western Sahara */
  | 'EH'
  /** Eritrea */
  | 'ER'
  /** Spain */
  | 'ES'
  /** Ethiopia */
  | 'ET'
  /** Finland */
  | 'FI'
  /** Fiji */
  | 'FJ'
  /** Falkland Islands */
  | 'FK'
  /** Micronesia */
  | 'FM'
  /** Faroe Islands */
  | 'FO'
  /** France */
  | 'FR'
  /** Gabon */
  | 'GA'
  /** United Kingdom */
  | 'GB'
  /** Grenada */
  | 'GD'
  /** Georgia */
  | 'GE'
  /** French Guiana */
  | 'GF'
  /** Guernsey */
  | 'GG'
  /** Ghana */
  | 'GH'
  /** Gibraltar */
  | 'GI'
  /** Greenland */
  | 'GL'
  /** Gambia */
  | 'GM'
  /** Guinea */
  | 'GN'
  /** Guadeloupe */
  | 'GP'
  /** Equatorial Guinea */
  | 'GQ'
  /** Greece */
  | 'GR'
  /** South Georgia and South Sandwich Islands */
  | 'GS'
  /** Guatemala */
  | 'GT'
  /** Guam */
  | 'GU'
  /** Guinea-Bissau */
  | 'GW'
  /** Guyana */
  | 'GY'
  /** Hong Kong */
  | 'HK'
  /** Heard and McDonald Islands */
  | 'HM'
  /** Honduras */
  | 'HN'
  /** Croatia */
  | 'HR'
  /** Haiti */
  | 'HT'
  /** Hungary */
  | 'HU'
  /** Indonesia */
  | 'ID'
  /** Ireland */
  | 'IE'
  /** Israel */
  | 'IL'
  /** Isle of Man */
  | 'IM'
  /** India */
  | 'IN'
  /** British Indian Ocean Territory */
  | 'IO'
  /** Iraq */
  | 'IQ'
  /** Iran */
  | 'IR'
  /** Iceland */
  | 'IS'
  /** Italy */
  | 'IT'
  /** Jersey */
  | 'JE'
  /** Jamaica */
  | 'JM'
  /** Jordan */
  | 'JO'
  /** Japan */
  | 'JP'
  /** Kenya */
  | 'KE'
  /** Kyrgyzstan */
  | 'KG'
  /** Cambodia */
  | 'KH'
  /** Kiribati */
  | 'KI'
  /** Comoros */
  | 'KM'
  /** Saint Kitts and Nevis */
  | 'KN'
  /** Korea, South */
  | 'KR'
  /** Kuwait */
  | 'KW'
  /** Cayman Islands */
  | 'KY'
  /** Kazakhstan */
  | 'KZ'
  /** Laos */
  | 'LA'
  /** Lebanon */
  | 'LB'
  /** Saint Lucia */
  | 'LC'
  /** Liechtenstein */
  | 'LI'
  /** Sri Lanka */
  | 'LK'
  /** Liberia */
  | 'LR'
  /** Lesotho */
  | 'LS'
  /** Lithuania */
  | 'LT'
  /** Luxembourg */
  | 'LU'
  /** Latvia */
  | 'LV'
  /** Libya */
  | 'LY'
  /** Morocco */
  | 'MA'
  /** Monaco */
  | 'MC'
  /** Moldova */
  | 'MD'
  /** Montenegro */
  | 'ME'
  /** Saint Martin (French part) */
  | 'MF'
  /** Madagascar */
  | 'MG'
  /** Marshall Islands */
  | 'MH'
  /** Macedonia */
  | 'MK'
  /** Mali */
  | 'ML'
  /** Myanmar */
  | 'MM'
  /** Mongolia */
  | 'MN'
  /** Macau */
  | 'MO'
  /** Northern Mariana Islands */
  | 'MP'
  /** Martinique */
  | 'MQ'
  /** Mauritania */
  | 'MR'
  /** Montserrat */
  | 'MS'
  /** Malta */
  | 'MT'
  /** Mauritius */
  | 'MU'
  /** Maldives */
  | 'MV'
  /** Malawi */
  | 'MW'
  /** Mexico */
  | 'MX'
  /** Malaysia */
  | 'MY'
  /** Mozambique */
  | 'MZ'
  /** Namibia */
  | 'NA'
  /** New Caledonia */
  | 'NC'
  /** Niger */
  | 'NE'
  /** Norfolk Island */
  | 'NF'
  /** Nigeria */
  | 'NG'
  /** Nicaragua */
  | 'NI'
  /** Netherlands */
  | 'NL'
  /** Norway */
  | 'NO'
  /** Nepal */
  | 'NP'
  /** Nauru */
  | 'NR'
  /** Niue */
  | 'NU'
  /** New Zealand */
  | 'NZ'
  /** Oman */
  | 'OM'
  /** Panama */
  | 'PA'
  /** Peru */
  | 'PE'
  /** French Polynesia */
  | 'PF'
  /** Papua New Guinea */
  | 'PG'
  /** Philippines */
  | 'PH'
  /** Pakistan */
  | 'PK'
  /** Poland */
  | 'PL'
  /** Saint Pierre and Miquelon */
  | 'PM'
  /** Pitcairn */
  | 'PN'
  /** Puerto Rico */
  | 'PR'
  /** Palestine */
  | 'PS'
  /** Portugal */
  | 'PT'
  /** Palau */
  | 'PW'
  /** Paraguay */
  | 'PY'
  /** Qatar */
  | 'QA'
  /** Reunion */
  | 'RE'
  /** Romania */
  | 'RO'
  /** Serbia */
  | 'RS'
  /** Russian Federation */
  | 'RU'
  /** Rwanda */
  | 'RW'
  /** Saudi Arabia */
  | 'SA'
  /** Solomon Islands */
  | 'SB'
  /** Seychelles */
  | 'SC'
  /** Sudan */
  | 'SD'
  /** Sweden */
  | 'SE'
  /** Singapore */
  | 'SG'
  /** Saint Helena */
  | 'SH'
  /** Slovenia */
  | 'SI'
  /** Svalbard and Jan Mayen Islands */
  | 'SJ'
  /** Slovakia */
  | 'SK'
  /** Sierra Leone */
  | 'SL'
  /** San Marino */
  | 'SM'
  /** Senegal */
  | 'SN'
  /** Somalia */
  | 'SO'
  /** Suriname */
  | 'SR'
  /** South Sudan */
  | 'SS'
  /** Sao Tome and Principe */
  | 'ST'
  /** El Salvador */
  | 'SV'
  /** Sint Maarten (Dutch part) */
  | 'SX'
  /** Swaziland */
  | 'SZ'
  /** Turks and Caicos Islands */
  | 'TC'
  /** Chad */
  | 'TD'
  /** French Southern Lands */
  | 'TF'
  /** Togo */
  | 'TG'
  /** Thailand */
  | 'TH'
  /** Tajikistan */
  | 'TJ'
  /** Tokelau */
  | 'TK'
  /** Timor-Leste */
  | 'TL'
  /** Turkmenistan */
  | 'TM'
  /** Tunisia */
  | 'TN'
  /** Tonga */
  | 'TO'
  /** Türkiye */
  | 'TR'
  /** Trinidad and Tobago */
  | 'TT'
  /** Tuvalu */
  | 'TV'
  /** Taiwan */
  | 'TW'
  /** Tanzania */
  | 'TZ'
  /** Ukraine */
  | 'UA'
  /** Uganda */
  | 'UG'
  /** United States Minor Outlying Islands */
  | 'UM'
  /** United States of America */
  | 'US'
  /** Uruguay */
  | 'UY'
  /** Uzbekistan */
  | 'UZ'
  /** Vatican City */
  | 'VA'
  /** Saint Vincent and the Grenadines */
  | 'VC'
  /** Venezuela */
  | 'VE'
  /** Virgin Islands, British */
  | 'VG'
  /** Virgin Islands, U.S. */
  | 'VI'
  /** Vietnam */
  | 'VN'
  /** Vanuatu */
  | 'VU'
  /** Wallis and Futuna Islands */
  | 'WF'
  /** Samoa */
  | 'WS'
  /** Yemen */
  | 'YE'
  /** Mayotte */
  | 'YT'
  /** South Africa */
  | 'ZA'
  /** Zambia */
  | 'ZM'
  /** Zimbabwe */
  | 'ZW';

/** A goal associated with a GitHub Sponsors listing, representing a target the sponsored maintainer would like to attain. */
export type gh_SponsorsGoal = {
  /** A description of the goal from the maintainer. */
  description?: Maybe<Scalars['String']['output']>;
  /** What the objective of this goal is. */
  kind: gh_SponsorsGoalKind;
  /** The percentage representing how complete this goal is, between 0-100. */
  percentComplete: Scalars['Int']['output'];
  /**
   * What the goal amount is. Represents an amount in USD for monthly sponsorship
   * amount goals. Represents a count of unique sponsors for total sponsors count goals.
   */
  targetValue: Scalars['Int']['output'];
  /** A brief summary of the kind and target value of this goal. */
  title: Scalars['String']['output'];
};

/** The different kinds of goals a GitHub Sponsors member can have. */
export type gh_SponsorsGoalKind =
  /** The goal is about getting a certain amount in USD from sponsorships each month. */
  | 'MONTHLY_SPONSORSHIP_AMOUNT'
  /** The goal is about reaching a certain number of sponsors. */
  | 'TOTAL_SPONSORS_COUNT';

/** A GitHub Sponsors listing. */
export type gh_SponsorsListing = gh_Node & {
  /** The current goal the maintainer is trying to reach with GitHub Sponsors, if any. */
  activeGoal?: Maybe<gh_SponsorsGoal>;
  /**
   * The Stripe Connect account currently in use for payouts for this Sponsors
   * listing, if any. Will only return a value when queried by the maintainer
   * themselves, or by an admin of the sponsorable organization.
   */
  activeStripeConnectAccount?: Maybe<gh_StripeConnectAccount>;
  /**
   * The name of the country or region with the maintainer's bank account or fiscal
   * host. Will only return a value when queried by the maintainer themselves, or
   * by an admin of the sponsorable organization.
   */
  billingCountryOrRegion?: Maybe<Scalars['String']['output']>;
  /**
   * The email address used by GitHub to contact the sponsorable about their GitHub
   * Sponsors profile. Will only return a value when queried by the maintainer
   * themselves, or by an admin of the sponsorable organization.
   */
  contactEmailAddress?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The HTTP path for the Sponsors dashboard for this Sponsors listing. */
  dashboardResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for the Sponsors dashboard for this Sponsors listing. */
  dashboardUrl: Scalars['gh_URI']['output'];
  /** The records featured on the GitHub Sponsors profile. */
  featuredItems: Array<gh_SponsorsListingFeaturedItem>;
  /**
   * The fiscal host used for payments, if any. Will only return a value when
   * queried by the maintainer themselves, or by an admin of the sponsorable organization.
   */
  fiscalHost?: Maybe<gh_Organization>;
  /** The full description of the listing. */
  fullDescription: Scalars['String']['output'];
  /** The full description of the listing rendered to HTML. */
  fullDescriptionHTML: Scalars['gh_HTML']['output'];
  /** The Node ID of the SponsorsListing object */
  id: Scalars['ID']['output'];
  /** Whether this listing is publicly visible. */
  isPublic: Scalars['Boolean']['output'];
  /** The listing's full name. */
  name: Scalars['String']['output'];
  /** A future date on which this listing is eligible to receive a payout. */
  nextPayoutDate?: Maybe<Scalars['Date']['output']>;
  /**
   * The name of the country or region where the maintainer resides. Will only
   * return a value when queried by the maintainer themselves, or by an admin of
   * the sponsorable organization.
   */
  residenceCountryOrRegion?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this Sponsors listing. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The short description of the listing. */
  shortDescription: Scalars['String']['output'];
  /** The short name of the listing. */
  slug: Scalars['String']['output'];
  /** The entity this listing represents who can be sponsored on GitHub Sponsors. */
  sponsorable: gh_Sponsorable;
  /** The tiers for this GitHub Sponsors profile. */
  tiers?: Maybe<gh_SponsorsTierConnection>;
  /** The HTTP URL for this Sponsors listing. */
  url: Scalars['gh_URI']['output'];
};


/** A GitHub Sponsors listing. */
export type gh_SponsorsListingfeaturedItemsArgs = {
  featureableTypes?: InputMaybe<Array<gh_SponsorsListingFeaturedItemFeatureableType>>;
};


/** A GitHub Sponsors listing. */
export type gh_SponsorsListingtiersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnpublished?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorsTierOrder>;
};

/** A record that can be featured on a GitHub Sponsors profile. */
export type gh_SponsorsListingFeatureableItem = gh_Repository | gh_User;

/** A record that is promoted on a GitHub Sponsors profile. */
export type gh_SponsorsListingFeaturedItem = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /**
   * Will either be a description from the sponsorable maintainer about why they
   * featured this item, or the item's description itself, such as a user's bio
   * from their GitHub profile page.
   */
  description?: Maybe<Scalars['String']['output']>;
  /** The record that is featured on the GitHub Sponsors profile. */
  featureable: gh_SponsorsListingFeatureableItem;
  /** The Node ID of the SponsorsListingFeaturedItem object */
  id: Scalars['ID']['output'];
  /**
   * The position of this featured item on the GitHub Sponsors profile with a lower
   * position indicating higher precedence. Starts at 1.
   */
  position: Scalars['Int']['output'];
  /** The GitHub Sponsors profile that features this record. */
  sponsorsListing: gh_SponsorsListing;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The different kinds of records that can be featured on a GitHub Sponsors profile page. */
export type gh_SponsorsListingFeaturedItemFeatureableType =
  /** A repository owned by the user or organization with the GitHub Sponsors profile. */
  | 'REPOSITORY'
  /** A user who belongs to the organization with the GitHub Sponsors profile. */
  | 'USER';

/** A GitHub Sponsors tier associated with a GitHub Sponsors listing. */
export type gh_SponsorsTier = gh_Node & {
  /** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
  adminInfo?: Maybe<gh_SponsorsTierAdminInfo>;
  /**
   * Get a different tier for this tier's maintainer that is at the same frequency
   * as this tier but with an equal or lesser cost. Returns the published tier with
   * the monthly price closest to this tier's without going over.
   */
  closestLesserValueTier?: Maybe<gh_SponsorsTier>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The description of the tier. */
  description: Scalars['String']['output'];
  /** The tier description rendered to HTML */
  descriptionHTML: Scalars['gh_HTML']['output'];
  /** The Node ID of the SponsorsTier object */
  id: Scalars['ID']['output'];
  /**
   * Whether this tier was chosen at checkout time by the sponsor rather than
   * defined ahead of time by the maintainer who manages the Sponsors listing.
   */
  isCustomAmount: Scalars['Boolean']['output'];
  /** Whether this tier is only for use with one-time sponsorships. */
  isOneTime: Scalars['Boolean']['output'];
  /** How much this tier costs per month in cents. */
  monthlyPriceInCents: Scalars['Int']['output'];
  /** How much this tier costs per month in USD. */
  monthlyPriceInDollars: Scalars['Int']['output'];
  /** The name of the tier. */
  name: Scalars['String']['output'];
  /** The sponsors listing that this tier belongs to. */
  sponsorsListing: gh_SponsorsListing;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type gh_SponsorsTierAdminInfo = {
  /**
   * Indicates whether this tier is still a work in progress by the sponsorable and
   * not yet published to the associated GitHub Sponsors profile. Draft tiers
   * cannot be used for new sponsorships and will not be in use on existing
   * sponsorships. Draft tiers cannot be seen by anyone but the admins of the
   * GitHub Sponsors profile.
   */
  isDraft: Scalars['Boolean']['output'];
  /**
   * Indicates whether this tier is published to the associated GitHub Sponsors
   * profile. Published tiers are visible to anyone who can see the GitHub Sponsors
   * profile, and are available for use in sponsorships if the GitHub Sponsors
   * profile is publicly visible.
   */
  isPublished: Scalars['Boolean']['output'];
  /**
   * Indicates whether this tier has been retired from the associated GitHub
   * Sponsors profile. Retired tiers are no longer shown on the GitHub Sponsors
   * profile and cannot be chosen for new sponsorships. Existing sponsorships may
   * still use retired tiers if the sponsor selected the tier before it was retired.
   */
  isRetired: Scalars['Boolean']['output'];
  /** The sponsorships using this tier. */
  sponsorships: gh_SponsorshipConnection;
};


/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type gh_SponsorsTierAdminInfosponsorshipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorshipOrder>;
};

/** The connection type for SponsorsTier. */
export type gh_SponsorsTierConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_SponsorsTierEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_SponsorsTier>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_SponsorsTierEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_SponsorsTier>;
};

/** Ordering options for Sponsors tiers connections. */
export type gh_SponsorsTierOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order tiers by. */
  field: gh_SponsorsTierOrderField;
};

/** Properties by which Sponsors tiers connections can be ordered. */
export type gh_SponsorsTierOrderField =
  /** Order tiers by creation time. */
  | 'CREATED_AT'
  /** Order tiers by their monthly price in cents */
  | 'MONTHLY_PRICE_IN_CENTS';

/** A sponsorship relationship between a sponsor and a maintainer */
export type gh_Sponsorship = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the Sponsorship object */
  id: Scalars['ID']['output'];
  /**
   * Whether the sponsorship is active. False implies the sponsor is a past sponsor
   * of the maintainer, while true implies they are a current sponsor.
   */
  isActive: Scalars['Boolean']['output'];
  /** Whether this sponsorship represents a one-time payment versus a recurring sponsorship. */
  isOneTimePayment: Scalars['Boolean']['output'];
  /**
   * Whether the sponsor has chosen to receive sponsorship update emails sent from
   * the sponsorable. Only returns a non-null value when the viewer has permission to know this.
   */
  isSponsorOptedIntoEmail?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The entity that is being sponsored
   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.
   */
  maintainer: gh_User;
  /** The platform that was most recently used to pay for the sponsorship. */
  paymentSource?: Maybe<gh_SponsorshipPaymentSource>;
  /** The privacy level for this sponsorship. */
  privacyLevel: gh_SponsorshipPrivacy;
  /**
   * The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.
   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.
   */
  sponsor?: Maybe<gh_User>;
  /** The user or organization that is sponsoring, if you have permission to view them. */
  sponsorEntity?: Maybe<gh_Sponsor>;
  /** The entity that is being sponsored */
  sponsorable: gh_Sponsorable;
  /** The associated sponsorship tier */
  tier?: Maybe<gh_SponsorsTier>;
  /** Identifies the date and time when the current tier was chosen for this sponsorship. */
  tierSelectedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** The connection type for Sponsorship. */
export type gh_SponsorshipConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_SponsorshipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Sponsorship>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
  /**
   * The total amount in cents of all recurring sponsorships in the connection
   * whose amount you can view. Does not include one-time sponsorships.
   */
  totalRecurringMonthlyPriceInCents: Scalars['Int']['output'];
  /**
   * The total amount in USD of all recurring sponsorships in the connection whose
   * amount you can view. Does not include one-time sponsorships.
   */
  totalRecurringMonthlyPriceInDollars: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_SponsorshipEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Sponsorship>;
};

/** An update sent to sponsors of a user or organization on GitHub Sponsors. */
export type gh_SponsorshipNewsletter = gh_Node & {
  /** The author of the newsletter. */
  author?: Maybe<gh_User>;
  /** The contents of the newsletter, the message the sponsorable wanted to give. */
  body: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the SponsorshipNewsletter object */
  id: Scalars['ID']['output'];
  /** Indicates if the newsletter has been made available to sponsors. */
  isPublished: Scalars['Boolean']['output'];
  /** The user or organization this newsletter is from. */
  sponsorable: gh_Sponsorable;
  /** The subject of the newsletter, what it's about. */
  subject: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for SponsorshipNewsletter. */
export type gh_SponsorshipNewsletterConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_SponsorshipNewsletterEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_SponsorshipNewsletter>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_SponsorshipNewsletterEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_SponsorshipNewsletter>;
};

/** Ordering options for sponsorship newsletter connections. */
export type gh_SponsorshipNewsletterOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order sponsorship newsletters by. */
  field: gh_SponsorshipNewsletterOrderField;
};

/** Properties by which sponsorship update connections can be ordered. */
export type gh_SponsorshipNewsletterOrderField =
  /** Order sponsorship newsletters by when they were created. */
  | 'CREATED_AT';

/** Ordering options for sponsorship connections. */
export type gh_SponsorshipOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order sponsorship by. */
  field: gh_SponsorshipOrderField;
};

/** Properties by which sponsorship connections can be ordered. */
export type gh_SponsorshipOrderField =
  /** Order sponsorship by creation time. */
  | 'CREATED_AT';

/** How payment was made for funding a GitHub Sponsors sponsorship. */
export type gh_SponsorshipPaymentSource =
  /** Payment was made through GitHub. */
  | 'GITHUB'
  /** Payment was made through Patreon. */
  | 'PATREON';

/** The privacy of a sponsorship */
export type gh_SponsorshipPrivacy =
  /** Private */
  | 'PRIVATE'
  /** Public */
  | 'PUBLIC';

/** The possible default commit messages for squash merges. */
export type gh_SquashMergeCommitMessage =
  /** Default to a blank commit message. */
  | 'BLANK'
  /** Default to the branch's commit messages. */
  | 'COMMIT_MESSAGES'
  /** Default to the pull request's body. */
  | 'PR_BODY';

/** The possible default commit titles for squash merges. */
export type gh_SquashMergeCommitTitle =
  /** Default to the commit's title (if only one commit) or the pull request's title (when more than one commit). */
  | 'COMMIT_OR_PR_TITLE'
  /** Default to the pull request's title. */
  | 'PR_TITLE';

/** Represents an SSH signature on a Commit or Tag. */
export type gh_SshSignature = gh_GitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean']['output'];
  /** Hex-encoded fingerprint of the key that signed this object. */
  keyFingerprint?: Maybe<Scalars['String']['output']>;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<gh_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: gh_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** Ways in which star connections can be ordered. */
export type gh_StarOrder = {
  /** The direction in which to order nodes. */
  direction: gh_OrderDirection;
  /** The field in which to order nodes by. */
  field: gh_StarOrderField;
};

/** Properties by which star connections can be ordered. */
export type gh_StarOrderField =
  /** Allows ordering a list of stars by when they were created. */
  | 'STARRED_AT';

/** The connection type for User. */
export type gh_StargazerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_StargazerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_User>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a user that's starred a repository. */
export type gh_StargazerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  node: gh_User;
  /** Identifies when the item was starred. */
  starredAt: Scalars['DateTime']['output'];
};

/** Things that can be starred. */
export type gh_Starrable = {
  /** The Node ID of the Starrable object */
  id: Scalars['ID']['output'];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int']['output'];
  /** A list of users who have starred this starrable. */
  stargazers: gh_StargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean']['output'];
};


/** Things that can be starred. */
export type gh_StarrablestargazersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_StarOrder>;
};

/** The connection type for Repository. */
export type gh_StarredRepositoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_StarredRepositoryEdge>>>;
  /** Is the list of stars for this user truncated? This is true for users that have many stars. */
  isOverLimit: Scalars['Boolean']['output'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a starred repository. */
export type gh_StarredRepositoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  node: gh_Repository;
  /** Identifies when the item was starred. */
  starredAt: Scalars['DateTime']['output'];
};

/** Autogenerated input type of StartOrganizationMigration */
export type gh_StartOrganizationMigrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The migration source access token. */
  sourceAccessToken: Scalars['String']['input'];
  /** The URL of the organization to migrate. */
  sourceOrgUrl: Scalars['gh_URI']['input'];
  /** The ID of the enterprise the target organization belongs to. */
  targetEnterpriseId: Scalars['ID']['input'];
  /** The name of the target organization. */
  targetOrgName: Scalars['String']['input'];
};

/** Autogenerated return type of StartOrganizationMigration */
export type gh_StartOrganizationMigrationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new organization migration. */
  orgMigration?: Maybe<gh_OrganizationMigration>;
};

/** Autogenerated input type of StartRepositoryMigration */
export type gh_StartRepositoryMigrationInput = {
  /** The migration source access token. */
  accessToken?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether to continue the migration on error. Defaults to `true`. */
  continueOnError?: InputMaybe<Scalars['Boolean']['input']>;
  /** The signed URL to access the user-uploaded git archive. */
  gitArchiveUrl?: InputMaybe<Scalars['String']['input']>;
  /** The GitHub personal access token of the user importing to the target repository. */
  githubPat?: InputMaybe<Scalars['String']['input']>;
  /** Whether to lock the source repository. */
  lockSource?: InputMaybe<Scalars['Boolean']['input']>;
  /** The signed URL to access the user-uploaded metadata archive. */
  metadataArchiveUrl?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that will own the imported repository. */
  ownerId: Scalars['ID']['input'];
  /** The name of the imported repository. */
  repositoryName: Scalars['String']['input'];
  /** Whether to skip migrating releases for the repository. */
  skipReleases?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the migration source. */
  sourceId: Scalars['ID']['input'];
  /** The URL of the source repository. */
  sourceRepositoryUrl?: InputMaybe<Scalars['gh_URI']['input']>;
  /** The visibility of the imported repository. */
  targetRepoVisibility?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of StartRepositoryMigration */
export type gh_StartRepositoryMigrationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new repository migration. */
  repositoryMigration?: Maybe<gh_RepositoryMigration>;
};

/** Represents a commit status. */
export type gh_Status = gh_Node & {
  /** A list of status contexts and check runs for this commit. */
  combinedContexts: gh_StatusCheckRollupContextConnection;
  /** The commit this status is attached to. */
  commit?: Maybe<gh_Commit>;
  /** Looks up an individual status context by context name. */
  context?: Maybe<gh_StatusContext>;
  /** The individual status contexts for this commit. */
  contexts: Array<gh_StatusContext>;
  /** The Node ID of the Status object */
  id: Scalars['ID']['output'];
  /** The combined commit status. */
  state: gh_StatusState;
};


/** Represents a commit status. */
export type gh_StatuscombinedContextsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a commit status. */
export type gh_StatuscontextArgs = {
  name: Scalars['String']['input'];
};

/** Required status check */
export type gh_StatusCheckConfiguration = {
  /** The status check context name that must be present on the commit. */
  context: Scalars['String']['output'];
  /** The optional integration ID that this status check must originate from. */
  integrationId?: Maybe<Scalars['Int']['output']>;
};

/** Required status check */
export type gh_StatusCheckConfigurationInput = {
  /** The status check context name that must be present on the commit. */
  context: Scalars['String']['input'];
  /** The optional integration ID that this status check must originate from. */
  integrationId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents the rollup for both the check runs and status for a commit. */
export type gh_StatusCheckRollup = gh_Node & {
  /** The commit the status and check runs are attached to. */
  commit?: Maybe<gh_Commit>;
  /** A list of status contexts and check runs for this commit. */
  contexts: gh_StatusCheckRollupContextConnection;
  /** The Node ID of the StatusCheckRollup object */
  id: Scalars['ID']['output'];
  /** The combined status for the commit. */
  state: gh_StatusState;
};


/** Represents the rollup for both the check runs and status for a commit. */
export type gh_StatusCheckRollupcontextsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Types that can be inside a StatusCheckRollup context. */
export type gh_StatusCheckRollupContext = gh_CheckRun | gh_StatusContext;

/** The connection type for StatusCheckRollupContext. */
export type gh_StatusCheckRollupContextConnection = {
  /** The number of check runs in this rollup. */
  checkRunCount: Scalars['Int']['output'];
  /** Counts of check runs by state. */
  checkRunCountsByState?: Maybe<Array<gh_CheckRunStateCount>>;
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_StatusCheckRollupContextEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_StatusCheckRollupContext>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** The number of status contexts in this rollup. */
  statusContextCount: Scalars['Int']['output'];
  /** Counts of status contexts by state. */
  statusContextCountsByState?: Maybe<Array<gh_StatusContextStateCount>>;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_StatusCheckRollupContextEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_StatusCheckRollupContext>;
};

/** Represents an individual commit status context */
export type gh_StatusContext = gh_Node & gh_RequirableByPullRequest & {
  /** The avatar of the OAuth application or the user that created the status */
  avatarUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** This commit this status context is attached to. */
  commit?: Maybe<gh_Commit>;
  /** The name of this status context. */
  context: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The actor who created this status context. */
  creator?: Maybe<gh_Actor>;
  /** The description for this status context. */
  description?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the StatusContext object */
  id: Scalars['ID']['output'];
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars['Boolean']['output'];
  /** The state of this status context. */
  state: gh_StatusState;
  /** The URL for this status context. */
  targetUrl?: Maybe<Scalars['gh_URI']['output']>;
};


/** Represents an individual commit status context */
export type gh_StatusContextavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an individual commit status context */
export type gh_StatusContextisRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents a count of the state of a status context. */
export type gh_StatusContextStateCount = {
  /** The number of statuses with this state. */
  count: Scalars['Int']['output'];
  /** The state of a status context. */
  state: gh_StatusState;
};

/** The possible commit status states. */
export type gh_StatusState =
  /** Status is errored. */
  | 'ERROR'
  /** Status is expected. */
  | 'EXPECTED'
  /** Status is failing. */
  | 'FAILURE'
  /** Status is pending. */
  | 'PENDING'
  /** Status is successful. */
  | 'SUCCESS';

/** A Stripe Connect account for receiving sponsorship funds from GitHub Sponsors. */
export type gh_StripeConnectAccount = {
  /** The account number used to identify this Stripe Connect account. */
  accountId: Scalars['String']['output'];
  /**
   * The name of the country or region of an external account, such as a bank
   * account, tied to the Stripe Connect account. Will only return a value when
   * queried by the maintainer of the associated GitHub Sponsors profile
   * themselves, or by an admin of the sponsorable organization.
   */
  billingCountryOrRegion?: Maybe<Scalars['String']['output']>;
  /**
   * The name of the country or region of the Stripe Connect account. Will only
   * return a value when queried by the maintainer of the associated GitHub
   * Sponsors profile themselves, or by an admin of the sponsorable organization.
   */
  countryOrRegion?: Maybe<Scalars['String']['output']>;
  /** Whether this Stripe Connect account is currently in use for the associated GitHub Sponsors profile. */
  isActive: Scalars['Boolean']['output'];
  /** The GitHub Sponsors profile associated with this Stripe Connect account. */
  sponsorsListing: gh_SponsorsListing;
  /** The URL to access this Stripe Connect account on Stripe's website. */
  stripeDashboardUrl: Scalars['gh_URI']['output'];
};

/** Autogenerated input type of SubmitPullRequestReview */
export type gh_SubmitPullRequestReviewInput = {
  /** The text field to set on the Pull Request Review. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The event to send to the Pull Request Review. */
  event: gh_PullRequestReviewEvent;
  /** The Pull Request ID to submit any pending reviews. */
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  /** The Pull Request Review ID to submit. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of SubmitPullRequestReview */
export type gh_SubmitPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The submitted pull request review. */
  pullRequestReview?: Maybe<gh_PullRequestReview>;
};

/** A pointer to a repository at a specific revision embedded inside another repository. */
export type gh_Submodule = {
  /** The branch of the upstream submodule for tracking updates */
  branch?: Maybe<Scalars['String']['output']>;
  /** The git URL of the submodule repository */
  gitUrl: Scalars['gh_URI']['output'];
  /** The name of the submodule in .gitmodules */
  name: Scalars['String']['output'];
  /** The name of the submodule in .gitmodules (Base64-encoded) */
  nameRaw: Scalars['gh_Base64String']['output'];
  /** The path in the superproject that this submodule is located in */
  path: Scalars['String']['output'];
  /** The path in the superproject that this submodule is located in (Base64-encoded) */
  pathRaw: Scalars['gh_Base64String']['output'];
  /** The commit revision of the subproject repository being tracked by the submodule */
  subprojectCommitOid?: Maybe<Scalars['gh_GitObjectID']['output']>;
};

/** The connection type for Submodule. */
export type gh_SubmoduleConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_SubmoduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Submodule>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_SubmoduleEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Submodule>;
};

/** Entities that can be subscribed to for web and email notifications. */
export type gh_Subscribable = {
  /** The Node ID of the Subscribable object */
  id: Scalars['ID']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<gh_SubscriptionState>;
};

/** Entities that can be subscribed to for web and email notifications. */
export type gh_SubscribableThread = {
  /** The Node ID of the SubscribableThread object */
  id: Scalars['ID']['output'];
  /** Identifies the viewer's thread subscription form action. */
  viewerThreadSubscriptionFormAction?: Maybe<gh_ThreadSubscriptionFormAction>;
  /** Identifies the viewer's thread subscription status. */
  viewerThreadSubscriptionStatus?: Maybe<gh_ThreadSubscriptionState>;
};

/** Represents a 'subscribed' event on a given `Subscribable`. */
export type gh_SubscribedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the SubscribedEvent object */
  id: Scalars['ID']['output'];
  /** Object referenced by event. */
  subscribable: gh_Subscribable;
};

/** The possible states of a subscription. */
export type gh_SubscriptionState =
  /** The User is never notified. */
  | 'IGNORED'
  /** The User is notified of all conversations. */
  | 'SUBSCRIBED'
  /** The User is only notified when participating or @mentioned. */
  | 'UNSUBSCRIBED';

/** A suggestion to review a pull request based on a user's commit history and review comments. */
export type gh_SuggestedReviewer = {
  /** Is this suggestion based on past commits? */
  isAuthor: Scalars['Boolean']['output'];
  /** Is this suggestion based on past review comments? */
  isCommenter: Scalars['Boolean']['output'];
  /** Identifies the user suggested to review the pull request. */
  reviewer: gh_User;
};

/** Represents a Git tag. */
export type gh_Tag = gh_GitObject & gh_Node & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String']['output'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['gh_URI']['output'];
  /** The Node ID of the Tag object */
  id: Scalars['ID']['output'];
  /** The Git tag message. */
  message?: Maybe<Scalars['String']['output']>;
  /** The Git tag name. */
  name: Scalars['String']['output'];
  /** The Git object ID */
  oid: Scalars['gh_GitObjectID']['output'];
  /** The Repository the Git object belongs to */
  repository: gh_Repository;
  /** Details about the tag author. */
  tagger?: Maybe<gh_GitActor>;
  /** The Git object the tag points to. */
  target: gh_GitObject;
};

/** Parameters to be used for the tag_name_pattern rule */
export type gh_TagNamePatternParameters = {
  /** How this rule will appear to users. */
  name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  operator: Scalars['String']['output'];
  /** The pattern to match with. */
  pattern: Scalars['String']['output'];
};

/** Parameters to be used for the tag_name_pattern rule */
export type gh_TagNamePatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/** A team of users in an organization. */
export type gh_Team = gh_MemberStatusable & gh_Node & gh_Subscribable & {
  /** A list of teams that are ancestors of this team. */
  ancestors: gh_TeamConnection;
  /** A URL pointing to the team's avatar. */
  avatarUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** List of child teams belonging to this team */
  childTeams: gh_TeamConnection;
  /** The slug corresponding to the organization and team. */
  combinedSlug: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The description of the team. */
  description?: Maybe<Scalars['String']['output']>;
  /** Find a team discussion by its number. */
  discussion?: Maybe<gh_TeamDiscussion>;
  /** A list of team discussions. */
  discussions: gh_TeamDiscussionConnection;
  /** The HTTP path for team discussions */
  discussionsResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for team discussions */
  discussionsUrl: Scalars['gh_URI']['output'];
  /** The HTTP path for editing this team */
  editTeamResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for editing this team */
  editTeamUrl: Scalars['gh_URI']['output'];
  /** The Node ID of the Team object */
  id: Scalars['ID']['output'];
  /** A list of pending invitations for users to this team */
  invitations?: Maybe<gh_OrganizationInvitationConnection>;
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: gh_UserStatusConnection;
  /** A list of users who are members of this team. */
  members: gh_TeamMemberConnection;
  /** The HTTP path for the team' members */
  membersResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for the team' members */
  membersUrl: Scalars['gh_URI']['output'];
  /** The name of the team. */
  name: Scalars['String']['output'];
  /** The HTTP path creating a new team */
  newTeamResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL creating a new team */
  newTeamUrl: Scalars['gh_URI']['output'];
  /** The notification setting that the team has set. */
  notificationSetting: gh_TeamNotificationSetting;
  /** The organization that owns this team. */
  organization: gh_Organization;
  /** The parent team of the team. */
  parentTeam?: Maybe<gh_Team>;
  /** The level of privacy the team has. */
  privacy: gh_TeamPrivacy;
  /** Finds and returns the project according to the provided project number. */
  projectV2?: Maybe<gh_ProjectV2>;
  /** List of projects this team has collaborator access to. */
  projectsV2: gh_ProjectV2Connection;
  /** A list of repositories this team has access to. */
  repositories: gh_TeamRepositoryConnection;
  /** The HTTP path for this team's repositories */
  repositoriesResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this team's repositories */
  repositoriesUrl: Scalars['gh_URI']['output'];
  /** The HTTP path for this team */
  resourcePath: Scalars['gh_URI']['output'];
  /** What algorithm is used for review assignment for this team */
  reviewRequestDelegationAlgorithm?: Maybe<gh_TeamReviewAssignmentAlgorithm>;
  /** True if review assignment is enabled for this team */
  reviewRequestDelegationEnabled: Scalars['Boolean']['output'];
  /** How many team members are required for review assignment for this team */
  reviewRequestDelegationMemberCount?: Maybe<Scalars['Int']['output']>;
  /** When assigning team members via delegation, whether the entire team should be notified as well. */
  reviewRequestDelegationNotifyTeam: Scalars['Boolean']['output'];
  /** The slug corresponding to the team. */
  slug: Scalars['String']['output'];
  /** The HTTP path for this team's teams */
  teamsResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this team's teams */
  teamsUrl: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this team */
  url: Scalars['gh_URI']['output'];
  /** Team is adminable by the viewer. */
  viewerCanAdminister: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<gh_SubscriptionState>;
};


/** A team of users in an organization. */
export type gh_TeamancestorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A team of users in an organization. */
export type gh_TeamavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** A team of users in an organization. */
export type gh_TeamchildTeamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  immediateOnly?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_TeamOrder>;
  userLogins?: InputMaybe<Array<Scalars['String']['input']>>;
};


/** A team of users in an organization. */
export type gh_TeamdiscussionArgs = {
  number: Scalars['Int']['input'];
};


/** A team of users in an organization. */
export type gh_TeamdiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  isPinned?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_TeamDiscussionOrder>;
};


/** A team of users in an organization. */
export type gh_TeaminvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A team of users in an organization. */
export type gh_TeammemberStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_UserStatusOrder>;
};


/** A team of users in an organization. */
export type gh_TeammembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  membership?: InputMaybe<gh_TeamMembershipType>;
  orderBy?: InputMaybe<gh_TeamMemberOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<gh_TeamMemberRole>;
};


/** A team of users in an organization. */
export type gh_TeamprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** A team of users in an organization. */
export type gh_TeamprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<gh_ProjectV2Filters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A team of users in an organization. */
export type gh_TeamrepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_TeamRepositoryOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
};

/** Audit log entry for a team.add_member event. */
export type gh_TeamAddMemberAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the TeamAddMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The team associated with the action */
  team?: Maybe<gh_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a team.add_repository event. */
export type gh_TeamAddRepositoryAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & gh_TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the TeamAddRepositoryAuditEntry object */
  id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The team associated with the action */
  team?: Maybe<gh_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Metadata for an audit entry with action team.* */
export type gh_TeamAuditEntryData = {
  /** The team associated with the action */
  team?: Maybe<gh_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a team.change_parent_team event. */
export type gh_TeamChangeParentTeamAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the TeamChangeParentTeamAuditEntry object */
  id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The new parent team. */
  parentTeam?: Maybe<gh_Team>;
  /** The name of the new parent team */
  parentTeamName?: Maybe<Scalars['String']['output']>;
  /** The name of the former parent team */
  parentTeamNameWas?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the parent team */
  parentTeamResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the parent team */
  parentTeamUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The former parent team. */
  parentTeamWas?: Maybe<gh_Team>;
  /** The HTTP path for the previous parent team */
  parentTeamWasResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the previous parent team */
  parentTeamWasUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The team associated with the action */
  team?: Maybe<gh_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** The connection type for Team. */
export type gh_TeamConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_TeamEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Team>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A team discussion. */
export type gh_TeamDiscussion = gh_Comment & gh_Deletable & gh_Node & gh_Reactable & gh_Subscribable & gh_UniformResourceLocatable & gh_Updatable & gh_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<gh_Actor>;
  /**
   * Author's association with the discussion's team.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  authorAssociation: gh_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /**
   * Identifies the discussion body hash.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  bodyVersion: Scalars['String']['output'];
  /**
   * A list of comments on this discussion.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  comments: gh_TeamDiscussionCommentConnection;
  /**
   * The HTTP path for discussion comments
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  commentsResourcePath: Scalars['gh_URI']['output'];
  /**
   * The HTTP URL for discussion comments
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  commentsUrl: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  editor?: Maybe<gh_Actor>;
  /** The Node ID of the TeamDiscussion object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /**
   * Whether or not the discussion is pinned.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  isPinned: Scalars['Boolean']['output'];
  /**
   * Whether or not the discussion is only visible to team members and organization owners.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  isPrivate: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Identifies the discussion within its team.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  number: Scalars['Int']['output'];
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: gh_ReactionConnection;
  /**
   * The HTTP path for this discussion
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  resourcePath: Scalars['gh_URI']['output'];
  /**
   * The team that defines the context of this discussion.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  team: gh_Team;
  /**
   * The title of the discussion
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /**
   * The HTTP URL for this discussion
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  url: Scalars['gh_URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<gh_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /**
   * Whether or not the current viewer can pin this discussion.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  viewerCanPin: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<gh_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<gh_SubscriptionState>;
};


/** A team discussion. */
export type gh_TeamDiscussioncommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fromComment?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_TeamDiscussionCommentOrder>;
};


/** A team discussion. */
export type gh_TeamDiscussionreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<gh_ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ReactionOrder>;
};


/** A team discussion. */
export type gh_TeamDiscussionuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A comment on a team discussion. */
export type gh_TeamDiscussionComment = gh_Comment & gh_Deletable & gh_Node & gh_Reactable & gh_UniformResourceLocatable & gh_Updatable & gh_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<gh_Actor>;
  /**
   * Author's association with the comment's team.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  authorAssociation: gh_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['gh_HTML']['output'];
  /** The body rendered to text. */
  bodyText: Scalars['String']['output'];
  /**
   * The current version of the body content.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  bodyVersion: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /**
   * The discussion this comment is about.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  discussion: gh_TeamDiscussion;
  /** The actor who edited the comment. */
  editor?: Maybe<gh_Actor>;
  /** The Node ID of the TeamDiscussionComment object */
  id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Identifies the comment number.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  number: Scalars['Int']['output'];
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<gh_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: gh_ReactionConnection;
  /**
   * The HTTP path for this comment
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  resourcePath: Scalars['gh_URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /**
   * The HTTP URL for this comment
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  url: Scalars['gh_URI']['output'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<gh_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<gh_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean']['output'];
};


/** A comment on a team discussion. */
export type gh_TeamDiscussionCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<gh_ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ReactionOrder>;
};


/** A comment on a team discussion. */
export type gh_TeamDiscussionCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for TeamDiscussionComment. */
export type gh_TeamDiscussionCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_TeamDiscussionCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_TeamDiscussionComment>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_TeamDiscussionCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_TeamDiscussionComment>;
};

/** Ways in which team discussion comment connections can be ordered. */
export type gh_TeamDiscussionCommentOrder = {
  /** The direction in which to order nodes. */
  direction: gh_OrderDirection;
  /** The field by which to order nodes. */
  field: gh_TeamDiscussionCommentOrderField;
};

/** Properties by which team discussion comment connections can be ordered. */
export type gh_TeamDiscussionCommentOrderField =
  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */
  | 'NUMBER';

/** The connection type for TeamDiscussion. */
export type gh_TeamDiscussionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_TeamDiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_TeamDiscussion>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_TeamDiscussionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_TeamDiscussion>;
};

/** Ways in which team discussion connections can be ordered. */
export type gh_TeamDiscussionOrder = {
  /** The direction in which to order nodes. */
  direction: gh_OrderDirection;
  /** The field by which to order nodes. */
  field: gh_TeamDiscussionOrderField;
};

/** Properties by which team discussion connections can be ordered. */
export type gh_TeamDiscussionOrderField =
  /** Allows chronological ordering of team discussions. */
  | 'CREATED_AT';

/** An edge in a connection. */
export type gh_TeamEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_Team>;
};

/** The connection type for User. */
export type gh_TeamMemberConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_TeamMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_User>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a user who is a member of a team. */
export type gh_TeamMemberEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The HTTP path to the organization's member access page. */
  memberAccessResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL to the organization's member access page. */
  memberAccessUrl: Scalars['gh_URI']['output'];
  node: gh_User;
  /** The role the member has on the team. */
  role: gh_TeamMemberRole;
};

/** Ordering options for team member connections */
export type gh_TeamMemberOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order team members by. */
  field: gh_TeamMemberOrderField;
};

/** Properties by which team member connections can be ordered. */
export type gh_TeamMemberOrderField =
  /** Order team members by creation time */
  | 'CREATED_AT'
  /** Order team members by login */
  | 'LOGIN';

/** The possible team member roles; either 'maintainer' or 'member'. */
export type gh_TeamMemberRole =
  /** A team maintainer has permission to add and remove team members. */
  | 'MAINTAINER'
  /** A team member has no administrative permissions on the team. */
  | 'MEMBER';

/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
export type gh_TeamMembershipType =
  /** Includes immediate and child team members for the team. */
  | 'ALL'
  /** Includes only child team members for the team. */
  | 'CHILD_TEAM'
  /** Includes only immediate members of the team. */
  | 'IMMEDIATE';

/** The possible team notification values. */
export type gh_TeamNotificationSetting =
  /** No one will receive notifications. */
  | 'NOTIFICATIONS_DISABLED'
  /** Everyone will receive notifications when the team is @mentioned. */
  | 'NOTIFICATIONS_ENABLED';

/** Ways in which team connections can be ordered. */
export type gh_TeamOrder = {
  /** The direction in which to order nodes. */
  direction: gh_OrderDirection;
  /** The field in which to order nodes by. */
  field: gh_TeamOrderField;
};

/** Properties by which team connections can be ordered. */
export type gh_TeamOrderField =
  /** Allows ordering a list of teams by name. */
  | 'NAME';

/** The possible team privacy values. */
export type gh_TeamPrivacy =
  /** A secret team can only be seen by its members. */
  | 'SECRET'
  /** A visible team can be seen and @mentioned by every member of the organization. */
  | 'VISIBLE';

/** Audit log entry for a team.remove_member event. */
export type gh_TeamRemoveMemberAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the TeamRemoveMemberAuditEntry object */
  id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The team associated with the action */
  team?: Maybe<gh_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** Audit log entry for a team.remove_repository event. */
export type gh_TeamRemoveRepositoryAuditEntry = gh_AuditEntry & gh_Node & gh_OrganizationAuditEntryData & gh_RepositoryAuditEntryData & gh_TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String']['output'];
  /** The user who initiated the action */
  actor?: Maybe<gh_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<gh_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The time the action was initiated */
  createdAt: Scalars['gh_PreciseDateTime']['output'];
  /** The Node ID of the TeamRemoveRepositoryAuditEntry object */
  id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<gh_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<gh_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The repository associated with the action */
  repository?: Maybe<gh_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The team associated with the action */
  team?: Maybe<gh_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['gh_URI']['output']>;
  /** The user affected by the action */
  user?: Maybe<gh_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['gh_URI']['output']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['gh_URI']['output']>;
};

/** The connection type for Repository. */
export type gh_TeamRepositoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_TeamRepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Represents a team repository. */
export type gh_TeamRepositoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  node: gh_Repository;
  /** The permission level the team has on the repository */
  permission: gh_RepositoryPermission;
};

/** Ordering options for team repository connections */
export type gh_TeamRepositoryOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order repositories by. */
  field: gh_TeamRepositoryOrderField;
};

/** Properties by which team repository connections can be ordered. */
export type gh_TeamRepositoryOrderField =
  /** Order repositories by creation time */
  | 'CREATED_AT'
  /** Order repositories by name */
  | 'NAME'
  /** Order repositories by permission */
  | 'PERMISSION'
  /** Order repositories by push time */
  | 'PUSHED_AT'
  /** Order repositories by number of stargazers */
  | 'STARGAZERS'
  /** Order repositories by update time */
  | 'UPDATED_AT';

/** The possible team review assignment algorithms */
export type gh_TeamReviewAssignmentAlgorithm =
  /** Balance review load across the entire team */
  | 'LOAD_BALANCE'
  /** Alternate reviews between each team member */
  | 'ROUND_ROBIN';

/** The role of a user on a team. */
export type gh_TeamRole =
  /** User has admin rights on the team. */
  | 'ADMIN'
  /** User is a member of the team. */
  | 'MEMBER';

/** A text match within a search result. */
export type gh_TextMatch = {
  /** The specific text fragment within the property matched on. */
  fragment: Scalars['String']['output'];
  /** Highlights within the matched fragment. */
  highlights: Array<gh_TextMatchHighlight>;
  /** The property matched on. */
  property: Scalars['String']['output'];
};

/** Represents a single highlight in a search result match. */
export type gh_TextMatchHighlight = {
  /** The indice in the fragment where the matched text begins. */
  beginIndice: Scalars['Int']['output'];
  /** The indice in the fragment where the matched text ends. */
  endIndice: Scalars['Int']['output'];
  /** The text matched. */
  text: Scalars['String']['output'];
};

/** The possible states of a thread subscription form action */
export type gh_ThreadSubscriptionFormAction =
  /** The User cannot subscribe or unsubscribe to the thread */
  | 'NONE'
  /** The User can subscribe to the thread */
  | 'SUBSCRIBE'
  /** The User can unsubscribe to the thread */
  | 'UNSUBSCRIBE';

/** The possible states of a subscription. */
export type gh_ThreadSubscriptionState =
  /** The subscription status is currently disabled. */
  | 'DISABLED'
  /** The User is never notified because they are ignoring the list */
  | 'IGNORING_LIST'
  /** The User is never notified because they are ignoring the thread */
  | 'IGNORING_THREAD'
  /** The User is not recieving notifications from this thread */
  | 'NONE'
  /** The User is notified becuase they are watching the list */
  | 'SUBSCRIBED_TO_LIST'
  /** The User is notified because they are subscribed to the thread */
  | 'SUBSCRIBED_TO_THREAD'
  /** The User is notified because they chose custom settings for this thread. */
  | 'SUBSCRIBED_TO_THREAD_EVENTS'
  /** The User is notified because they chose custom settings for this thread. */
  | 'SUBSCRIBED_TO_THREAD_TYPE'
  /** The subscription status is currently unavailable. */
  | 'UNAVAILABLE';

/** A topic aggregates entities that are related to a subject. */
export type gh_Topic = gh_Node & gh_Starrable & {
  /** The Node ID of the Topic object */
  id: Scalars['ID']['output'];
  /** The topic's name. */
  name: Scalars['String']['output'];
  /**
   * A list of related topics, including aliases of this topic, sorted with the most relevant
   * first. Returns up to 10 Topics.
   */
  relatedTopics: Array<gh_Topic>;
  /** A list of repositories. */
  repositories: gh_RepositoryConnection;
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int']['output'];
  /** A list of users who have starred this starrable. */
  stargazers: gh_StargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean']['output'];
};


/** A topic aggregates entities that are related to a subject. */
export type gh_TopicrelatedTopicsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** A topic aggregates entities that are related to a subject. */
export type gh_TopicrepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<gh_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<gh_RepositoryAffiliation>>>;
  privacy?: InputMaybe<gh_RepositoryPrivacy>;
  sponsorableOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A topic aggregates entities that are related to a subject. */
export type gh_TopicstargazersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_StarOrder>;
};

/** Metadata for an audit entry with a topic. */
export type gh_TopicAuditEntryData = {
  /** The name of the topic added to the repository */
  topic?: Maybe<gh_Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']['output']>;
};

/** Reason that the suggested topic is declined. */
export type gh_TopicSuggestionDeclineReason =
  /** The suggested topic is not relevant to the repository. */
  | 'NOT_RELEVANT'
  /** The viewer does not like the suggested topic. */
  | 'PERSONAL_PREFERENCE'
  /** The suggested topic is too general for the repository. */
  | 'TOO_GENERAL'
  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */
  | 'TOO_SPECIFIC';

/** The possible states of a tracked issue. */
export type gh_TrackedIssueStates =
  /** The tracked issue is closed */
  | 'CLOSED'
  /** The tracked issue is open */
  | 'OPEN';

/** Autogenerated input type of TransferEnterpriseOrganization */
export type gh_TransferEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise where the organization should be transferred. */
  destinationEnterpriseId: Scalars['ID']['input'];
  /** The ID of the organization to transfer. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of TransferEnterpriseOrganization */
export type gh_TransferEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organization for which a transfer was initiated. */
  organization?: Maybe<gh_Organization>;
};

/** Autogenerated input type of TransferIssue */
export type gh_TransferIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether to create labels if they don't exist in the target repository (matched by name) */
  createLabelsIfMissing?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node ID of the issue to be transferred */
  issueId: Scalars['ID']['input'];
  /** The Node ID of the repository the issue should be transferred to */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of TransferIssue */
export type gh_TransferIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was transferred */
  issue?: Maybe<gh_Issue>;
};

/** Represents a 'transferred' event on a given issue or pull request. */
export type gh_TransferredEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The repository this came from */
  fromRepository?: Maybe<gh_Repository>;
  /** The Node ID of the TransferredEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the issue associated with the event. */
  issue: gh_Issue;
};

/** Represents a Git tree. */
export type gh_Tree = gh_GitObject & gh_Node & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String']['output'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['gh_URI']['output'];
  /** A list of tree entries. */
  entries?: Maybe<Array<gh_TreeEntry>>;
  /** The Node ID of the Tree object */
  id: Scalars['ID']['output'];
  /** The Git object ID */
  oid: Scalars['gh_GitObjectID']['output'];
  /** The Repository the Git object belongs to */
  repository: gh_Repository;
};

/** Represents a Git tree entry. */
export type gh_TreeEntry = {
  /** The extension of the file */
  extension?: Maybe<Scalars['String']['output']>;
  /** Whether or not this tree entry is generated */
  isGenerated: Scalars['Boolean']['output'];
  /** The programming language this file is written in. */
  language?: Maybe<gh_Language>;
  /** Number of lines in the file. */
  lineCount?: Maybe<Scalars['Int']['output']>;
  /** Entry file mode. */
  mode: Scalars['Int']['output'];
  /** Entry file name. */
  name: Scalars['String']['output'];
  /** Entry file name. (Base64-encoded) */
  nameRaw: Scalars['gh_Base64String']['output'];
  /** Entry file object. */
  object?: Maybe<gh_GitObject>;
  /** Entry file Git object ID. */
  oid: Scalars['gh_GitObjectID']['output'];
  /** The full path of the file. */
  path?: Maybe<Scalars['String']['output']>;
  /** The full path of the file. (Base64-encoded) */
  pathRaw?: Maybe<Scalars['gh_Base64String']['output']>;
  /** The Repository the tree entry belongs to */
  repository: gh_Repository;
  /** Entry byte size */
  size: Scalars['Int']['output'];
  /** If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule */
  submodule?: Maybe<gh_Submodule>;
  /** Entry file type. */
  type: Scalars['String']['output'];
};

/** Autogenerated input type of UnarchiveProjectV2Item */
export type gh_UnarchiveProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the ProjectV2Item to unarchive. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project to archive the item from. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnarchiveProjectV2Item */
export type gh_UnarchiveProjectV2ItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item unarchived from the project. */
  item?: Maybe<gh_ProjectV2Item>;
};

/** Autogenerated input type of UnarchiveRepository */
export type gh_UnarchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to unarchive. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnarchiveRepository */
export type gh_UnarchiveRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository that was unarchived. */
  repository?: Maybe<gh_Repository>;
};

/** Represents an 'unassigned' event on any assignable object. */
export type gh_UnassignedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the assignable associated with the event. */
  assignable: gh_Assignable;
  /** Identifies the user or mannequin that was unassigned. */
  assignee?: Maybe<gh_Assignee>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the UnassignedEvent object */
  id: Scalars['ID']['output'];
  /**
   * Identifies the subject (user) who was unassigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  user?: Maybe<gh_User>;
};

/** Autogenerated input type of UnfollowOrganization */
export type gh_UnfollowOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the organization to unfollow. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnfollowOrganization */
export type gh_UnfollowOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organization that was unfollowed. */
  organization?: Maybe<gh_Organization>;
};

/** Autogenerated input type of UnfollowUser */
export type gh_UnfollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the user to unfollow. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnfollowUser */
export type gh_UnfollowUserPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The user that was unfollowed. */
  user?: Maybe<gh_User>;
};

/** Represents a type that can be retrieved by a URL. */
export type gh_UniformResourceLocatable = {
  /** The HTML path to this resource. */
  resourcePath: Scalars['gh_URI']['output'];
  /** The URL to this resource. */
  url: Scalars['gh_URI']['output'];
};

/** Represents an unknown signature on a Commit or Tag. */
export type gh_UnknownSignature = gh_GitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean']['output'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<gh_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: gh_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** Represents an 'unlabeled' event on a given issue or pull request. */
export type gh_UnlabeledEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the UnlabeledEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the label associated with the 'unlabeled' event. */
  label: gh_Label;
  /** Identifies the `Labelable` associated with the event. */
  labelable: gh_Labelable;
};

/** Autogenerated input type of UnlinkProjectV2FromRepository */
export type gh_UnlinkProjectV2FromRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to unlink from the repository. */
  projectId: Scalars['ID']['input'];
  /** The ID of the repository to unlink from the project. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlinkProjectV2FromRepository */
export type gh_UnlinkProjectV2FromRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository the project is no longer linked to. */
  repository?: Maybe<gh_Repository>;
};

/** Autogenerated input type of UnlinkProjectV2FromTeam */
export type gh_UnlinkProjectV2FromTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to unlink from the team. */
  projectId: Scalars['ID']['input'];
  /** The ID of the team to unlink from the project. */
  teamId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlinkProjectV2FromTeam */
export type gh_UnlinkProjectV2FromTeamPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The team the project is unlinked from */
  team?: Maybe<gh_Team>;
};

/** Autogenerated input type of UnlinkRepositoryFromProject */
export type gh_UnlinkRepositoryFromProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project linked to the Repository. */
  projectId: Scalars['ID']['input'];
  /** The ID of the Repository linked to the Project. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlinkRepositoryFromProject */
export type gh_UnlinkRepositoryFromProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The linked Project. */
  project?: Maybe<gh_Project>;
  /** The linked Repository. */
  repository?: Maybe<gh_Repository>;
};

/** Autogenerated input type of UnlockLockable */
export type gh_UnlockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the item to be unlocked. */
  lockableId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlockLockable */
export type gh_UnlockLockablePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was unlocked. */
  unlockedRecord?: Maybe<gh_Lockable>;
};

/** Represents an 'unlocked' event on a given issue or pull request. */
export type gh_UnlockedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the UnlockedEvent object */
  id: Scalars['ID']['output'];
  /** Object that was unlocked. */
  lockable: gh_Lockable;
};

/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */
export type gh_UnmarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion comment to unmark as an answer. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UnmarkDiscussionCommentAsAnswer */
export type gh_UnmarkDiscussionCommentAsAnswerPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that includes the comment. */
  discussion?: Maybe<gh_Discussion>;
};

/** Autogenerated input type of UnmarkFileAsViewed */
export type gh_UnmarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The path of the file to mark as unviewed */
  path: Scalars['String']['input'];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnmarkFileAsViewed */
export type gh_UnmarkFileAsViewedPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Autogenerated input type of UnmarkIssueAsDuplicate */
export type gh_UnmarkIssueAsDuplicateInput = {
  /** ID of the issue or pull request currently considered canonical/authoritative/original. */
  canonicalId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue or pull request currently marked as a duplicate. */
  duplicateId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnmarkIssueAsDuplicate */
export type gh_UnmarkIssueAsDuplicatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue or pull request that was marked as a duplicate. */
  duplicate?: Maybe<gh_IssueOrPullRequest>;
};

/** Autogenerated input type of UnmarkProjectV2AsTemplate */
export type gh_UnmarkProjectV2AsTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to unmark as a template. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnmarkProjectV2AsTemplate */
export type gh_UnmarkProjectV2AsTemplatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The project. */
  projectV2?: Maybe<gh_ProjectV2>;
};

/** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
export type gh_UnmarkedAsDuplicateEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** The authoritative issue or pull request which has been duplicated by another. */
  canonical?: Maybe<gh_IssueOrPullRequest>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The issue or pull request which has been marked as a duplicate of another. */
  duplicate?: Maybe<gh_IssueOrPullRequest>;
  /** The Node ID of the UnmarkedAsDuplicateEvent object */
  id: Scalars['ID']['output'];
  /** Canonical and duplicate belong to different repositories. */
  isCrossRepository: Scalars['Boolean']['output'];
};

/** Autogenerated input type of UnminimizeComment */
export type gh_UnminimizeCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnminimizeComment */
export type gh_UnminimizeCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The comment that was unminimized. */
  unminimizedComment?: Maybe<gh_Minimizable>;
};

/** Autogenerated input type of UnpinIssue */
export type gh_UnpinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the issue to be unpinned */
  issueId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnpinIssue */
export type gh_UnpinIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was unpinned */
  issue?: Maybe<gh_Issue>;
};

/** Represents an 'unpinned' event on a given issue or pull request. */
export type gh_UnpinnedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the UnpinnedEvent object */
  id: Scalars['ID']['output'];
  /** Identifies the issue associated with the event. */
  issue: gh_Issue;
};

/** Autogenerated input type of UnresolveReviewThread */
export type gh_UnresolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the thread to unresolve */
  threadId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnresolveReviewThread */
export type gh_UnresolveReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The thread to resolve. */
  thread?: Maybe<gh_PullRequestReviewThread>;
};

/** Autogenerated input type of UnsubscribeFromNotifications */
export type gh_UnsubscribeFromNotificationsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The NotificationThread IDs of the objects to unsubscribe from. */
  ids: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of UnsubscribeFromNotifications */
export type gh_UnsubscribeFromNotificationsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Represents an 'unsubscribed' event on a given `Subscribable`. */
export type gh_UnsubscribedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the UnsubscribedEvent object */
  id: Scalars['ID']['output'];
  /** Object referenced by event. */
  subscribable: gh_Subscribable;
};

/** Entities that can be updated. */
export type gh_Updatable = {
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean']['output'];
};

/** Comments that can be updated. */
export type gh_UpdatableComment = {
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<gh_CommentCannotUpdateReason>;
};

/** Autogenerated input type of UpdateBranchProtectionRule */
export type gh_UpdateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is branch creation a protected operation. */
  blocksCreations?: InputMaybe<Scalars['Boolean']['input']>;
  /** The global relay id of the branch protection rule to be updated. */
  branchProtectionRuleId: Scalars['ID']['input'];
  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */
  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */
  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Can admins override branch protection. */
  isAdminEnforced?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch?: InputMaybe<Scalars['Boolean']['input']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern?: InputMaybe<Scalars['String']['input']>;
  /** A list of User, Team, or App IDs allowed to push to matching branches. */
  pushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval?: InputMaybe<Scalars['Boolean']['input']>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']['input']>;
  /** The list of required deployment environments */
  requiredDeploymentEnvironments?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The list of required status checks */
  requiredStatusChecks?: InputMaybe<Array<gh_RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are successful deployments required before merging. */
  requiresDeployments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of UpdateBranchProtectionRule */
export type gh_UpdateBranchProtectionRulePayload = {
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<gh_BranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateCheckRun */
export type gh_UpdateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: InputMaybe<Array<gh_CheckRunAction>>;
  /** The node of the check. */
  checkRunId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The time that the check run finished. */
  completedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The final conclusion of the check. */
  conclusion?: InputMaybe<gh_CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: InputMaybe<Scalars['gh_URI']['input']>;
  /** A reference for the run on the integrator's system. */
  externalId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the check. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Descriptive details about the run. */
  output?: InputMaybe<gh_CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** The time that the check run began. */
  startedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The current status. */
  status?: InputMaybe<gh_RequestableCheckStatusState>;
};

/** Autogenerated return type of UpdateCheckRun */
export type gh_UpdateCheckRunPayload = {
  /** The updated check run. */
  checkRun?: Maybe<gh_CheckRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateCheckSuitePreferences */
export type gh_UpdateCheckSuitePreferencesInput = {
  /** The check suite preferences to modify. */
  autoTriggerPreferences: Array<gh_CheckSuiteAutoTriggerPreference>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateCheckSuitePreferences */
export type gh_UpdateCheckSuitePreferencesPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated repository. */
  repository?: Maybe<gh_Repository>;
};

/** Autogenerated input type of UpdateDiscussionComment */
export type gh_UpdateDiscussionCommentInput = {
  /** The new contents of the comment body. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion comment to update. */
  commentId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateDiscussionComment */
export type gh_UpdateDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The modified discussion comment. */
  comment?: Maybe<gh_DiscussionComment>;
};

/** Autogenerated input type of UpdateDiscussion */
export type gh_UpdateDiscussionInput = {
  /** The new contents of the discussion body. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of a discussion category within the same repository to change this discussion to. */
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion to update. */
  discussionId: Scalars['ID']['input'];
  /** The new discussion title. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateDiscussion */
export type gh_UpdateDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The modified discussion. */
  discussion?: Maybe<gh_Discussion>;
};

/** Autogenerated input type of UpdateEnterpriseAdministratorRole */
export type gh_UpdateEnterpriseAdministratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of a administrator whose role is being changed. */
  login: Scalars['String']['input'];
  /** The new role for the Enterprise administrator. */
  role: gh_EnterpriseAdministratorRole;
};

/** Autogenerated return type of UpdateEnterpriseAdministratorRole */
export type gh_UpdateEnterpriseAdministratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of changing the administrator's role. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the allow private repository forking setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the allow private repository forking policy on the enterprise. */
  policyValue?: InputMaybe<gh_EnterpriseAllowPrivateRepositoryForkingPolicyValue>;
  /** The value for the allow private repository forking setting on the enterprise. */
  settingValue: gh_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated allow private repository forking setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the allow private repository forking setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type gh_UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the base repository permission setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the base repository permission setting on the enterprise. */
  settingValue: gh_EnterpriseDefaultRepositoryPermissionSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type gh_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated base repository permission setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the base repository permission setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can change repository visibility setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can change repository visibility setting on the enterprise. */
  settingValue: gh_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can change repository visibility setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the members can change repository visibility setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can create repositories setting. */
  enterpriseId: Scalars['ID']['input'];
  /** Allow members to create internal repositories. Defaults to current value. */
  membersCanCreateInternalRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  /** Allow members to create private repositories. Defaults to current value. */
  membersCanCreatePrivateRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  /** Allow members to create public repositories. Defaults to current value. */
  membersCanCreatePublicRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  /** When false, allow member organizations to set their own repository creation member privileges. */
  membersCanCreateRepositoriesPolicyEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Value for the members can create repositories setting on the enterprise. This
   * or the granular public/private/internal allowed fields (but not both) must be provided.
   */
  settingValue?: InputMaybe<gh_EnterpriseMembersCanCreateRepositoriesSettingValue>;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can create repositories setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the members can create repositories setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type gh_UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can delete issues setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can delete issues setting on the enterprise. */
  settingValue: gh_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type gh_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can delete issues setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the members can delete issues setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can delete repositories setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can delete repositories setting on the enterprise. */
  settingValue: gh_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can delete repositories setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the members can delete repositories setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can invite collaborators setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can invite collaborators setting on the enterprise. */
  settingValue: gh_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can invite collaborators setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the members can invite collaborators setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type gh_UpdateEnterpriseMembersCanMakePurchasesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can make purchases setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can make purchases setting on the enterprise. */
  settingValue: gh_EnterpriseMembersCanMakePurchasesSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type gh_UpdateEnterpriseMembersCanMakePurchasesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can make purchases setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the members can make purchases setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can update protected branches setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can update protected branches setting on the enterprise. */
  settingValue: gh_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can update protected branches setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the members can update protected branches setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can view dependency insights setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can view dependency insights setting on the enterprise. */
  settingValue: gh_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can view dependency insights setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the members can view dependency insights setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */
export type gh_UpdateEnterpriseOrganizationProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the organization projects setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the organization projects setting on the enterprise. */
  settingValue: gh_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseOrganizationProjectsSetting */
export type gh_UpdateEnterpriseOrganizationProjectsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated organization projects setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the organization projects setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseOwnerOrganizationRole */
export type gh_UpdateEnterpriseOwnerOrganizationRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the owner belongs to. */
  enterpriseId: Scalars['ID']['input'];
  /** The ID of the organization for membership change. */
  organizationId: Scalars['ID']['input'];
  /** The role to assume in the organization. */
  organizationRole: gh_RoleInOrganization;
};

/** Autogenerated return type of UpdateEnterpriseOwnerOrganizationRole */
export type gh_UpdateEnterpriseOwnerOrganizationRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of changing the owner's organization role. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseProfile */
export type gh_UpdateEnterpriseProfileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The description of the enterprise. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The Enterprise ID to update. */
  enterpriseId: Scalars['ID']['input'];
  /** The location of the enterprise. */
  location?: InputMaybe<Scalars['String']['input']>;
  /** The name of the enterprise. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the enterprise's website. */
  websiteUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateEnterpriseProfile */
export type gh_UpdateEnterpriseProfilePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated enterprise. */
  enterprise?: Maybe<gh_Enterprise>;
};

/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */
export type gh_UpdateEnterpriseRepositoryProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the repository projects setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the repository projects setting on the enterprise. */
  settingValue: gh_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseRepositoryProjectsSetting */
export type gh_UpdateEnterpriseRepositoryProjectsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated repository projects setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the repository projects setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */
export type gh_UpdateEnterpriseTeamDiscussionsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the team discussions setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the team discussions setting on the enterprise. */
  settingValue: gh_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTeamDiscussionsSetting */
export type gh_UpdateEnterpriseTeamDiscussionsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated team discussions setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the team discussions setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the two factor authentication required setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the two factor authentication required setting on the enterprise. */
  settingValue: gh_EnterpriseEnabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated two factor authentication required setting. */
  enterprise?: Maybe<gh_Enterprise>;
  /** A message confirming the result of updating the two factor authentication required setting. */
  message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnvironment */
export type gh_UpdateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The node ID of the environment. */
  environmentId: Scalars['ID']['input'];
  /** Whether deployments to this environment can be approved by the user who created the deployment. */
  preventSelfReview?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ids of users or teams that can approve deployments to this environment */
  reviewers?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The wait timer in minutes. */
  waitTimer?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateEnvironment */
export type gh_UpdateEnvironmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated environment. */
  environment?: Maybe<gh_Environment>;
};

/** Autogenerated input type of UpdateIpAllowListEnabledSetting */
export type gh_UpdateIpAllowListEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner on which to set the IP allow list enabled setting. */
  ownerId: Scalars['ID']['input'];
  /** The value for the IP allow list enabled setting. */
  settingValue: gh_IpAllowListEnabledSettingValue;
};

/** Autogenerated return type of UpdateIpAllowListEnabledSetting */
export type gh_UpdateIpAllowListEnabledSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list owner on which the setting was updated. */
  owner?: Maybe<gh_IpAllowListOwner>;
};

/** Autogenerated input type of UpdateIpAllowListEntry */
export type gh_UpdateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the IP allow list entry to update. */
  ipAllowListEntryId: Scalars['ID']['input'];
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean']['input'];
  /** An optional name for the IP allow list entry. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateIpAllowListEntry */
export type gh_UpdateIpAllowListEntryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list entry that was updated. */
  ipAllowListEntry?: Maybe<gh_IpAllowListEntry>;
};

/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */
export type gh_UpdateIpAllowListForInstalledAppsEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner. */
  ownerId: Scalars['ID']['input'];
  /** The value for the IP allow list configuration for installed GitHub Apps setting. */
  settingValue: gh_IpAllowListForInstalledAppsEnabledSettingValue;
};

/** Autogenerated return type of UpdateIpAllowListForInstalledAppsEnabledSetting */
export type gh_UpdateIpAllowListForInstalledAppsEnabledSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list owner on which the setting was updated. */
  owner?: Maybe<gh_IpAllowListOwner>;
};

/** Autogenerated input type of UpdateIssueComment */
export type gh_UpdateIssueCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the IssueComment to modify. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateIssueComment */
export type gh_UpdateIssueCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated comment. */
  issueComment?: Maybe<gh_IssueComment>;
};

/** Autogenerated input type of UpdateIssue */
export type gh_UpdateIssueInput = {
  /** An array of Node IDs of users for this issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The body for the issue description. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Issue to modify. */
  id: Scalars['ID']['input'];
  /** An array of Node IDs of labels for this issue. */
  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: InputMaybe<Scalars['ID']['input']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The desired issue state. */
  state?: InputMaybe<gh_IssueState>;
  /** The title for the issue. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateIssue */
export type gh_UpdateIssuePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue. */
  issue?: Maybe<gh_Issue>;
};

/** Autogenerated input type of UpdateLabel */
export type gh_UpdateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */
  color?: InputMaybe<Scalars['String']['input']>;
  /** A brief description of the label, such as its purpose. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the label to be updated. */
  id: Scalars['ID']['input'];
  /** The updated name of the label. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateLabel */
export type gh_UpdateLabelPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated label. */
  label?: Maybe<gh_Label>;
};

/** Autogenerated input type of UpdateNotificationRestrictionSetting */
export type gh_UpdateNotificationRestrictionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner on which to set the restrict notifications setting. */
  ownerId: Scalars['ID']['input'];
  /** The value for the restrict notifications setting. */
  settingValue: gh_NotificationRestrictionSettingValue;
};

/** Autogenerated return type of UpdateNotificationRestrictionSetting */
export type gh_UpdateNotificationRestrictionSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The owner on which the setting was updated. */
  owner?: Maybe<gh_VerifiableDomainOwner>;
};

/** Autogenerated input type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */
export type gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Enable forking of private repositories in the organization? */
  forkingEnabled: Scalars['Boolean']['input'];
  /** The ID of the organization on which to set the allow private repository forking setting. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */
export type gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of updating the allow private repository forking setting. */
  message?: Maybe<Scalars['String']['output']>;
  /** The organization with the updated allow private repository forking setting. */
  organization?: Maybe<gh_Organization>;
};

/** Autogenerated input type of UpdateOrganizationWebCommitSignoffSetting */
export type gh_UpdateOrganizationWebCommitSignoffSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization on which to set the web commit signoff setting. */
  organizationId: Scalars['ID']['input'];
  /** Enable signoff on web-based commits for repositories in the organization? */
  webCommitSignoffRequired: Scalars['Boolean']['input'];
};

/** Autogenerated return type of UpdateOrganizationWebCommitSignoffSetting */
export type gh_UpdateOrganizationWebCommitSignoffSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of updating the web commit signoff setting. */
  message?: Maybe<Scalars['String']['output']>;
  /** The organization with the updated web commit signoff setting. */
  organization?: Maybe<gh_Organization>;
};

/** Only allow users with bypass permission to update matching refs. */
export type gh_UpdateParameters = {
  /** Branch can pull changes from its upstream repository */
  updateAllowsFetchAndMerge: Scalars['Boolean']['output'];
};

/** Only allow users with bypass permission to update matching refs. */
export type gh_UpdateParametersInput = {
  /** Branch can pull changes from its upstream repository */
  updateAllowsFetchAndMerge: Scalars['Boolean']['input'];
};

/** Autogenerated input type of UpdatePatreonSponsorability */
export type gh_UpdatePatreonSponsorabilityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Whether Patreon tiers should be shown on the GitHub Sponsors profile page,
   * allowing potential sponsors to make their payment through Patreon instead of GitHub.
   */
  enablePatreonSponsorships: Scalars['Boolean']['input'];
  /**
   * The username of the organization with the GitHub Sponsors profile, if any.
   * Defaults to the GitHub Sponsors profile for the authenticated user if omitted.
   */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdatePatreonSponsorability */
export type gh_UpdatePatreonSponsorabilityPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The GitHub Sponsors profile. */
  sponsorsListing?: Maybe<gh_SponsorsListing>;
};

/** Autogenerated input type of UpdateProjectCard */
export type gh_UpdateProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not the ProjectCard should be archived */
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  /** The note of ProjectCard. */
  note?: InputMaybe<Scalars['String']['input']>;
  /** The ProjectCard ID to update. */
  projectCardId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProjectCard */
export type gh_UpdateProjectCardPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated ProjectCard. */
  projectCard?: Maybe<gh_ProjectCard>;
};

/** Autogenerated input type of UpdateProjectColumn */
export type gh_UpdateProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of project column. */
  name: Scalars['String']['input'];
  /** The ProjectColumn ID to update. */
  projectColumnId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProjectColumn */
export type gh_UpdateProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated project column. */
  projectColumn?: Maybe<gh_ProjectColumn>;
};

/** Autogenerated input type of UpdateProject */
export type gh_UpdateProjectInput = {
  /** The description of project. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of project. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The Project ID to update. */
  projectId: Scalars['ID']['input'];
  /** Whether the project is public or not. */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the project is open or closed. */
  state?: InputMaybe<gh_ProjectState>;
};

/** Autogenerated return type of UpdateProject */
export type gh_UpdateProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated project. */
  project?: Maybe<gh_Project>;
};

/** Autogenerated input type of UpdateProjectV2Collaborators */
export type gh_UpdateProjectV2CollaboratorsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The collaborators to update. */
  collaborators: Array<gh_ProjectV2Collaborator>;
  /** The ID of the project to update the collaborators for. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProjectV2Collaborators */
export type gh_UpdateProjectV2CollaboratorsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The collaborators granted a role */
  collaborators?: Maybe<gh_ProjectV2ActorConnection>;
};


/** Autogenerated return type of UpdateProjectV2Collaborators */
export type gh_UpdateProjectV2CollaboratorsPayloadcollaboratorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UpdateProjectV2DraftIssue */
export type gh_UpdateProjectV2DraftIssueInput = {
  /** The IDs of the assignees of the draft issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The body of the draft issue. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the draft issue to update. */
  draftIssueId: Scalars['ID']['input'];
  /** The title of the draft issue. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateProjectV2DraftIssue */
export type gh_UpdateProjectV2DraftIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The draft issue updated in the project. */
  draftIssue?: Maybe<gh_DraftIssue>;
};

/** Autogenerated input type of UpdateProjectV2 */
export type gh_UpdateProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Set the project to closed or open. */
  closed?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the Project to update. */
  projectId: Scalars['ID']['input'];
  /** Set the project to public or private. */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  /** Set the readme description of the project. */
  readme?: InputMaybe<Scalars['String']['input']>;
  /** Set the short description of the project. */
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  /** Set the title of the project. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateProjectV2ItemFieldValue */
export type gh_UpdateProjectV2ItemFieldValueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the field to be updated. */
  fieldId: Scalars['ID']['input'];
  /** The ID of the item to be updated. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project. */
  projectId: Scalars['ID']['input'];
  /** The value which will be set on the field. */
  value: gh_ProjectV2FieldValue;
};

/** Autogenerated return type of UpdateProjectV2ItemFieldValue */
export type gh_UpdateProjectV2ItemFieldValuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated item. */
  projectV2Item?: Maybe<gh_ProjectV2Item>;
};

/** Autogenerated input type of UpdateProjectV2ItemPosition */
export type gh_UpdateProjectV2ItemPositionInput = {
  /** The ID of the item to position this item after. If omitted or set to null the item will be moved to top. */
  afterId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the item to be moved. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProjectV2ItemPosition */
export type gh_UpdateProjectV2ItemPositionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The items in the new order */
  items?: Maybe<gh_ProjectV2ItemConnection>;
};


/** Autogenerated return type of UpdateProjectV2ItemPosition */
export type gh_UpdateProjectV2ItemPositionPayloaditemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateProjectV2 */
export type gh_UpdateProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated Project. */
  projectV2?: Maybe<gh_ProjectV2>;
};

/** Autogenerated input type of UpdatePullRequestBranch */
export type gh_UpdatePullRequestBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The head ref oid for the upstream branch. */
  expectedHeadOid?: InputMaybe<Scalars['gh_GitObjectID']['input']>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID']['input'];
  /** The update branch method to use. If omitted, defaults to 'MERGE' */
  updateMethod?: InputMaybe<gh_PullRequestBranchUpdateMethod>;
};

/** Autogenerated return type of UpdatePullRequestBranch */
export type gh_UpdatePullRequestBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Autogenerated input type of UpdatePullRequest */
export type gh_UpdatePullRequestInput = {
  /** An array of Node IDs of users for this pull request. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository.
   */
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  /** The contents of the pull request. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An array of Node IDs of labels for this pull request. */
  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node ID of the milestone for this pull request. */
  milestoneId?: InputMaybe<Scalars['ID']['input']>;
  /** An array of Node IDs for projects associated with this pull request. */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID']['input'];
  /** The target state of the pull request. */
  state?: InputMaybe<gh_PullRequestUpdateState>;
  /** The title of the pull request. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdatePullRequest */
export type gh_UpdatePullRequestPayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request. */
  pullRequest?: Maybe<gh_PullRequest>;
};

/** Autogenerated input type of UpdatePullRequestReviewComment */
export type gh_UpdatePullRequestReviewCommentInput = {
  /** The text of the comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the comment to modify. */
  pullRequestReviewCommentId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdatePullRequestReviewComment */
export type gh_UpdatePullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated comment. */
  pullRequestReviewComment?: Maybe<gh_PullRequestReviewComment>;
};

/** Autogenerated input type of UpdatePullRequestReview */
export type gh_UpdatePullRequestReviewInput = {
  /** The contents of the pull request review body. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdatePullRequestReview */
export type gh_UpdatePullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request review. */
  pullRequestReview?: Maybe<gh_PullRequestReview>;
};

/** Autogenerated input type of UpdateRef */
export type gh_UpdateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Permit updates of branch Refs that are not fast-forwards? */
  force?: InputMaybe<Scalars['Boolean']['input']>;
  /** The GitObjectID that the Ref shall be updated to target. */
  oid: Scalars['gh_GitObjectID']['input'];
  /** The Node ID of the Ref to be updated. */
  refId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateRef */
export type gh_UpdateRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated Ref. */
  ref?: Maybe<gh_Ref>;
};

/** Autogenerated input type of UpdateRefs */
export type gh_UpdateRefsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A list of ref updates. */
  refUpdates: Array<gh_RefUpdate>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateRefs */
export type gh_UpdateRefsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateRepository */
export type gh_UpdateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A new description for the repository. Pass an empty string to erase the existing description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if the repository should have the discussions feature enabled. */
  hasDiscussionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the project boards feature enabled. */
  hasProjectsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */
  homepageUrl?: InputMaybe<Scalars['gh_URI']['input']>;
  /** The new name of the repository. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to update. */
  repositoryId: Scalars['ID']['input'];
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of UpdateRepository */
export type gh_UpdateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated repository. */
  repository?: Maybe<gh_Repository>;
};

/** Autogenerated input type of UpdateRepositoryRuleset */
export type gh_UpdateRepositoryRulesetInput = {
  /** A list of actors that are allowed to bypass rules in this ruleset. */
  bypassActors?: InputMaybe<Array<gh_RepositoryRulesetBypassActorInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The list of conditions for this ruleset */
  conditions?: InputMaybe<gh_RepositoryRuleConditionsInput>;
  /** The enforcement level for this ruleset */
  enforcement?: InputMaybe<gh_RuleEnforcement>;
  /** The name of the ruleset. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The global relay id of the repository ruleset to be updated. */
  repositoryRulesetId: Scalars['ID']['input'];
  /** The list of rules for this ruleset */
  rules?: InputMaybe<Array<gh_RepositoryRuleInput>>;
  /** The target of the ruleset. */
  target?: InputMaybe<gh_RepositoryRulesetTarget>;
};

/** Autogenerated return type of UpdateRepositoryRuleset */
export type gh_UpdateRepositoryRulesetPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created Ruleset. */
  ruleset?: Maybe<gh_RepositoryRuleset>;
};

/** Autogenerated input type of UpdateRepositoryWebCommitSignoffSetting */
export type gh_UpdateRepositoryWebCommitSignoffSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to update. */
  repositoryId: Scalars['ID']['input'];
  /** Indicates if the repository should require signoff on web-based commits. */
  webCommitSignoffRequired: Scalars['Boolean']['input'];
};

/** Autogenerated return type of UpdateRepositoryWebCommitSignoffSetting */
export type gh_UpdateRepositoryWebCommitSignoffSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of updating the web commit signoff setting. */
  message?: Maybe<Scalars['String']['output']>;
  /** The updated repository. */
  repository?: Maybe<gh_Repository>;
};

/** Autogenerated input type of UpdateSponsorshipPreferences */
export type gh_UpdateSponsorshipPreferencesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  privacyLevel?: InputMaybe<gh_SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateSponsorshipPreferences */
export type gh_UpdateSponsorshipPreferencesPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The sponsorship that was updated. */
  sponsorship?: Maybe<gh_Sponsorship>;
};

/** Autogenerated input type of UpdateSubscription */
export type gh_UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The new state of the subscription. */
  state: gh_SubscriptionState;
  /** The Node ID of the subscribable object to modify. */
  subscribableId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateSubscription */
export type gh_UpdateSubscriptionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The input subscribable entity. */
  subscribable?: Maybe<gh_Subscribable>;
};

/** Autogenerated input type of UpdateTeamDiscussionComment */
export type gh_UpdateTeamDiscussionCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String']['input'];
  /** The current version of the body content. */
  bodyVersion?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to modify. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateTeamDiscussionComment */
export type gh_UpdateTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated comment. */
  teamDiscussionComment?: Maybe<gh_TeamDiscussionComment>;
};

/** Autogenerated input type of UpdateTeamDiscussion */
export type gh_UpdateTeamDiscussionInput = {
  /** The updated text of the discussion. */
  body?: InputMaybe<Scalars['String']['input']>;
  /**
   * The current version of the body content. If provided, this update operation
   * will be rejected if the given version does not match the latest version on the server.
   */
  bodyVersion?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion to modify. */
  id: Scalars['ID']['input'];
  /** If provided, sets the pinned state of the updated discussion. */
  pinned?: InputMaybe<Scalars['Boolean']['input']>;
  /** The updated title of the discussion. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateTeamDiscussion */
export type gh_UpdateTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated discussion. */
  teamDiscussion?: Maybe<gh_TeamDiscussion>;
};

/** Autogenerated input type of UpdateTeamReviewAssignment */
export type gh_UpdateTeamReviewAssignmentInput = {
  /** The algorithm to use for review assignment */
  algorithm?: InputMaybe<gh_TeamReviewAssignmentAlgorithm>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Turn on or off review assignment */
  enabled: Scalars['Boolean']['input'];
  /** An array of team member IDs to exclude */
  excludedTeamMemberIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the team to update review assignments of */
  id: Scalars['ID']['input'];
  /** Notify the entire team of the PR if it is delegated */
  notifyTeam?: InputMaybe<Scalars['Boolean']['input']>;
  /** The number of team members to assign */
  teamMemberCount?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateTeamReviewAssignment */
export type gh_UpdateTeamReviewAssignmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The team that was modified */
  team?: Maybe<gh_Team>;
};

/** Autogenerated input type of UpdateTeamsRepository */
export type gh_UpdateTeamsRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Permission that should be granted to the teams. */
  permission: gh_RepositoryPermission;
  /** Repository ID being granted access to. */
  repositoryId: Scalars['ID']['input'];
  /** A list of teams being granted access. Limit: 10 */
  teamIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of UpdateTeamsRepository */
export type gh_UpdateTeamsRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository that was updated. */
  repository?: Maybe<gh_Repository>;
  /** The teams granted permission on the repository. */
  teams?: Maybe<Array<gh_Team>>;
};

/** Autogenerated input type of UpdateTopics */
export type gh_UpdateTopicsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** An array of topic names. */
  topicNames: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateTopics */
export type gh_UpdateTopicsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Names of the provided topics that are not valid. */
  invalidTopicNames?: Maybe<Array<Scalars['String']['output']>>;
  /** The updated repository. */
  repository?: Maybe<gh_Repository>;
};

/** Autogenerated input type of UpdateUserList */
export type gh_UpdateUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A description of the list */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not the list is private */
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the list to update. */
  listId: Scalars['ID']['input'];
  /** The name of the list */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateUserList */
export type gh_UpdateUserListPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The list that was just updated */
  list?: Maybe<gh_UserList>;
};

/** Autogenerated input type of UpdateUserListsForItem */
export type gh_UpdateUserListsForItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The item to add to the list */
  itemId: Scalars['ID']['input'];
  /** The lists to which this item should belong */
  listIds: Array<Scalars['ID']['input']>;
  /** The suggested lists to create and add this item to */
  suggestedListIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of UpdateUserListsForItem */
export type gh_UpdateUserListsForItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was added */
  item?: Maybe<gh_UserListItems>;
  /** The lists to which this item belongs */
  lists?: Maybe<Array<gh_UserList>>;
  /** The user who owns the lists */
  user?: Maybe<gh_User>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_User = gh_Actor & gh_Node & gh_PackageOwner & gh_ProfileOwner & gh_ProjectOwner & gh_ProjectV2Owner & gh_ProjectV2Recent & gh_RepositoryDiscussionAuthor & gh_RepositoryDiscussionCommentAuthor & gh_RepositoryOwner & gh_Sponsorable & gh_UniformResourceLocatable & {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean']['output'];
  /** A URL pointing to the user's public avatar. */
  avatarUrl: Scalars['gh_URI']['output'];
  /** The user's public profile bio. */
  bio?: Maybe<Scalars['String']['output']>;
  /** The user's public profile bio as HTML. */
  bioHTML: Scalars['gh_HTML']['output'];
  /** Could this user receive email notifications, if the organization had notification restrictions enabled? */
  canReceiveOrganizationEmailsWhenNotificationsRestricted: Scalars['Boolean']['output'];
  /** A list of commit comments made by this user. */
  commitComments: gh_CommitCommentConnection;
  /** The user's public profile company. */
  company?: Maybe<Scalars['String']['output']>;
  /** The user's public profile company as HTML. */
  companyHTML: Scalars['gh_HTML']['output'];
  /** The collection of contributions this user has made to different repositories. */
  contributionsCollection: gh_ContributionsCollection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The user's publicly visible profile email. */
  email: Scalars['String']['output'];
  /** A list of enterprises that the user belongs to. */
  enterprises?: Maybe<gh_EnterpriseConnection>;
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars['Int']['output'];
  /** A list of users the given user is followed by. */
  followers: gh_FollowerConnection;
  /** A list of users the given user is following. */
  following: gh_FollowingConnection;
  /** Find gist by repo name. */
  gist?: Maybe<gh_Gist>;
  /** A list of gist comments made by this user. */
  gistComments: gh_GistCommentConnection;
  /** A list of the Gists the user has created. */
  gists: gh_GistConnection;
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars['Boolean']['output'];
  /** The hovercard information for this user in a given context */
  hovercard: gh_Hovercard;
  /** The Node ID of the User object */
  id: Scalars['ID']['output'];
  /** The interaction ability settings for this user. */
  interactionAbility?: Maybe<gh_RepositoryInteractionAbility>;
  /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */
  isBountyHunter: Scalars['Boolean']['output'];
  /** Whether or not this user is a participant in the GitHub Campus Experts Program. */
  isCampusExpert: Scalars['Boolean']['output'];
  /** Whether or not this user is a GitHub Developer Program member. */
  isDeveloperProgramMember: Scalars['Boolean']['output'];
  /** Whether or not this user is a GitHub employee. */
  isEmployee: Scalars['Boolean']['output'];
  /** Whether or not this user is following the viewer. Inverse of viewerIsFollowing */
  isFollowingViewer: Scalars['Boolean']['output'];
  /** Whether or not this user is a member of the GitHub Stars Program. */
  isGitHubStar: Scalars['Boolean']['output'];
  /** Whether or not the user has marked themselves as for hire. */
  isHireable: Scalars['Boolean']['output'];
  /** Whether or not this user is a site administrator. */
  isSiteAdmin: Scalars['Boolean']['output'];
  /** Whether the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars['Boolean']['output'];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars['Boolean']['output'];
  /** Whether or not this user is the viewing user. */
  isViewer: Scalars['Boolean']['output'];
  /** A list of issue comments made by this user. */
  issueComments: gh_IssueCommentConnection;
  /** A list of issues associated with this user. */
  issues: gh_IssueConnection;
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: gh_ProfileItemShowcase;
  /** A user-curated list of repositories */
  lists: gh_UserListConnection;
  /** The user's public profile location. */
  location?: Maybe<Scalars['String']['output']>;
  /** The username used to login. */
  login: Scalars['String']['output'];
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']['output'];
  /** The user's public profile name. */
  name?: Maybe<Scalars['String']['output']>;
  /** Find an organization by its login that the user belongs to. */
  organization?: Maybe<gh_Organization>;
  /** Verified email addresses that match verified domains for a specified organization the user is a member of. */
  organizationVerifiedDomainEmails: Array<Scalars['String']['output']>;
  /** A list of organizations the user belongs to. */
  organizations: gh_OrganizationConnection;
  /** A list of packages under the owner. */
  packages: gh_PackageConnection;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: gh_PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: gh_PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int']['output'];
  /** Find project by number. */
  project?: Maybe<gh_Project>;
  /** Find a project by number. */
  projectV2?: Maybe<gh_ProjectV2>;
  /** A list of projects under the owner. */
  projects: gh_ProjectConnection;
  /** The HTTP path listing user's projects */
  projectsResourcePath: Scalars['gh_URI']['output'];
  /** The HTTP URL listing user's projects */
  projectsUrl: Scalars['gh_URI']['output'];
  /** A list of projects under the owner. */
  projectsV2: gh_ProjectV2Connection;
  /** The user's profile pronouns */
  pronouns?: Maybe<Scalars['String']['output']>;
  /** A list of public keys associated with this user. */
  publicKeys: gh_PublicKeyConnection;
  /** A list of pull requests associated with this user. */
  pullRequests: gh_PullRequestConnection;
  /** Recent projects that this user has modified in the context of the owner. */
  recentProjects: gh_ProjectV2Connection;
  /** A list of repositories that the user owns. */
  repositories: gh_RepositoryConnection;
  /** A list of repositories that the user recently contributed to. */
  repositoriesContributedTo: gh_RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<gh_Repository>;
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: gh_DiscussionCommentConnection;
  /** Discussions this user has started. */
  repositoryDiscussions: gh_DiscussionConnection;
  /** The HTTP path for this user */
  resourcePath: Scalars['gh_URI']['output'];
  /** Replies this user has saved */
  savedReplies?: Maybe<gh_SavedReplyConnection>;
  /** The user's social media accounts, ordered as they appear on the user's profile. */
  socialAccounts: gh_SocialAccountConnection;
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: gh_SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: gh_SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: gh_SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<gh_SponsorsListing>;
  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
  sponsorshipForViewerAsSponsor?: Maybe<gh_Sponsorship>;
  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
  sponsorshipForViewerAsSponsorable?: Maybe<gh_Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: gh_SponsorshipNewsletterConnection;
  /** The sponsorships where this user or organization is the maintainer receiving the funds. */
  sponsorshipsAsMaintainer: gh_SponsorshipConnection;
  /** The sponsorships where this user or organization is the funder. */
  sponsorshipsAsSponsor: gh_SponsorshipConnection;
  /** Repositories the user has starred. */
  starredRepositories: gh_StarredRepositoryConnection;
  /** The user's description of what they're currently doing. */
  status?: Maybe<gh_UserStatus>;
  /** Suggested names for user lists */
  suggestedListNames: Array<gh_UserListSuggestion>;
  /** Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created */
  topRepositories: gh_RepositoryConnection;
  /**
   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
   * user themselves or by a user who can manage sponsorships for the requested organization.
   */
  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']['output']>;
  /** The user's Twitter username. */
  twitterUsername?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this user */
  url: Scalars['gh_URI']['output'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean']['output'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean']['output'];
  /** Whether or not the viewer is able to follow the user. */
  viewerCanFollow: Scalars['Boolean']['output'];
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars['Boolean']['output'];
  /** Whether or not this user is followed by the viewer. Inverse of isFollowingViewer. */
  viewerIsFollowing: Scalars['Boolean']['output'];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars['Boolean']['output'];
  /** A list of repositories the given user is watching. */
  watching: gh_RepositoryConnection;
  /** A URL pointing to the user's public website/blog. */
  websiteUrl?: Maybe<Scalars['gh_URI']['output']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UseranyPinnableItemsArgs = {
  type?: InputMaybe<gh_PinnableItemType>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UseravatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsercanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs = {
  login: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsercommitCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsercontributionsCollectionArgs = {
  from?: InputMaybe<Scalars['DateTime']['input']>;
  organizationID?: InputMaybe<Scalars['ID']['input']>;
  to?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserenterprisesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  membershipType?: InputMaybe<gh_EnterpriseMembershipType>;
  orderBy?: InputMaybe<gh_EnterpriseOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserfollowersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserfollowingArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsergistArgs = {
  name: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsergistCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsergistsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_GistOrder>;
  privacy?: InputMaybe<gh_GistPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserhovercardArgs = {
  primarySubjectId?: InputMaybe<Scalars['ID']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserisSponsoredByArgs = {
  accountLogin: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserissueCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueCommentOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserissuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<gh_IssueFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueOrder>;
  states?: InputMaybe<Array<gh_IssueState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserlistsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserorganizationArgs = {
  login: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserorganizationVerifiedDomainEmailsArgs = {
  login: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserorganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_OrganizationOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserpackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<gh_PackageOrder>;
  packageType?: InputMaybe<gh_PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserpinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<gh_PinnableItemType>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserpinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<gh_PinnableItemType>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserprojectArgs = {
  number: Scalars['Int']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserprojectV2Args = {
  number: Scalars['Int']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserprojectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<gh_ProjectState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserprojectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserpublicKeysArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserpullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_IssueOrder>;
  states?: InputMaybe<Array<gh_PullRequestState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserrecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserrepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<gh_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  isFork?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<gh_RepositoryAffiliation>>>;
  privacy?: InputMaybe<gh_RepositoryPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserrepositoriesContributedToArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  contributionTypes?: InputMaybe<Array<InputMaybe<gh_RepositoryContributionType>>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssues?: InputMaybe<Scalars['Boolean']['input']>;
  includeUserRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_RepositoryOrder>;
  privacy?: InputMaybe<gh_RepositoryPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserrepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserrepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']['input']>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserrepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  answered?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  states?: InputMaybe<Array<gh_DiscussionState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsersavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SavedReplyOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsersocialAccountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsersponsoringArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsersponsorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsersponsorsActivitiesArgs = {
  actions?: InputMaybe<Array<gh_SponsorsActivityAction>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAsSponsor?: InputMaybe<Scalars['Boolean']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorsActivityOrder>;
  period?: InputMaybe<gh_SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsersponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsersponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsersponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorshipNewsletterOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsersponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SponsorshipOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsersponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  maintainerLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  orderBy?: InputMaybe<gh_SponsorshipOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserstarredRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_StarOrder>;
  ownedByViewer?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsertopRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy: gh_RepositoryOrder;
  since?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UsertotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars['DateTime']['input']>;
  sponsorableLogins?: InputMaybe<Array<Scalars['String']['input']>>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type gh_UserwatchingArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<gh_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<gh_RepositoryAffiliation>>>;
  privacy?: InputMaybe<gh_RepositoryPrivacy>;
};

/** The possible durations that a user can be blocked for. */
export type gh_UserBlockDuration =
  /** The user was blocked for 1 day */
  | 'ONE_DAY'
  /** The user was blocked for 30 days */
  | 'ONE_MONTH'
  /** The user was blocked for 7 days */
  | 'ONE_WEEK'
  /** The user was blocked permanently */
  | 'PERMANENT'
  /** The user was blocked for 3 days */
  | 'THREE_DAYS';

/** Represents a 'user_blocked' event on a given user. */
export type gh_UserBlockedEvent = gh_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<gh_Actor>;
  /** Number of days that the user was blocked for. */
  blockDuration: gh_UserBlockDuration;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The Node ID of the UserBlockedEvent object */
  id: Scalars['ID']['output'];
  /** The user who was blocked. */
  subject?: Maybe<gh_User>;
};

/** The connection type for User. */
export type gh_UserConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_User>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edit on user content */
export type gh_UserContentEdit = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the date and time when the object was deleted. */
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The actor who deleted this content */
  deletedBy?: Maybe<gh_Actor>;
  /** A summary of the changes for this edit */
  diff?: Maybe<Scalars['String']['output']>;
  /** When this content was edited */
  editedAt: Scalars['DateTime']['output'];
  /** The actor who edited this content */
  editor?: Maybe<gh_Actor>;
  /** The Node ID of the UserContentEdit object */
  id: Scalars['ID']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
};

/** A list of edits to content. */
export type gh_UserContentEditConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_UserContentEditEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_UserContentEdit>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_UserContentEditEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_UserContentEdit>;
};

/** Represents a user. */
export type gh_UserEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_User>;
};

/** Email attributes from External Identity */
export type gh_UserEmailMetadata = {
  /** Boolean to identify primary emails */
  primary?: Maybe<Scalars['Boolean']['output']>;
  /** Type of email */
  type?: Maybe<Scalars['String']['output']>;
  /** Email id */
  value: Scalars['String']['output'];
};

/** A user-curated list of repositories */
export type gh_UserList = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The description of this list */
  description?: Maybe<Scalars['String']['output']>;
  /** The Node ID of the UserList object */
  id: Scalars['ID']['output'];
  /** Whether or not this list is private */
  isPrivate: Scalars['Boolean']['output'];
  /** The items associated with this list */
  items: gh_UserListItemsConnection;
  /** The date and time at which this list was created or last had items added to it */
  lastAddedAt: Scalars['DateTime']['output'];
  /** The name of this list */
  name: Scalars['String']['output'];
  /** The slug of this list */
  slug: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The user to which this list belongs */
  user: gh_User;
};


/** A user-curated list of repositories */
export type gh_UserListitemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for UserList. */
export type gh_UserListConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_UserListEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_UserList>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_UserListEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_UserList>;
};

/** Types that can be added to a user list. */
export type gh_UserListItems = gh_Repository;

/** The connection type for UserListItems. */
export type gh_UserListItemsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_UserListItemsEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_UserListItems>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_UserListItemsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_UserListItems>;
};

/** Represents a suggested user list. */
export type gh_UserListSuggestion = {
  /** The ID of the suggested user list */
  id?: Maybe<Scalars['ID']['output']>;
  /** The name of the suggested user list */
  name?: Maybe<Scalars['String']['output']>;
};

/** The user's description of what they're currently doing. */
export type gh_UserStatus = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** An emoji summarizing the user's status. */
  emoji?: Maybe<Scalars['String']['output']>;
  /** The status emoji as HTML. */
  emojiHTML?: Maybe<Scalars['gh_HTML']['output']>;
  /** If set, the status will not be shown after this date. */
  expiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** The Node ID of the UserStatus object */
  id: Scalars['ID']['output'];
  /** Whether this status indicates the user is not fully available on GitHub. */
  indicatesLimitedAvailability: Scalars['Boolean']['output'];
  /** A brief message describing what the user is doing. */
  message?: Maybe<Scalars['String']['output']>;
  /** The organization whose members can see this status. If null, this status is publicly visible. */
  organization?: Maybe<gh_Organization>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The user who has this status. */
  user: gh_User;
};

/** The connection type for UserStatus. */
export type gh_UserStatusConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_UserStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_UserStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_UserStatusEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_UserStatus>;
};

/** Ordering options for user status connections. */
export type gh_UserStatusOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order user statuses by. */
  field: gh_UserStatusOrderField;
};

/** Properties by which user status connections can be ordered. */
export type gh_UserStatusOrderField =
  /** Order user statuses by when they were updated. */
  | 'UPDATED_AT';

/** A domain that can be verified or approved for an organization or an enterprise. */
export type gh_VerifiableDomain = gh_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The DNS host name that should be used for verification. */
  dnsHostName?: Maybe<Scalars['gh_URI']['output']>;
  /** The unicode encoded domain. */
  domain: Scalars['gh_URI']['output'];
  /** Whether a TXT record for verification with the expected host name was found. */
  hasFoundHostName: Scalars['Boolean']['output'];
  /** Whether a TXT record for verification with the expected verification token was found. */
  hasFoundVerificationToken: Scalars['Boolean']['output'];
  /** The Node ID of the VerifiableDomain object */
  id: Scalars['ID']['output'];
  /** Whether or not the domain is approved. */
  isApproved: Scalars['Boolean']['output'];
  /** Whether this domain is required to exist for an organization or enterprise policy to be enforced. */
  isRequiredForPolicyEnforcement: Scalars['Boolean']['output'];
  /** Whether or not the domain is verified. */
  isVerified: Scalars['Boolean']['output'];
  /** The owner of the domain. */
  owner: gh_VerifiableDomainOwner;
  /** The punycode encoded domain. */
  punycodeEncodedDomain: Scalars['gh_URI']['output'];
  /** The time that the current verification token will expire. */
  tokenExpirationTime?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The current verification token for the domain. */
  verificationToken?: Maybe<Scalars['String']['output']>;
};

/** The connection type for VerifiableDomain. */
export type gh_VerifiableDomainConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_VerifiableDomainEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_VerifiableDomain>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_VerifiableDomainEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_VerifiableDomain>;
};

/** Ordering options for verifiable domain connections. */
export type gh_VerifiableDomainOrder = {
  /** The ordering direction. */
  direction: gh_OrderDirection;
  /** The field to order verifiable domains by. */
  field: gh_VerifiableDomainOrderField;
};

/** Properties by which verifiable domain connections can be ordered. */
export type gh_VerifiableDomainOrderField =
  /** Order verifiable domains by their creation date. */
  | 'CREATED_AT'
  /** Order verifiable domains by the domain name. */
  | 'DOMAIN';

/** Types that can own a verifiable domain. */
export type gh_VerifiableDomainOwner = gh_Enterprise | gh_Organization;

/** Autogenerated input type of VerifyVerifiableDomain */
export type gh_VerifyVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to verify. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of VerifyVerifiableDomain */
export type gh_VerifyVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The verifiable domain that was verified. */
  domain?: Maybe<gh_VerifiableDomain>;
};

/** A hovercard context with a message describing how the viewer is related. */
export type gh_ViewerHovercardContext = gh_HovercardContext & {
  /** A string describing this context */
  message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  octicon: Scalars['String']['output'];
  /** Identifies the user who is related to this context. */
  viewer: gh_User;
};

/** A subject that may be upvoted. */
export type gh_Votable = {
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars['Int']['output'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars['Boolean']['output'];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars['Boolean']['output'];
};

/** A workflow contains meta information about an Actions workflow file. */
export type gh_Workflow = gh_Node & gh_UniformResourceLocatable & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Node ID of the Workflow object */
  id: Scalars['ID']['output'];
  /** The name of the workflow. */
  name: Scalars['String']['output'];
  /** The HTTP path for this workflow */
  resourcePath: Scalars['gh_URI']['output'];
  /** The runs of the workflow. */
  runs: gh_WorkflowRunConnection;
  /** The state of the workflow. */
  state: gh_WorkflowState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this workflow */
  url: Scalars['gh_URI']['output'];
};


/** A workflow contains meta information about an Actions workflow file. */
export type gh_WorkflowrunsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_WorkflowRunOrder>;
};

/** A workflow that must run for this rule to pass */
export type gh_WorkflowFileReference = {
  /** The path to the workflow file */
  path: Scalars['String']['output'];
  /** The ref (branch or tag) of the workflow file to use */
  ref?: Maybe<Scalars['String']['output']>;
  /** The ID of the repository where the workflow is defined */
  repositoryId: Scalars['Int']['output'];
  /** The commit SHA of the workflow file to use */
  sha?: Maybe<Scalars['String']['output']>;
};

/** A workflow that must run for this rule to pass */
export type gh_WorkflowFileReferenceInput = {
  /** The path to the workflow file */
  path: Scalars['String']['input'];
  /** The ref (branch or tag) of the workflow file to use */
  ref?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository where the workflow is defined */
  repositoryId: Scalars['Int']['input'];
  /** The commit SHA of the workflow file to use */
  sha?: InputMaybe<Scalars['String']['input']>;
};

/** A workflow run. */
export type gh_WorkflowRun = gh_Node & gh_UniformResourceLocatable & {
  /** The check suite this workflow run belongs to. */
  checkSuite: gh_CheckSuite;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']['output']>;
  /** The log of deployment reviews */
  deploymentReviews: gh_DeploymentReviewConnection;
  /** The event that triggered the workflow run */
  event: Scalars['String']['output'];
  /** The workflow file */
  file?: Maybe<gh_WorkflowRunFile>;
  /** The Node ID of the WorkflowRun object */
  id: Scalars['ID']['output'];
  /** The pending deployment requests of all check runs in this workflow run */
  pendingDeploymentRequests: gh_DeploymentRequestConnection;
  /** The HTTP path for this workflow run */
  resourcePath: Scalars['gh_URI']['output'];
  /** A number that uniquely identifies this workflow run in its parent workflow. */
  runNumber: Scalars['Int']['output'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this workflow run */
  url: Scalars['gh_URI']['output'];
  /** The workflow executed in this workflow run. */
  workflow: gh_Workflow;
};


/** A workflow run. */
export type gh_WorkflowRundeploymentReviewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A workflow run. */
export type gh_WorkflowRunpendingDeploymentRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for WorkflowRun. */
export type gh_WorkflowRunConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<gh_WorkflowRunEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<gh_WorkflowRun>>>;
  /** Information to aid in pagination. */
  pageInfo: gh_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type gh_WorkflowRunEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<gh_WorkflowRun>;
};

/** An executed workflow file for a workflow run. */
export type gh_WorkflowRunFile = gh_Node & gh_UniformResourceLocatable & {
  /** The Node ID of the WorkflowRunFile object */
  id: Scalars['ID']['output'];
  /** The path of the workflow file relative to its repository. */
  path: Scalars['String']['output'];
  /** The direct link to the file in the repository which stores the workflow file. */
  repositoryFileUrl: Scalars['gh_URI']['output'];
  /** The repository name and owner which stores the workflow file. */
  repositoryName: Scalars['gh_URI']['output'];
  /** The HTTP path for this workflow run file */
  resourcePath: Scalars['gh_URI']['output'];
  /** The parent workflow run execution for this file. */
  run: gh_WorkflowRun;
  /** The HTTP URL for this workflow run file */
  url: Scalars['gh_URI']['output'];
  /** If the viewer has permissions to push to the repository which stores the workflow. */
  viewerCanPushRepository: Scalars['Boolean']['output'];
  /** If the viewer has permissions to read the repository which stores the workflow. */
  viewerCanReadRepository: Scalars['Boolean']['output'];
};

/** Ways in which lists of workflow runs can be ordered upon return. */
export type gh_WorkflowRunOrder = {
  /** The direction in which to order workflow runs by the specified field. */
  direction: gh_OrderDirection;
  /** The field by which to order workflows. */
  field: gh_WorkflowRunOrderField;
};

/** Properties by which workflow run connections can be ordered. */
export type gh_WorkflowRunOrderField =
  /** Order workflow runs by most recently created */
  | 'CREATED_AT';

/** The possible states for a workflow. */
export type gh_WorkflowState =
  /** The workflow is active. */
  | 'ACTIVE'
  /** The workflow was deleted from the git repository. */
  | 'DELETED'
  /** The workflow was disabled by default on a fork. */
  | 'DISABLED_FORK'
  /** The workflow was disabled for inactivity in the repository. */
  | 'DISABLED_INACTIVITY'
  /** The workflow was disabled manually. */
  | 'DISABLED_MANUALLY';

/** Require all changes made to a targeted branch to pass the specified workflows before they can be merged. */
export type gh_WorkflowsParameters = {
  /** Workflows that must pass for this rule to pass. */
  workflows: Array<gh_WorkflowFileReference>;
};

/** Require all changes made to a targeted branch to pass the specified workflows before they can be merged. */
export type gh_WorkflowsParametersInput = {
  /** Workflows that must pass for this rule to pass. */
  workflows: Array<gh_WorkflowFileReferenceInput>;
};

export type GithubQuery = {
  /** Look up a code of conduct by its key */
  gh_codeOfConduct?: Maybe<gh_CodeOfConduct>;
  /** Look up a code of conduct by its key */
  gh_codesOfConduct?: Maybe<Array<Maybe<gh_CodeOfConduct>>>;
  /** Look up an enterprise by URL slug. */
  gh_enterprise?: Maybe<gh_Enterprise>;
  /** Look up a pending enterprise administrator invitation by invitee, enterprise and role. */
  gh_enterpriseAdministratorInvitation?: Maybe<gh_EnterpriseAdministratorInvitation>;
  /** Look up a pending enterprise administrator invitation by invitation token. */
  gh_enterpriseAdministratorInvitationByToken?: Maybe<gh_EnterpriseAdministratorInvitation>;
  /** Look up an open source license by its key */
  gh_license?: Maybe<gh_License>;
  /** Return a list of known open source licenses */
  gh_licenses: Array<Maybe<gh_License>>;
  /** Get alphabetically sorted list of Marketplace categories */
  gh_marketplaceCategories: Array<gh_MarketplaceCategory>;
  /** Look up a Marketplace category by its slug. */
  gh_marketplaceCategory?: Maybe<gh_MarketplaceCategory>;
  /** Look up a single Marketplace listing */
  gh_marketplaceListing?: Maybe<gh_MarketplaceListing>;
  /** Look up Marketplace listings */
  gh_marketplaceListings: gh_MarketplaceListingConnection;
  /** Return information about the GitHub instance */
  gh_meta: gh_GitHubMetadata;
  /** Fetches an object given its ID. */
  gh_node?: Maybe<gh_Node>;
  /** Lookup nodes by a list of IDs. */
  gh_nodes: Array<Maybe<gh_Node>>;
  /** Lookup a organization by login. */
  gh_organization?: Maybe<gh_Organization>;
  /** The client's rate limit information. */
  gh_rateLimit?: Maybe<gh_RateLimit>;
  /**
   * Workaround for re-exposing the root query object. (Refer to
   * https://github.com/facebook/relay/issues/112 for more information.)
   */
  gh_relay: Query;
  /** Lookup a given repository by the owner and repository name. */
  gh_repository?: Maybe<gh_Repository>;
  /** Lookup a repository owner (ie. either a User or an Organization) by login. */
  gh_repositoryOwner?: Maybe<gh_RepositoryOwner>;
  /** Lookup resource by a URL. */
  gh_resource?: Maybe<gh_UniformResourceLocatable>;
  /** Perform a search across resources, returning a maximum of 1,000 results. */
  gh_search: gh_SearchResultItemConnection;
  /** GitHub Security Advisories */
  gh_securityAdvisories: gh_SecurityAdvisoryConnection;
  /** Fetch a Security Advisory by its GHSA ID */
  gh_securityAdvisory?: Maybe<gh_SecurityAdvisory>;
  /** Software Vulnerabilities documented by GitHub Security Advisories */
  gh_securityVulnerabilities: gh_SecurityVulnerabilityConnection;
  /** Users and organizations who can be sponsored via GitHub Sponsors. */
  gh_sponsorables: gh_SponsorableItemConnection;
  /** Look up a topic by name. */
  gh_topic?: Maybe<gh_Topic>;
  /** Lookup a user by login. */
  gh_user?: Maybe<gh_User>;
  /** The currently authenticated user. */
  gh_viewer: gh_User;
};


export type GithubQuerygh_codeOfConductArgs = {
  key: Scalars['String']['input'];
};


export type GithubQuerygh_enterpriseArgs = {
  invitationToken?: InputMaybe<Scalars['String']['input']>;
  slug: Scalars['String']['input'];
};


export type GithubQuerygh_enterpriseAdministratorInvitationArgs = {
  enterpriseSlug: Scalars['String']['input'];
  role: gh_EnterpriseAdministratorRole;
  userLogin: Scalars['String']['input'];
};


export type GithubQuerygh_enterpriseAdministratorInvitationByTokenArgs = {
  invitationToken: Scalars['String']['input'];
};


export type GithubQuerygh_licenseArgs = {
  key: Scalars['String']['input'];
};


export type GithubQuerygh_marketplaceCategoriesArgs = {
  excludeEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  excludeSubcategories?: InputMaybe<Scalars['Boolean']['input']>;
  includeCategories?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type GithubQuerygh_marketplaceCategoryArgs = {
  slug: Scalars['String']['input'];
  useTopicAliases?: InputMaybe<Scalars['Boolean']['input']>;
};


export type GithubQuerygh_marketplaceListingArgs = {
  slug: Scalars['String']['input'];
};


export type GithubQuerygh_marketplaceListingsArgs = {
  adminId?: InputMaybe<Scalars['ID']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  allStates?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  categorySlug?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  organizationId?: InputMaybe<Scalars['ID']['input']>;
  primaryCategoryOnly?: InputMaybe<Scalars['Boolean']['input']>;
  slugs?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  useTopicAliases?: InputMaybe<Scalars['Boolean']['input']>;
  viewerCanAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  withFreeTrialsOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


export type GithubQuerygh_nodeArgs = {
  id: Scalars['ID']['input'];
};


export type GithubQuerygh_nodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type GithubQuerygh_organizationArgs = {
  login: Scalars['String']['input'];
};


export type GithubQuerygh_rateLimitArgs = {
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
};


export type GithubQuerygh_repositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  owner: Scalars['String']['input'];
};


export type GithubQuerygh_repositoryOwnerArgs = {
  login: Scalars['String']['input'];
};


export type GithubQuerygh_resourceArgs = {
  url: Scalars['gh_URI']['input'];
};


export type GithubQuerygh_searchArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query: Scalars['String']['input'];
  type: gh_SearchType;
};


export type GithubQuerygh_securityAdvisoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  classifications?: InputMaybe<Array<gh_SecurityAdvisoryClassification>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  identifier?: InputMaybe<gh_SecurityAdvisoryIdentifierFilter>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SecurityAdvisoryOrder>;
  publishedSince?: InputMaybe<Scalars['DateTime']['input']>;
  updatedSince?: InputMaybe<Scalars['DateTime']['input']>;
};


export type GithubQuerygh_securityAdvisoryArgs = {
  ghsaId: Scalars['String']['input'];
};


export type GithubQuerygh_securityVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  classifications?: InputMaybe<Array<gh_SecurityAdvisoryClassification>>;
  ecosystem?: InputMaybe<gh_SecurityAdvisoryEcosystem>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<gh_SecurityVulnerabilityOrder>;
  package?: InputMaybe<Scalars['String']['input']>;
  severities?: InputMaybe<Array<gh_SecurityAdvisorySeverity>>;
};


export type GithubQuerygh_sponsorablesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  dependencyEcosystem?: InputMaybe<gh_SecurityAdvisoryEcosystem>;
  ecosystem?: InputMaybe<gh_DependencyGraphEcosystem>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyDependencies?: InputMaybe<Scalars['Boolean']['input']>;
  orderBy?: InputMaybe<gh_SponsorableOrder>;
  orgLoginForDependencies?: InputMaybe<Scalars['String']['input']>;
};


export type GithubQuerygh_topicArgs = {
  name: Scalars['String']['input'];
};


export type GithubQuerygh_userArgs = {
  login: Scalars['String']['input'];
};

export type GithubMutation = {
  /** Clear all of a customer's queued migrations */
  gh_abortQueuedMigrations?: Maybe<gh_AbortQueuedMigrationsPayload>;
  /** Abort a repository migration queued or in progress. */
  gh_abortRepositoryMigration?: Maybe<gh_AbortRepositoryMigrationPayload>;
  /** Accepts a pending invitation for a user to become an administrator of an enterprise. */
  gh_acceptEnterpriseAdministratorInvitation?: Maybe<gh_AcceptEnterpriseAdministratorInvitationPayload>;
  /** Applies a suggested topic to the repository. */
  gh_acceptTopicSuggestion?: Maybe<gh_AcceptTopicSuggestionPayload>;
  /** Adds assignees to an assignable object. */
  gh_addAssigneesToAssignable?: Maybe<gh_AddAssigneesToAssignablePayload>;
  /** Adds a comment to an Issue or Pull Request. */
  gh_addComment?: Maybe<gh_AddCommentPayload>;
  /** Adds a comment to a Discussion, possibly as a reply to another comment. */
  gh_addDiscussionComment?: Maybe<gh_AddDiscussionCommentPayload>;
  /** Vote for an option in a discussion poll. */
  gh_addDiscussionPollVote?: Maybe<gh_AddDiscussionPollVotePayload>;
  /** Adds enterprise members to an organization within the enterprise. */
  gh_addEnterpriseOrganizationMember?: Maybe<gh_AddEnterpriseOrganizationMemberPayload>;
  /** Adds a support entitlement to an enterprise member. */
  gh_addEnterpriseSupportEntitlement?: Maybe<gh_AddEnterpriseSupportEntitlementPayload>;
  /** Adds labels to a labelable object. */
  gh_addLabelsToLabelable?: Maybe<gh_AddLabelsToLabelablePayload>;
  /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */
  gh_addProjectCard?: Maybe<gh_AddProjectCardPayload>;
  /** Adds a column to a Project. */
  gh_addProjectColumn?: Maybe<gh_AddProjectColumnPayload>;
  /** Creates a new draft issue and add it to a Project. */
  gh_addProjectV2DraftIssue?: Maybe<gh_AddProjectV2DraftIssuePayload>;
  /** Links an existing content instance to a Project. */
  gh_addProjectV2ItemById?: Maybe<gh_AddProjectV2ItemByIdPayload>;
  /** Adds a review to a Pull Request. */
  gh_addPullRequestReview?: Maybe<gh_AddPullRequestReviewPayload>;
  /** Adds a comment to a review. */
  gh_addPullRequestReviewComment?: Maybe<gh_AddPullRequestReviewCommentPayload>;
  /** Adds a new thread to a pending Pull Request Review. */
  gh_addPullRequestReviewThread?: Maybe<gh_AddPullRequestReviewThreadPayload>;
  /** Adds a reply to an existing Pull Request Review Thread. */
  gh_addPullRequestReviewThreadReply?: Maybe<gh_AddPullRequestReviewThreadReplyPayload>;
  /** Adds a reaction to a subject. */
  gh_addReaction?: Maybe<gh_AddReactionPayload>;
  /** Adds a star to a Starrable. */
  gh_addStar?: Maybe<gh_AddStarPayload>;
  /** Add an upvote to a discussion or discussion comment. */
  gh_addUpvote?: Maybe<gh_AddUpvotePayload>;
  /** Adds a verifiable domain to an owning account. */
  gh_addVerifiableDomain?: Maybe<gh_AddVerifiableDomainPayload>;
  /** Approve all pending deployments under one or more environments */
  gh_approveDeployments?: Maybe<gh_ApproveDeploymentsPayload>;
  /** Approve a verifiable domain for notification delivery. */
  gh_approveVerifiableDomain?: Maybe<gh_ApproveVerifiableDomainPayload>;
  /** Archives a ProjectV2Item */
  gh_archiveProjectV2Item?: Maybe<gh_ArchiveProjectV2ItemPayload>;
  /** Marks a repository as archived. */
  gh_archiveRepository?: Maybe<gh_ArchiveRepositoryPayload>;
  /** Cancels a pending invitation for an administrator to join an enterprise. */
  gh_cancelEnterpriseAdminInvitation?: Maybe<gh_CancelEnterpriseAdminInvitationPayload>;
  /** Cancel an active sponsorship. */
  gh_cancelSponsorship?: Maybe<gh_CancelSponsorshipPayload>;
  /** Update your status on GitHub. */
  gh_changeUserStatus?: Maybe<gh_ChangeUserStatusPayload>;
  /** Clears all labels from a labelable object. */
  gh_clearLabelsFromLabelable?: Maybe<gh_ClearLabelsFromLabelablePayload>;
  /**
   * This mutation clears the value of a field for an item in a Project. Currently
   * only text, number, date, assignees, labels, single-select, iteration and
   * milestone fields are supported.
   */
  gh_clearProjectV2ItemFieldValue?: Maybe<gh_ClearProjectV2ItemFieldValuePayload>;
  /** Creates a new project by cloning configuration from an existing project. */
  gh_cloneProject?: Maybe<gh_CloneProjectPayload>;
  /** Create a new repository with the same files and directory structure as a template repository. */
  gh_cloneTemplateRepository?: Maybe<gh_CloneTemplateRepositoryPayload>;
  /** Close a discussion. */
  gh_closeDiscussion?: Maybe<gh_CloseDiscussionPayload>;
  /** Close an issue. */
  gh_closeIssue?: Maybe<gh_CloseIssuePayload>;
  /** Close a pull request. */
  gh_closePullRequest?: Maybe<gh_ClosePullRequestPayload>;
  /** Convert a project note card to one associated with a newly created issue. */
  gh_convertProjectCardNoteToIssue?: Maybe<gh_ConvertProjectCardNoteToIssuePayload>;
  /** Converts a pull request to draft */
  gh_convertPullRequestToDraft?: Maybe<gh_ConvertPullRequestToDraftPayload>;
  /** Copy a project. */
  gh_copyProjectV2?: Maybe<gh_CopyProjectV2Payload>;
  /** Invites a user to claim reattributable data */
  gh_createAttributionInvitation?: Maybe<gh_CreateAttributionInvitationPayload>;
  /** Create a new branch protection rule */
  gh_createBranchProtectionRule?: Maybe<gh_CreateBranchProtectionRulePayload>;
  /** Create a check run. */
  gh_createCheckRun?: Maybe<gh_CreateCheckRunPayload>;
  /** Create a check suite */
  gh_createCheckSuite?: Maybe<gh_CreateCheckSuitePayload>;
  /**
   * Appends a commit to the given branch as the authenticated user.
   *
   * This mutation creates a commit whose parent is the HEAD of the provided
   * branch and also updates that branch to point to the new commit.
   * It can be thought of as similar to `git commit`.
   *
   * ### Locating a Branch
   *
   * Commits are appended to a `branch` of type `Ref`.
   * This must refer to a git branch (i.e.  the fully qualified path must
   * begin with `refs/heads/`, although including this prefix is optional.
   *
   * Callers may specify the `branch` to commit to either by its global node
   * ID or by passing both of `repositoryNameWithOwner` and `refName`.  For
   * more details see the documentation for `CommittableBranch`.
   *
   * ### Describing Changes
   *
   * `fileChanges` are specified as a `FilesChanges` object describing
   * `FileAdditions` and `FileDeletions`.
   *
   * Please see the documentation for `FileChanges` for more information on
   * how to use this argument to describe any set of file changes.
   *
   * ### Authorship
   *
   * Similar to the web commit interface, this mutation does not support
   * specifying the author or committer of the commit and will not add
   * support for this in the future.
   *
   * A commit created by a successful execution of this mutation will be
   * authored by the owner of the credential which authenticates the API
   * request.  The committer will be identical to that of commits authored
   * using the web interface.
   *
   * If you need full control over author and committer information, please
   * use the Git Database REST API instead.
   *
   * ### Commit Signing
   *
   * Commits made using this mutation are automatically signed by GitHub if
   * supported and will be marked as verified in the user interface.
   */
  gh_createCommitOnBranch?: Maybe<gh_CreateCommitOnBranchPayload>;
  /** Creates a new deployment event. */
  gh_createDeployment?: Maybe<gh_CreateDeploymentPayload>;
  /** Create a deployment status. */
  gh_createDeploymentStatus?: Maybe<gh_CreateDeploymentStatusPayload>;
  /** Create a discussion. */
  gh_createDiscussion?: Maybe<gh_CreateDiscussionPayload>;
  /**
   * Creates an organization as part of an enterprise account. A personal access
   * token used to create an organization is implicitly permitted to update the
   * organization it created, if the organization is part of an enterprise that has
   * SAML enabled or uses Enterprise Managed Users. If the organization is not part
   * of such an enterprise, and instead has SAML enabled for it individually, the
   * token will then require SAML authorization to continue working against that organization.
   */
  gh_createEnterpriseOrganization?: Maybe<gh_CreateEnterpriseOrganizationPayload>;
  /** Creates an environment or simply returns it if already exists. */
  gh_createEnvironment?: Maybe<gh_CreateEnvironmentPayload>;
  /** Creates a new IP allow list entry. */
  gh_createIpAllowListEntry?: Maybe<gh_CreateIpAllowListEntryPayload>;
  /** Creates a new issue. */
  gh_createIssue?: Maybe<gh_CreateIssuePayload>;
  /** Creates a new label. */
  gh_createLabel?: Maybe<gh_CreateLabelPayload>;
  /** Create a branch linked to an issue. */
  gh_createLinkedBranch?: Maybe<gh_CreateLinkedBranchPayload>;
  /** Creates a GitHub Enterprise Importer (GEI) migration source. */
  gh_createMigrationSource?: Maybe<gh_CreateMigrationSourcePayload>;
  /** Creates a new project. */
  gh_createProject?: Maybe<gh_CreateProjectPayload>;
  /** Creates a new project. */
  gh_createProjectV2?: Maybe<gh_CreateProjectV2Payload>;
  /** Create a new project field. */
  gh_createProjectV2Field?: Maybe<gh_CreateProjectV2FieldPayload>;
  /** Create a new pull request */
  gh_createPullRequest?: Maybe<gh_CreatePullRequestPayload>;
  /** Create a new Git Ref. */
  gh_createRef?: Maybe<gh_CreateRefPayload>;
  /** Create a new repository. */
  gh_createRepository?: Maybe<gh_CreateRepositoryPayload>;
  /** Create a repository ruleset */
  gh_createRepositoryRuleset?: Maybe<gh_CreateRepositoryRulesetPayload>;
  /** Create a GitHub Sponsors profile to allow others to sponsor you or your organization. */
  gh_createSponsorsListing?: Maybe<gh_CreateSponsorsListingPayload>;
  /** Create a new payment tier for your GitHub Sponsors profile. */
  gh_createSponsorsTier?: Maybe<gh_CreateSponsorsTierPayload>;
  /** Start a new sponsorship of a maintainer in GitHub Sponsors, or reactivate a past sponsorship. */
  gh_createSponsorship?: Maybe<gh_CreateSponsorshipPayload>;
  /**
   * Make many one-time sponsorships for different sponsorable users or
   * organizations at once. Can only sponsor those who have a public GitHub
   * Sponsors profile.
   */
  gh_createSponsorships?: Maybe<gh_CreateSponsorshipsPayload>;
  /** Creates a new team discussion. */
  gh_createTeamDiscussion?: Maybe<gh_CreateTeamDiscussionPayload>;
  /** Creates a new team discussion comment. */
  gh_createTeamDiscussionComment?: Maybe<gh_CreateTeamDiscussionCommentPayload>;
  /** Creates a new user list. */
  gh_createUserList?: Maybe<gh_CreateUserListPayload>;
  /** Rejects a suggested topic for the repository. */
  gh_declineTopicSuggestion?: Maybe<gh_DeclineTopicSuggestionPayload>;
  /** Delete a branch protection rule */
  gh_deleteBranchProtectionRule?: Maybe<gh_DeleteBranchProtectionRulePayload>;
  /** Deletes a deployment. */
  gh_deleteDeployment?: Maybe<gh_DeleteDeploymentPayload>;
  /** Delete a discussion and all of its replies. */
  gh_deleteDiscussion?: Maybe<gh_DeleteDiscussionPayload>;
  /** Delete a discussion comment. If it has replies, wipe it instead. */
  gh_deleteDiscussionComment?: Maybe<gh_DeleteDiscussionCommentPayload>;
  /** Deletes an environment */
  gh_deleteEnvironment?: Maybe<gh_DeleteEnvironmentPayload>;
  /** Deletes an IP allow list entry. */
  gh_deleteIpAllowListEntry?: Maybe<gh_DeleteIpAllowListEntryPayload>;
  /** Deletes an Issue object. */
  gh_deleteIssue?: Maybe<gh_DeleteIssuePayload>;
  /** Deletes an IssueComment object. */
  gh_deleteIssueComment?: Maybe<gh_DeleteIssueCommentPayload>;
  /** Deletes a label. */
  gh_deleteLabel?: Maybe<gh_DeleteLabelPayload>;
  /** Unlink a branch from an issue. */
  gh_deleteLinkedBranch?: Maybe<gh_DeleteLinkedBranchPayload>;
  /** Delete a package version. */
  gh_deletePackageVersion?: Maybe<gh_DeletePackageVersionPayload>;
  /** Deletes a project. */
  gh_deleteProject?: Maybe<gh_DeleteProjectPayload>;
  /** Deletes a project card. */
  gh_deleteProjectCard?: Maybe<gh_DeleteProjectCardPayload>;
  /** Deletes a project column. */
  gh_deleteProjectColumn?: Maybe<gh_DeleteProjectColumnPayload>;
  /** Delete a project. */
  gh_deleteProjectV2?: Maybe<gh_DeleteProjectV2Payload>;
  /** Delete a project field. */
  gh_deleteProjectV2Field?: Maybe<gh_DeleteProjectV2FieldPayload>;
  /** Deletes an item from a Project. */
  gh_deleteProjectV2Item?: Maybe<gh_DeleteProjectV2ItemPayload>;
  /** Deletes a project workflow. */
  gh_deleteProjectV2Workflow?: Maybe<gh_DeleteProjectV2WorkflowPayload>;
  /** Deletes a pull request review. */
  gh_deletePullRequestReview?: Maybe<gh_DeletePullRequestReviewPayload>;
  /** Deletes a pull request review comment. */
  gh_deletePullRequestReviewComment?: Maybe<gh_DeletePullRequestReviewCommentPayload>;
  /** Delete a Git Ref. */
  gh_deleteRef?: Maybe<gh_DeleteRefPayload>;
  /** Delete a repository ruleset */
  gh_deleteRepositoryRuleset?: Maybe<gh_DeleteRepositoryRulesetPayload>;
  /** Deletes a team discussion. */
  gh_deleteTeamDiscussion?: Maybe<gh_DeleteTeamDiscussionPayload>;
  /** Deletes a team discussion comment. */
  gh_deleteTeamDiscussionComment?: Maybe<gh_DeleteTeamDiscussionCommentPayload>;
  /** Deletes a user list. */
  gh_deleteUserList?: Maybe<gh_DeleteUserListPayload>;
  /** Deletes a verifiable domain. */
  gh_deleteVerifiableDomain?: Maybe<gh_DeleteVerifiableDomainPayload>;
  /** Remove a pull request from the merge queue. */
  gh_dequeuePullRequest?: Maybe<gh_DequeuePullRequestPayload>;
  /** Disable auto merge on the given pull request */
  gh_disablePullRequestAutoMerge?: Maybe<gh_DisablePullRequestAutoMergePayload>;
  /** Dismisses an approved or rejected pull request review. */
  gh_dismissPullRequestReview?: Maybe<gh_DismissPullRequestReviewPayload>;
  /** Dismisses the Dependabot alert. */
  gh_dismissRepositoryVulnerabilityAlert?: Maybe<gh_DismissRepositoryVulnerabilityAlertPayload>;
  /** Enable the default auto-merge on a pull request. */
  gh_enablePullRequestAutoMerge?: Maybe<gh_EnablePullRequestAutoMergePayload>;
  /** Add a pull request to the merge queue. */
  gh_enqueuePullRequest?: Maybe<gh_EnqueuePullRequestPayload>;
  /** Follow an organization. */
  gh_followOrganization?: Maybe<gh_FollowOrganizationPayload>;
  /** Follow a user. */
  gh_followUser?: Maybe<gh_FollowUserPayload>;
  /** Grant the migrator role to a user for all organizations under an enterprise account. */
  gh_grantEnterpriseOrganizationsMigratorRole?: Maybe<gh_GrantEnterpriseOrganizationsMigratorRolePayload>;
  /** Grant the migrator role to a user or a team. */
  gh_grantMigratorRole?: Maybe<gh_GrantMigratorRolePayload>;
  /** Creates a new project by importing columns and a list of issues/PRs. */
  gh_importProject?: Maybe<gh_ImportProjectPayload>;
  /** Invite someone to become an administrator of the enterprise. */
  gh_inviteEnterpriseAdmin?: Maybe<gh_InviteEnterpriseAdminPayload>;
  /** Links a project to a repository. */
  gh_linkProjectV2ToRepository?: Maybe<gh_LinkProjectV2ToRepositoryPayload>;
  /** Links a project to a team. */
  gh_linkProjectV2ToTeam?: Maybe<gh_LinkProjectV2ToTeamPayload>;
  /** Creates a repository link for a project. */
  gh_linkRepositoryToProject?: Maybe<gh_LinkRepositoryToProjectPayload>;
  /** Lock a lockable object */
  gh_lockLockable?: Maybe<gh_LockLockablePayload>;
  /** Mark a discussion comment as the chosen answer for discussions in an answerable category. */
  gh_markDiscussionCommentAsAnswer?: Maybe<gh_MarkDiscussionCommentAsAnswerPayload>;
  /** Mark a pull request file as viewed */
  gh_markFileAsViewed?: Maybe<gh_MarkFileAsViewedPayload>;
  /** Mark a project as a template. Note that only projects which are owned by an Organization can be marked as a template. */
  gh_markProjectV2AsTemplate?: Maybe<gh_MarkProjectV2AsTemplatePayload>;
  /** Marks a pull request ready for review. */
  gh_markPullRequestReadyForReview?: Maybe<gh_MarkPullRequestReadyForReviewPayload>;
  /** Merge a head into a branch. */
  gh_mergeBranch?: Maybe<gh_MergeBranchPayload>;
  /** Merge a pull request. */
  gh_mergePullRequest?: Maybe<gh_MergePullRequestPayload>;
  /** Minimizes a comment on an Issue, Commit, Pull Request, or Gist */
  gh_minimizeComment?: Maybe<gh_MinimizeCommentPayload>;
  /** Moves a project card to another place. */
  gh_moveProjectCard?: Maybe<gh_MoveProjectCardPayload>;
  /** Moves a project column to another place. */
  gh_moveProjectColumn?: Maybe<gh_MoveProjectColumnPayload>;
  /** Pin an issue to a repository */
  gh_pinIssue?: Maybe<gh_PinIssuePayload>;
  /** Publish an existing sponsorship tier that is currently still a draft to a GitHub Sponsors profile. */
  gh_publishSponsorsTier?: Maybe<gh_PublishSponsorsTierPayload>;
  /** Regenerates the identity provider recovery codes for an enterprise */
  gh_regenerateEnterpriseIdentityProviderRecoveryCodes?: Maybe<gh_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;
  /** Regenerates a verifiable domain's verification token. */
  gh_regenerateVerifiableDomainToken?: Maybe<gh_RegenerateVerifiableDomainTokenPayload>;
  /** Reject all pending deployments under one or more environments */
  gh_rejectDeployments?: Maybe<gh_RejectDeploymentsPayload>;
  /** Removes assignees from an assignable object. */
  gh_removeAssigneesFromAssignable?: Maybe<gh_RemoveAssigneesFromAssignablePayload>;
  /** Removes an administrator from the enterprise. */
  gh_removeEnterpriseAdmin?: Maybe<gh_RemoveEnterpriseAdminPayload>;
  /** Removes the identity provider from an enterprise */
  gh_removeEnterpriseIdentityProvider?: Maybe<gh_RemoveEnterpriseIdentityProviderPayload>;
  /** Removes a user from all organizations within the enterprise */
  gh_removeEnterpriseMember?: Maybe<gh_RemoveEnterpriseMemberPayload>;
  /** Removes an organization from the enterprise */
  gh_removeEnterpriseOrganization?: Maybe<gh_RemoveEnterpriseOrganizationPayload>;
  /** Removes a support entitlement from an enterprise member. */
  gh_removeEnterpriseSupportEntitlement?: Maybe<gh_RemoveEnterpriseSupportEntitlementPayload>;
  /** Removes labels from a Labelable object. */
  gh_removeLabelsFromLabelable?: Maybe<gh_RemoveLabelsFromLabelablePayload>;
  /** Removes outside collaborator from all repositories in an organization. */
  gh_removeOutsideCollaborator?: Maybe<gh_RemoveOutsideCollaboratorPayload>;
  /** Removes a reaction from a subject. */
  gh_removeReaction?: Maybe<gh_RemoveReactionPayload>;
  /** Removes a star from a Starrable. */
  gh_removeStar?: Maybe<gh_RemoveStarPayload>;
  /** Remove an upvote to a discussion or discussion comment. */
  gh_removeUpvote?: Maybe<gh_RemoveUpvotePayload>;
  /** Reopen a discussion. */
  gh_reopenDiscussion?: Maybe<gh_ReopenDiscussionPayload>;
  /** Reopen a issue. */
  gh_reopenIssue?: Maybe<gh_ReopenIssuePayload>;
  /** Reopen a pull request. */
  gh_reopenPullRequest?: Maybe<gh_ReopenPullRequestPayload>;
  /** Set review requests on a pull request. */
  gh_requestReviews?: Maybe<gh_RequestReviewsPayload>;
  /** Rerequests an existing check suite. */
  gh_rerequestCheckSuite?: Maybe<gh_RerequestCheckSuitePayload>;
  /** Marks a review thread as resolved. */
  gh_resolveReviewThread?: Maybe<gh_ResolveReviewThreadPayload>;
  /** Retire a published payment tier from your GitHub Sponsors profile so it cannot be used to start new sponsorships. */
  gh_retireSponsorsTier?: Maybe<gh_RetireSponsorsTierPayload>;
  /** Create a pull request that reverts the changes from a merged pull request. */
  gh_revertPullRequest?: Maybe<gh_RevertPullRequestPayload>;
  /** Revoke the migrator role to a user for all organizations under an enterprise account. */
  gh_revokeEnterpriseOrganizationsMigratorRole?: Maybe<gh_RevokeEnterpriseOrganizationsMigratorRolePayload>;
  /** Revoke the migrator role from a user or a team. */
  gh_revokeMigratorRole?: Maybe<gh_RevokeMigratorRolePayload>;
  /** Creates or updates the identity provider for an enterprise. */
  gh_setEnterpriseIdentityProvider?: Maybe<gh_SetEnterpriseIdentityProviderPayload>;
  /** Set an organization level interaction limit for an organization's public repositories. */
  gh_setOrganizationInteractionLimit?: Maybe<gh_SetOrganizationInteractionLimitPayload>;
  /** Sets an interaction limit setting for a repository. */
  gh_setRepositoryInteractionLimit?: Maybe<gh_SetRepositoryInteractionLimitPayload>;
  /** Set a user level interaction limit for an user's public repositories. */
  gh_setUserInteractionLimit?: Maybe<gh_SetUserInteractionLimitPayload>;
  /** Starts a GitHub Enterprise Importer organization migration. */
  gh_startOrganizationMigration?: Maybe<gh_StartOrganizationMigrationPayload>;
  /** Starts a GitHub Enterprise Importer (GEI) repository migration. */
  gh_startRepositoryMigration?: Maybe<gh_StartRepositoryMigrationPayload>;
  /** Submits a pending pull request review. */
  gh_submitPullRequestReview?: Maybe<gh_SubmitPullRequestReviewPayload>;
  /** Transfer an organization from one enterprise to another enterprise. */
  gh_transferEnterpriseOrganization?: Maybe<gh_TransferEnterpriseOrganizationPayload>;
  /** Transfer an issue to a different repository */
  gh_transferIssue?: Maybe<gh_TransferIssuePayload>;
  /** Unarchives a ProjectV2Item */
  gh_unarchiveProjectV2Item?: Maybe<gh_UnarchiveProjectV2ItemPayload>;
  /** Unarchives a repository. */
  gh_unarchiveRepository?: Maybe<gh_UnarchiveRepositoryPayload>;
  /** Unfollow an organization. */
  gh_unfollowOrganization?: Maybe<gh_UnfollowOrganizationPayload>;
  /** Unfollow a user. */
  gh_unfollowUser?: Maybe<gh_UnfollowUserPayload>;
  /** Unlinks a project from a repository. */
  gh_unlinkProjectV2FromRepository?: Maybe<gh_UnlinkProjectV2FromRepositoryPayload>;
  /** Unlinks a project to a team. */
  gh_unlinkProjectV2FromTeam?: Maybe<gh_UnlinkProjectV2FromTeamPayload>;
  /** Deletes a repository link from a project. */
  gh_unlinkRepositoryFromProject?: Maybe<gh_UnlinkRepositoryFromProjectPayload>;
  /** Unlock a lockable object */
  gh_unlockLockable?: Maybe<gh_UnlockLockablePayload>;
  /** Unmark a discussion comment as the chosen answer for discussions in an answerable category. */
  gh_unmarkDiscussionCommentAsAnswer?: Maybe<gh_UnmarkDiscussionCommentAsAnswerPayload>;
  /** Unmark a pull request file as viewed */
  gh_unmarkFileAsViewed?: Maybe<gh_UnmarkFileAsViewedPayload>;
  /** Unmark an issue as a duplicate of another issue. */
  gh_unmarkIssueAsDuplicate?: Maybe<gh_UnmarkIssueAsDuplicatePayload>;
  /** Unmark a project as a template. */
  gh_unmarkProjectV2AsTemplate?: Maybe<gh_UnmarkProjectV2AsTemplatePayload>;
  /** Unminimizes a comment on an Issue, Commit, Pull Request, or Gist */
  gh_unminimizeComment?: Maybe<gh_UnminimizeCommentPayload>;
  /** Unpin a pinned issue from a repository */
  gh_unpinIssue?: Maybe<gh_UnpinIssuePayload>;
  /** Marks a review thread as unresolved. */
  gh_unresolveReviewThread?: Maybe<gh_UnresolveReviewThreadPayload>;
  /** Unsubscribes from notifications */
  gh_unsubscribeFromNotifications?: Maybe<gh_UnsubscribeFromNotificationsPayload>;
  /** Update a branch protection rule */
  gh_updateBranchProtectionRule?: Maybe<gh_UpdateBranchProtectionRulePayload>;
  /** Update a check run */
  gh_updateCheckRun?: Maybe<gh_UpdateCheckRunPayload>;
  /** Modifies the settings of an existing check suite */
  gh_updateCheckSuitePreferences?: Maybe<gh_UpdateCheckSuitePreferencesPayload>;
  /** Update a discussion */
  gh_updateDiscussion?: Maybe<gh_UpdateDiscussionPayload>;
  /** Update the contents of a comment on a Discussion */
  gh_updateDiscussionComment?: Maybe<gh_UpdateDiscussionCommentPayload>;
  /** Updates the role of an enterprise administrator. */
  gh_updateEnterpriseAdministratorRole?: Maybe<gh_UpdateEnterpriseAdministratorRolePayload>;
  /** Sets whether private repository forks are enabled for an enterprise. */
  gh_updateEnterpriseAllowPrivateRepositoryForkingSetting?: Maybe<gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;
  /** Sets the base repository permission for organizations in an enterprise. */
  gh_updateEnterpriseDefaultRepositoryPermissionSetting?: Maybe<gh_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;
  /** Sets whether organization members with admin permissions on a repository can change repository visibility. */
  gh_updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Maybe<gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;
  /** Sets the members can create repositories setting for an enterprise. */
  gh_updateEnterpriseMembersCanCreateRepositoriesSetting?: Maybe<gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;
  /** Sets the members can delete issues setting for an enterprise. */
  gh_updateEnterpriseMembersCanDeleteIssuesSetting?: Maybe<gh_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;
  /** Sets the members can delete repositories setting for an enterprise. */
  gh_updateEnterpriseMembersCanDeleteRepositoriesSetting?: Maybe<gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;
  /** Sets whether members can invite collaborators are enabled for an enterprise. */
  gh_updateEnterpriseMembersCanInviteCollaboratorsSetting?: Maybe<gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;
  /** Sets whether or not an organization owner can make purchases. */
  gh_updateEnterpriseMembersCanMakePurchasesSetting?: Maybe<gh_UpdateEnterpriseMembersCanMakePurchasesSettingPayload>;
  /** Sets the members can update protected branches setting for an enterprise. */
  gh_updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Maybe<gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;
  /** Sets the members can view dependency insights for an enterprise. */
  gh_updateEnterpriseMembersCanViewDependencyInsightsSetting?: Maybe<gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;
  /** Sets whether organization projects are enabled for an enterprise. */
  gh_updateEnterpriseOrganizationProjectsSetting?: Maybe<gh_UpdateEnterpriseOrganizationProjectsSettingPayload>;
  /** Updates the role of an enterprise owner with an organization. */
  gh_updateEnterpriseOwnerOrganizationRole?: Maybe<gh_UpdateEnterpriseOwnerOrganizationRolePayload>;
  /** Updates an enterprise's profile. */
  gh_updateEnterpriseProfile?: Maybe<gh_UpdateEnterpriseProfilePayload>;
  /** Sets whether repository projects are enabled for a enterprise. */
  gh_updateEnterpriseRepositoryProjectsSetting?: Maybe<gh_UpdateEnterpriseRepositoryProjectsSettingPayload>;
  /** Sets whether team discussions are enabled for an enterprise. */
  gh_updateEnterpriseTeamDiscussionsSetting?: Maybe<gh_UpdateEnterpriseTeamDiscussionsSettingPayload>;
  /** Sets whether two factor authentication is required for all users in an enterprise. */
  gh_updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Maybe<gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;
  /** Updates an environment. */
  gh_updateEnvironment?: Maybe<gh_UpdateEnvironmentPayload>;
  /** Sets whether an IP allow list is enabled on an owner. */
  gh_updateIpAllowListEnabledSetting?: Maybe<gh_UpdateIpAllowListEnabledSettingPayload>;
  /** Updates an IP allow list entry. */
  gh_updateIpAllowListEntry?: Maybe<gh_UpdateIpAllowListEntryPayload>;
  /** Sets whether IP allow list configuration for installed GitHub Apps is enabled on an owner. */
  gh_updateIpAllowListForInstalledAppsEnabledSetting?: Maybe<gh_UpdateIpAllowListForInstalledAppsEnabledSettingPayload>;
  /** Updates an Issue. */
  gh_updateIssue?: Maybe<gh_UpdateIssuePayload>;
  /** Updates an IssueComment object. */
  gh_updateIssueComment?: Maybe<gh_UpdateIssueCommentPayload>;
  /** Updates an existing label. */
  gh_updateLabel?: Maybe<gh_UpdateLabelPayload>;
  /** Update the setting to restrict notifications to only verified or approved domains available to an owner. */
  gh_updateNotificationRestrictionSetting?: Maybe<gh_UpdateNotificationRestrictionSettingPayload>;
  /** Sets whether private repository forks are enabled for an organization. */
  gh_updateOrganizationAllowPrivateRepositoryForkingSetting?: Maybe<gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload>;
  /** Sets whether contributors are required to sign off on web-based commits for repositories in an organization. */
  gh_updateOrganizationWebCommitSignoffSetting?: Maybe<gh_UpdateOrganizationWebCommitSignoffSettingPayload>;
  /**
   * Toggle the setting for your GitHub Sponsors profile that allows other GitHub
   * accounts to sponsor you on GitHub while paying for the sponsorship on Patreon.
   * Only applicable when you have a GitHub Sponsors profile and have connected
   * your GitHub account with Patreon.
   */
  gh_updatePatreonSponsorability?: Maybe<gh_UpdatePatreonSponsorabilityPayload>;
  /** Updates an existing project. */
  gh_updateProject?: Maybe<gh_UpdateProjectPayload>;
  /** Updates an existing project card. */
  gh_updateProjectCard?: Maybe<gh_UpdateProjectCardPayload>;
  /** Updates an existing project column. */
  gh_updateProjectColumn?: Maybe<gh_UpdateProjectColumnPayload>;
  /** Updates an existing project. */
  gh_updateProjectV2?: Maybe<gh_UpdateProjectV2Payload>;
  /** Update the collaborators on a team or a project */
  gh_updateProjectV2Collaborators?: Maybe<gh_UpdateProjectV2CollaboratorsPayload>;
  /** Updates a draft issue within a Project. */
  gh_updateProjectV2DraftIssue?: Maybe<gh_UpdateProjectV2DraftIssuePayload>;
  /**
   * This mutation updates the value of a field for an item in a Project. Currently
   * only single-select, text, number, date, and iteration fields are supported.
   */
  gh_updateProjectV2ItemFieldValue?: Maybe<gh_UpdateProjectV2ItemFieldValuePayload>;
  /** This mutation updates the position of the item in the project, where the position represents the priority of an item. */
  gh_updateProjectV2ItemPosition?: Maybe<gh_UpdateProjectV2ItemPositionPayload>;
  /** Update a pull request */
  gh_updatePullRequest?: Maybe<gh_UpdatePullRequestPayload>;
  /** Merge or Rebase HEAD from upstream branch into pull request branch */
  gh_updatePullRequestBranch?: Maybe<gh_UpdatePullRequestBranchPayload>;
  /** Updates the body of a pull request review. */
  gh_updatePullRequestReview?: Maybe<gh_UpdatePullRequestReviewPayload>;
  /** Updates a pull request review comment. */
  gh_updatePullRequestReviewComment?: Maybe<gh_UpdatePullRequestReviewCommentPayload>;
  /** Update a Git Ref. */
  gh_updateRef?: Maybe<gh_UpdateRefPayload>;
  /**
   * Creates, updates and/or deletes multiple refs in a repository.
   *
   * This mutation takes a list of `RefUpdate`s and performs these updates
   * on the repository. All updates are performed atomically, meaning that
   * if one of them is rejected, no other ref will be modified.
   *
   * `RefUpdate.beforeOid` specifies that the given reference needs to point
   * to the given value before performing any updates. A value of
   * `0000000000000000000000000000000000000000` can be used to verify that
   * the references should not exist.
   *
   * `RefUpdate.afterOid` specifies the value that the given reference
   * will point to after performing all updates. A value of
   * `0000000000000000000000000000000000000000` can be used to delete a
   * reference.
   *
   * If `RefUpdate.force` is set to `true`, a non-fast-forward updates
   * for the given reference will be allowed.
   */
  gh_updateRefs?: Maybe<gh_UpdateRefsPayload>;
  /** Update information about a repository. */
  gh_updateRepository?: Maybe<gh_UpdateRepositoryPayload>;
  /** Update a repository ruleset */
  gh_updateRepositoryRuleset?: Maybe<gh_UpdateRepositoryRulesetPayload>;
  /** Sets whether contributors are required to sign off on web-based commits for a repository. */
  gh_updateRepositoryWebCommitSignoffSetting?: Maybe<gh_UpdateRepositoryWebCommitSignoffSettingPayload>;
  /** Change visibility of your sponsorship and opt in or out of email updates from the maintainer. */
  gh_updateSponsorshipPreferences?: Maybe<gh_UpdateSponsorshipPreferencesPayload>;
  /** Updates the state for subscribable subjects. */
  gh_updateSubscription?: Maybe<gh_UpdateSubscriptionPayload>;
  /** Updates a team discussion. */
  gh_updateTeamDiscussion?: Maybe<gh_UpdateTeamDiscussionPayload>;
  /** Updates a discussion comment. */
  gh_updateTeamDiscussionComment?: Maybe<gh_UpdateTeamDiscussionCommentPayload>;
  /** Updates team review assignment. */
  gh_updateTeamReviewAssignment?: Maybe<gh_UpdateTeamReviewAssignmentPayload>;
  /** Update team repository. */
  gh_updateTeamsRepository?: Maybe<gh_UpdateTeamsRepositoryPayload>;
  /** Replaces the repository's topics with the given topics. */
  gh_updateTopics?: Maybe<gh_UpdateTopicsPayload>;
  /** Updates an existing user list. */
  gh_updateUserList?: Maybe<gh_UpdateUserListPayload>;
  /** Updates which of the viewer's lists an item belongs to */
  gh_updateUserListsForItem?: Maybe<gh_UpdateUserListsForItemPayload>;
  /** Verify that a verifiable domain has the expected DNS record. */
  gh_verifyVerifiableDomain?: Maybe<gh_VerifyVerifiableDomainPayload>;
};


export type GithubMutationgh_abortQueuedMigrationsArgs = {
  input: gh_AbortQueuedMigrationsInput;
};


export type GithubMutationgh_abortRepositoryMigrationArgs = {
  input: gh_AbortRepositoryMigrationInput;
};


export type GithubMutationgh_acceptEnterpriseAdministratorInvitationArgs = {
  input: gh_AcceptEnterpriseAdministratorInvitationInput;
};


export type GithubMutationgh_acceptTopicSuggestionArgs = {
  input: gh_AcceptTopicSuggestionInput;
};


export type GithubMutationgh_addAssigneesToAssignableArgs = {
  input: gh_AddAssigneesToAssignableInput;
};


export type GithubMutationgh_addCommentArgs = {
  input: gh_AddCommentInput;
};


export type GithubMutationgh_addDiscussionCommentArgs = {
  input: gh_AddDiscussionCommentInput;
};


export type GithubMutationgh_addDiscussionPollVoteArgs = {
  input: gh_AddDiscussionPollVoteInput;
};


export type GithubMutationgh_addEnterpriseOrganizationMemberArgs = {
  input: gh_AddEnterpriseOrganizationMemberInput;
};


export type GithubMutationgh_addEnterpriseSupportEntitlementArgs = {
  input: gh_AddEnterpriseSupportEntitlementInput;
};


export type GithubMutationgh_addLabelsToLabelableArgs = {
  input: gh_AddLabelsToLabelableInput;
};


export type GithubMutationgh_addProjectCardArgs = {
  input: gh_AddProjectCardInput;
};


export type GithubMutationgh_addProjectColumnArgs = {
  input: gh_AddProjectColumnInput;
};


export type GithubMutationgh_addProjectV2DraftIssueArgs = {
  input: gh_AddProjectV2DraftIssueInput;
};


export type GithubMutationgh_addProjectV2ItemByIdArgs = {
  input: gh_AddProjectV2ItemByIdInput;
};


export type GithubMutationgh_addPullRequestReviewArgs = {
  input: gh_AddPullRequestReviewInput;
};


export type GithubMutationgh_addPullRequestReviewCommentArgs = {
  input: gh_AddPullRequestReviewCommentInput;
};


export type GithubMutationgh_addPullRequestReviewThreadArgs = {
  input: gh_AddPullRequestReviewThreadInput;
};


export type GithubMutationgh_addPullRequestReviewThreadReplyArgs = {
  input: gh_AddPullRequestReviewThreadReplyInput;
};


export type GithubMutationgh_addReactionArgs = {
  input: gh_AddReactionInput;
};


export type GithubMutationgh_addStarArgs = {
  input: gh_AddStarInput;
};


export type GithubMutationgh_addUpvoteArgs = {
  input: gh_AddUpvoteInput;
};


export type GithubMutationgh_addVerifiableDomainArgs = {
  input: gh_AddVerifiableDomainInput;
};


export type GithubMutationgh_approveDeploymentsArgs = {
  input: gh_ApproveDeploymentsInput;
};


export type GithubMutationgh_approveVerifiableDomainArgs = {
  input: gh_ApproveVerifiableDomainInput;
};


export type GithubMutationgh_archiveProjectV2ItemArgs = {
  input: gh_ArchiveProjectV2ItemInput;
};


export type GithubMutationgh_archiveRepositoryArgs = {
  input: gh_ArchiveRepositoryInput;
};


export type GithubMutationgh_cancelEnterpriseAdminInvitationArgs = {
  input: gh_CancelEnterpriseAdminInvitationInput;
};


export type GithubMutationgh_cancelSponsorshipArgs = {
  input: gh_CancelSponsorshipInput;
};


export type GithubMutationgh_changeUserStatusArgs = {
  input: gh_ChangeUserStatusInput;
};


export type GithubMutationgh_clearLabelsFromLabelableArgs = {
  input: gh_ClearLabelsFromLabelableInput;
};


export type GithubMutationgh_clearProjectV2ItemFieldValueArgs = {
  input: gh_ClearProjectV2ItemFieldValueInput;
};


export type GithubMutationgh_cloneProjectArgs = {
  input: gh_CloneProjectInput;
};


export type GithubMutationgh_cloneTemplateRepositoryArgs = {
  input: gh_CloneTemplateRepositoryInput;
};


export type GithubMutationgh_closeDiscussionArgs = {
  input: gh_CloseDiscussionInput;
};


export type GithubMutationgh_closeIssueArgs = {
  input: gh_CloseIssueInput;
};


export type GithubMutationgh_closePullRequestArgs = {
  input: gh_ClosePullRequestInput;
};


export type GithubMutationgh_convertProjectCardNoteToIssueArgs = {
  input: gh_ConvertProjectCardNoteToIssueInput;
};


export type GithubMutationgh_convertPullRequestToDraftArgs = {
  input: gh_ConvertPullRequestToDraftInput;
};


export type GithubMutationgh_copyProjectV2Args = {
  input: gh_CopyProjectV2Input;
};


export type GithubMutationgh_createAttributionInvitationArgs = {
  input: gh_CreateAttributionInvitationInput;
};


export type GithubMutationgh_createBranchProtectionRuleArgs = {
  input: gh_CreateBranchProtectionRuleInput;
};


export type GithubMutationgh_createCheckRunArgs = {
  input: gh_CreateCheckRunInput;
};


export type GithubMutationgh_createCheckSuiteArgs = {
  input: gh_CreateCheckSuiteInput;
};


export type GithubMutationgh_createCommitOnBranchArgs = {
  input: gh_CreateCommitOnBranchInput;
};


export type GithubMutationgh_createDeploymentArgs = {
  input: gh_CreateDeploymentInput;
};


export type GithubMutationgh_createDeploymentStatusArgs = {
  input: gh_CreateDeploymentStatusInput;
};


export type GithubMutationgh_createDiscussionArgs = {
  input: gh_CreateDiscussionInput;
};


export type GithubMutationgh_createEnterpriseOrganizationArgs = {
  input: gh_CreateEnterpriseOrganizationInput;
};


export type GithubMutationgh_createEnvironmentArgs = {
  input: gh_CreateEnvironmentInput;
};


export type GithubMutationgh_createIpAllowListEntryArgs = {
  input: gh_CreateIpAllowListEntryInput;
};


export type GithubMutationgh_createIssueArgs = {
  input: gh_CreateIssueInput;
};


export type GithubMutationgh_createLabelArgs = {
  input: gh_CreateLabelInput;
};


export type GithubMutationgh_createLinkedBranchArgs = {
  input: gh_CreateLinkedBranchInput;
};


export type GithubMutationgh_createMigrationSourceArgs = {
  input: gh_CreateMigrationSourceInput;
};


export type GithubMutationgh_createProjectArgs = {
  input: gh_CreateProjectInput;
};


export type GithubMutationgh_createProjectV2Args = {
  input: gh_CreateProjectV2Input;
};


export type GithubMutationgh_createProjectV2FieldArgs = {
  input: gh_CreateProjectV2FieldInput;
};


export type GithubMutationgh_createPullRequestArgs = {
  input: gh_CreatePullRequestInput;
};


export type GithubMutationgh_createRefArgs = {
  input: gh_CreateRefInput;
};


export type GithubMutationgh_createRepositoryArgs = {
  input: gh_CreateRepositoryInput;
};


export type GithubMutationgh_createRepositoryRulesetArgs = {
  input: gh_CreateRepositoryRulesetInput;
};


export type GithubMutationgh_createSponsorsListingArgs = {
  input: gh_CreateSponsorsListingInput;
};


export type GithubMutationgh_createSponsorsTierArgs = {
  input: gh_CreateSponsorsTierInput;
};


export type GithubMutationgh_createSponsorshipArgs = {
  input: gh_CreateSponsorshipInput;
};


export type GithubMutationgh_createSponsorshipsArgs = {
  input: gh_CreateSponsorshipsInput;
};


export type GithubMutationgh_createTeamDiscussionArgs = {
  input: gh_CreateTeamDiscussionInput;
};


export type GithubMutationgh_createTeamDiscussionCommentArgs = {
  input: gh_CreateTeamDiscussionCommentInput;
};


export type GithubMutationgh_createUserListArgs = {
  input: gh_CreateUserListInput;
};


export type GithubMutationgh_declineTopicSuggestionArgs = {
  input: gh_DeclineTopicSuggestionInput;
};


export type GithubMutationgh_deleteBranchProtectionRuleArgs = {
  input: gh_DeleteBranchProtectionRuleInput;
};


export type GithubMutationgh_deleteDeploymentArgs = {
  input: gh_DeleteDeploymentInput;
};


export type GithubMutationgh_deleteDiscussionArgs = {
  input: gh_DeleteDiscussionInput;
};


export type GithubMutationgh_deleteDiscussionCommentArgs = {
  input: gh_DeleteDiscussionCommentInput;
};


export type GithubMutationgh_deleteEnvironmentArgs = {
  input: gh_DeleteEnvironmentInput;
};


export type GithubMutationgh_deleteIpAllowListEntryArgs = {
  input: gh_DeleteIpAllowListEntryInput;
};


export type GithubMutationgh_deleteIssueArgs = {
  input: gh_DeleteIssueInput;
};


export type GithubMutationgh_deleteIssueCommentArgs = {
  input: gh_DeleteIssueCommentInput;
};


export type GithubMutationgh_deleteLabelArgs = {
  input: gh_DeleteLabelInput;
};


export type GithubMutationgh_deleteLinkedBranchArgs = {
  input: gh_DeleteLinkedBranchInput;
};


export type GithubMutationgh_deletePackageVersionArgs = {
  input: gh_DeletePackageVersionInput;
};


export type GithubMutationgh_deleteProjectArgs = {
  input: gh_DeleteProjectInput;
};


export type GithubMutationgh_deleteProjectCardArgs = {
  input: gh_DeleteProjectCardInput;
};


export type GithubMutationgh_deleteProjectColumnArgs = {
  input: gh_DeleteProjectColumnInput;
};


export type GithubMutationgh_deleteProjectV2Args = {
  input: gh_DeleteProjectV2Input;
};


export type GithubMutationgh_deleteProjectV2FieldArgs = {
  input: gh_DeleteProjectV2FieldInput;
};


export type GithubMutationgh_deleteProjectV2ItemArgs = {
  input: gh_DeleteProjectV2ItemInput;
};


export type GithubMutationgh_deleteProjectV2WorkflowArgs = {
  input: gh_DeleteProjectV2WorkflowInput;
};


export type GithubMutationgh_deletePullRequestReviewArgs = {
  input: gh_DeletePullRequestReviewInput;
};


export type GithubMutationgh_deletePullRequestReviewCommentArgs = {
  input: gh_DeletePullRequestReviewCommentInput;
};


export type GithubMutationgh_deleteRefArgs = {
  input: gh_DeleteRefInput;
};


export type GithubMutationgh_deleteRepositoryRulesetArgs = {
  input: gh_DeleteRepositoryRulesetInput;
};


export type GithubMutationgh_deleteTeamDiscussionArgs = {
  input: gh_DeleteTeamDiscussionInput;
};


export type GithubMutationgh_deleteTeamDiscussionCommentArgs = {
  input: gh_DeleteTeamDiscussionCommentInput;
};


export type GithubMutationgh_deleteUserListArgs = {
  input: gh_DeleteUserListInput;
};


export type GithubMutationgh_deleteVerifiableDomainArgs = {
  input: gh_DeleteVerifiableDomainInput;
};


export type GithubMutationgh_dequeuePullRequestArgs = {
  input: gh_DequeuePullRequestInput;
};


export type GithubMutationgh_disablePullRequestAutoMergeArgs = {
  input: gh_DisablePullRequestAutoMergeInput;
};


export type GithubMutationgh_dismissPullRequestReviewArgs = {
  input: gh_DismissPullRequestReviewInput;
};


export type GithubMutationgh_dismissRepositoryVulnerabilityAlertArgs = {
  input: gh_DismissRepositoryVulnerabilityAlertInput;
};


export type GithubMutationgh_enablePullRequestAutoMergeArgs = {
  input: gh_EnablePullRequestAutoMergeInput;
};


export type GithubMutationgh_enqueuePullRequestArgs = {
  input: gh_EnqueuePullRequestInput;
};


export type GithubMutationgh_followOrganizationArgs = {
  input: gh_FollowOrganizationInput;
};


export type GithubMutationgh_followUserArgs = {
  input: gh_FollowUserInput;
};


export type GithubMutationgh_grantEnterpriseOrganizationsMigratorRoleArgs = {
  input: gh_GrantEnterpriseOrganizationsMigratorRoleInput;
};


export type GithubMutationgh_grantMigratorRoleArgs = {
  input: gh_GrantMigratorRoleInput;
};


export type GithubMutationgh_importProjectArgs = {
  input: gh_ImportProjectInput;
};


export type GithubMutationgh_inviteEnterpriseAdminArgs = {
  input: gh_InviteEnterpriseAdminInput;
};


export type GithubMutationgh_linkProjectV2ToRepositoryArgs = {
  input: gh_LinkProjectV2ToRepositoryInput;
};


export type GithubMutationgh_linkProjectV2ToTeamArgs = {
  input: gh_LinkProjectV2ToTeamInput;
};


export type GithubMutationgh_linkRepositoryToProjectArgs = {
  input: gh_LinkRepositoryToProjectInput;
};


export type GithubMutationgh_lockLockableArgs = {
  input: gh_LockLockableInput;
};


export type GithubMutationgh_markDiscussionCommentAsAnswerArgs = {
  input: gh_MarkDiscussionCommentAsAnswerInput;
};


export type GithubMutationgh_markFileAsViewedArgs = {
  input: gh_MarkFileAsViewedInput;
};


export type GithubMutationgh_markProjectV2AsTemplateArgs = {
  input: gh_MarkProjectV2AsTemplateInput;
};


export type GithubMutationgh_markPullRequestReadyForReviewArgs = {
  input: gh_MarkPullRequestReadyForReviewInput;
};


export type GithubMutationgh_mergeBranchArgs = {
  input: gh_MergeBranchInput;
};


export type GithubMutationgh_mergePullRequestArgs = {
  input: gh_MergePullRequestInput;
};


export type GithubMutationgh_minimizeCommentArgs = {
  input: gh_MinimizeCommentInput;
};


export type GithubMutationgh_moveProjectCardArgs = {
  input: gh_MoveProjectCardInput;
};


export type GithubMutationgh_moveProjectColumnArgs = {
  input: gh_MoveProjectColumnInput;
};


export type GithubMutationgh_pinIssueArgs = {
  input: gh_PinIssueInput;
};


export type GithubMutationgh_publishSponsorsTierArgs = {
  input: gh_PublishSponsorsTierInput;
};


export type GithubMutationgh_regenerateEnterpriseIdentityProviderRecoveryCodesArgs = {
  input: gh_RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
};


export type GithubMutationgh_regenerateVerifiableDomainTokenArgs = {
  input: gh_RegenerateVerifiableDomainTokenInput;
};


export type GithubMutationgh_rejectDeploymentsArgs = {
  input: gh_RejectDeploymentsInput;
};


export type GithubMutationgh_removeAssigneesFromAssignableArgs = {
  input: gh_RemoveAssigneesFromAssignableInput;
};


export type GithubMutationgh_removeEnterpriseAdminArgs = {
  input: gh_RemoveEnterpriseAdminInput;
};


export type GithubMutationgh_removeEnterpriseIdentityProviderArgs = {
  input: gh_RemoveEnterpriseIdentityProviderInput;
};


export type GithubMutationgh_removeEnterpriseMemberArgs = {
  input: gh_RemoveEnterpriseMemberInput;
};


export type GithubMutationgh_removeEnterpriseOrganizationArgs = {
  input: gh_RemoveEnterpriseOrganizationInput;
};


export type GithubMutationgh_removeEnterpriseSupportEntitlementArgs = {
  input: gh_RemoveEnterpriseSupportEntitlementInput;
};


export type GithubMutationgh_removeLabelsFromLabelableArgs = {
  input: gh_RemoveLabelsFromLabelableInput;
};


export type GithubMutationgh_removeOutsideCollaboratorArgs = {
  input: gh_RemoveOutsideCollaboratorInput;
};


export type GithubMutationgh_removeReactionArgs = {
  input: gh_RemoveReactionInput;
};


export type GithubMutationgh_removeStarArgs = {
  input: gh_RemoveStarInput;
};


export type GithubMutationgh_removeUpvoteArgs = {
  input: gh_RemoveUpvoteInput;
};


export type GithubMutationgh_reopenDiscussionArgs = {
  input: gh_ReopenDiscussionInput;
};


export type GithubMutationgh_reopenIssueArgs = {
  input: gh_ReopenIssueInput;
};


export type GithubMutationgh_reopenPullRequestArgs = {
  input: gh_ReopenPullRequestInput;
};


export type GithubMutationgh_requestReviewsArgs = {
  input: gh_RequestReviewsInput;
};


export type GithubMutationgh_rerequestCheckSuiteArgs = {
  input: gh_RerequestCheckSuiteInput;
};


export type GithubMutationgh_resolveReviewThreadArgs = {
  input: gh_ResolveReviewThreadInput;
};


export type GithubMutationgh_retireSponsorsTierArgs = {
  input: gh_RetireSponsorsTierInput;
};


export type GithubMutationgh_revertPullRequestArgs = {
  input: gh_RevertPullRequestInput;
};


export type GithubMutationgh_revokeEnterpriseOrganizationsMigratorRoleArgs = {
  input: gh_RevokeEnterpriseOrganizationsMigratorRoleInput;
};


export type GithubMutationgh_revokeMigratorRoleArgs = {
  input: gh_RevokeMigratorRoleInput;
};


export type GithubMutationgh_setEnterpriseIdentityProviderArgs = {
  input: gh_SetEnterpriseIdentityProviderInput;
};


export type GithubMutationgh_setOrganizationInteractionLimitArgs = {
  input: gh_SetOrganizationInteractionLimitInput;
};


export type GithubMutationgh_setRepositoryInteractionLimitArgs = {
  input: gh_SetRepositoryInteractionLimitInput;
};


export type GithubMutationgh_setUserInteractionLimitArgs = {
  input: gh_SetUserInteractionLimitInput;
};


export type GithubMutationgh_startOrganizationMigrationArgs = {
  input: gh_StartOrganizationMigrationInput;
};


export type GithubMutationgh_startRepositoryMigrationArgs = {
  input: gh_StartRepositoryMigrationInput;
};


export type GithubMutationgh_submitPullRequestReviewArgs = {
  input: gh_SubmitPullRequestReviewInput;
};


export type GithubMutationgh_transferEnterpriseOrganizationArgs = {
  input: gh_TransferEnterpriseOrganizationInput;
};


export type GithubMutationgh_transferIssueArgs = {
  input: gh_TransferIssueInput;
};


export type GithubMutationgh_unarchiveProjectV2ItemArgs = {
  input: gh_UnarchiveProjectV2ItemInput;
};


export type GithubMutationgh_unarchiveRepositoryArgs = {
  input: gh_UnarchiveRepositoryInput;
};


export type GithubMutationgh_unfollowOrganizationArgs = {
  input: gh_UnfollowOrganizationInput;
};


export type GithubMutationgh_unfollowUserArgs = {
  input: gh_UnfollowUserInput;
};


export type GithubMutationgh_unlinkProjectV2FromRepositoryArgs = {
  input: gh_UnlinkProjectV2FromRepositoryInput;
};


export type GithubMutationgh_unlinkProjectV2FromTeamArgs = {
  input: gh_UnlinkProjectV2FromTeamInput;
};


export type GithubMutationgh_unlinkRepositoryFromProjectArgs = {
  input: gh_UnlinkRepositoryFromProjectInput;
};


export type GithubMutationgh_unlockLockableArgs = {
  input: gh_UnlockLockableInput;
};


export type GithubMutationgh_unmarkDiscussionCommentAsAnswerArgs = {
  input: gh_UnmarkDiscussionCommentAsAnswerInput;
};


export type GithubMutationgh_unmarkFileAsViewedArgs = {
  input: gh_UnmarkFileAsViewedInput;
};


export type GithubMutationgh_unmarkIssueAsDuplicateArgs = {
  input: gh_UnmarkIssueAsDuplicateInput;
};


export type GithubMutationgh_unmarkProjectV2AsTemplateArgs = {
  input: gh_UnmarkProjectV2AsTemplateInput;
};


export type GithubMutationgh_unminimizeCommentArgs = {
  input: gh_UnminimizeCommentInput;
};


export type GithubMutationgh_unpinIssueArgs = {
  input: gh_UnpinIssueInput;
};


export type GithubMutationgh_unresolveReviewThreadArgs = {
  input: gh_UnresolveReviewThreadInput;
};


export type GithubMutationgh_unsubscribeFromNotificationsArgs = {
  input: gh_UnsubscribeFromNotificationsInput;
};


export type GithubMutationgh_updateBranchProtectionRuleArgs = {
  input: gh_UpdateBranchProtectionRuleInput;
};


export type GithubMutationgh_updateCheckRunArgs = {
  input: gh_UpdateCheckRunInput;
};


export type GithubMutationgh_updateCheckSuitePreferencesArgs = {
  input: gh_UpdateCheckSuitePreferencesInput;
};


export type GithubMutationgh_updateDiscussionArgs = {
  input: gh_UpdateDiscussionInput;
};


export type GithubMutationgh_updateDiscussionCommentArgs = {
  input: gh_UpdateDiscussionCommentInput;
};


export type GithubMutationgh_updateEnterpriseAdministratorRoleArgs = {
  input: gh_UpdateEnterpriseAdministratorRoleInput;
};


export type GithubMutationgh_updateEnterpriseAllowPrivateRepositoryForkingSettingArgs = {
  input: gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
};


export type GithubMutationgh_updateEnterpriseDefaultRepositoryPermissionSettingArgs = {
  input: gh_UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
};


export type GithubMutationgh_updateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs = {
  input: gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
};


export type GithubMutationgh_updateEnterpriseMembersCanCreateRepositoriesSettingArgs = {
  input: gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
};


export type GithubMutationgh_updateEnterpriseMembersCanDeleteIssuesSettingArgs = {
  input: gh_UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
};


export type GithubMutationgh_updateEnterpriseMembersCanDeleteRepositoriesSettingArgs = {
  input: gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
};


export type GithubMutationgh_updateEnterpriseMembersCanInviteCollaboratorsSettingArgs = {
  input: gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
};


export type GithubMutationgh_updateEnterpriseMembersCanMakePurchasesSettingArgs = {
  input: gh_UpdateEnterpriseMembersCanMakePurchasesSettingInput;
};


export type GithubMutationgh_updateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs = {
  input: gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
};


export type GithubMutationgh_updateEnterpriseMembersCanViewDependencyInsightsSettingArgs = {
  input: gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
};


export type GithubMutationgh_updateEnterpriseOrganizationProjectsSettingArgs = {
  input: gh_UpdateEnterpriseOrganizationProjectsSettingInput;
};


export type GithubMutationgh_updateEnterpriseOwnerOrganizationRoleArgs = {
  input: gh_UpdateEnterpriseOwnerOrganizationRoleInput;
};


export type GithubMutationgh_updateEnterpriseProfileArgs = {
  input: gh_UpdateEnterpriseProfileInput;
};


export type GithubMutationgh_updateEnterpriseRepositoryProjectsSettingArgs = {
  input: gh_UpdateEnterpriseRepositoryProjectsSettingInput;
};


export type GithubMutationgh_updateEnterpriseTeamDiscussionsSettingArgs = {
  input: gh_UpdateEnterpriseTeamDiscussionsSettingInput;
};


export type GithubMutationgh_updateEnterpriseTwoFactorAuthenticationRequiredSettingArgs = {
  input: gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
};


export type GithubMutationgh_updateEnvironmentArgs = {
  input: gh_UpdateEnvironmentInput;
};


export type GithubMutationgh_updateIpAllowListEnabledSettingArgs = {
  input: gh_UpdateIpAllowListEnabledSettingInput;
};


export type GithubMutationgh_updateIpAllowListEntryArgs = {
  input: gh_UpdateIpAllowListEntryInput;
};


export type GithubMutationgh_updateIpAllowListForInstalledAppsEnabledSettingArgs = {
  input: gh_UpdateIpAllowListForInstalledAppsEnabledSettingInput;
};


export type GithubMutationgh_updateIssueArgs = {
  input: gh_UpdateIssueInput;
};


export type GithubMutationgh_updateIssueCommentArgs = {
  input: gh_UpdateIssueCommentInput;
};


export type GithubMutationgh_updateLabelArgs = {
  input: gh_UpdateLabelInput;
};


export type GithubMutationgh_updateNotificationRestrictionSettingArgs = {
  input: gh_UpdateNotificationRestrictionSettingInput;
};


export type GithubMutationgh_updateOrganizationAllowPrivateRepositoryForkingSettingArgs = {
  input: gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
};


export type GithubMutationgh_updateOrganizationWebCommitSignoffSettingArgs = {
  input: gh_UpdateOrganizationWebCommitSignoffSettingInput;
};


export type GithubMutationgh_updatePatreonSponsorabilityArgs = {
  input: gh_UpdatePatreonSponsorabilityInput;
};


export type GithubMutationgh_updateProjectArgs = {
  input: gh_UpdateProjectInput;
};


export type GithubMutationgh_updateProjectCardArgs = {
  input: gh_UpdateProjectCardInput;
};


export type GithubMutationgh_updateProjectColumnArgs = {
  input: gh_UpdateProjectColumnInput;
};


export type GithubMutationgh_updateProjectV2Args = {
  input: gh_UpdateProjectV2Input;
};


export type GithubMutationgh_updateProjectV2CollaboratorsArgs = {
  input: gh_UpdateProjectV2CollaboratorsInput;
};


export type GithubMutationgh_updateProjectV2DraftIssueArgs = {
  input: gh_UpdateProjectV2DraftIssueInput;
};


export type GithubMutationgh_updateProjectV2ItemFieldValueArgs = {
  input: gh_UpdateProjectV2ItemFieldValueInput;
};


export type GithubMutationgh_updateProjectV2ItemPositionArgs = {
  input: gh_UpdateProjectV2ItemPositionInput;
};


export type GithubMutationgh_updatePullRequestArgs = {
  input: gh_UpdatePullRequestInput;
};


export type GithubMutationgh_updatePullRequestBranchArgs = {
  input: gh_UpdatePullRequestBranchInput;
};


export type GithubMutationgh_updatePullRequestReviewArgs = {
  input: gh_UpdatePullRequestReviewInput;
};


export type GithubMutationgh_updatePullRequestReviewCommentArgs = {
  input: gh_UpdatePullRequestReviewCommentInput;
};


export type GithubMutationgh_updateRefArgs = {
  input: gh_UpdateRefInput;
};


export type GithubMutationgh_updateRefsArgs = {
  input: gh_UpdateRefsInput;
};


export type GithubMutationgh_updateRepositoryArgs = {
  input: gh_UpdateRepositoryInput;
};


export type GithubMutationgh_updateRepositoryRulesetArgs = {
  input: gh_UpdateRepositoryRulesetInput;
};


export type GithubMutationgh_updateRepositoryWebCommitSignoffSettingArgs = {
  input: gh_UpdateRepositoryWebCommitSignoffSettingInput;
};


export type GithubMutationgh_updateSponsorshipPreferencesArgs = {
  input: gh_UpdateSponsorshipPreferencesInput;
};


export type GithubMutationgh_updateSubscriptionArgs = {
  input: gh_UpdateSubscriptionInput;
};


export type GithubMutationgh_updateTeamDiscussionArgs = {
  input: gh_UpdateTeamDiscussionInput;
};


export type GithubMutationgh_updateTeamDiscussionCommentArgs = {
  input: gh_UpdateTeamDiscussionCommentInput;
};


export type GithubMutationgh_updateTeamReviewAssignmentArgs = {
  input: gh_UpdateTeamReviewAssignmentInput;
};


export type GithubMutationgh_updateTeamsRepositoryArgs = {
  input: gh_UpdateTeamsRepositoryInput;
};


export type GithubMutationgh_updateTopicsArgs = {
  input: gh_UpdateTopicsInput;
};


export type GithubMutationgh_updateUserListArgs = {
  input: gh_UpdateUserListInput;
};


export type GithubMutationgh_updateUserListsForItemArgs = {
  input: gh_UpdateUserListsForItemInput;
};


export type GithubMutationgh_verifyVerifiableDomainArgs = {
  input: gh_VerifyVerifiableDomainInput;
};

/** Enum of all the scopes that can be used with the @requireAuth directive. */
export type hn_Scope =
  | 'write_post'
  | 'write_series'
  | 'create_pro'
  | 'assign_pro_publications'
  | 'active_pro_user'
  | 'change_pro_subscription'
  | 'signup'
  | 'import_subscribers_to_publication'
  | 'acknowledge_email_import'
  | 'recommend_publications'
  | 'publication_admin'
  | 'webhook_admin'
  | 'update_post'
  | 'publish_draft'
  | 'publish_post'
  | 'publish_comment'
  | 'update_comment'
  | 'remove_comment'
  | 'publish_reply'
  | 'update_reply'
  | 'remove_reply';

/** SortOrder is a common enum for all types that can be sorted. */
export type hn_SortOrder =
  | 'asc'
  | 'dsc';

/** Node is a common interface for all types example User, Post, Comment, etc. */
export type hn_Node = {
  /** The ID of the node. */
  id: Scalars['ID']['output'];
};

/**
 * Connection to get list of items.
 * Returns a list of edges which contains the items and cursor to the last item of the previous page.
 * This is a common interface for all connections.
 */
export type hn_Connection = {
  /** A list of edges of items connection. */
  edges: Array<hn_Edge>;
  /** Information to aid in pagination. */
  pageInfo: hn_PageInfo;
};

/**
 * An edge that contains a node and cursor to the node.
 * This is a common interface for all edges.
 */
export type hn_Edge = {
  /** A node in the connection. */
  node: hn_Node;
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
};

/**
 * A Connection for page based pagination to get a list of items.
 * Returns a list of nodes which contains the items.
 * This is a common interface for all page connections.
 */
export type hn_PageConnection = {
  /** A list of edges of items connection. */
  nodes: Array<hn_Node>;
  /** Information to aid in pagination. */
  pageInfo: hn_OffsetPageInfo;
};

/** Common fields that describe a feature. */
export type hn_Feature = {
  /** Whether the feature is enabled or not. */
  isEnabled: Scalars['Boolean']['output'];
};

/** Contains information to help in pagination. */
export type hn_PageInfo = {
  /** Indicates if there are more pages. */
  hasNextPage?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The cursor of the last item in the current page.
   * Use it as the after input to query the next page.
   */
  endCursor?: Maybe<Scalars['String']['output']>;
};

/** Contains information to help in pagination for page based pagination. */
export type hn_OffsetPageInfo = {
  /** Indicates if there are more pages. */
  hasNextPage?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates if there are previous pages */
  hasPreviousPage?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The page before the current page.
   * Use it to build page navigation
   */
  previousPage?: Maybe<Scalars['Int']['output']>;
  /**
   * The page after the current page.
   * Use it to build page navigation
   */
  nextPage?: Maybe<Scalars['Int']['output']>;
};

export type hn_Content = {
  /** The Markdown version of the content. */
  markdown: Scalars['String']['output'];
  /** The HTML version of the content. */
  html: Scalars['String']['output'];
  /** The text version from sanitized html content. HTML tags are stripped and only text is returned. */
  text: Scalars['String']['output'];
};

/** Information to help in seo related meta tags. */
export type hn_SEO = {
  /** The title used in og:title tag for SEO purposes. */
  title?: Maybe<Scalars['String']['output']>;
  /** The description used in og:description tag for SEO purposes. */
  description?: Maybe<Scalars['String']['output']>;
};

/** Information to help in open graph related meta tags. */
export type hn_OpenGraphMetaData = {
  /** The image used in og:image tag for SEO purposes. */
  image?: Maybe<Scalars['String']['output']>;
};

/**
 * Connection for users to another user. Contains a list of nodes.
 * Each node is a user.
 * Page info contains information about pagination like hasNextPage and endCursor.
 */
export type hn_UserConnection = hn_PageConnection & {
  /** A list of users */
  nodes: Array<hn_User>;
  /** Information for page based pagination in users connection. */
  pageInfo: hn_OffsetPageInfo;
  /** The total number of documents in the connection. */
  totalDocuments: Scalars['Int']['output'];
};

/** Basic information about a user on Hashnode. */
export type hn_IUser = {
  /** The ID of the user. It can be used to identify the user. */
  id: Scalars['ID']['output'];
  /** The username of the user. It is unique and tied with user's profile URL. Example - https://hashnode.com/@username */
  username: Scalars['String']['output'];
  /** The name of the user. */
  name: Scalars['String']['output'];
  /** The bio of the user. Visible in about me section of the user's profile. */
  bio?: Maybe<hn_Content>;
  /** The URL to the profile picture of the user. */
  profilePicture?: Maybe<Scalars['String']['output']>;
  /** The social media links of the user. Shown on the user's profile. */
  socialMediaLinks?: Maybe<hn_SocialMediaLinks>;
  /** Returns a list of badges that the user has earned. Shown on blogs /badges page. Example - https://iamshadmirza.com/badges */
  badges: Array<hn_Badge>;
  /** Publications associated with the user. Includes personal and team publications. */
  publications: hn_UserPublicationsConnection;
  /** Returns the list of posts the user has published. */
  posts: hn_UserPostConnection;
  /** The number of users that follow the requested user. Visible in the user's profile. */
  followersCount: Scalars['Int']['output'];
  /** The number of users that this user is following. Visible in the user's profile. */
  followingsCount: Scalars['Int']['output'];
  /** The tagline of the user. Shown on the user's profile below the name. */
  tagline?: Maybe<Scalars['String']['output']>;
  /** The date the user joined Hashnode. */
  dateJoined?: Maybe<Scalars['DateTime']['output']>;
  /** The location of the user. */
  location?: Maybe<Scalars['String']['output']>;
  /** The availability of the user based on tech stack and interests. Shown on the "I am available for" section in user's profile. */
  availableFor?: Maybe<Scalars['String']['output']>;
  /** Returns a list of tags that the user follows. */
  tagsFollowing: Array<hn_Tag>;
  /** Whether or not the user is an ambassador. */
  ambassador: Scalars['Boolean']['output'];
  /** Whether or not the user is deactivated. */
  deactivated: Scalars['Boolean']['output'];
  /** The users who are following this user */
  followers: hn_UserConnection;
  /** The users which this user is following */
  follows: hn_UserConnection;
};


/** Basic information about a user on Hashnode. */
export type hn_IUserpublicationsArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<hn_UserPublicationsConnectionFilter>;
};


/** Basic information about a user on Hashnode. */
export type hn_IUserpostsArgs = {
  pageSize: Scalars['Int']['input'];
  page: Scalars['Int']['input'];
  sortBy?: InputMaybe<hn_UserPostsSort>;
  filter?: InputMaybe<hn_UserPostConnectionFilter>;
};


/** Basic information about a user on Hashnode. */
export type hn_IUserfollowersArgs = {
  pageSize: Scalars['Int']['input'];
  page: Scalars['Int']['input'];
};


/** Basic information about a user on Hashnode. */
export type hn_IUserfollowsArgs = {
  pageSize: Scalars['Int']['input'];
  page: Scalars['Int']['input'];
};

/** Basic information about a user on Hashnode. */
export type hn_User = hn_IUser & hn_Node & {
  /** The ID of the user. It can be used to identify the user. */
  id: Scalars['ID']['output'];
  /** The username of the user. It is unique and tied with user's profile URL. Example - https://hashnode.com/@username */
  username: Scalars['String']['output'];
  /** The name of the user. */
  name: Scalars['String']['output'];
  /** The bio of the user. Visible in about me section of the user's profile. */
  bio?: Maybe<hn_Content>;
  /**
   * The bio of the user. Visible in about me section of the user's profile.
   * @deprecated Will be removed on 26/10/2023. Use bio instead of bioV2
   */
  bioV2?: Maybe<hn_Content>;
  /** The URL to the profile picture of the user. */
  profilePicture?: Maybe<Scalars['String']['output']>;
  /** The social media links of the user. Shown on the user's profile. */
  socialMediaLinks?: Maybe<hn_SocialMediaLinks>;
  /** Returns a list of badges that the user has earned. Shown on blogs /badges page. Example - https://iamshadmirza.com/badges */
  badges: Array<hn_Badge>;
  /** Publications associated with the user. Includes personal and team publications. */
  publications: hn_UserPublicationsConnection;
  /** Returns the list of posts the user has published. */
  posts: hn_UserPostConnection;
  /** The number of users that follow the requested user. Visible in the user's profile. */
  followersCount: Scalars['Int']['output'];
  /** The number of users that this user is following. Visible in the user's profile. */
  followingsCount: Scalars['Int']['output'];
  /** The tagline of the user. Shown on the user's profile below the name. */
  tagline?: Maybe<Scalars['String']['output']>;
  /** The date the user joined Hashnode. */
  dateJoined?: Maybe<Scalars['DateTime']['output']>;
  /** The location of the user. */
  location?: Maybe<Scalars['String']['output']>;
  /** The availability of the user based on tech stack and interests. Shown on the "I am available for" section in user's profile. */
  availableFor?: Maybe<Scalars['String']['output']>;
  /** Returns a list of tags that the user follows. */
  tagsFollowing: Array<hn_Tag>;
  /**
   * Whether or not the user is an ambassador.
   * @deprecated Ambassadors program no longer active. Will be removed after 02/01/2024
   */
  ambassador: Scalars['Boolean']['output'];
  /** Whether or not the user is deactivated. */
  deactivated: Scalars['Boolean']['output'];
  /**
   * Wether or not the authenticated user follows this user.
   * Returns false if the authenticated user this user.
   */
  following: Scalars['Boolean']['output'];
  /**
   * Wether or not this user follows the authenticated user.
   * Returns false if the authenticated user this user.
   */
  followsBack: Scalars['Boolean']['output'];
  /** Wether or not this is a pro user. */
  isPro: Scalars['Boolean']['output'];
  /** The users who are following this user */
  followers: hn_UserConnection;
  /** The users which this user is following */
  follows: hn_UserConnection;
};


/** Basic information about a user on Hashnode. */
export type hn_UserpublicationsArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<hn_UserPublicationsConnectionFilter>;
};


/** Basic information about a user on Hashnode. */
export type hn_UserpostsArgs = {
  pageSize: Scalars['Int']['input'];
  page: Scalars['Int']['input'];
  sortBy?: InputMaybe<hn_UserPostsSort>;
  filter?: InputMaybe<hn_UserPostConnectionFilter>;
};


/** Basic information about a user on Hashnode. */
export type hn_UserfollowersArgs = {
  pageSize: Scalars['Int']['input'];
  page: Scalars['Int']['input'];
};


/** Basic information about a user on Hashnode. */
export type hn_UserfollowsArgs = {
  pageSize: Scalars['Int']['input'];
  page: Scalars['Int']['input'];
};

/**
 * Basic information about the authenticated user.
 * User must be authenticated to use this type.
 */
export type hn_MyUser = hn_IUser & hn_Node & {
  /** The ID of the user. It can be used to identify the user. */
  id: Scalars['ID']['output'];
  /** The username of the user. It is unique and tied with user's profile URL. Example - https://hashnode.com/@username */
  username: Scalars['String']['output'];
  /** The name of the user. */
  name: Scalars['String']['output'];
  /** The bio of the user. Visible in about me section of the user's profile. */
  bio?: Maybe<hn_Content>;
  /** The URL to the profile picture of the user. */
  profilePicture?: Maybe<Scalars['String']['output']>;
  /** The social media links of the user. Shown on the user's profile. */
  socialMediaLinks?: Maybe<hn_SocialMediaLinks>;
  /** Returns a list of badges that the user has earned. Shown on blogs /badges page. Example - https://iamshadmirza.com/badges */
  badges: Array<hn_Badge>;
  /** Publications associated with the user. Includes personal and team publications. */
  publications: hn_UserPublicationsConnection;
  /** Returns the list of posts the user has published. */
  posts: hn_UserPostConnection;
  /** The number of users that follow the requested user. Visible in the user's profile. */
  followersCount: Scalars['Int']['output'];
  /** The number of users that this user is following. Visible in the user's profile. */
  followingsCount: Scalars['Int']['output'];
  /** The tagline of the user. Shown on the user's profile below the name. */
  tagline?: Maybe<Scalars['String']['output']>;
  /** The date the user joined Hashnode. */
  dateJoined?: Maybe<Scalars['DateTime']['output']>;
  /** The location of the user. */
  location?: Maybe<Scalars['String']['output']>;
  /** The availability of the user based on tech stack and interests. Shown on the "I am available for" section in user's profile. */
  availableFor?: Maybe<Scalars['String']['output']>;
  /** Returns a list of tags that the user follows. */
  tagsFollowing: Array<hn_Tag>;
  /**
   * Whether or not the user is an ambassador.
   * @deprecated Ambassadors program no longer active. Will be removed after 02/01/2024
   */
  ambassador: Scalars['Boolean']['output'];
  provider?: Maybe<Scalars['String']['output']>;
  /** Whether or not the user is deactivated. */
  deactivated: Scalars['Boolean']['output'];
  /** A list of beta features that the user has access to. Only available to the authenticated user. */
  betaFeatures: Array<hn_BetaFeature>;
  /** Hashnode users are subscribed to a newsletter by default. This field can be used to unsubscribe from the newsletter. Only available to the authenticated user. */
  unsubscribeCode?: Maybe<Scalars['String']['output']>;
  /** Email address of the user. Only available to the authenticated user. */
  email?: Maybe<Scalars['String']['output']>;
  /** The users who are following this user */
  followers: hn_UserConnection;
  /** The users which this user is following */
  follows: hn_UserConnection;
};


/**
 * Basic information about the authenticated user.
 * User must be authenticated to use this type.
 */
export type hn_MyUserpublicationsArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<hn_UserPublicationsConnectionFilter>;
};


/**
 * Basic information about the authenticated user.
 * User must be authenticated to use this type.
 */
export type hn_MyUserpostsArgs = {
  pageSize: Scalars['Int']['input'];
  page: Scalars['Int']['input'];
  sortBy?: InputMaybe<hn_UserPostsSort>;
  filter?: InputMaybe<hn_UserPostConnectionFilter>;
};


/**
 * Basic information about the authenticated user.
 * User must be authenticated to use this type.
 */
export type hn_MyUserfollowersArgs = {
  pageSize: Scalars['Int']['input'];
  page: Scalars['Int']['input'];
};


/**
 * Basic information about the authenticated user.
 * User must be authenticated to use this type.
 */
export type hn_MyUserfollowsArgs = {
  pageSize: Scalars['Int']['input'];
  page: Scalars['Int']['input'];
};

/**
 * Connection to get list of publications.
 * Returns a list of edges which contains the publications and cursor to the last item of the previous page.
 */
export type hn_UserPublicationsConnection = hn_Connection & {
  /** A list of edges of publications connection. */
  edges: Array<hn_UserPublicationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: hn_PageInfo;
  /** The total amount of publications taking into account the filter. */
  totalDocuments: Scalars['Int']['output'];
};

/** An edge that contains a node of type publication and cursor to the node. */
export type hn_UserPublicationsEdge = hn_Edge & {
  /** Node containing the publication. */
  node: hn_Publication;
  /** The cursor to the node. */
  cursor: Scalars['String']['output'];
  /** The role of the user in the publication. */
  role: hn_UserPublicationRole;
};

/** The role of the user in the publication. */
export type hn_UserPublicationRole =
  /** The owner is the creator of the publication and can do all things, including delete publication. */
  | 'OWNER'
  /**
   * The editor has access to the publication dashboard to customize the blog and approve/reject posts.
   * They also have access to the member panel to add/modify/remove members. Editors cannot remove other editors or update their roles.
   */
  | 'EDITOR'
  /** Contributors can join the publication and contribute an article. They cannot directly publish a new article. */
  | 'CONTRIBUTOR';

/** Available social media links. */
export type hn_SocialMediaLinks = {
  /** The user's website. */
  website?: Maybe<Scalars['String']['output']>;
  /** The user's GitHub profile. */
  github?: Maybe<Scalars['String']['output']>;
  /** The user's Twitter profile. */
  twitter?: Maybe<Scalars['String']['output']>;
  /** The user's Instagram profile. */
  instagram?: Maybe<Scalars['String']['output']>;
  /** The user's Facebook profile. */
  facebook?: Maybe<Scalars['String']['output']>;
  /** The user's StackOverflow profile. */
  stackoverflow?: Maybe<Scalars['String']['output']>;
  /** The user's LinkedIn profile. */
  linkedin?: Maybe<Scalars['String']['output']>;
  /** The user's YouTube profile. */
  youtube?: Maybe<Scalars['String']['output']>;
};

/** A badge that the user has earned. */
export type hn_Badge = hn_Node & {
  /** The ID of the badge. */
  id: Scalars['ID']['output'];
  /** The name of the badge. */
  name: Scalars['String']['output'];
  /** The description of the badge. */
  description?: Maybe<Scalars['String']['output']>;
  /** The image of the badge. */
  image: Scalars['String']['output'];
  /** The date the badge was earned. */
  dateAssigned?: Maybe<Scalars['DateTime']['output']>;
  /** Link to badge page on Hashnode. */
  infoURL?: Maybe<Scalars['String']['output']>;
  /** A flag to determine if the badge is hidden. */
  suppressed?: Maybe<Scalars['Boolean']['output']>;
};

/** Filter to apply to the publications. */
export type hn_UserPublicationsConnectionFilter = {
  /** Only include publication in which the user has one of the provided roles. */
  roles?: InputMaybe<Array<hn_UserPublicationRole>>;
  /** Only return pro publications. */
  isPro?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Payload for the toggleFollowingUser mutation. */
export type hn_ToggleFollowUserPayload = {
  /** The user that was followed/unfollowed. */
  user?: Maybe<hn_User>;
};

/**
 * Connection to get list of top commenters. Contains a list of edges containing nodes.
 * Each node is a user who commented recently.
 * Page info contains information about pagination like hasNextPage and endCursor.
 */
export type hn_CommenterUserConnection = hn_Connection & {
  /** A list of edges of commenters. */
  edges: Array<hn_UserEdge>;
  /** Information to aid in pagination. */
  pageInfo: hn_PageInfo;
};

/** Contains a node of type user and cursor for pagination. */
export type hn_UserEdge = hn_Edge & {
  /** The node containing User information */
  node: hn_User;
  /** The cursor for use in pagination. */
  cursor: Scalars['String']['output'];
};

/** Filter for the posts of a user. */
export type hn_UserPostsAuthorTypeFilter =
  /** Only posts that are authored by the user. */
  | 'AUTHOR_ONLY'
  /** Only posts that are co-authored by the user. */
  | 'CO_AUTHOR_ONLY';

/** Sorting for the posts of a user. */
export type hn_UserPostsSort =
  /** Newest posts first. */
  | 'DATE_PUBLISHED_DESC'
  /** Oldest posts first. */
  | 'DATE_PUBLISHED_ASC';

/** Filter for the posts of a user. */
export type hn_UserPostConnectionFilter = {
  /**
   * Only include posts that reference the provided tag IDs.
   *
   *
   * Filtering by `tags` and `tagSlugs` will filter posts that match either of those two filters.
   */
  tags?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * Only include posts that reference the provided tag slugs.
   *
   * Filtering by `tags` and `tagSlugs` will filter posts that match either of those two filters.
   */
  tagSlugs?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Filtering by publication IDs will return posts from the author within the publication. */
  publications?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filtering by author status. Either all posts the user has authored or co-authored are returned or the authored posts only. */
  authorType?: InputMaybe<hn_UserPostsAuthorTypeFilter>;
};

/**
 * Contains basic information about the tag.
 * A tag is a label that categorizes posts with similar topics.
 */
export type hn_ITag = {
  /** The ID of the tag. */
  id: Scalars['ID']['output'];
  /** The name of the tag. Shown in tag page. */
  name: Scalars['String']['output'];
  /** The slug of the tag. Used to access tags feed.  Example https://hashnode.com/n/graphql */
  slug: Scalars['String']['output'];
  /** The logo of the tag. Shown in tag page. */
  logo?: Maybe<Scalars['String']['output']>;
  /** The tagline of the tag. */
  tagline?: Maybe<Scalars['String']['output']>;
  /** Information about the tag. Contains markdown html and text version of the tag's info. */
  info?: Maybe<hn_Content>;
  /** Total number of users following this tag. */
  followersCount: Scalars['Int']['output'];
  /** Alltime usage count of this tag in posts. */
  postsCount: Scalars['Int']['output'];
};

export type hn_Tag = hn_ITag & hn_Node & {
  /** The ID of the tag. */
  id: Scalars['ID']['output'];
  /** The name of the tag. Shown in tag page. */
  name: Scalars['String']['output'];
  /** The slug of the tag. Used to access tags feed.  Example https://hashnode.com/n/graphql */
  slug: Scalars['String']['output'];
  /** The logo of the tag. Shown in tag page. */
  logo?: Maybe<Scalars['String']['output']>;
  /** The tagline of the tag. */
  tagline?: Maybe<Scalars['String']['output']>;
  /** Information about the tag. Contains markdown html and text version of the tag's info. */
  info?: Maybe<hn_Content>;
  /** Total number of users following this tag. */
  followersCount: Scalars['Int']['output'];
  /** Alltime usage count of this tag in posts. */
  postsCount: Scalars['Int']['output'];
  /** Paginated list of posts published under this tag */
  posts: hn_FeedPostConnection;
};


export type hn_TagpostsArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  filter: hn_TagPostConnectionFilter;
};

/** Contains basic information about the tag returned by popularTags query. */
export type hn_PopularTag = hn_ITag & hn_Node & {
  /** The ID of the tag. */
  id: Scalars['ID']['output'];
  /** The name of the tag. Shown in tag page. */
  name: Scalars['String']['output'];
  /** The slug of the tag. Used to access tags feed.  Example https://hashnode.com/n/graphql */
  slug: Scalars['String']['output'];
  /** The logo of the tag. Shown in tag page. */
  logo?: Maybe<Scalars['String']['output']>;
  /** The tagline of the tag. */
  tagline?: Maybe<Scalars['String']['output']>;
  /** Information about the tag. Contains markdown html and text version of the tag's info. */
  info?: Maybe<hn_Content>;
  /** Total number of users following this tag. */
  followersCount: Scalars['Int']['output'];
  /** Alltime usage count of this tag in posts. */
  postsCount: Scalars['Int']['output'];
  /** The number of posts published in the given period that use this tag. */
  postsCountInPeriod: Scalars['Int']['output'];
};

/** The field by which to sort the tag feed. */
export type hn_TagPostsSort =
  /** Determinate how to sort the results. Defaults to recents, used in New tag feed. */
  | 'recent'
  /** Sorts by popularity, used in Hot tag feed. */
  | 'popular'
  /** Trending is particular used to fetch top posts trending within a week time under a tag */
  | 'trending';

export type hn_TagPostConnectionFilter = {
  /** Sort tag feed by recents, popular, or trending. Defaults to recents. */
  sortBy?: InputMaybe<hn_TagPostsSort>;
};

/** Contains a tag and a cursor for pagination. */
export type hn_PopularTagEdge = hn_Edge & {
  /** The node holding the Tag information */
  node: hn_PopularTag;
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
};

/** Contains a tag and a cursor for pagination. */
export type hn_TagEdge = hn_Edge & {
  /** The node holding the Tag information */
  node: hn_Tag;
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
};

/**
 * Contains basic information about the publication.
 * A publication is a blog that can be created for a user or a team.
 */
export type hn_Publication = hn_Node & {
  /** The ID of the publication. */
  id: Scalars['ID']['output'];
  /**
   * The title of the publication.
   * Title is used as logo if logo is not provided.
   */
  title: Scalars['String']['output'];
  /** The title of the publication. Shown in blog home page. */
  displayTitle?: Maybe<Scalars['String']['output']>;
  /** The description of the publication, used in og:description meta tag. Fall backs to Publication.about.text if no SEO description is provided. */
  descriptionSEO?: Maybe<Scalars['String']['output']>;
  /** The about section of the publication. */
  about?: Maybe<hn_Content>;
  /** The domain of the publication. Used to access publication. Example https://johndoe.com */
  url: Scalars['String']['output'];
  /** The canonical URL of the publication. */
  canonicalURL: Scalars['String']['output'];
  /** The author who owns the publication. */
  author: hn_User;
  /** The favicon of the publication. Used in browser tab. */
  favicon?: Maybe<Scalars['String']['output']>;
  /** Color code of the header color of the publication. Used to style header of blog. */
  headerColor?: Maybe<Scalars['String']['output']>;
  /** The meta tags associated with the publication. */
  metaTags?: Maybe<Scalars['String']['output']>;
  /** The integrations connected to the publication. */
  integrations?: Maybe<hn_PublicationIntegrations>;
  /** The publication preferences around layout, theme and other personalisations. */
  preferences: hn_Preferences;
  /** Total number of followers of the publication. */
  followersCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Summary of the contact information and information related to copyrights, usually used in German-speaking countries.
   * @deprecated Use `imprintV2` instead. Will be removed after 16/12/2023.
   */
  imprint?: Maybe<Scalars['String']['output']>;
  /** Summary of the contact information and information related to copyrights, usually used in German-speaking countries. */
  imprintV2?: Maybe<hn_Content>;
  /** True if the publication is a team publication and false otherwise. */
  isTeam: Scalars['Boolean']['output'];
  /** Links to the publication's social media profiles. */
  links?: Maybe<hn_PublicationLinks>;
  /** Domain information of the publication. */
  domainInfo: hn_DomainInfo;
  /** A flag to indicate if the publication is using Headless CMS. This can be used to check if the post redirect needs authentication. */
  isHeadless: Scalars['Boolean']['output'];
  /** Returns series by slug in the publication. */
  series?: Maybe<hn_Series>;
  /** Returns the list of series in the publication. */
  seriesList: hn_SeriesConnection;
  /** Returns the list of posts in the publication. */
  posts: hn_PublicationPostConnection;
  /** Returns the pinned post of the publication. */
  pinnedPost?: Maybe<hn_Post>;
  /** Returns the post with the given slug. */
  post?: Maybe<hn_Post>;
  /** Information about the publication's Open Graph metadata i.e. image. */
  ogMetaData: hn_OpenGraphMetaData;
  /** Object containing information about beta features enabled for the publication. */
  features: hn_PublicationFeatures;
  /** Returns the list of drafts in the publication. */
  drafts: hn_DraftConnection;
  /** Returns the scheduled drafts of the publication. */
  scheduledDrafts: hn_DraftConnection;
  /** Returns the static page with the given slug. */
  staticPage?: Maybe<hn_StaticPage>;
  /** Returns a list of static pages in the publication. */
  staticPages: hn_StaticPageConnection;
  /** Returns the list of submitted drafts in the publication. */
  submittedDrafts: hn_DraftConnection;
  /** Returns true if GitHub backup is configured and active and false otherwise. */
  isGitHubBackupEnabled: Scalars['Boolean']['output'];
  /** Determines the structure of the post URLs. */
  urlPattern: hn_UrlPattern;
  /** Returns the publication's email imports, used with newsletter feature. */
  emailImport?: Maybe<hn_EmailImport>;
  /** Configured redirection rules for the publication. */
  redirectionRules: Array<hn_RedirectionRule>;
  /** Whether the publication has earned any badges or not. */
  hasBadges: Scalars['Boolean']['output'];
  /** Contains the publication's sponsorships information. */
  sponsorship?: Maybe<hn_PublicationSponsorship>;
  /** Publications that are recommended by this publication. */
  recommendedPublications: Array<hn_UserRecommendedPublicationEdge>;
  /** The total amount of recommended publications by this publication. */
  totalRecommendedPublications: Scalars['Int']['output'];
  /** Publications that are recommending this publication. */
  recommendingPublications: hn_PublicationUserRecommendingPublicationConnection;
};


/**
 * Contains basic information about the publication.
 * A publication is a blog that can be created for a user or a team.
 */
export type hn_PublicationseriesArgs = {
  slug: Scalars['String']['input'];
};


/**
 * Contains basic information about the publication.
 * A publication is a blog that can be created for a user or a team.
 */
export type hn_PublicationseriesListArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
};


/**
 * Contains basic information about the publication.
 * A publication is a blog that can be created for a user or a team.
 */
export type hn_PublicationpostsArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<hn_PublicationPostConnectionFilter>;
};


/**
 * Contains basic information about the publication.
 * A publication is a blog that can be created for a user or a team.
 */
export type hn_PublicationpostArgs = {
  slug: Scalars['String']['input'];
};


/**
 * Contains basic information about the publication.
 * A publication is a blog that can be created for a user or a team.
 */
export type hn_PublicationdraftsArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<hn_PublicationDraftConnectionFilter>;
};


/**
 * Contains basic information about the publication.
 * A publication is a blog that can be created for a user or a team.
 */
export type hn_PublicationscheduledDraftsArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<hn_PublicationDraftConnectionFilter>;
};


/**
 * Contains basic information about the publication.
 * A publication is a blog that can be created for a user or a team.
 */
export type hn_PublicationstaticPageArgs = {
  slug: Scalars['String']['input'];
};


/**
 * Contains basic information about the publication.
 * A publication is a blog that can be created for a user or a team.
 */
export type hn_PublicationstaticPagesArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
};


/**
 * Contains basic information about the publication.
 * A publication is a blog that can be created for a user or a team.
 */
export type hn_PublicationsubmittedDraftsArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<hn_PublicationDraftConnectionFilter>;
};


/**
 * Contains basic information about the publication.
 * A publication is a blog that can be created for a user or a team.
 */
export type hn_PublicationrecommendingPublicationsArgs = {
  pageSize: Scalars['Int']['input'];
  page: Scalars['Int']['input'];
};

export type hn_UserRecommendedPublicationEdge = {
  /** The publication that is recommended by the publication this connection originates from. */
  node: hn_Publication;
  /** The amount of followers the publication referenced in `node` has gained by recommendations from the publication. */
  totalFollowersGained: Scalars['Int']['output'];
};

export type hn_PublicationUserRecommendingPublicationConnection = hn_PageConnection & {
  /** A list of edges containing Post information */
  edges: Array<hn_UserRecommendingPublicationEdge>;
  /** Publications recommending this publication. */
  nodes: Array<hn_Publication>;
  /** Information for page based pagination in Post connection. */
  pageInfo: hn_OffsetPageInfo;
  /** The total number of documents in the connection. */
  totalDocuments: Scalars['Int']['output'];
};

export type hn_UserRecommendingPublicationEdge = {
  /** The publication that is recommending the publication this connection originates from. */
  node: hn_Publication;
  /** The amount of followers the publication has gained by recommendations from the publication referenced in `node`. */
  totalFollowersGained: Scalars['Int']['output'];
};

export type hn_RSSImport = hn_Node & {
  id: Scalars['ID']['output'];
  /** The URL pointing to the RSS feed. */
  rssURL: Scalars['String']['output'];
};

/**
 * Contains the publication's Sponsorship information.
 * User can sponsor their favorite publications and pay them directly using Stripe.
 */
export type hn_PublicationSponsorship = {
  /**
   * The content shared by author of the publication to their sponsors.
   * This is used as note to inform that author is open for sponsorship.
   */
  content?: Maybe<hn_Content>;
  /** The Stripe configuration of the publication's Sponsorship. */
  stripe?: Maybe<hn_StripeConfiguration>;
};

/** Contains the publication's Stripe configuration. */
export type hn_StripeConfiguration = {
  /** A flag indicating if the publication is connected to Stripe. */
  connected: Scalars['Boolean']['output'];
  /** The Stripe account ID of the publication. */
  accountId?: Maybe<Scalars['String']['output']>;
  /** The country of origin of the publication. */
  country?: Maybe<Scalars['String']['output']>;
};

export type hn_RedirectionRule = {
  /** The type of the redirection rule. */
  type: hn_HttpRedirectionType;
  /** The source URL of the redirection rule. */
  source: Scalars['String']['output'];
  /** The destination URL of the redirection rule. */
  destination: Scalars['String']['output'];
};

export type hn_HttpRedirectionType =
  /** A temporary redirect that corresponds to the 307 HTTP status code. */
  | 'TEMPORARY'
  /** A permanent redirect that corresponds to the 308 HTTP status code. */
  | 'PERMANENT';

/**
 * Connection to get list of posts in publications.
 * Returns a list of edges which contains the posts in publication and cursor to the last item of the previous page.
 */
export type hn_PublicationPostConnectionFilter = {
  /**
   * Filtering by tag slugs and tag IDs will return posts that match either of the filters.
   *
   * It is an "OR" filter and not an "AND" filter.
   */
  tags?: InputMaybe<Array<Scalars['hn_ObjectId']['input']>>;
  /**
   * Filtering by tag slugs and tag IDs will return posts that match either of the filters.
   *
   * It is an "OR" filter and not an "AND" filter.
   */
  tagSlugs?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Remove pinned post from the result set. */
  excludePinnedPost?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * Connection to get list of drafts in publications.
 * Returns a list of edges which contains the drafts in publication and cursor to the last item of the previous page.
 */
export type hn_PublicationDraftConnectionFilter = {
  /** Search filter will be applied to the title of a draft */
  search?: InputMaybe<Scalars['String']['input']>;
};

/** Contains the publication's beta features. */
export type hn_PublicationFeatures = {
  /** Newsletter feature for the publication which adds a `/newsletter` route for collecting subscribers and allows sending out newsletters. */
  newsletter: hn_NewsletterFeature;
  /** Show the view count for blog posts. */
  viewCount: hn_ViewCountFeature;
  /** Show the read time for blog posts. */
  readTime: hn_ReadTimeFeature;
  /** Audio player for blog posts. */
  audioBlog: hn_AudioBlogFeature;
  /** Widget that shows up if a text on a blog post is selected. Allows for easy sharing or copying of the selected text. */
  textSelectionSharer: hn_TextSelectionSharerFeature;
  /** Individual styling for the publication. */
  customCSS: hn_CustomCSSFeature;
};

/**
 * Contains the flag indicating if the newsletter feature is enabled or not.
 * User can enable or disable the newsletter feature from the publication settings.
 * Shows a newsletter prompt on blog if enabled.
 */
export type hn_NewsletterFeature = hn_Feature & {
  /** A flag indicating if the newsletter feature is enabled or not. */
  isEnabled: Scalars['Boolean']['output'];
  frequency?: Maybe<hn_NewsletterFrequency>;
};

export type hn_NewsletterFrequency =
  | 'asap'
  | 'weekly';

/**
 * Contains the flag indicating if the view count feature is enabled or not.
 * User can enable or disable the view count feature from the publication settings.
 * Shows total views on blogs if enabled.
 */
export type hn_ViewCountFeature = hn_Feature & {
  /** A flag indicating if the view count feature is enabled or not. */
  isEnabled: Scalars['Boolean']['output'];
};

/**
 * Contains the flag indicating if the read time feature is enabled or not.
 * User can enable or disable the read time feature from the publication settings.
 * Shows read time on blogs if enabled.
 */
export type hn_ReadTimeFeature = hn_Feature & {
  /** A flag indicating if the read time feature is enabled or not. */
  isEnabled: Scalars['Boolean']['output'];
};

/**
 * Contains the flag indicating if the audio blog feature is enabled or not.
 * User can enable or disable the audio blog feature from the publication settings.
 * Shows audio player on blogs if enabled.
 */
export type hn_AudioBlogFeature = hn_Feature & {
  /** A flag indicating if the audio blog feature is enabled or not. */
  isEnabled: Scalars['Boolean']['output'];
  /** The voice type for the audio blog. */
  voiceType: hn_AudioBlogVoiceType;
};

/**
 * Contains the flag indicating if the text selection sharer feature is enabled or not.
 * User can enable or disable the text selection sharer feature from the publication settings.
 * Shows a widget if a text on a blog post is selected. Allows for easy sharing or copying of the selected text.
 */
export type hn_TextSelectionSharerFeature = hn_Feature & {
  /** A flag indicating if the text selection sharer feature is enabled or not. */
  isEnabled: Scalars['Boolean']['output'];
};

export type hn_CustomCSSFeature = hn_Feature & {
  /** A flag indicating if the custom CSS feature is enabled or not. */
  isEnabled: Scalars['Boolean']['output'];
  /** CSS that is live. */
  published?: Maybe<hn_CustomCSS>;
  /** CSS that is not published yet. */
  draft?: Maybe<hn_CustomCSS>;
};

export type hn_CustomCSS = {
  /** Custom CSS that will be applied on the publication homepage. */
  home?: Maybe<Scalars['String']['output']>;
  /** Custom CSS that will be applied on all posts of the publication. */
  post?: Maybe<Scalars['String']['output']>;
  /** Custom CSS that will be applied on all static pages of the publication. */
  static?: Maybe<Scalars['String']['output']>;
  /** The same as `home` but minified. */
  homeMinified?: Maybe<Scalars['String']['output']>;
  /** The same as `post` but minified. */
  postMinified?: Maybe<Scalars['String']['output']>;
  /** The same as `static` but minified. */
  staticMinified?: Maybe<Scalars['String']['output']>;
};

export type hn_UrlPattern =
  /** Post URLs contain the slug (for example `my slug`) and a random id (like `1234`) , e.g. "/my-slug-1234". */
  | 'DEFAULT'
  /** Post URLs only contain the slug, e.g. "/my-slug". */
  | 'SIMPLE';

/** Contains publication's layout choices. */
export type hn_PublicationLayout =
  /** Changes the layout of blog into stacked list of posts. */
  | 'stacked'
  /** Changes the layout of blog into grid 3 post cards per row. */
  | 'grid'
  /**
   * Changes the layout of blog into magazine style.
   * This is the newest layout.
   */
  | 'magazine';

/** Contains the publication's domain information. */
export type hn_DomainInfo = {
  /**
   * The subdomain of the publication on hashnode.dev.
   *
   * It will redirect to you custom domain if it is present and ready.
   */
  hashnodeSubdomain?: Maybe<Scalars['String']['output']>;
  /** The domain of the publication. */
  domain?: Maybe<hn_DomainStatus>;
  /** The www prefixed domain of the publication. Says if redirect to www domain is configured. */
  wwwPrefixedDomain?: Maybe<hn_DomainStatus>;
};

/** Contains the publication's domain status. */
export type hn_DomainStatus = {
  /** The host of the publication domain. */
  host: Scalars['String']['output'];
  /** A flag indicating if the publication domain is ready. */
  ready: Scalars['Boolean']['output'];
};

/** Contains the publication's preferences for layout, theme and other personalisations. */
export type hn_Preferences = {
  /** The publication's logo url. */
  logo?: Maybe<Scalars['String']['output']>;
  /** The publication's darkmode preferences. Can be used to load blog in dark mode by default and add a custom dark mode logo. */
  darkMode?: Maybe<hn_DarkModePreferences>;
  /** An object containing pages enabled for the publication. */
  enabledPages?: Maybe<hn_PagesPreferences>;
  /** The items in the publication's navigation bar. */
  navbarItems: Array<hn_PublicationNavbarItem>;
  /** The selected publication's layout, can be stacked, grid or magazine. */
  layout?: Maybe<hn_PublicationLayout>;
  /** A flag indicating if the hashnode's footer branding is disabled for the publication. */
  disableFooterBranding?: Maybe<Scalars['Boolean']['output']>;
  /** A flag indicating if subscription popup needs to be shown to be shown for the publication */
  isSubscriptionModalDisabled?: Maybe<Scalars['Boolean']['output']>;
};

/** Contains the publication's navbar items. */
export type hn_PublicationNavbarItem = {
  /** The unique identifier of the navbar item. */
  id: Scalars['ID']['output'];
  /** The label of the navbar item. */
  label?: Maybe<Scalars['String']['output']>;
  /** The URL of the navbar item. */
  url?: Maybe<Scalars['String']['output']>;
  /** The order of the navbar item. */
  priority?: Maybe<Scalars['Int']['output']>;
  /** The type of the navbar item, can be series, link or page. */
  type: hn_PublicationNavigationType;
  /** The series added to the navbar item. */
  series?: Maybe<hn_Series>;
  /** The static page added to the navbar item. */
  page?: Maybe<hn_StaticPage>;
};

/** The type of the navbar item, can be series, link or page. */
export type hn_PublicationNavigationType =
  /** The navbar item is a series. */
  | 'series'
  /** The navbar item is a link. */
  | 'link'
  /** The navbar item is a static page. */
  | 'page';

/**
 * Contains the preferences publication's autogenerated pages.
 * Used to enable or disable pages like badge, newsletter and members.
 */
export type hn_PagesPreferences = {
  /** A flag indicating if the publication's badge page is enabled. */
  badges?: Maybe<Scalars['Boolean']['output']>;
  /** A flag indicating if the publication's newsletter page is enabled. */
  newsletter?: Maybe<Scalars['Boolean']['output']>;
  /** A flag indicating if the publication's member page is enabled. */
  members?: Maybe<Scalars['Boolean']['output']>;
};

/** Contains the publication's dark mode preferences. */
export type hn_DarkModePreferences = {
  /** A flag indicating if the dark mode is enabled for the publication. */
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** The custom dark mode logo of the publication. */
  logo?: Maybe<Scalars['String']['output']>;
};

/**
 * Contains the publication's integrations.
 * Used to connect the publication with third party services like Google Analytics, Facebook Pixel, etc.
 */
export type hn_PublicationIntegrations = {
  /** FB Pixel ID for integration with Facebook Pixel. */
  fbPixelID?: Maybe<Scalars['String']['output']>;
  /** Fathom Analytics Site ID for integration with Fathom Analytics. */
  fathomSiteID?: Maybe<Scalars['String']['output']>;
  /** A flag indicating if the custom domain is enabled for integration with Fathom Analytics. */
  fathomCustomDomainEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Custom domain for integration with Fathom Analytics. */
  fathomCustomDomain?: Maybe<Scalars['String']['output']>;
  /** Hotjar Site ID for integration with Hotjar. */
  hotjarSiteID?: Maybe<Scalars['String']['output']>;
  /** Matomo Site ID for integration with Matomo Analytics. */
  matomoSiteID?: Maybe<Scalars['String']['output']>;
  /** Matomo URL for integration with Matomo Analytics. */
  matomoURL?: Maybe<Scalars['String']['output']>;
  /** Google Analytics Tracking ID for integration with Google Analytics. */
  gaTrackingID?: Maybe<Scalars['String']['output']>;
  /** A flag indicating if the custom domain is enabled for integration with Plausible Analytics. */
  plausibleAnalyticsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Web Monetization Payment Pointer for integration with Web Monetization. */
  wmPaymentPointer?: Maybe<Scalars['String']['output']>;
  /** The ID for the Hashnode-provided Umami analytics instance. */
  umamiWebsiteUUID?: Maybe<Scalars['String']['output']>;
  /** Google Tag Manager ID for integration with Google Tag Manager. */
  gTagManagerID?: Maybe<Scalars['String']['output']>;
};

/** Contains the publication's social media links. */
export type hn_PublicationLinks = {
  /** Twitter URL of the publication. */
  twitter?: Maybe<Scalars['String']['output']>;
  /** Instagram URL of the publication. */
  instagram?: Maybe<Scalars['String']['output']>;
  /** GitHub URL of the publication. */
  github?: Maybe<Scalars['String']['output']>;
  /** Website URL of the publication. */
  website?: Maybe<Scalars['String']['output']>;
  /** Hashnode profile of author of the publication. */
  hashnode?: Maybe<Scalars['String']['output']>;
  /** YouTube URL of the publication. */
  youtube?: Maybe<Scalars['String']['output']>;
  /** Daily.dev URL of the publication. */
  dailydev?: Maybe<Scalars['String']['output']>;
  /** LinkedIn URL of the publication. */
  linkedin?: Maybe<Scalars['String']['output']>;
  /** Mastodon URL of the publication. */
  mastodon?: Maybe<Scalars['String']['output']>;
};

/** The voice type for the audio blog. */
export type hn_AudioBlogVoiceType =
  /** Enum for the female voice type of the audio blog. */
  | 'FEMALE'
  /** Enum for the male voice type of the audio blog. */
  | 'MALE';

/** The status of the email import. */
export type hn_EmailImportStatus =
  /** Import has been initialized but is not yet in progress. */
  | 'INITIALIZED'
  /** Import is in progress. */
  | 'IN_PROGRESS'
  /** Import has to be reviewed by Hashnode. It is not yet reviewed. */
  | 'IN_REVIEW'
  /** Import was successful. New emails have been imported. */
  | 'SUCCESS'
  /** There was an error during the import. */
  | 'FAILED'
  /** The has been rejected. Nothing has been imported. */
  | 'REJECTED'
  /** The import has been acknowledged by the user. */
  | 'FINISHED';

/** Contains information about the email import. */
export type hn_EmailImport = {
  /** Contains information about the current import example if it is in progress or has finished, date started, etc */
  currentImport?: Maybe<hn_EmailCurrentImport>;
};

/** The input for the email import acknowledgement mutation. */
export type hn_EmailCurrentImport = {
  /** The status of the import */
  status: hn_EmailImportStatus;
  /** The date the import started */
  importStartedAt: Scalars['DateTime']['output'];
  /** The number of subscribers that have been successfully imported */
  successfullyImported?: Maybe<Scalars['Int']['output']>;
  /** The number of subscribers that have attempted to import */
  attemptedToImport?: Maybe<Scalars['Int']['output']>;
  /** The filename of the csv file containing emails */
  filename?: Maybe<Scalars['String']['output']>;
};

/** Contains a publication and a cursor for pagination. */
export type hn_RecommendedPublicationEdge = hn_Edge & {
  /** The node holding the Publication information */
  node: hn_Publication;
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
};

export type hn_SubscribeToNewsletterInput = {
  /** The ID of the publication to subscribe to. */
  publicationId: Scalars['hn_ObjectId']['input'];
  /** The email of the subscriber. */
  email: Scalars['String']['input'];
};

export type hn_UnsubscribeFromNewsletterInput = {
  /** The ID of the publication to unsubscribe from. */
  publicationId: Scalars['hn_ObjectId']['input'];
  /** The email that is currently subscribed. */
  email: Scalars['String']['input'];
};

export type hn_NewsletterSubscribeStatus =
  | 'PENDING';

export type hn_SubscribeToNewsletterPayload = {
  status?: Maybe<hn_NewsletterSubscribeStatus>;
};

export type hn_NewsletterUnsubscribeStatus =
  | 'UNSUBSCRIBED';

export type hn_UnsubscribeFromNewsletterPayload = {
  status?: Maybe<hn_NewsletterUnsubscribeStatus>;
};

/**
 * Contains basic information about the post.
 * A post is a published article on Hashnode.
 */
export type hn_Post = hn_Node & {
  /** The ID of the post. Used to uniquely identify the post. */
  id: Scalars['ID']['output'];
  /** The slug of the post. Used as address of the post on blog. Example - https://johndoe.com/my-post-slug */
  slug: Scalars['String']['output'];
  /** The title of the post. */
  title: Scalars['String']['output'];
  /** The subtitle of the post. Subtitle is a short description of the post which is also used in SEO if meta tags are not provided. */
  subtitle?: Maybe<Scalars['String']['output']>;
  /** Returns the user details of the author of the post. */
  author: hn_User;
  /**
   * Returns the user details of the co-authors of the post.
   * Hashnode users can add up to 4 co-authors as collaborators to their posts.
   * This functionality is limited to teams publication.
   */
  coAuthors?: Maybe<Array<hn_User>>;
  /** Returns list of tags added to the post. Contains tag id, name, slug, etc. */
  tags?: Maybe<Array<hn_Tag>>;
  /** Complete URL of the post including the domain name. Example - https://johndoe.com/my-post-slug */
  url: Scalars['String']['output'];
  /** Canonical URL set by author in case of republished posts. */
  canonicalUrl?: Maybe<Scalars['String']['output']>;
  /** The publication the post belongs to. */
  publication?: Maybe<hn_Publication>;
  /** Unique ID to identify post, used internally by hashnode. */
  cuid?: Maybe<Scalars['String']['output']>;
  /** The cover image preference of the post. Contains cover image URL and other details. */
  coverImage?: Maybe<hn_PostCoverImage>;
  /** Brief is a short description of the post extracted from the content of the post. It's 250 characters long sanitized string. */
  brief: Scalars['String']['output'];
  /** The estimated time to read the post in minutes. */
  readTimeInMinutes: Scalars['Int']['output'];
  /** The number of views on the post. Can be used to show the popularity of the post. */
  views: Scalars['Int']['output'];
  /** Information of the series the post belongs to. */
  series?: Maybe<hn_Series>;
  /** The number of hearts on the post. Shows how many users liked the post. */
  reactionCount: Scalars['Int']['output'];
  /** The number of replies on the post. */
  replyCount: Scalars['Int']['output'];
  /** The number of comments on the post. */
  responseCount: Scalars['Int']['output'];
  /** Flag to indicate if the post is featured on Hashnode feed. */
  featured: Scalars['Boolean']['output'];
  /**
   * A list of contributors of the post. Contributors are users who have commented or replied to the post.
   * @deprecated Will be removed on 10th Oct 2023. Use `commenters` instead.
   */
  contributors: Array<hn_User>;
  /** List of users who have commented on the post. */
  commenters: hn_PostCommenterConnection;
  /** A list of comments on the post. */
  comments: hn_PostCommentConnection;
  /**
   * Flag to indicate if the post is bookmarked by the requesting user.
   *
   * Returns `false` if the user is not authenticated.
   */
  bookmarked: Scalars['Boolean']['output'];
  /** Content of the post. Contains HTML and Markdown version of the post content. */
  content: hn_Content;
  /** A list of users who liked the post. */
  likedBy: hn_PostLikerConnection;
  /** The date and time the post was featured. Used along with featured flag to determine if the post is featured. */
  featuredAt?: Maybe<Scalars['DateTime']['output']>;
  /** The date and time the post was published. */
  publishedAt: Scalars['DateTime']['output'];
  /** The date and time the post was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Preference settings for the post. Contains information about if the post is pinned to blog, comments are disabled, etc. */
  preferences: hn_PostPreferences;
  /** Returns male and female audio url of the post. Available in case the Audioblog is enabled. */
  audioUrls?: Maybe<hn_AudioUrls>;
  /** SEO information of the post. Contains title and description used in meta tags. */
  seo?: Maybe<hn_SEO>;
  /** OG meta-data of the post. Contains image url used in open graph meta tags. */
  ogMetaData?: Maybe<hn_OpenGraphMetaData>;
  /** A flag to indicate if the post contains LaTeX. Latex is used to write mathematical equations. */
  hasLatexInPost: Scalars['Boolean']['output'];
  /**
   * Wether or not the authenticated user is following this post.
   *
   * Returns `null` if the user is not authenticated.
   */
  isFollowed?: Maybe<Scalars['Boolean']['output']>;
  /** Wether or not the post has automatically been published via RSS feed. */
  isAutoPublishedFromRSS: Scalars['Boolean']['output'];
  /** Post feature-related fields. */
  features: hn_PostFeatures;
};


/**
 * Contains basic information about the post.
 * A post is a published article on Hashnode.
 */
export type hn_PostcommentersArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<hn_PostCommenterSortBy>;
};


/**
 * Contains basic information about the post.
 * A post is a published article on Hashnode.
 */
export type hn_PostcommentsArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<hn_PostCommentSortBy>;
};


/**
 * Contains basic information about the post.
 * A post is a published article on Hashnode.
 */
export type hn_PostlikedByArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<hn_PostLikerFilter>;
};

export type hn_PostFeatures = {
  tableOfContents: hn_TableOfContentsFeature;
  badges: hn_PostBadgesFeature;
};

export type hn_TableOfContentsFeature = hn_Feature & {
  /** Wether or not ser has chosen to show a table of contents on the post. */
  isEnabled: Scalars['Boolean']['output'];
  /** The content of the table of contents. */
  items: Array<hn_TableOfContentsItem>;
};

export type hn_PostBadgesFeature = hn_Feature & {
  /** Wether or not the user has chosen to show badges on the post. */
  isEnabled: Scalars['Boolean']['output'];
  items: Array<hn_PostBadge>;
};

export type hn_TableOfContentsItem = hn_Node & {
  /** Unique identifier. */
  id: Scalars['ID']['output'];
  /** The level of nesting. Refers to the heading level in the post. */
  level: Scalars['Int']['output'];
  /** The slug of the referenced headline. */
  slug: Scalars['String']['output'];
  /** The title of the referenced headline. */
  title: Scalars['String']['output'];
  /** ID of the `TableOfContentsItem` that is one level higher in the hierarchy. `null` if this is a top level item. */
  parentId?: Maybe<Scalars['ID']['output']>;
};

export type hn_PostBadge = hn_Node & {
  /** Unique identifier. */
  id: Scalars['ID']['output'];
  /** The type of the badge. */
  type: hn_PostBadgeType;
};

export type hn_PostBadgeType =
  | 'FEATURED_HASHNODE'
  | 'FEATURED_DAILY_DOT_DEV';

export type hn_PostLikerFilter = {
  /** Only return likes from users with the given user IDs. */
  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Used when Audioblog feature is enabled. Contains URLs to the audioblog of the post. */
export type hn_AudioUrls = {
  /** Male version of audio url of the post. */
  male?: Maybe<Scalars['String']['output']>;
  /** Female version of audio url of the post. */
  female?: Maybe<Scalars['String']['output']>;
};

/** Contains Post preferences. Used to determine if the post is pinned to blog, comments are disabled, or cover image is sticked to bottom. */
export type hn_PostPreferences = {
  /** A flag to indicate if the post is pinned to blog. Pinned post is shown on top of the blog. */
  pinnedToBlog: Scalars['Boolean']['output'];
  /** A flag to indicate if the comments are disabled for the post. */
  disableComments: Scalars['Boolean']['output'];
  /** A flag to indicate if the cover image is shown below title of the post. Default position of cover is top of title. */
  stickCoverToBottom: Scalars['Boolean']['output'];
  /** Wether or not the post is hidden from the Hashnode community. */
  isDelisted: Scalars['Boolean']['output'];
};

/** Sorting options for commenters. Used to sort commenters by popularity or recency. */
export type hn_PostCommenterSortBy =
  /** Sorts commenters by popularity. */
  | 'POPULAR'
  /** Sorts commenters by recency. */
  | 'RECENT';

/**
 * Connection for commenters (users). Contains a list of edges containing nodes.
 * Each node holds commenter.
 * Page info contains information about pagination like hasNextPage and endCursor.
 * Total documents contains the total number of commenters.
 */
export type hn_PostCommenterConnection = hn_Connection & {
  /** A list of edges containing commenters as nodes. */
  edges: Array<hn_PostCommenterEdge>;
  /** Information about pagination in a connection. */
  pageInfo: hn_PageInfo;
  /** Total number of nodes available i.e. number of commenters. */
  totalDocuments: Scalars['Int']['output'];
};

/** A commenter on the post. Contains information about the user who commented. */
export type hn_PostCommenterEdge = hn_Edge & {
  /** The commenter on the post. */
  node: hn_User;
  /** The cursor for this node used for pagination. */
  cursor: Scalars['String']['output'];
};

/** Sorting options for comments. Used to sort comments by top or recent. */
export type hn_PostCommentSortBy =
  /** Sorts comments by popularity. */
  | 'TOP'
  /** Sorts comments by recency. */
  | 'RECENT';

/**
 * Connection for comments. Contains a list of edges containing nodes.
 * Each node holds a comment.
 * Page info contains information about pagination like hasNextPage and endCursor.
 * Total documents contains the total number of comments.
 */
export type hn_PostCommentConnection = hn_Connection & {
  /** A list of edges containing comments as nodes. */
  edges: Array<hn_PostCommentEdge>;
  /** Information about pagination in a connection. */
  pageInfo: hn_PageInfo;
  /** Total number of nodes available i.e. number of comments. */
  totalDocuments: Scalars['Int']['output'];
};

/** A comment on the post. Contains information about the content of the comment, user who commented, etc. */
export type hn_PostCommentEdge = hn_Edge & {
  /** The comment on the post. */
  node: hn_Comment;
  /** The cursor for this node used for pagination. */
  cursor: Scalars['String']['output'];
};

/** A user who liked the post. Contains information about the user and number of reactions added by the user. */
export type hn_PostLikerEdge = hn_Edge & {
  /** The user who liked the post. */
  node: hn_User;
  /** The cursor for this node used for pagination. */
  cursor: Scalars['String']['output'];
  /** The number of reaction added by the user. */
  reactionCount: Scalars['Int']['output'];
};

/**
 * Connection for users who liked the post. Contains a list of edges containing nodes.
 * Each node is a user who liked the post.
 * Page info contains information about pagination like hasNextPage and endCursor.
 * Total documents contains the total number of users who liked the post.
 */
export type hn_PostLikerConnection = hn_Connection & {
  /** A list of edges containing users as nodes */
  edges: Array<hn_PostLikerEdge>;
  /** Information about pagination in a connection. */
  pageInfo: hn_PageInfo;
  /** Total number of nodes available i.e. number of users who liked the post. */
  totalDocuments: Scalars['Int']['output'];
};

/** Contains information about the cover image of the post. */
export type hn_PostCoverImage = {
  /** The URL of the cover image. */
  url: Scalars['String']['output'];
  /** Indicates whether the cover image is in portrait orientation. */
  isPortrait: Scalars['Boolean']['output'];
  /** Provides attribution information for the cover image, if available. */
  attribution?: Maybe<Scalars['String']['output']>;
  /** The name of the photographer who captured the cover image. */
  photographer?: Maybe<Scalars['String']['output']>;
  /** True if the image attribution should be hidden. */
  isAttributionHidden: Scalars['Boolean']['output'];
};

/** Contains a post and a cursor for pagination. */
export type hn_PostEdge = hn_Edge & {
  /** The node holding the Post information */
  node: hn_Post;
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
};

/** The author type of a post from a user's perspective */
export type hn_PostAuthorType =
  /** The user has authored the post. */
  | 'AUTHOR'
  /** The user is a co-author of post. */
  | 'CO_AUTHOR';

/** Contains a post and the author status. */
export type hn_UserPostEdge = {
  /** The node holding the Post information. */
  node: hn_Post;
  /** Indicates weather the user is the author or co-author of the post. */
  authorType: hn_PostAuthorType;
};

/**
 * Connection for posts within a feed. Contains a list of edges containing nodes.
 * Each node is a post.
 * Page info contains information about pagination like hasNextPage and endCursor.
 */
export type hn_FeedPostConnection = hn_Connection & {
  /** A list of edges containing Post information */
  edges: Array<hn_PostEdge>;
  /** Information for pagination in Post connection. */
  pageInfo: hn_PageInfo;
};

/**
 * Connection for posts within a publication search. Contains a list of edges containing nodes.
 * Each node is a post.
 * Page info contains information about pagination like hasNextPage and endCursor.
 */
export type hn_SearchPostConnection = hn_Connection & {
  /** A list of edges containing Post information */
  edges: Array<hn_PostEdge>;
  /** Information for pagination in Post connection. */
  pageInfo: hn_PageInfo;
};

/**
 * Connection for posts within a series. Contains a list of edges containing nodes.
 * Each node is a post.
 * Page info contains information about pagination like hasNextPage and endCursor.
 */
export type hn_SeriesPostConnection = hn_Connection & {
  /** A list of edges containing Post information */
  edges: Array<hn_PostEdge>;
  /** Information for pagination in Post connection. */
  pageInfo: hn_PageInfo;
  /** The total number of documents in the connection. */
  totalDocuments: Scalars['Int']['output'];
};

/**
 * Connection for posts within a publication. Contains a list of edges containing nodes.
 * Each node is a post.
 * Page info contains information about pagination like hasNextPage and endCursor.
 */
export type hn_PublicationPostConnection = hn_Connection & {
  /** A list of edges containing Post information */
  edges: Array<hn_PostEdge>;
  /** Information for pagination in Post connection. */
  pageInfo: hn_PageInfo;
  /** The total number of documents in the connection. */
  totalDocuments: Scalars['Int']['output'];
};

/**
 * Connection for posts written by a single user. Contains a list of edges containing nodes.
 * Each node is a post.
 * Page info contains information about pagination like hasNextPage and endCursor.
 */
export type hn_UserPostConnection = hn_PageConnection & {
  /** A list of edges containing Post information */
  edges: Array<hn_UserPostEdge>;
  /** A list of posts */
  nodes: Array<hn_Post>;
  /** Information for page based pagination in Post connection. */
  pageInfo: hn_OffsetPageInfo;
  /** The total number of documents in the connection. */
  totalDocuments: Scalars['Int']['output'];
};

export type hn_PublishPostPayload = {
  post?: Maybe<hn_Post>;
};

export type hn_UpdatePostPayload = {
  post?: Maybe<hn_Post>;
};

export type hn_RemovePostPayload = {
  /** The deleted post. */
  post?: Maybe<hn_Post>;
};

export type hn_RemovePostInput = {
  /** The ID of the post to remove. */
  id: Scalars['ID']['input'];
};

/** Contains information about cover image options of the post. Like URL of the cover image, attribution, etc. */
export type hn_CoverImageOptionsInput = {
  /** The URL of the cover image. */
  coverImageURL?: InputMaybe<Scalars['String']['input']>;
  /** A flag to indicate if the cover attribution is hidden, used when cover was chosen from unsplash. */
  isCoverAttributionHidden?: InputMaybe<Scalars['Boolean']['input']>;
  /** Information about the cover image attribution. */
  coverImageAttribution?: InputMaybe<Scalars['String']['input']>;
  /** The name of the cover image photographer, used when cover was chosen from unsplash. */
  coverImagePhotographer?: InputMaybe<Scalars['String']['input']>;
  /** A flag to indicate if the cover image is sticked to bottom. */
  stickCoverToBottom?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Contains information about meta tags of the post. Used for SEO purpose. */
export type hn_MetaTagsInput = {
  /** The title of the post used in og:title for SEO. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The description of the post used in og:description for SEO. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The image URL of the post used in og:image for SEO. */
  image?: InputMaybe<Scalars['String']['input']>;
};

export type hn_PublishPostTagInput = {
  /**
   * A tag id that is referencing an existing tag.
   *
   * Either this or name and slug should be provided. If both are provided, the id will be used.
   */
  id?: InputMaybe<Scalars['hn_ObjectId']['input']>;
  /**
   * A slug of a new tag to create.
   *
   * Either this and name or id should be provided. If both are provided, the id will be used.
   */
  slug?: InputMaybe<Scalars['String']['input']>;
  /**
   * A name of a new tag to create.
   *
   * Either this and slug or id should be provided. If both are provided, the id will be used.
   */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type hn_UpdatePostSettingsInput = {
  /** A flag to indicate if the post contains table of content */
  isTableOfContentEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** A flag to indicate if the post is delisted, used to hide the post from public feed. */
  delisted?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not comments should be disabled. */
  disableComments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Pin the post to the blog homepage. */
  pinToBlog?: InputMaybe<Scalars['Boolean']['input']>;
};

export type hn_PublishPostSettingsInput = {
  /** A flag to indicate if the post is scheduled. */
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  /** A flag to indicate if the post contains table of content */
  enableTableOfContent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Flag to indicate if the slug is overridden by the user. */
  slugOverridden?: InputMaybe<Scalars['Boolean']['input']>;
  /** Wether to send a newsletter for this post. */
  isNewsletterActivated?: InputMaybe<Scalars['Boolean']['input']>;
  /** A flag to indicate if the post is delisted, used to hide the post from public feed. */
  delisted?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Contains information about the post to be published. */
export type hn_PublishPostInput = {
  /** The title of the post. */
  title: Scalars['String']['input'];
  /** The subtitle of the post. */
  subtitle?: InputMaybe<Scalars['String']['input']>;
  /** The ID of publication the post belongs to. */
  publicationId: Scalars['hn_ObjectId']['input'];
  /** Content of the post in markdown format. */
  contentMarkdown: Scalars['String']['input'];
  /** Date when the post is published. */
  publishedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Options for the cover image of the post. */
  coverImageOptions?: InputMaybe<hn_CoverImageOptionsInput>;
  /** Slug of the post. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the original article if the post is imported from an external source. */
  originalArticleURL?: InputMaybe<Scalars['String']['input']>;
  /** A list of tags added to the post. */
  tags: Array<hn_PublishPostTagInput>;
  /** A flag to indicate if the comments are disabled for the post. */
  disableComments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Information about the meta tags added to the post, used for SEO purpose. */
  metaTags?: InputMaybe<hn_MetaTagsInput>;
  /**
   * Publish the post on behalf of another user who is a member of the publication.
   *
   * Only applicable for team publications.
   */
  publishAs?: InputMaybe<Scalars['hn_ObjectId']['input']>;
  /** Providing a seriesId will add the post to that series. */
  seriesId?: InputMaybe<Scalars['hn_ObjectId']['input']>;
  /** Settings for the post like table of contents and newsletter activation. */
  settings?: InputMaybe<hn_PublishPostSettingsInput>;
  /** Ids of the co-authors of the post. */
  coAuthors?: InputMaybe<Array<Scalars['hn_ObjectId']['input']>>;
};

export type hn_UpdatePostInput = {
  /** The id of the post to update. */
  id: Scalars['ID']['input'];
  /** The new title of the post */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The subtitle of the post */
  subtitle?: InputMaybe<Scalars['String']['input']>;
  /** The publication the post is published to. */
  contentMarkdown?: InputMaybe<Scalars['String']['input']>;
  /** Backdated publish date. */
  publishedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Options for the cover image of the post. */
  coverImageOptions?: InputMaybe<hn_CoverImageOptionsInput>;
  /** Slug of the post. Only if you want to override the slug that will be generated based on the title. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** Canonical URL of the original article. */
  originalArticleURL?: InputMaybe<Scalars['String']['input']>;
  /** Tags to add to the post. New tags will be created if they don't exist. It overrides the existing tags. */
  tags?: InputMaybe<Array<hn_PublishPostTagInput>>;
  /** Information about the meta tags added to the post, used for SEO purpose. */
  metaTags?: InputMaybe<hn_MetaTagsInput>;
  /**
   * Set a different author for the post than the requesting user.
   * Must be a member of the publication.
   */
  publishAs?: InputMaybe<Scalars['hn_ObjectId']['input']>;
  /**
   * Update co-authors of the post.
   * Must be a member of the publication.
   */
  coAuthors?: InputMaybe<Array<Scalars['hn_ObjectId']['input']>>;
  /**
   * Providing a seriesId will add the post to that series.
   * Must be a series of the publication.
   */
  seriesId?: InputMaybe<Scalars['hn_ObjectId']['input']>;
  /** Whether or not to enable the table of content. */
  settings?: InputMaybe<hn_UpdatePostSettingsInput>;
  /** If the publication should be changed this is the new Publication ID */
  publicationId?: InputMaybe<Scalars['hn_ObjectId']['input']>;
};

export type hn_AddPostToSeriesInput = {
  /** The ID of the post to be added to the series. */
  postId: Scalars['hn_ObjectId']['input'];
  /** The ID of the series to which the post is to be added. */
  seriesId: Scalars['hn_ObjectId']['input'];
};

export type hn_AddPostToSeriesPayload = {
  /** The series to which the post was added. */
  series?: Maybe<hn_Series>;
};

/** Contains information about type of feed to be returned. */
export type hn_FeedType =
  /**
   * Returns only posts of the users you follow or publications you have subscribed to.
   *
   * Note: You have to be authenticated to use this feed type.
   */
  | 'FOLLOWING'
  /**
   * Returns only posts based on users following and interactions.
   *
   * Personalised feed is curated per requesting user basis.
   */
  | 'PERSONALIZED'
  /** Returns posts which were published recently, sorted based on recency. */
  | 'RECENT'
  /** Returns posts based on old personalization algorithm. */
  | 'RELEVANT'
  /** Returns posts which were featured, sorted based on recency. */
  | 'FEATURED'
  /** Returns posts which were bookmarked by the user, sorted based on recency. */
  | 'BOOKMARKS'
  /** Returns posts which were viewed by the user, sorted based on recency. */
  | 'READING_HISTORY';

export type hn_FeedFilter = {
  /** The type of feed to be returned. */
  type?: InputMaybe<hn_FeedType>;
  /** Adds a filter to return posts with minimum number of minutes required to read the post. */
  minReadTime?: InputMaybe<Scalars['Int']['input']>;
  /** Adds a filter to return posts with maximum number of minutes required to read the post. */
  maxReadTime?: InputMaybe<Scalars['Int']['input']>;
  /** Adds a filter to return posts with tagged with provided tags only. */
  tags?: InputMaybe<Array<Scalars['hn_ObjectId']['input']>>;
};

export type hn_SearchPostsOfPublicationFilter = {
  /** The query to be searched in post. */
  query: Scalars['String']['input'];
  /** The ID of publications to search from. */
  publicationId: Scalars['hn_ObjectId']['input'];
};

/**
 * Contains basic information about the comment.
 * A comment is a response to a post.
 */
export type hn_Comment = hn_Node & {
  /** The ID of the comment. */
  id: Scalars['ID']['output'];
  /** The content of the comment in markdown and html format. */
  content: hn_Content;
  /** The author of the comment. */
  author: hn_User;
  /** Returns a list of replies to the comment. */
  replies: hn_CommentReplyConnection;
  /** The date the comment was created. */
  dateAdded: Scalars['DateTime']['output'];
  /** A unique string identifying the comment. Used as element id in the DOM on hashnode blogs. */
  stamp?: Maybe<Scalars['String']['output']>;
  /** Total number of reactions on the comment. Reactions are hearts added to any comment. */
  totalReactions: Scalars['Int']['output'];
  /** Total number of reactions on the comment by the authenticated user. User must be authenticated to use this field. */
  myTotalReactions: Scalars['Int']['output'];
};


/**
 * Contains basic information about the comment.
 * A comment is a response to a post.
 */
export type hn_CommentrepliesArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Connection to get list of replies to a comment.
 * Returns a list of edges which contains the posts in publication and cursor to the last item of the previous page.
 */
export type hn_CommentReplyConnection = hn_Connection & {
  /**
   * A list of edges containing nodes in the connection.
   * A node contains a reply to a comment.
   */
  edges: Array<hn_CommentReplyEdge>;
  /** Information to aid in pagination. */
  pageInfo: hn_PageInfo;
  /** The total number of documents in the connection. */
  totalDocuments: Scalars['Int']['output'];
};

/** An edge that contains a node of type reply and cursor to the node. */
export type hn_CommentReplyEdge = hn_Edge & {
  /** The node containing a reply to a comment. */
  node: hn_Reply;
  /** A cursor to the last item of the previous page. */
  cursor: Scalars['String']['output'];
};

/**
 * Contains basic information about the reply.
 * A reply is a response to a comment.
 */
export type hn_Reply = hn_Node & {
  /** The ID of the reply. */
  id: Scalars['ID']['output'];
  /** The content of the reply in markdown and html format. */
  content: hn_Content;
  /** The author of the reply. */
  author: hn_User;
  /** The date the reply was created. */
  dateAdded: Scalars['DateTime']['output'];
  /**
   * A unique string identifying the reply. Used as element id in the DOM on hashnode blogs.
   * It can be used to scroll to the reply in browser.
   */
  stamp?: Maybe<Scalars['String']['output']>;
  /** Total number of reactions on the reply. Reactions are hearts added to any reply. */
  totalReactions: Scalars['Int']['output'];
  /** Total number of reactions on the reply by the authenticated user. User must be authenticated to use this field. */
  myTotalReactions: Scalars['Int']['output'];
};

/**
 * Contains basic information about the series.
 * A series is a collection of posts that are related to each other.
 */
export type hn_Series = hn_Node & {
  /** The ID of the series. */
  id: Scalars['ID']['output'];
  /** The name of the series. Shown in series page. */
  name: Scalars['String']['output'];
  /** The date and time the series was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The description of the series. Contains markdown and html version of the series's description. */
  description?: Maybe<hn_Content>;
  /** The cover image of the series. */
  coverImage?: Maybe<Scalars['String']['output']>;
  /** Returns the user who is author of the series. */
  author: hn_User;
  /** Unique identifier for the series. */
  cuid?: Maybe<Scalars['ID']['output']>;
  /** The slug of the series. Used to access series page.  Example https://johndoe.com/series/series-slug */
  slug: Scalars['String']['output'];
  /** The sort order of the series, determines if the latest posts should appear first or last in series. */
  sortOrder: hn_SortOrder;
  /** Returns a list of posts in the series. */
  posts: hn_SeriesPostConnection;
};


/**
 * Contains basic information about the series.
 * A series is a collection of posts that are related to each other.
 */
export type hn_SeriespostsArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
};

/** Contains a Series and a cursor for pagination. */
export type hn_SeriesEdge = hn_Edge & {
  /** The node holding the Series information */
  node: hn_Series;
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
};

/**
 * Connection for Series. Contains a list of edges containing nodes.
 * Each node is a Series.
 * Page info contains information about pagination like hasNextPage and endCursor.
 */
export type hn_SeriesConnection = hn_Connection & {
  /** A list of edges containing Series information */
  edges: Array<hn_SeriesEdge>;
  /** Information for pagination in SeriesList connection. */
  pageInfo: hn_PageInfo;
  /** The total number of documents in the connection. */
  totalDocuments: Scalars['Int']['output'];
};

/**
 * Contains basic information about the draft.
 * A draft is a post that is not published yet.
 */
export type hn_Draft = hn_Node & {
  /** The ID of the draft. */
  id: Scalars['ID']['output'];
  slug: Scalars['String']['output'];
  /** The title of the draft. It would become the title of the post when published. */
  title?: Maybe<Scalars['String']['output']>;
  /** The subtitle of the draft. It would become the subtitle of the post when published. */
  subtitle?: Maybe<Scalars['String']['output']>;
  /** The author of the draft. */
  author: hn_User;
  /**
   * Returns the user details of the co-authors of the post.
   * Hashnode users can add up to 4 co-authors as collaborators to their posts.
   * This functionality is limited to teams publication.
   */
  coAuthors?: Maybe<Array<hn_User>>;
  /** Returns list of tags added to the draft. Contains tag id, name, slug, etc. */
  tags: Array<hn_Tag>;
  canonicalUrl?: Maybe<Scalars['String']['output']>;
  /** The cover image preference of the draft. Contains cover image URL and other details. */
  coverImage?: Maybe<hn_DraftCoverImage>;
  readTimeInMinutes: Scalars['Int']['output'];
  /** Information of the series the draft belongs to. */
  series?: Maybe<hn_Series>;
  /** Content of the draft in HTML and markdown */
  content?: Maybe<hn_Content>;
  /**
   * The date the draft was updated.
   * @deprecated Use updatedAt instead. Will be removed on 26/12/2023.
   */
  dateUpdated: Scalars['DateTime']['output'];
  updatedAt: Scalars['DateTime']['output'];
  settings: hn_DraftSettings;
  /** SEO information of the draft. Contains title and description used in meta tags. */
  seo?: Maybe<hn_SEO>;
  /** OG meta-data of the draft. Contains image url used in open graph meta tags. */
  ogMetaData?: Maybe<hn_OpenGraphMetaData>;
  /** Draft feature-related fields. */
  features: hn_DraftFeatures;
  /** Information about the last backup of the draft. */
  lastBackup?: Maybe<hn_DraftBackup>;
  /** The date the draft was last successfully backed up. */
  lastSuccessfulBackupAt?: Maybe<Scalars['DateTime']['output']>;
  /** The date the draft last failed to back up. */
  lastFailedBackupAt?: Maybe<Scalars['DateTime']['output']>;
};

export type hn_DraftSettings = {
  /** A flag to indicate if the comments are disabled for the post. */
  disableComments: Scalars['Boolean']['output'];
  /** A flag to indicate if the cover image is shown below title of the post. Default position of cover is top of title. */
  stickCoverToBottom: Scalars['Boolean']['output'];
  /** Wether or not the post is hidden from the Hashnode community. */
  isDelisted: Scalars['Boolean']['output'];
};

export type hn_DraftFeatures = {
  tableOfContents: hn_TableOfContentsFeature;
};

export type hn_DraftBackup = {
  /** The status of the backup i.e., success or failure. */
  status?: Maybe<hn_BackupStatus>;
  /** The date the backup was created. */
  at?: Maybe<Scalars['DateTime']['output']>;
};

/** The status of the backup i.e., success or failure. */
export type hn_BackupStatus =
  /** The backup was successful. */
  | 'success'
  /** The backup failed. */
  | 'failed';

/**
 * Connection to get list of drafts.
 * Returns a list of edges which contains the draft and cursor to the last item of the previous page.
 */
export type hn_DraftConnection = hn_Connection & {
  /** A list of edges of drafts connection. */
  edges: Array<hn_DraftEdge>;
  /** Information to aid in pagination. */
  pageInfo: hn_PageInfo;
  /** The total number of documents in the connection. */
  totalDocuments: Scalars['Int']['output'];
};

/** Contains information about the cover image of the draft. */
export type hn_DraftCoverImage = {
  /** The URL of the cover image. */
  url: Scalars['String']['output'];
  /** Provides attribution information for the cover image, if available. */
  attribution?: Maybe<Scalars['String']['output']>;
  /** The name of the photographer who captured the cover image. */
  photographer?: Maybe<Scalars['String']['output']>;
  /** True if the image attribution should be hidden. */
  isAttributionHidden: Scalars['Boolean']['output'];
};

/** An edge that contains a node of type draft and cursor to the node. */
export type hn_DraftEdge = hn_Edge & {
  /** A node in the connection containing a draft. */
  node: hn_Draft;
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
};

/**
 * Contains basic information about the beta feature.
 * A beta feature is a feature that is not yet released to all users.
 */
export type hn_BetaFeature = hn_Node & {
  /** The ID of the beta feature. */
  id: Scalars['ID']['output'];
  /** The key of the beta feature. */
  key: Scalars['String']['output'];
  /** The title of the beta feature. */
  title?: Maybe<Scalars['String']['output']>;
  /** The description of the beta feature. */
  description?: Maybe<Scalars['String']['output']>;
  /** The url of the beta feature. */
  url?: Maybe<Scalars['String']['output']>;
  /** The date the beta feature was created. */
  enabled: Scalars['Boolean']['output'];
};

/**
 * Contains basic information about the scheduled post.
 * A scheduled post is a post that is scheduled to be published in the future.
 */
export type hn_ScheduledPost = hn_Node & {
  /** The ID of the scheduled post. */
  id: Scalars['ID']['output'];
  /** The date the scheduled post was created. */
  author: hn_User;
  /** Returns the draft associated with the scheduled post. */
  draft?: Maybe<hn_Draft>;
  /** The scheduled date for the post to be published. This is the date the post will be published. */
  scheduledDate: Scalars['DateTime']['output'];
  /** Returns user who scheduled the post. This is usually the author of the post. */
  scheduledBy?: Maybe<hn_User>;
  /** Returns the publication the post is scheduled for. */
  publication: hn_Publication;
};

export type hn_ReschedulePostInput = {
  /** The Draft ID of the scheduled post. */
  draftId: Scalars['hn_ObjectId']['input'];
  /** New scheduled date for the post to be rescheduled. */
  scheduledDate: Scalars['DateTime']['input'];
};

export type hn_ScheduledPostPayload = {
  /** Payload returned in response of reschedulePost mutation. */
  payload: hn_ScheduledPost;
};

/**
 * Contains basic information about the static page.
 * Static pages are pages that are written in markdown and can be added to blog.
 */
export type hn_StaticPage = hn_Node & {
  /** The ID of the static page. */
  id: Scalars['ID']['output'];
  /** The title of the static page. Shown in nav bar. */
  title: Scalars['String']['output'];
  /** The slug of the static page. Used to access static page.  Example https://johndoe.com/my-page */
  slug: Scalars['String']['output'];
  /** Content of the static page. Contains markdown and html version of the static page's content. */
  content: hn_Content;
  /** A flag to determine if the static page is hidden from public or not, this is used to hide the page instead of deleting it. */
  hidden: Scalars['Boolean']['output'];
  /** Information about the static page's Open Graph metadata i.e. image. */
  ogMetaData?: Maybe<hn_OpenGraphMetaData>;
  /** Information about the static page's SEO metadata i.e. title and description. */
  seo?: Maybe<hn_SEO>;
};

/**
 * Connection to get list of static pages.
 * Returns a list of edges which contains the static page and cursor to the last item of the previous page.
 */
export type hn_StaticPageConnection = hn_Connection & {
  /** A list of edges containing nodes in the connection. */
  edges: Array<hn_StaticPageEdge>;
  /** Information to aid in pagination. */
  pageInfo: hn_PageInfo;
  /** The total number of documents in the connection. */
  totalDocuments: Scalars['Int']['output'];
};

/** An edge that contains a node of type static page and cursor to the node. */
export type hn_StaticPageEdge = hn_Edge & {
  /** The node containing a static page. */
  node: hn_StaticPage;
  /** A cursor to the last item of the previous page. */
  cursor: Scalars['String']['output'];
};

export type hn_Webhook = hn_Node & {
  /** The ID of the post. Used to uniquely identify the post. */
  id: Scalars['ID']['output'];
  publication: hn_Publication;
  url: Scalars['String']['output'];
  events: Array<hn_WebhookEvent>;
  secret: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Messages that has been sent via this webhook.
   * Messages include the request and eventual response.
   */
  messages: hn_WebhookMessageConnection;
};


export type hn_WebhookmessagesArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
};

export type hn_WebhookEvent =
  | 'POST_PUBLISHED'
  | 'POST_UPDATED'
  | 'POST_DELETED'
  | 'STATIC_PAGE_PUBLISHED'
  | 'STATIC_PAGE_EDITED'
  | 'STATIC_PAGE_DELETED';

export type hn_WebhookMessageConnection = hn_Connection & {
  edges: Array<hn_WebhookMessageEdge>;
  pageInfo: hn_PageInfo;
};

export type hn_WebhookMessageEdge = hn_Edge & {
  node: hn_WebhookMessage;
  cursor: Scalars['String']['output'];
};

export type hn_WebhookMessage = hn_Node & {
  id: Scalars['ID']['output'];
  url: Scalars['String']['output'];
  event: hn_WebhookEvent;
  /** True if either the request failed or the response status code was not 2xx. */
  isError: Scalars['Boolean']['output'];
  /** True if the message was sent as a test. */
  isTest: Scalars['Boolean']['output'];
  /** True if the message was resent. */
  isResent: Scalars['Boolean']['output'];
  request: hn_WebhookMessageRequest;
  response?: Maybe<hn_WebhookMessageResponse>;
  createdAt: Scalars['DateTime']['output'];
};

export type hn_WebhookMessageRequest = {
  /** Unique identifier of the request. Can be used to deduplicate requests. */
  uuid: Scalars['String']['output'];
  headers: Scalars['String']['output'];
  body: Scalars['String']['output'];
  error?: Maybe<hn_WebhookMessageRequestError>;
};

export type hn_WebhookMessageRequestError = {
  code: Scalars['String']['output'];
  message: Scalars['String']['output'];
};

export type hn_WebhookMessageResponse = {
  httpStatus: Scalars['Int']['output'];
  headers?: Maybe<Scalars['String']['output']>;
  body?: Maybe<Scalars['String']['output']>;
  /** The time it took from the moment the request has been send until the first byte of the response has been received. */
  timeToFirstByteMilliseconds?: Maybe<Scalars['Int']['output']>;
};

export type HashnodeQuery = {
  /** Returns the user with the username. */
  hn_user?: Maybe<hn_User>;
  /** Returns users who have most actively participated in discussions by commenting in the last 7 days. */
  hn_topCommenters: hn_CommenterUserConnection;
  /** Returns the current authenticated user. Only available to the authenticated user. */
  hn_me: hn_MyUser;
  /** Returns tag details by its slug. */
  hn_tag?: Maybe<hn_Tag>;
  /**
   * Returns the publication with the given ID or host.
   * User can pass anyone of them.
   */
  hn_publication?: Maybe<hn_Publication>;
  /**
   * Returns a paginated list of posts based on the provided filter.
   * Used in Hashnode home feed.
   */
  hn_feed: hn_FeedPostConnection;
  /** Returns a paginated list of posts based on search query for a particular publication id. */
  hn_searchPostsOfPublication: hn_SearchPostConnection;
  /**
   * Returns a draft by ID.
   * Draft is a post that is not published yet.
   */
  hn_draft?: Maybe<hn_Draft>;
  /** Get a scheduled post by ID. */
  hn_scheduledPost?: Maybe<hn_ScheduledPost>;
};


export type HashnodeQueryhn_userArgs = {
  username: Scalars['String']['input'];
};


export type HashnodeQueryhn_topCommentersArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
};


export type HashnodeQueryhn_tagArgs = {
  slug: Scalars['String']['input'];
};


export type HashnodeQueryhn_publicationArgs = {
  id?: InputMaybe<Scalars['hn_ObjectId']['input']>;
  host?: InputMaybe<Scalars['String']['input']>;
};


export type HashnodeQueryhn_feedArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<hn_FeedFilter>;
};


export type HashnodeQueryhn_searchPostsOfPublicationArgs = {
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  filter: hn_SearchPostsOfPublicationFilter;
};


export type HashnodeQueryhn_draftArgs = {
  id: Scalars['hn_ObjectId']['input'];
};


export type HashnodeQueryhn_scheduledPostArgs = {
  id?: InputMaybe<Scalars['hn_ObjectId']['input']>;
};

export type HashnodeMutation = {
  /**
   * Update the follow state for the user that is provided via id or username.
   * If the authenticated user does not follow the user, the mutation will follow the user.
   * If the authenticated user already follows the user, the mutation will un-follow the user.
   * Only available to the authenticated user.
   */
  hn_toggleFollowUser: hn_ToggleFollowUserPayload;
  hn_subscribeToNewsletter: hn_SubscribeToNewsletterPayload;
  hn_unsubscribeFromNewsletter: hn_UnsubscribeFromNewsletterPayload;
  /** Creates a new post. */
  hn_publishPost: hn_PublishPostPayload;
  /** Adds a post to a series. */
  hn_addPostToSeries: hn_AddPostToSeriesPayload;
  hn_updatePost: hn_UpdatePostPayload;
  /** Removes a post. */
  hn_removePost: hn_RemovePostPayload;
  /** Reschedule a post. */
  hn_reschedulePost?: Maybe<hn_ScheduledPostPayload>;
};


export type HashnodeMutationhn_toggleFollowUserArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


export type HashnodeMutationhn_subscribeToNewsletterArgs = {
  input: hn_SubscribeToNewsletterInput;
};


export type HashnodeMutationhn_unsubscribeFromNewsletterArgs = {
  input: hn_UnsubscribeFromNewsletterInput;
};


export type HashnodeMutationhn_publishPostArgs = {
  input: hn_PublishPostInput;
};


export type HashnodeMutationhn_addPostToSeriesArgs = {
  input: hn_AddPostToSeriesInput;
};


export type HashnodeMutationhn_updatePostArgs = {
  input: hn_UpdatePostInput;
};


export type HashnodeMutationhn_removePostArgs = {
  input: hn_RemovePostInput;
};


export type HashnodeMutationhn_reschedulePostArgs = {
  input: hn_ReschedulePostInput;
};

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
  selectionSet: string | ((fieldNode: FieldNode) => SelectionSetNode);
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping of union types */
export type ResolversUnionTypes<RefType extends Record<string, unknown>> = ResolversObject<{
  gh_Assignee: ( gh_Bot ) | ( gh_Mannequin ) | ( gh_Organization ) | ( gh_User );
  gh_AuditEntryActor: ( gh_Bot ) | ( gh_Organization ) | ( gh_User );
  gh_BranchActorAllowanceActor: ( gh_App ) | ( gh_Team ) | ( gh_User );
  gh_BypassActor: ( gh_App ) | ( gh_Team );
  gh_Claimable: ( gh_Mannequin ) | ( gh_User );
  gh_Closer: ( gh_Commit ) | ( gh_PullRequest );
  gh_CreatedIssueOrRestrictedContribution: ( gh_CreatedIssueContribution ) | ( gh_RestrictedContribution );
  gh_CreatedPullRequestOrRestrictedContribution: ( gh_CreatedPullRequestContribution ) | ( gh_RestrictedContribution );
  gh_CreatedRepositoryOrRestrictedContribution: ( gh_CreatedRepositoryContribution ) | ( gh_RestrictedContribution );
  gh_DeploymentReviewer: ( gh_Team ) | ( gh_User );
  gh_EnterpriseMember: ( gh_EnterpriseUserAccount ) | ( gh_User );
  gh_IpAllowListOwner: ( gh_App ) | ( gh_Enterprise ) | ( gh_Organization );
  gh_IssueOrPullRequest: ( gh_Issue ) | ( gh_PullRequest );
  gh_IssueTimelineItem: ( Omit<gh_AssignedEvent, 'assignee'> & { assignee?: Maybe<RefType['gh_Assignee']> } ) | ( Omit<gh_ClosedEvent, 'closer'> & { closer?: Maybe<RefType['gh_Closer']> } ) | ( gh_Commit ) | ( Omit<gh_CrossReferencedEvent, 'source' | 'target'> & { source: RefType['gh_ReferencedSubject'], target: RefType['gh_ReferencedSubject'] } ) | ( Omit<gh_DemilestonedEvent, 'subject'> & { subject: RefType['gh_MilestoneItem'] } ) | ( gh_IssueComment ) | ( gh_LabeledEvent ) | ( gh_LockedEvent ) | ( Omit<gh_MilestonedEvent, 'subject'> & { subject: RefType['gh_MilestoneItem'] } ) | ( Omit<gh_ReferencedEvent, 'subject'> & { subject: RefType['gh_ReferencedSubject'] } ) | ( Omit<gh_RenamedTitleEvent, 'subject'> & { subject: RefType['gh_RenamedTitleSubject'] } ) | ( gh_ReopenedEvent ) | ( gh_SubscribedEvent ) | ( gh_TransferredEvent ) | ( Omit<gh_UnassignedEvent, 'assignee'> & { assignee?: Maybe<RefType['gh_Assignee']> } ) | ( gh_UnlabeledEvent ) | ( gh_UnlockedEvent ) | ( gh_UnsubscribedEvent ) | ( gh_UserBlockedEvent );
  gh_IssueTimelineItems: ( gh_AddedToProjectEvent ) | ( Omit<gh_AssignedEvent, 'assignee'> & { assignee?: Maybe<RefType['gh_Assignee']> } ) | ( Omit<gh_ClosedEvent, 'closer'> & { closer?: Maybe<RefType['gh_Closer']> } ) | ( gh_CommentDeletedEvent ) | ( Omit<gh_ConnectedEvent, 'source' | 'subject'> & { source: RefType['gh_ReferencedSubject'], subject: RefType['gh_ReferencedSubject'] } ) | ( gh_ConvertedNoteToIssueEvent ) | ( gh_ConvertedToDiscussionEvent ) | ( Omit<gh_CrossReferencedEvent, 'source' | 'target'> & { source: RefType['gh_ReferencedSubject'], target: RefType['gh_ReferencedSubject'] } ) | ( Omit<gh_DemilestonedEvent, 'subject'> & { subject: RefType['gh_MilestoneItem'] } ) | ( Omit<gh_DisconnectedEvent, 'source' | 'subject'> & { source: RefType['gh_ReferencedSubject'], subject: RefType['gh_ReferencedSubject'] } ) | ( gh_IssueComment ) | ( gh_LabeledEvent ) | ( gh_LockedEvent ) | ( Omit<gh_MarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<RefType['gh_IssueOrPullRequest']>, duplicate?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_MentionedEvent ) | ( Omit<gh_MilestonedEvent, 'subject'> & { subject: RefType['gh_MilestoneItem'] } ) | ( gh_MovedColumnsInProjectEvent ) | ( gh_PinnedEvent ) | ( Omit<gh_ReferencedEvent, 'subject'> & { subject: RefType['gh_ReferencedSubject'] } ) | ( gh_RemovedFromProjectEvent ) | ( Omit<gh_RenamedTitleEvent, 'subject'> & { subject: RefType['gh_RenamedTitleSubject'] } ) | ( gh_ReopenedEvent ) | ( gh_SubscribedEvent ) | ( gh_TransferredEvent ) | ( Omit<gh_UnassignedEvent, 'assignee'> & { assignee?: Maybe<RefType['gh_Assignee']> } ) | ( gh_UnlabeledEvent ) | ( gh_UnlockedEvent ) | ( Omit<gh_UnmarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<RefType['gh_IssueOrPullRequest']>, duplicate?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_UnpinnedEvent ) | ( gh_UnsubscribedEvent ) | ( gh_UserBlockedEvent );
  gh_MilestoneItem: ( gh_Issue ) | ( gh_PullRequest );
  gh_OrgRestoreMemberAuditEntryMembership: ( gh_OrgRestoreMemberMembershipOrganizationAuditEntryData ) | ( gh_OrgRestoreMemberMembershipRepositoryAuditEntryData ) | ( gh_OrgRestoreMemberMembershipTeamAuditEntryData );
  gh_OrganizationAuditEntry: ( Omit<gh_MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<RefType['gh_AuditEntryActor']>, restoredMemberships?: Maybe<Array<RefType['gh_OrgRestoreMemberAuditEntryMembership']>> } ) | ( Omit<gh_OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } );
  gh_OrganizationOrUser: ( gh_Organization ) | ( gh_User );
  gh_PermissionGranter: ( gh_Organization ) | ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_Team );
  gh_PinnableItem: ( gh_Gist ) | ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } );
  gh_ProjectCardItem: ( gh_Issue ) | ( gh_PullRequest );
  gh_ProjectV2Actor: ( gh_Team ) | ( gh_User );
  gh_ProjectV2FieldConfiguration: ( gh_ProjectV2Field ) | ( gh_ProjectV2IterationField ) | ( gh_ProjectV2SingleSelectField );
  gh_ProjectV2ItemContent: ( gh_DraftIssue ) | ( gh_Issue ) | ( gh_PullRequest );
  gh_ProjectV2ItemFieldValue: ( Omit<gh_ProjectV2ItemFieldDateValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldIterationValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldLabelValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldMilestoneValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldNumberValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldPullRequestValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldRepositoryValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldReviewerValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldSingleSelectValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldTextValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldUserValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } );
  gh_PullRequestTimelineItem: ( Omit<gh_AssignedEvent, 'assignee'> & { assignee?: Maybe<RefType['gh_Assignee']> } ) | ( gh_BaseRefDeletedEvent ) | ( gh_BaseRefForcePushedEvent ) | ( Omit<gh_ClosedEvent, 'closer'> & { closer?: Maybe<RefType['gh_Closer']> } ) | ( gh_Commit ) | ( gh_CommitCommentThread ) | ( Omit<gh_CrossReferencedEvent, 'source' | 'target'> & { source: RefType['gh_ReferencedSubject'], target: RefType['gh_ReferencedSubject'] } ) | ( Omit<gh_DemilestonedEvent, 'subject'> & { subject: RefType['gh_MilestoneItem'] } ) | ( gh_DeployedEvent ) | ( gh_DeploymentEnvironmentChangedEvent ) | ( gh_HeadRefDeletedEvent ) | ( gh_HeadRefForcePushedEvent ) | ( gh_HeadRefRestoredEvent ) | ( gh_IssueComment ) | ( gh_LabeledEvent ) | ( gh_LockedEvent ) | ( gh_MergedEvent ) | ( Omit<gh_MilestonedEvent, 'subject'> & { subject: RefType['gh_MilestoneItem'] } ) | ( gh_PullRequestReview ) | ( gh_PullRequestReviewComment ) | ( gh_PullRequestReviewThread ) | ( Omit<gh_ReferencedEvent, 'subject'> & { subject: RefType['gh_ReferencedSubject'] } ) | ( Omit<gh_RenamedTitleEvent, 'subject'> & { subject: RefType['gh_RenamedTitleSubject'] } ) | ( gh_ReopenedEvent ) | ( gh_ReviewDismissedEvent ) | ( Omit<gh_ReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['gh_RequestedReviewer']> } ) | ( Omit<gh_ReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['gh_RequestedReviewer']> } ) | ( gh_SubscribedEvent ) | ( Omit<gh_UnassignedEvent, 'assignee'> & { assignee?: Maybe<RefType['gh_Assignee']> } ) | ( gh_UnlabeledEvent ) | ( gh_UnlockedEvent ) | ( gh_UnsubscribedEvent ) | ( gh_UserBlockedEvent );
  gh_PullRequestTimelineItems: ( gh_AddedToMergeQueueEvent ) | ( gh_AddedToProjectEvent ) | ( Omit<gh_AssignedEvent, 'assignee'> & { assignee?: Maybe<RefType['gh_Assignee']> } ) | ( gh_AutoMergeDisabledEvent ) | ( gh_AutoMergeEnabledEvent ) | ( gh_AutoRebaseEnabledEvent ) | ( gh_AutoSquashEnabledEvent ) | ( gh_AutomaticBaseChangeFailedEvent ) | ( gh_AutomaticBaseChangeSucceededEvent ) | ( gh_BaseRefChangedEvent ) | ( gh_BaseRefDeletedEvent ) | ( gh_BaseRefForcePushedEvent ) | ( Omit<gh_ClosedEvent, 'closer'> & { closer?: Maybe<RefType['gh_Closer']> } ) | ( gh_CommentDeletedEvent ) | ( Omit<gh_ConnectedEvent, 'source' | 'subject'> & { source: RefType['gh_ReferencedSubject'], subject: RefType['gh_ReferencedSubject'] } ) | ( gh_ConvertToDraftEvent ) | ( gh_ConvertedNoteToIssueEvent ) | ( gh_ConvertedToDiscussionEvent ) | ( Omit<gh_CrossReferencedEvent, 'source' | 'target'> & { source: RefType['gh_ReferencedSubject'], target: RefType['gh_ReferencedSubject'] } ) | ( Omit<gh_DemilestonedEvent, 'subject'> & { subject: RefType['gh_MilestoneItem'] } ) | ( gh_DeployedEvent ) | ( gh_DeploymentEnvironmentChangedEvent ) | ( Omit<gh_DisconnectedEvent, 'source' | 'subject'> & { source: RefType['gh_ReferencedSubject'], subject: RefType['gh_ReferencedSubject'] } ) | ( gh_HeadRefDeletedEvent ) | ( gh_HeadRefForcePushedEvent ) | ( gh_HeadRefRestoredEvent ) | ( gh_IssueComment ) | ( gh_LabeledEvent ) | ( gh_LockedEvent ) | ( Omit<gh_MarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<RefType['gh_IssueOrPullRequest']>, duplicate?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_MentionedEvent ) | ( gh_MergedEvent ) | ( Omit<gh_MilestonedEvent, 'subject'> & { subject: RefType['gh_MilestoneItem'] } ) | ( gh_MovedColumnsInProjectEvent ) | ( gh_PinnedEvent ) | ( gh_PullRequestCommit ) | ( gh_PullRequestCommitCommentThread ) | ( gh_PullRequestReview ) | ( gh_PullRequestReviewThread ) | ( gh_PullRequestRevisionMarker ) | ( gh_ReadyForReviewEvent ) | ( Omit<gh_ReferencedEvent, 'subject'> & { subject: RefType['gh_ReferencedSubject'] } ) | ( gh_RemovedFromMergeQueueEvent ) | ( gh_RemovedFromProjectEvent ) | ( Omit<gh_RenamedTitleEvent, 'subject'> & { subject: RefType['gh_RenamedTitleSubject'] } ) | ( gh_ReopenedEvent ) | ( gh_ReviewDismissedEvent ) | ( Omit<gh_ReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['gh_RequestedReviewer']> } ) | ( Omit<gh_ReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['gh_RequestedReviewer']> } ) | ( gh_SubscribedEvent ) | ( gh_TransferredEvent ) | ( Omit<gh_UnassignedEvent, 'assignee'> & { assignee?: Maybe<RefType['gh_Assignee']> } ) | ( gh_UnlabeledEvent ) | ( gh_UnlockedEvent ) | ( Omit<gh_UnmarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<RefType['gh_IssueOrPullRequest']>, duplicate?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_UnpinnedEvent ) | ( gh_UnsubscribedEvent ) | ( gh_UserBlockedEvent );
  gh_PushAllowanceActor: ( gh_App ) | ( gh_Team ) | ( gh_User );
  gh_Reactor: ( gh_Bot ) | ( gh_Mannequin ) | ( gh_Organization ) | ( gh_User );
  gh_ReferencedSubject: ( gh_Issue ) | ( gh_PullRequest );
  gh_RenamedTitleSubject: ( gh_Issue ) | ( gh_PullRequest );
  gh_RequestedReviewer: ( gh_Bot ) | ( gh_Mannequin ) | ( gh_Team ) | ( gh_User );
  gh_ReviewDismissalAllowanceActor: ( gh_App ) | ( gh_Team ) | ( gh_User );
  gh_RuleParameters: ( gh_BranchNamePatternParameters ) | ( gh_CommitAuthorEmailPatternParameters ) | ( gh_CommitMessagePatternParameters ) | ( gh_CommitterEmailPatternParameters ) | ( gh_PullRequestParameters ) | ( gh_RequiredDeploymentsParameters ) | ( gh_RequiredStatusChecksParameters ) | ( gh_TagNamePatternParameters ) | ( gh_UpdateParameters ) | ( gh_WorkflowsParameters );
  gh_RuleSource: ( gh_Organization ) | ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } );
  gh_SearchResultItem: ( gh_App ) | ( gh_Discussion ) | ( gh_Issue ) | ( gh_MarketplaceListing ) | ( gh_Organization ) | ( gh_PullRequest ) | ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_User );
  gh_Sponsor: ( gh_Organization ) | ( gh_User );
  gh_SponsorableItem: ( gh_Organization ) | ( gh_User );
  gh_SponsorsListingFeatureableItem: ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_User );
  gh_StatusCheckRollupContext: ( gh_CheckRun ) | ( gh_StatusContext );
  gh_UserListItems: ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } );
  gh_VerifiableDomainOwner: ( gh_Enterprise ) | ( gh_Organization );
}>;

/** Mapping of interface types */
export type ResolversInterfaceTypes<RefType extends Record<string, unknown>> = ResolversObject<{
  gh_Actor: ( gh_Bot ) | ( gh_EnterpriseUserAccount ) | ( gh_Mannequin ) | ( gh_Organization ) | ( gh_User );
  gh_AnnouncementBanner: ( gh_Enterprise ) | ( gh_Organization );
  gh_Assignable: ( gh_Issue ) | ( gh_PullRequest );
  gh_AuditEntry: ( Omit<gh_MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<RefType['gh_AuditEntryActor']>, restoredMemberships?: Maybe<Array<RefType['gh_OrgRestoreMemberAuditEntryMembership']>> } ) | ( Omit<gh_OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } );
  gh_Closable: ( gh_Discussion ) | ( gh_Issue ) | ( gh_Milestone ) | ( gh_Project ) | ( Omit<gh_ProjectV2, 'field'> & { field?: Maybe<RefType['gh_ProjectV2FieldConfiguration']> } ) | ( gh_PullRequest );
  gh_Comment: ( gh_CommitComment ) | ( gh_Discussion ) | ( gh_DiscussionComment ) | ( gh_GistComment ) | ( gh_Issue ) | ( gh_IssueComment ) | ( gh_PullRequest ) | ( gh_PullRequestReview ) | ( gh_PullRequestReviewComment ) | ( gh_TeamDiscussion ) | ( gh_TeamDiscussionComment );
  gh_Contribution: ( gh_CreatedCommitContribution ) | ( gh_CreatedIssueContribution ) | ( gh_CreatedPullRequestContribution ) | ( gh_CreatedPullRequestReviewContribution ) | ( gh_CreatedRepositoryContribution ) | ( gh_JoinedGitHubContribution ) | ( gh_RestrictedContribution );
  gh_Deletable: ( gh_CommitComment ) | ( gh_Discussion ) | ( gh_DiscussionComment ) | ( gh_GistComment ) | ( gh_Issue ) | ( gh_IssueComment ) | ( gh_PullRequestReview ) | ( gh_PullRequestReviewComment ) | ( gh_TeamDiscussion ) | ( gh_TeamDiscussionComment );
  gh_EnterpriseAuditEntryData: ( Omit<gh_MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } );
  gh_GitObject: ( gh_Blob ) | ( gh_Commit ) | ( gh_Tag ) | ( gh_Tree );
  gh_GitSignature: ( gh_GpgSignature ) | ( gh_SmimeSignature ) | ( gh_SshSignature ) | ( gh_UnknownSignature );
  gh_HovercardContext: ( gh_GenericHovercardContext ) | ( gh_OrganizationTeamsHovercardContext ) | ( gh_OrganizationsHovercardContext ) | ( gh_ReviewStatusHovercardContext ) | ( gh_ViewerHovercardContext );
  gh_Labelable: ( gh_Discussion ) | ( gh_Issue ) | ( gh_PullRequest );
  gh_Lockable: ( gh_Discussion ) | ( gh_Issue ) | ( gh_PullRequest );
  gh_MemberStatusable: ( gh_Organization ) | ( gh_Team );
  gh_Migration: ( gh_RepositoryMigration );
  gh_Minimizable: ( gh_CommitComment ) | ( gh_DiscussionComment ) | ( gh_GistComment ) | ( gh_IssueComment ) | ( gh_PullRequestReview ) | ( gh_PullRequestReviewComment );
  gh_Node: ( gh_AddedToMergeQueueEvent ) | ( gh_AddedToProjectEvent ) | ( gh_App ) | ( Omit<gh_AssignedEvent, 'assignee'> & { assignee?: Maybe<RefType['gh_Assignee']> } ) | ( gh_AutoMergeDisabledEvent ) | ( gh_AutoMergeEnabledEvent ) | ( gh_AutoRebaseEnabledEvent ) | ( gh_AutoSquashEnabledEvent ) | ( gh_AutomaticBaseChangeFailedEvent ) | ( gh_AutomaticBaseChangeSucceededEvent ) | ( gh_BaseRefChangedEvent ) | ( gh_BaseRefDeletedEvent ) | ( gh_BaseRefForcePushedEvent ) | ( gh_Blob ) | ( gh_Bot ) | ( gh_BranchProtectionRule ) | ( Omit<gh_BypassForcePushAllowance, 'actor'> & { actor?: Maybe<RefType['gh_BranchActorAllowanceActor']> } ) | ( Omit<gh_BypassPullRequestAllowance, 'actor'> & { actor?: Maybe<RefType['gh_BranchActorAllowanceActor']> } ) | ( gh_CWE ) | ( gh_CheckRun ) | ( gh_CheckSuite ) | ( Omit<gh_ClosedEvent, 'closer'> & { closer?: Maybe<RefType['gh_Closer']> } ) | ( gh_CodeOfConduct ) | ( gh_CommentDeletedEvent ) | ( gh_Commit ) | ( gh_CommitComment ) | ( gh_CommitCommentThread ) | ( gh_Comparison ) | ( Omit<gh_ConnectedEvent, 'source' | 'subject'> & { source: RefType['gh_ReferencedSubject'], subject: RefType['gh_ReferencedSubject'] } ) | ( gh_ConvertToDraftEvent ) | ( gh_ConvertedNoteToIssueEvent ) | ( gh_ConvertedToDiscussionEvent ) | ( Omit<gh_CrossReferencedEvent, 'source' | 'target'> & { source: RefType['gh_ReferencedSubject'], target: RefType['gh_ReferencedSubject'] } ) | ( Omit<gh_DemilestonedEvent, 'subject'> & { subject: RefType['gh_MilestoneItem'] } ) | ( gh_DependencyGraphManifest ) | ( gh_DeployKey ) | ( gh_DeployedEvent ) | ( gh_Deployment ) | ( gh_DeploymentEnvironmentChangedEvent ) | ( gh_DeploymentReview ) | ( gh_DeploymentStatus ) | ( Omit<gh_DisconnectedEvent, 'source' | 'subject'> & { source: RefType['gh_ReferencedSubject'], subject: RefType['gh_ReferencedSubject'] } ) | ( gh_Discussion ) | ( gh_DiscussionCategory ) | ( gh_DiscussionComment ) | ( gh_DiscussionPoll ) | ( gh_DiscussionPollOption ) | ( gh_DraftIssue ) | ( gh_Enterprise ) | ( gh_EnterpriseAdministratorInvitation ) | ( gh_EnterpriseIdentityProvider ) | ( gh_EnterpriseRepositoryInfo ) | ( gh_EnterpriseServerInstallation ) | ( gh_EnterpriseServerUserAccount ) | ( gh_EnterpriseServerUserAccountEmail ) | ( gh_EnterpriseServerUserAccountsUpload ) | ( gh_EnterpriseUserAccount ) | ( gh_Environment ) | ( gh_ExternalIdentity ) | ( gh_Gist ) | ( gh_GistComment ) | ( gh_HeadRefDeletedEvent ) | ( gh_HeadRefForcePushedEvent ) | ( gh_HeadRefRestoredEvent ) | ( Omit<gh_IpAllowListEntry, 'owner'> & { owner: RefType['gh_IpAllowListOwner'] } ) | ( gh_Issue ) | ( gh_IssueComment ) | ( gh_Label ) | ( gh_LabeledEvent ) | ( gh_Language ) | ( gh_License ) | ( gh_LinkedBranch ) | ( gh_LockedEvent ) | ( gh_Mannequin ) | ( Omit<gh_MarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<RefType['gh_IssueOrPullRequest']>, duplicate?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_MarketplaceCategory ) | ( gh_MarketplaceListing ) | ( gh_MemberFeatureRequestNotification ) | ( Omit<gh_MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( gh_MentionedEvent ) | ( gh_MergeQueue ) | ( gh_MergeQueueEntry ) | ( gh_MergedEvent ) | ( gh_MigrationSource ) | ( gh_Milestone ) | ( Omit<gh_MilestonedEvent, 'subject'> & { subject: RefType['gh_MilestoneItem'] } ) | ( gh_MovedColumnsInProjectEvent ) | ( gh_OIDCProvider ) | ( Omit<gh_OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<RefType['gh_AuditEntryActor']>, restoredMemberships?: Maybe<Array<RefType['gh_OrgRestoreMemberAuditEntryMembership']>> } ) | ( Omit<gh_OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( gh_Organization ) | ( gh_OrganizationIdentityProvider ) | ( gh_OrganizationInvitation ) | ( gh_OrganizationMigration ) | ( gh_Package ) | ( gh_PackageFile ) | ( gh_PackageTag ) | ( gh_PackageVersion ) | ( gh_PinnedDiscussion ) | ( gh_PinnedEvent ) | ( gh_PinnedIssue ) | ( Omit<gh_PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( gh_Project ) | ( Omit<gh_ProjectCard, 'content'> & { content?: Maybe<RefType['gh_ProjectCardItem']> } ) | ( gh_ProjectColumn ) | ( Omit<gh_ProjectV2, 'field'> & { field?: Maybe<RefType['gh_ProjectV2FieldConfiguration']> } ) | ( gh_ProjectV2Field ) | ( Omit<gh_ProjectV2Item, 'content' | 'fieldValueByName'> & { content?: Maybe<RefType['gh_ProjectV2ItemContent']>, fieldValueByName?: Maybe<RefType['gh_ProjectV2ItemFieldValue']> } ) | ( Omit<gh_ProjectV2ItemFieldDateValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldIterationValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldNumberValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldSingleSelectValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldTextValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( gh_ProjectV2IterationField ) | ( gh_ProjectV2SingleSelectField ) | ( gh_ProjectV2View ) | ( gh_ProjectV2Workflow ) | ( gh_PublicKey ) | ( gh_PullRequest ) | ( gh_PullRequestCommit ) | ( gh_PullRequestCommitCommentThread ) | ( gh_PullRequestReview ) | ( gh_PullRequestReviewComment ) | ( gh_PullRequestReviewThread ) | ( gh_PullRequestThread ) | ( gh_Push ) | ( Omit<gh_PushAllowance, 'actor'> & { actor?: Maybe<RefType['gh_PushAllowanceActor']> } ) | ( gh_Reaction ) | ( gh_ReadyForReviewEvent ) | ( gh_Ref ) | ( Omit<gh_ReferencedEvent, 'subject'> & { subject: RefType['gh_ReferencedSubject'] } ) | ( gh_Release ) | ( gh_ReleaseAsset ) | ( gh_RemovedFromMergeQueueEvent ) | ( gh_RemovedFromProjectEvent ) | ( Omit<gh_RenamedTitleEvent, 'subject'> & { subject: RefType['gh_RenamedTitleSubject'] } ) | ( gh_ReopenedEvent ) | ( Omit<gh_RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_RepositoryInvitation ) | ( gh_RepositoryMigration ) | ( Omit<gh_RepositoryRule, 'parameters'> & { parameters?: Maybe<RefType['gh_RuleParameters']> } ) | ( Omit<gh_RepositoryRuleset, 'source'> & { source: RefType['gh_RuleSource'] } ) | ( Omit<gh_RepositoryRulesetBypassActor, 'actor'> & { actor?: Maybe<RefType['gh_BypassActor']> } ) | ( gh_RepositoryTopic ) | ( Omit<gh_RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( gh_RepositoryVulnerabilityAlert ) | ( Omit<gh_ReviewDismissalAllowance, 'actor'> & { actor?: Maybe<RefType['gh_ReviewDismissalAllowanceActor']> } ) | ( gh_ReviewDismissedEvent ) | ( Omit<gh_ReviewRequest, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['gh_RequestedReviewer']> } ) | ( Omit<gh_ReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['gh_RequestedReviewer']> } ) | ( Omit<gh_ReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<RefType['gh_RequestedReviewer']> } ) | ( gh_SavedReply ) | ( gh_SecurityAdvisory ) | ( Omit<gh_SponsorsActivity, 'sponsor'> & { sponsor?: Maybe<RefType['gh_Sponsor']> } ) | ( gh_SponsorsListing ) | ( Omit<gh_SponsorsListingFeaturedItem, 'featureable'> & { featureable: RefType['gh_SponsorsListingFeatureableItem'] } ) | ( gh_SponsorsTier ) | ( Omit<gh_Sponsorship, 'sponsorEntity'> & { sponsorEntity?: Maybe<RefType['gh_Sponsor']> } ) | ( gh_SponsorshipNewsletter ) | ( gh_Status ) | ( gh_StatusCheckRollup ) | ( gh_StatusContext ) | ( gh_SubscribedEvent ) | ( gh_Tag ) | ( gh_Team ) | ( Omit<gh_TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( gh_TeamDiscussion ) | ( gh_TeamDiscussionComment ) | ( Omit<gh_TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( gh_Topic ) | ( gh_TransferredEvent ) | ( gh_Tree ) | ( Omit<gh_UnassignedEvent, 'assignee'> & { assignee?: Maybe<RefType['gh_Assignee']> } ) | ( gh_UnlabeledEvent ) | ( gh_UnlockedEvent ) | ( Omit<gh_UnmarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<RefType['gh_IssueOrPullRequest']>, duplicate?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_UnpinnedEvent ) | ( gh_UnsubscribedEvent ) | ( gh_User ) | ( gh_UserBlockedEvent ) | ( gh_UserContentEdit ) | ( gh_UserList ) | ( gh_UserStatus ) | ( Omit<gh_VerifiableDomain, 'owner'> & { owner: RefType['gh_VerifiableDomainOwner'] } ) | ( gh_Workflow ) | ( gh_WorkflowRun ) | ( gh_WorkflowRunFile );
  gh_OauthApplicationAuditEntryData: ( Omit<gh_OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } );
  gh_OrganizationAuditEntryData: ( Omit<gh_MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<RefType['gh_AuditEntryActor']>, restoredMemberships?: Maybe<Array<RefType['gh_OrgRestoreMemberAuditEntryMembership']>> } ) | ( gh_OrgRestoreMemberMembershipOrganizationAuditEntryData ) | ( Omit<gh_OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } );
  gh_PackageOwner: ( gh_Organization ) | ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_User );
  gh_ProfileOwner: ( gh_Organization ) | ( gh_User );
  gh_ProjectOwner: ( gh_Organization ) | ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_User );
  gh_ProjectV2FieldCommon: ( gh_ProjectV2Field ) | ( gh_ProjectV2IterationField ) | ( gh_ProjectV2SingleSelectField );
  gh_ProjectV2ItemFieldValueCommon: ( Omit<gh_ProjectV2ItemFieldDateValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldIterationValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldNumberValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldSingleSelectValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } ) | ( Omit<gh_ProjectV2ItemFieldTextValue, 'field'> & { field: RefType['gh_ProjectV2FieldConfiguration'] } );
  gh_ProjectV2Owner: ( gh_Issue ) | ( gh_Organization ) | ( gh_PullRequest ) | ( gh_User );
  gh_ProjectV2Recent: ( gh_Organization ) | ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_User );
  gh_Reactable: ( gh_CommitComment ) | ( gh_Discussion ) | ( gh_DiscussionComment ) | ( gh_Issue ) | ( gh_IssueComment ) | ( gh_PullRequest ) | ( gh_PullRequestReview ) | ( gh_PullRequestReviewComment ) | ( gh_Release ) | ( gh_TeamDiscussion ) | ( gh_TeamDiscussionComment );
  gh_RepositoryAuditEntryData: ( gh_OrgRestoreMemberMembershipRepositoryAuditEntryData ) | ( Omit<gh_PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } );
  gh_RepositoryDiscussionAuthor: ( gh_Organization ) | ( gh_User );
  gh_RepositoryDiscussionCommentAuthor: ( gh_Organization ) | ( gh_User );
  gh_RepositoryInfo: ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } );
  gh_RepositoryNode: ( gh_CommitComment ) | ( gh_CommitCommentThread ) | ( gh_DependabotUpdate ) | ( gh_Discussion ) | ( gh_DiscussionCategory ) | ( gh_Issue ) | ( gh_IssueComment ) | ( gh_PinnedDiscussion ) | ( gh_PullRequest ) | ( gh_PullRequestCommitCommentThread ) | ( gh_PullRequestReview ) | ( gh_PullRequestReviewComment ) | ( gh_RepositoryVulnerabilityAlert );
  gh_RepositoryOwner: ( gh_Organization ) | ( gh_User );
  gh_RequirableByPullRequest: ( gh_CheckRun ) | ( gh_StatusContext );
  gh_Sponsorable: ( gh_Organization ) | ( gh_User );
  gh_Starrable: ( gh_Gist ) | ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_Topic );
  gh_Subscribable: ( gh_Commit ) | ( gh_Discussion ) | ( gh_Issue ) | ( gh_PullRequest ) | ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_Team ) | ( gh_TeamDiscussion );
  gh_SubscribableThread: ( gh_Issue );
  gh_TeamAuditEntryData: ( gh_OrgRestoreMemberMembershipTeamAuditEntryData ) | ( Omit<gh_TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } );
  gh_TopicAuditEntryData: ( Omit<gh_RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } ) | ( Omit<gh_RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<RefType['gh_AuditEntryActor']> } );
  gh_UniformResourceLocatable: ( gh_Bot ) | ( gh_CheckRun ) | ( Omit<gh_ClosedEvent, 'closer'> & { closer?: Maybe<RefType['gh_Closer']> } ) | ( gh_Commit ) | ( gh_ConvertToDraftEvent ) | ( Omit<gh_CrossReferencedEvent, 'source' | 'target'> & { source: RefType['gh_ReferencedSubject'], target: RefType['gh_ReferencedSubject'] } ) | ( gh_Gist ) | ( gh_Issue ) | ( gh_Mannequin ) | ( gh_MergedEvent ) | ( gh_Milestone ) | ( gh_Organization ) | ( gh_PullRequest ) | ( gh_PullRequestCommit ) | ( gh_ReadyForReviewEvent ) | ( gh_Release ) | ( Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<RefType['gh_IssueOrPullRequest']> } ) | ( gh_RepositoryTopic ) | ( gh_ReviewDismissedEvent ) | ( gh_TeamDiscussion ) | ( gh_TeamDiscussionComment ) | ( gh_User ) | ( gh_Workflow ) | ( gh_WorkflowRun ) | ( gh_WorkflowRunFile );
  gh_Updatable: ( gh_CommitComment ) | ( gh_Discussion ) | ( gh_DiscussionComment ) | ( gh_GistComment ) | ( gh_Issue ) | ( gh_IssueComment ) | ( gh_Project ) | ( Omit<gh_ProjectV2, 'field'> & { field?: Maybe<RefType['gh_ProjectV2FieldConfiguration']> } ) | ( gh_PullRequest ) | ( gh_PullRequestReview ) | ( gh_PullRequestReviewComment ) | ( gh_TeamDiscussion ) | ( gh_TeamDiscussionComment );
  gh_UpdatableComment: ( gh_CommitComment ) | ( gh_DiscussionComment ) | ( gh_GistComment ) | ( gh_Issue ) | ( gh_IssueComment ) | ( gh_PullRequest ) | ( gh_PullRequestReview ) | ( gh_PullRequestReviewComment ) | ( gh_TeamDiscussion ) | ( gh_TeamDiscussionComment );
  gh_Votable: ( gh_Discussion ) | ( gh_DiscussionComment );
  hn_Node: ( hn_User ) | ( hn_MyUser ) | ( hn_Badge ) | ( hn_Tag ) | ( hn_PopularTag ) | ( hn_Publication ) | ( hn_RSSImport ) | ( hn_Post ) | ( hn_TableOfContentsItem ) | ( hn_PostBadge ) | ( hn_Comment ) | ( hn_Reply ) | ( hn_Series ) | ( hn_Draft ) | ( hn_BetaFeature ) | ( hn_ScheduledPost ) | ( hn_StaticPage ) | ( hn_Webhook ) | ( hn_WebhookMessage );
  hn_Connection: ( hn_UserPublicationsConnection ) | ( hn_CommenterUserConnection ) | ( hn_PostCommenterConnection ) | ( hn_PostCommentConnection ) | ( hn_PostLikerConnection ) | ( hn_FeedPostConnection ) | ( hn_SearchPostConnection ) | ( hn_SeriesPostConnection ) | ( hn_PublicationPostConnection ) | ( hn_CommentReplyConnection ) | ( hn_SeriesConnection ) | ( hn_DraftConnection ) | ( hn_StaticPageConnection ) | ( hn_WebhookMessageConnection );
  hn_Edge: ( hn_UserPublicationsEdge ) | ( hn_UserEdge ) | ( hn_PopularTagEdge ) | ( hn_TagEdge ) | ( hn_RecommendedPublicationEdge ) | ( hn_PostCommenterEdge ) | ( hn_PostCommentEdge ) | ( hn_PostLikerEdge ) | ( hn_PostEdge ) | ( hn_CommentReplyEdge ) | ( hn_SeriesEdge ) | ( hn_DraftEdge ) | ( hn_StaticPageEdge ) | ( hn_WebhookMessageEdge );
  hn_PageConnection: ( hn_UserConnection ) | ( hn_PublicationUserRecommendingPublicationConnection ) | ( hn_UserPostConnection );
  hn_Feature: ( hn_NewsletterFeature ) | ( hn_ViewCountFeature ) | ( hn_ReadTimeFeature ) | ( hn_AudioBlogFeature ) | ( hn_TextSelectionSharerFeature ) | ( hn_CustomCSSFeature ) | ( hn_TableOfContentsFeature ) | ( hn_PostBadgesFeature );
  hn_IUser: ( hn_User ) | ( hn_MyUser );
  hn_ITag: ( hn_Tag ) | ( hn_PopularTag );
}>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  Query: ResolverTypeWrapper<{}>;
  Mutation: ResolverTypeWrapper<{}>;
  gh_AbortQueuedMigrationsInput: gh_AbortQueuedMigrationsInput;
  String: ResolverTypeWrapper<Scalars['String']['output']>;
  ID: ResolverTypeWrapper<Scalars['ID']['output']>;
  gh_AbortQueuedMigrationsPayload: ResolverTypeWrapper<gh_AbortQueuedMigrationsPayload>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
  gh_AbortRepositoryMigrationInput: gh_AbortRepositoryMigrationInput;
  gh_AbortRepositoryMigrationPayload: ResolverTypeWrapper<gh_AbortRepositoryMigrationPayload>;
  gh_AcceptEnterpriseAdministratorInvitationInput: gh_AcceptEnterpriseAdministratorInvitationInput;
  gh_AcceptEnterpriseAdministratorInvitationPayload: ResolverTypeWrapper<gh_AcceptEnterpriseAdministratorInvitationPayload>;
  gh_AcceptTopicSuggestionInput: gh_AcceptTopicSuggestionInput;
  gh_AcceptTopicSuggestionPayload: ResolverTypeWrapper<gh_AcceptTopicSuggestionPayload>;
  gh_Actor: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Actor']>;
  Int: ResolverTypeWrapper<Scalars['Int']['output']>;
  gh_ActorLocation: ResolverTypeWrapper<gh_ActorLocation>;
  gh_ActorType: gh_ActorType;
  gh_AddAssigneesToAssignableInput: gh_AddAssigneesToAssignableInput;
  gh_AddAssigneesToAssignablePayload: ResolverTypeWrapper<gh_AddAssigneesToAssignablePayload>;
  gh_AddCommentInput: gh_AddCommentInput;
  gh_AddCommentPayload: ResolverTypeWrapper<gh_AddCommentPayload>;
  gh_AddDiscussionCommentInput: gh_AddDiscussionCommentInput;
  gh_AddDiscussionCommentPayload: ResolverTypeWrapper<gh_AddDiscussionCommentPayload>;
  gh_AddDiscussionPollVoteInput: gh_AddDiscussionPollVoteInput;
  gh_AddDiscussionPollVotePayload: ResolverTypeWrapper<gh_AddDiscussionPollVotePayload>;
  gh_AddEnterpriseOrganizationMemberInput: gh_AddEnterpriseOrganizationMemberInput;
  gh_AddEnterpriseOrganizationMemberPayload: ResolverTypeWrapper<gh_AddEnterpriseOrganizationMemberPayload>;
  gh_AddEnterpriseSupportEntitlementInput: gh_AddEnterpriseSupportEntitlementInput;
  gh_AddEnterpriseSupportEntitlementPayload: ResolverTypeWrapper<gh_AddEnterpriseSupportEntitlementPayload>;
  gh_AddLabelsToLabelableInput: gh_AddLabelsToLabelableInput;
  gh_AddLabelsToLabelablePayload: ResolverTypeWrapper<gh_AddLabelsToLabelablePayload>;
  gh_AddProjectCardInput: gh_AddProjectCardInput;
  gh_AddProjectCardPayload: ResolverTypeWrapper<gh_AddProjectCardPayload>;
  gh_AddProjectColumnInput: gh_AddProjectColumnInput;
  gh_AddProjectColumnPayload: ResolverTypeWrapper<gh_AddProjectColumnPayload>;
  gh_AddProjectV2DraftIssueInput: gh_AddProjectV2DraftIssueInput;
  gh_AddProjectV2DraftIssuePayload: ResolverTypeWrapper<gh_AddProjectV2DraftIssuePayload>;
  gh_AddProjectV2ItemByIdInput: gh_AddProjectV2ItemByIdInput;
  gh_AddProjectV2ItemByIdPayload: ResolverTypeWrapper<gh_AddProjectV2ItemByIdPayload>;
  gh_AddPullRequestReviewCommentInput: gh_AddPullRequestReviewCommentInput;
  gh_AddPullRequestReviewCommentPayload: ResolverTypeWrapper<gh_AddPullRequestReviewCommentPayload>;
  gh_AddPullRequestReviewInput: gh_AddPullRequestReviewInput;
  gh_AddPullRequestReviewPayload: ResolverTypeWrapper<gh_AddPullRequestReviewPayload>;
  gh_AddPullRequestReviewThreadInput: gh_AddPullRequestReviewThreadInput;
  gh_AddPullRequestReviewThreadPayload: ResolverTypeWrapper<gh_AddPullRequestReviewThreadPayload>;
  gh_AddPullRequestReviewThreadReplyInput: gh_AddPullRequestReviewThreadReplyInput;
  gh_AddPullRequestReviewThreadReplyPayload: ResolverTypeWrapper<gh_AddPullRequestReviewThreadReplyPayload>;
  gh_AddReactionInput: gh_AddReactionInput;
  gh_AddReactionPayload: ResolverTypeWrapper<gh_AddReactionPayload>;
  gh_AddStarInput: gh_AddStarInput;
  gh_AddStarPayload: ResolverTypeWrapper<gh_AddStarPayload>;
  gh_AddUpvoteInput: gh_AddUpvoteInput;
  gh_AddUpvotePayload: ResolverTypeWrapper<gh_AddUpvotePayload>;
  gh_AddVerifiableDomainInput: gh_AddVerifiableDomainInput;
  gh_AddVerifiableDomainPayload: ResolverTypeWrapper<gh_AddVerifiableDomainPayload>;
  gh_AddedToMergeQueueEvent: ResolverTypeWrapper<gh_AddedToMergeQueueEvent>;
  gh_AddedToProjectEvent: ResolverTypeWrapper<gh_AddedToProjectEvent>;
  gh_AnnouncementBanner: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_AnnouncementBanner']>;
  gh_App: ResolverTypeWrapper<gh_App>;
  gh_ApproveDeploymentsInput: gh_ApproveDeploymentsInput;
  gh_ApproveDeploymentsPayload: ResolverTypeWrapper<gh_ApproveDeploymentsPayload>;
  gh_ApproveVerifiableDomainInput: gh_ApproveVerifiableDomainInput;
  gh_ApproveVerifiableDomainPayload: ResolverTypeWrapper<gh_ApproveVerifiableDomainPayload>;
  gh_ArchiveProjectV2ItemInput: gh_ArchiveProjectV2ItemInput;
  gh_ArchiveProjectV2ItemPayload: ResolverTypeWrapper<gh_ArchiveProjectV2ItemPayload>;
  gh_ArchiveRepositoryInput: gh_ArchiveRepositoryInput;
  gh_ArchiveRepositoryPayload: ResolverTypeWrapper<gh_ArchiveRepositoryPayload>;
  gh_Assignable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Assignable']>;
  gh_AssignedEvent: ResolverTypeWrapper<Omit<gh_AssignedEvent, 'assignee'> & { assignee?: Maybe<ResolversTypes['gh_Assignee']> }>;
  gh_Assignee: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_Assignee']>;
  gh_AuditEntry: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_AuditEntry']>;
  gh_AuditEntryActor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_AuditEntryActor']>;
  gh_AuditLogOrder: gh_AuditLogOrder;
  gh_AuditLogOrderField: gh_AuditLogOrderField;
  gh_AutoMergeDisabledEvent: ResolverTypeWrapper<gh_AutoMergeDisabledEvent>;
  gh_AutoMergeEnabledEvent: ResolverTypeWrapper<gh_AutoMergeEnabledEvent>;
  gh_AutoMergeRequest: ResolverTypeWrapper<gh_AutoMergeRequest>;
  gh_AutoRebaseEnabledEvent: ResolverTypeWrapper<gh_AutoRebaseEnabledEvent>;
  gh_AutoSquashEnabledEvent: ResolverTypeWrapper<gh_AutoSquashEnabledEvent>;
  gh_AutomaticBaseChangeFailedEvent: ResolverTypeWrapper<gh_AutomaticBaseChangeFailedEvent>;
  gh_AutomaticBaseChangeSucceededEvent: ResolverTypeWrapper<gh_AutomaticBaseChangeSucceededEvent>;
  gh_Base64String: ResolverTypeWrapper<Scalars['gh_Base64String']['output']>;
  gh_BaseRefChangedEvent: ResolverTypeWrapper<gh_BaseRefChangedEvent>;
  gh_BaseRefDeletedEvent: ResolverTypeWrapper<gh_BaseRefDeletedEvent>;
  gh_BaseRefForcePushedEvent: ResolverTypeWrapper<gh_BaseRefForcePushedEvent>;
  BigInt: ResolverTypeWrapper<Scalars['BigInt']['output']>;
  gh_Blame: ResolverTypeWrapper<gh_Blame>;
  gh_BlameRange: ResolverTypeWrapper<gh_BlameRange>;
  gh_Blob: ResolverTypeWrapper<gh_Blob>;
  gh_Bot: ResolverTypeWrapper<gh_Bot>;
  gh_BranchActorAllowanceActor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_BranchActorAllowanceActor']>;
  gh_BranchNamePatternParameters: ResolverTypeWrapper<gh_BranchNamePatternParameters>;
  gh_BranchNamePatternParametersInput: gh_BranchNamePatternParametersInput;
  gh_BranchProtectionRule: ResolverTypeWrapper<gh_BranchProtectionRule>;
  gh_BranchProtectionRuleConflict: ResolverTypeWrapper<gh_BranchProtectionRuleConflict>;
  gh_BranchProtectionRuleConflictConnection: ResolverTypeWrapper<gh_BranchProtectionRuleConflictConnection>;
  gh_BranchProtectionRuleConflictEdge: ResolverTypeWrapper<gh_BranchProtectionRuleConflictEdge>;
  gh_BranchProtectionRuleConnection: ResolverTypeWrapper<gh_BranchProtectionRuleConnection>;
  gh_BranchProtectionRuleEdge: ResolverTypeWrapper<gh_BranchProtectionRuleEdge>;
  gh_BulkSponsorship: gh_BulkSponsorship;
  gh_BypassActor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_BypassActor']>;
  gh_BypassForcePushAllowance: ResolverTypeWrapper<Omit<gh_BypassForcePushAllowance, 'actor'> & { actor?: Maybe<ResolversTypes['gh_BranchActorAllowanceActor']> }>;
  gh_BypassForcePushAllowanceConnection: ResolverTypeWrapper<gh_BypassForcePushAllowanceConnection>;
  gh_BypassForcePushAllowanceEdge: ResolverTypeWrapper<gh_BypassForcePushAllowanceEdge>;
  gh_BypassPullRequestAllowance: ResolverTypeWrapper<Omit<gh_BypassPullRequestAllowance, 'actor'> & { actor?: Maybe<ResolversTypes['gh_BranchActorAllowanceActor']> }>;
  gh_BypassPullRequestAllowanceConnection: ResolverTypeWrapper<gh_BypassPullRequestAllowanceConnection>;
  gh_BypassPullRequestAllowanceEdge: ResolverTypeWrapper<gh_BypassPullRequestAllowanceEdge>;
  gh_CVSS: ResolverTypeWrapper<gh_CVSS>;
  Float: ResolverTypeWrapper<Scalars['Float']['output']>;
  gh_CWE: ResolverTypeWrapper<gh_CWE>;
  gh_CWEConnection: ResolverTypeWrapper<gh_CWEConnection>;
  gh_CWEEdge: ResolverTypeWrapper<gh_CWEEdge>;
  gh_CancelEnterpriseAdminInvitationInput: gh_CancelEnterpriseAdminInvitationInput;
  gh_CancelEnterpriseAdminInvitationPayload: ResolverTypeWrapper<gh_CancelEnterpriseAdminInvitationPayload>;
  gh_CancelSponsorshipInput: gh_CancelSponsorshipInput;
  gh_CancelSponsorshipPayload: ResolverTypeWrapper<gh_CancelSponsorshipPayload>;
  gh_ChangeUserStatusInput: gh_ChangeUserStatusInput;
  gh_ChangeUserStatusPayload: ResolverTypeWrapper<gh_ChangeUserStatusPayload>;
  gh_CheckAnnotation: ResolverTypeWrapper<gh_CheckAnnotation>;
  gh_CheckAnnotationConnection: ResolverTypeWrapper<gh_CheckAnnotationConnection>;
  gh_CheckAnnotationData: gh_CheckAnnotationData;
  gh_CheckAnnotationEdge: ResolverTypeWrapper<gh_CheckAnnotationEdge>;
  gh_CheckAnnotationLevel: gh_CheckAnnotationLevel;
  gh_CheckAnnotationPosition: ResolverTypeWrapper<gh_CheckAnnotationPosition>;
  gh_CheckAnnotationRange: gh_CheckAnnotationRange;
  gh_CheckAnnotationSpan: ResolverTypeWrapper<gh_CheckAnnotationSpan>;
  gh_CheckConclusionState: gh_CheckConclusionState;
  gh_CheckRun: ResolverTypeWrapper<gh_CheckRun>;
  gh_CheckRunAction: gh_CheckRunAction;
  gh_CheckRunConnection: ResolverTypeWrapper<gh_CheckRunConnection>;
  gh_CheckRunEdge: ResolverTypeWrapper<gh_CheckRunEdge>;
  gh_CheckRunFilter: gh_CheckRunFilter;
  gh_CheckRunOutput: gh_CheckRunOutput;
  gh_CheckRunOutputImage: gh_CheckRunOutputImage;
  gh_CheckRunState: gh_CheckRunState;
  gh_CheckRunStateCount: ResolverTypeWrapper<gh_CheckRunStateCount>;
  gh_CheckRunType: gh_CheckRunType;
  gh_CheckStatusState: gh_CheckStatusState;
  gh_CheckStep: ResolverTypeWrapper<gh_CheckStep>;
  gh_CheckStepConnection: ResolverTypeWrapper<gh_CheckStepConnection>;
  gh_CheckStepEdge: ResolverTypeWrapper<gh_CheckStepEdge>;
  gh_CheckSuite: ResolverTypeWrapper<gh_CheckSuite>;
  gh_CheckSuiteAutoTriggerPreference: gh_CheckSuiteAutoTriggerPreference;
  gh_CheckSuiteConnection: ResolverTypeWrapper<gh_CheckSuiteConnection>;
  gh_CheckSuiteEdge: ResolverTypeWrapper<gh_CheckSuiteEdge>;
  gh_CheckSuiteFilter: gh_CheckSuiteFilter;
  gh_Claimable: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_Claimable']>;
  gh_ClearLabelsFromLabelableInput: gh_ClearLabelsFromLabelableInput;
  gh_ClearLabelsFromLabelablePayload: ResolverTypeWrapper<gh_ClearLabelsFromLabelablePayload>;
  gh_ClearProjectV2ItemFieldValueInput: gh_ClearProjectV2ItemFieldValueInput;
  gh_ClearProjectV2ItemFieldValuePayload: ResolverTypeWrapper<gh_ClearProjectV2ItemFieldValuePayload>;
  gh_CloneProjectInput: gh_CloneProjectInput;
  gh_CloneProjectPayload: ResolverTypeWrapper<gh_CloneProjectPayload>;
  gh_CloneTemplateRepositoryInput: gh_CloneTemplateRepositoryInput;
  gh_CloneTemplateRepositoryPayload: ResolverTypeWrapper<gh_CloneTemplateRepositoryPayload>;
  gh_Closable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Closable']>;
  gh_CloseDiscussionInput: gh_CloseDiscussionInput;
  gh_CloseDiscussionPayload: ResolverTypeWrapper<gh_CloseDiscussionPayload>;
  gh_CloseIssueInput: gh_CloseIssueInput;
  gh_CloseIssuePayload: ResolverTypeWrapper<gh_CloseIssuePayload>;
  gh_ClosePullRequestInput: gh_ClosePullRequestInput;
  gh_ClosePullRequestPayload: ResolverTypeWrapper<gh_ClosePullRequestPayload>;
  gh_ClosedEvent: ResolverTypeWrapper<Omit<gh_ClosedEvent, 'closer'> & { closer?: Maybe<ResolversTypes['gh_Closer']> }>;
  gh_Closer: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_Closer']>;
  gh_CodeOfConduct: ResolverTypeWrapper<gh_CodeOfConduct>;
  gh_CollaboratorAffiliation: gh_CollaboratorAffiliation;
  gh_Comment: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Comment']>;
  gh_CommentAuthorAssociation: gh_CommentAuthorAssociation;
  gh_CommentCannotUpdateReason: gh_CommentCannotUpdateReason;
  gh_CommentDeletedEvent: ResolverTypeWrapper<gh_CommentDeletedEvent>;
  gh_Commit: ResolverTypeWrapper<gh_Commit>;
  gh_CommitAuthor: gh_CommitAuthor;
  gh_CommitAuthorEmailPatternParameters: ResolverTypeWrapper<gh_CommitAuthorEmailPatternParameters>;
  gh_CommitAuthorEmailPatternParametersInput: gh_CommitAuthorEmailPatternParametersInput;
  gh_CommitComment: ResolverTypeWrapper<gh_CommitComment>;
  gh_CommitCommentConnection: ResolverTypeWrapper<gh_CommitCommentConnection>;
  gh_CommitCommentEdge: ResolverTypeWrapper<gh_CommitCommentEdge>;
  gh_CommitCommentThread: ResolverTypeWrapper<gh_CommitCommentThread>;
  gh_CommitConnection: ResolverTypeWrapper<gh_CommitConnection>;
  gh_CommitContributionOrder: gh_CommitContributionOrder;
  gh_CommitContributionOrderField: gh_CommitContributionOrderField;
  gh_CommitContributionsByRepository: ResolverTypeWrapper<gh_CommitContributionsByRepository>;
  gh_CommitEdge: ResolverTypeWrapper<gh_CommitEdge>;
  gh_CommitHistoryConnection: ResolverTypeWrapper<gh_CommitHistoryConnection>;
  gh_CommitMessage: gh_CommitMessage;
  gh_CommitMessagePatternParameters: ResolverTypeWrapper<gh_CommitMessagePatternParameters>;
  gh_CommitMessagePatternParametersInput: gh_CommitMessagePatternParametersInput;
  gh_CommittableBranch: gh_CommittableBranch;
  gh_CommitterEmailPatternParameters: ResolverTypeWrapper<gh_CommitterEmailPatternParameters>;
  gh_CommitterEmailPatternParametersInput: gh_CommitterEmailPatternParametersInput;
  gh_Comparison: ResolverTypeWrapper<gh_Comparison>;
  gh_ComparisonCommitConnection: ResolverTypeWrapper<gh_ComparisonCommitConnection>;
  gh_ComparisonStatus: gh_ComparisonStatus;
  gh_ConnectedEvent: ResolverTypeWrapper<Omit<gh_ConnectedEvent, 'source' | 'subject'> & { source: ResolversTypes['gh_ReferencedSubject'], subject: ResolversTypes['gh_ReferencedSubject'] }>;
  gh_ContributingGuidelines: ResolverTypeWrapper<gh_ContributingGuidelines>;
  gh_Contribution: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Contribution']>;
  gh_ContributionCalendar: ResolverTypeWrapper<gh_ContributionCalendar>;
  gh_ContributionCalendarDay: ResolverTypeWrapper<gh_ContributionCalendarDay>;
  gh_ContributionCalendarMonth: ResolverTypeWrapper<gh_ContributionCalendarMonth>;
  gh_ContributionCalendarWeek: ResolverTypeWrapper<gh_ContributionCalendarWeek>;
  gh_ContributionLevel: gh_ContributionLevel;
  gh_ContributionOrder: gh_ContributionOrder;
  gh_ContributionsCollection: ResolverTypeWrapper<Omit<gh_ContributionsCollection, 'firstIssueContribution' | 'firstPullRequestContribution' | 'firstRepositoryContribution'> & { firstIssueContribution?: Maybe<ResolversTypes['gh_CreatedIssueOrRestrictedContribution']>, firstPullRequestContribution?: Maybe<ResolversTypes['gh_CreatedPullRequestOrRestrictedContribution']>, firstRepositoryContribution?: Maybe<ResolversTypes['gh_CreatedRepositoryOrRestrictedContribution']> }>;
  gh_ConvertProjectCardNoteToIssueInput: gh_ConvertProjectCardNoteToIssueInput;
  gh_ConvertProjectCardNoteToIssuePayload: ResolverTypeWrapper<gh_ConvertProjectCardNoteToIssuePayload>;
  gh_ConvertPullRequestToDraftInput: gh_ConvertPullRequestToDraftInput;
  gh_ConvertPullRequestToDraftPayload: ResolverTypeWrapper<gh_ConvertPullRequestToDraftPayload>;
  gh_ConvertToDraftEvent: ResolverTypeWrapper<gh_ConvertToDraftEvent>;
  gh_ConvertedNoteToIssueEvent: ResolverTypeWrapper<gh_ConvertedNoteToIssueEvent>;
  gh_ConvertedToDiscussionEvent: ResolverTypeWrapper<gh_ConvertedToDiscussionEvent>;
  gh_CopyProjectV2Input: gh_CopyProjectV2Input;
  gh_CopyProjectV2Payload: ResolverTypeWrapper<gh_CopyProjectV2Payload>;
  gh_CreateAttributionInvitationInput: gh_CreateAttributionInvitationInput;
  gh_CreateAttributionInvitationPayload: ResolverTypeWrapper<Omit<gh_CreateAttributionInvitationPayload, 'source' | 'target'> & { source?: Maybe<ResolversTypes['gh_Claimable']>, target?: Maybe<ResolversTypes['gh_Claimable']> }>;
  gh_CreateBranchProtectionRuleInput: gh_CreateBranchProtectionRuleInput;
  gh_CreateBranchProtectionRulePayload: ResolverTypeWrapper<gh_CreateBranchProtectionRulePayload>;
  gh_CreateCheckRunInput: gh_CreateCheckRunInput;
  gh_CreateCheckRunPayload: ResolverTypeWrapper<gh_CreateCheckRunPayload>;
  gh_CreateCheckSuiteInput: gh_CreateCheckSuiteInput;
  gh_CreateCheckSuitePayload: ResolverTypeWrapper<gh_CreateCheckSuitePayload>;
  gh_CreateCommitOnBranchInput: gh_CreateCommitOnBranchInput;
  gh_CreateCommitOnBranchPayload: ResolverTypeWrapper<gh_CreateCommitOnBranchPayload>;
  gh_CreateDeploymentInput: gh_CreateDeploymentInput;
  gh_CreateDeploymentPayload: ResolverTypeWrapper<gh_CreateDeploymentPayload>;
  gh_CreateDeploymentStatusInput: gh_CreateDeploymentStatusInput;
  gh_CreateDeploymentStatusPayload: ResolverTypeWrapper<gh_CreateDeploymentStatusPayload>;
  gh_CreateDiscussionInput: gh_CreateDiscussionInput;
  gh_CreateDiscussionPayload: ResolverTypeWrapper<gh_CreateDiscussionPayload>;
  gh_CreateEnterpriseOrganizationInput: gh_CreateEnterpriseOrganizationInput;
  gh_CreateEnterpriseOrganizationPayload: ResolverTypeWrapper<gh_CreateEnterpriseOrganizationPayload>;
  gh_CreateEnvironmentInput: gh_CreateEnvironmentInput;
  gh_CreateEnvironmentPayload: ResolverTypeWrapper<gh_CreateEnvironmentPayload>;
  gh_CreateIpAllowListEntryInput: gh_CreateIpAllowListEntryInput;
  gh_CreateIpAllowListEntryPayload: ResolverTypeWrapper<gh_CreateIpAllowListEntryPayload>;
  gh_CreateIssueInput: gh_CreateIssueInput;
  gh_CreateIssuePayload: ResolverTypeWrapper<gh_CreateIssuePayload>;
  gh_CreateLabelInput: gh_CreateLabelInput;
  gh_CreateLabelPayload: ResolverTypeWrapper<gh_CreateLabelPayload>;
  gh_CreateLinkedBranchInput: gh_CreateLinkedBranchInput;
  gh_CreateLinkedBranchPayload: ResolverTypeWrapper<gh_CreateLinkedBranchPayload>;
  gh_CreateMigrationSourceInput: gh_CreateMigrationSourceInput;
  gh_CreateMigrationSourcePayload: ResolverTypeWrapper<gh_CreateMigrationSourcePayload>;
  gh_CreateProjectInput: gh_CreateProjectInput;
  gh_CreateProjectPayload: ResolverTypeWrapper<gh_CreateProjectPayload>;
  gh_CreateProjectV2FieldInput: gh_CreateProjectV2FieldInput;
  gh_CreateProjectV2FieldPayload: ResolverTypeWrapper<Omit<gh_CreateProjectV2FieldPayload, 'projectV2Field'> & { projectV2Field?: Maybe<ResolversTypes['gh_ProjectV2FieldConfiguration']> }>;
  gh_CreateProjectV2Input: gh_CreateProjectV2Input;
  gh_CreateProjectV2Payload: ResolverTypeWrapper<gh_CreateProjectV2Payload>;
  gh_CreatePullRequestInput: gh_CreatePullRequestInput;
  gh_CreatePullRequestPayload: ResolverTypeWrapper<gh_CreatePullRequestPayload>;
  gh_CreateRefInput: gh_CreateRefInput;
  gh_CreateRefPayload: ResolverTypeWrapper<gh_CreateRefPayload>;
  gh_CreateRepositoryInput: gh_CreateRepositoryInput;
  gh_CreateRepositoryPayload: ResolverTypeWrapper<gh_CreateRepositoryPayload>;
  gh_CreateRepositoryRulesetInput: gh_CreateRepositoryRulesetInput;
  gh_CreateRepositoryRulesetPayload: ResolverTypeWrapper<gh_CreateRepositoryRulesetPayload>;
  gh_CreateSponsorsListingInput: gh_CreateSponsorsListingInput;
  gh_CreateSponsorsListingPayload: ResolverTypeWrapper<gh_CreateSponsorsListingPayload>;
  gh_CreateSponsorsTierInput: gh_CreateSponsorsTierInput;
  gh_CreateSponsorsTierPayload: ResolverTypeWrapper<gh_CreateSponsorsTierPayload>;
  gh_CreateSponsorshipInput: gh_CreateSponsorshipInput;
  gh_CreateSponsorshipPayload: ResolverTypeWrapper<gh_CreateSponsorshipPayload>;
  gh_CreateSponsorshipsInput: gh_CreateSponsorshipsInput;
  gh_CreateSponsorshipsPayload: ResolverTypeWrapper<gh_CreateSponsorshipsPayload>;
  gh_CreateTeamDiscussionCommentInput: gh_CreateTeamDiscussionCommentInput;
  gh_CreateTeamDiscussionCommentPayload: ResolverTypeWrapper<gh_CreateTeamDiscussionCommentPayload>;
  gh_CreateTeamDiscussionInput: gh_CreateTeamDiscussionInput;
  gh_CreateTeamDiscussionPayload: ResolverTypeWrapper<gh_CreateTeamDiscussionPayload>;
  gh_CreateUserListInput: gh_CreateUserListInput;
  gh_CreateUserListPayload: ResolverTypeWrapper<gh_CreateUserListPayload>;
  gh_CreatedCommitContribution: ResolverTypeWrapper<gh_CreatedCommitContribution>;
  gh_CreatedCommitContributionConnection: ResolverTypeWrapper<gh_CreatedCommitContributionConnection>;
  gh_CreatedCommitContributionEdge: ResolverTypeWrapper<gh_CreatedCommitContributionEdge>;
  gh_CreatedIssueContribution: ResolverTypeWrapper<gh_CreatedIssueContribution>;
  gh_CreatedIssueContributionConnection: ResolverTypeWrapper<gh_CreatedIssueContributionConnection>;
  gh_CreatedIssueContributionEdge: ResolverTypeWrapper<gh_CreatedIssueContributionEdge>;
  gh_CreatedIssueOrRestrictedContribution: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_CreatedIssueOrRestrictedContribution']>;
  gh_CreatedPullRequestContribution: ResolverTypeWrapper<gh_CreatedPullRequestContribution>;
  gh_CreatedPullRequestContributionConnection: ResolverTypeWrapper<gh_CreatedPullRequestContributionConnection>;
  gh_CreatedPullRequestContributionEdge: ResolverTypeWrapper<gh_CreatedPullRequestContributionEdge>;
  gh_CreatedPullRequestOrRestrictedContribution: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_CreatedPullRequestOrRestrictedContribution']>;
  gh_CreatedPullRequestReviewContribution: ResolverTypeWrapper<gh_CreatedPullRequestReviewContribution>;
  gh_CreatedPullRequestReviewContributionConnection: ResolverTypeWrapper<gh_CreatedPullRequestReviewContributionConnection>;
  gh_CreatedPullRequestReviewContributionEdge: ResolverTypeWrapper<gh_CreatedPullRequestReviewContributionEdge>;
  gh_CreatedRepositoryContribution: ResolverTypeWrapper<gh_CreatedRepositoryContribution>;
  gh_CreatedRepositoryContributionConnection: ResolverTypeWrapper<gh_CreatedRepositoryContributionConnection>;
  gh_CreatedRepositoryContributionEdge: ResolverTypeWrapper<gh_CreatedRepositoryContributionEdge>;
  gh_CreatedRepositoryOrRestrictedContribution: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_CreatedRepositoryOrRestrictedContribution']>;
  gh_CrossReferencedEvent: ResolverTypeWrapper<Omit<gh_CrossReferencedEvent, 'source' | 'target'> & { source: ResolversTypes['gh_ReferencedSubject'], target: ResolversTypes['gh_ReferencedSubject'] }>;
  Date: ResolverTypeWrapper<Scalars['Date']['output']>;
  DateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;
  gh_DeclineTopicSuggestionInput: gh_DeclineTopicSuggestionInput;
  gh_DeclineTopicSuggestionPayload: ResolverTypeWrapper<gh_DeclineTopicSuggestionPayload>;
  gh_DefaultRepositoryPermissionField: gh_DefaultRepositoryPermissionField;
  gh_Deletable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Deletable']>;
  gh_DeleteBranchProtectionRuleInput: gh_DeleteBranchProtectionRuleInput;
  gh_DeleteBranchProtectionRulePayload: ResolverTypeWrapper<gh_DeleteBranchProtectionRulePayload>;
  gh_DeleteDeploymentInput: gh_DeleteDeploymentInput;
  gh_DeleteDeploymentPayload: ResolverTypeWrapper<gh_DeleteDeploymentPayload>;
  gh_DeleteDiscussionCommentInput: gh_DeleteDiscussionCommentInput;
  gh_DeleteDiscussionCommentPayload: ResolverTypeWrapper<gh_DeleteDiscussionCommentPayload>;
  gh_DeleteDiscussionInput: gh_DeleteDiscussionInput;
  gh_DeleteDiscussionPayload: ResolverTypeWrapper<gh_DeleteDiscussionPayload>;
  gh_DeleteEnvironmentInput: gh_DeleteEnvironmentInput;
  gh_DeleteEnvironmentPayload: ResolverTypeWrapper<gh_DeleteEnvironmentPayload>;
  gh_DeleteIpAllowListEntryInput: gh_DeleteIpAllowListEntryInput;
  gh_DeleteIpAllowListEntryPayload: ResolverTypeWrapper<gh_DeleteIpAllowListEntryPayload>;
  gh_DeleteIssueCommentInput: gh_DeleteIssueCommentInput;
  gh_DeleteIssueCommentPayload: ResolverTypeWrapper<gh_DeleteIssueCommentPayload>;
  gh_DeleteIssueInput: gh_DeleteIssueInput;
  gh_DeleteIssuePayload: ResolverTypeWrapper<gh_DeleteIssuePayload>;
  gh_DeleteLabelInput: gh_DeleteLabelInput;
  gh_DeleteLabelPayload: ResolverTypeWrapper<gh_DeleteLabelPayload>;
  gh_DeleteLinkedBranchInput: gh_DeleteLinkedBranchInput;
  gh_DeleteLinkedBranchPayload: ResolverTypeWrapper<gh_DeleteLinkedBranchPayload>;
  gh_DeletePackageVersionInput: gh_DeletePackageVersionInput;
  gh_DeletePackageVersionPayload: ResolverTypeWrapper<gh_DeletePackageVersionPayload>;
  gh_DeleteProjectCardInput: gh_DeleteProjectCardInput;
  gh_DeleteProjectCardPayload: ResolverTypeWrapper<gh_DeleteProjectCardPayload>;
  gh_DeleteProjectColumnInput: gh_DeleteProjectColumnInput;
  gh_DeleteProjectColumnPayload: ResolverTypeWrapper<gh_DeleteProjectColumnPayload>;
  gh_DeleteProjectInput: gh_DeleteProjectInput;
  gh_DeleteProjectPayload: ResolverTypeWrapper<gh_DeleteProjectPayload>;
  gh_DeleteProjectV2FieldInput: gh_DeleteProjectV2FieldInput;
  gh_DeleteProjectV2FieldPayload: ResolverTypeWrapper<Omit<gh_DeleteProjectV2FieldPayload, 'projectV2Field'> & { projectV2Field?: Maybe<ResolversTypes['gh_ProjectV2FieldConfiguration']> }>;
  gh_DeleteProjectV2Input: gh_DeleteProjectV2Input;
  gh_DeleteProjectV2ItemInput: gh_DeleteProjectV2ItemInput;
  gh_DeleteProjectV2ItemPayload: ResolverTypeWrapper<gh_DeleteProjectV2ItemPayload>;
  gh_DeleteProjectV2Payload: ResolverTypeWrapper<gh_DeleteProjectV2Payload>;
  gh_DeleteProjectV2WorkflowInput: gh_DeleteProjectV2WorkflowInput;
  gh_DeleteProjectV2WorkflowPayload: ResolverTypeWrapper<gh_DeleteProjectV2WorkflowPayload>;
  gh_DeletePullRequestReviewCommentInput: gh_DeletePullRequestReviewCommentInput;
  gh_DeletePullRequestReviewCommentPayload: ResolverTypeWrapper<gh_DeletePullRequestReviewCommentPayload>;
  gh_DeletePullRequestReviewInput: gh_DeletePullRequestReviewInput;
  gh_DeletePullRequestReviewPayload: ResolverTypeWrapper<gh_DeletePullRequestReviewPayload>;
  gh_DeleteRefInput: gh_DeleteRefInput;
  gh_DeleteRefPayload: ResolverTypeWrapper<gh_DeleteRefPayload>;
  gh_DeleteRepositoryRulesetInput: gh_DeleteRepositoryRulesetInput;
  gh_DeleteRepositoryRulesetPayload: ResolverTypeWrapper<gh_DeleteRepositoryRulesetPayload>;
  gh_DeleteTeamDiscussionCommentInput: gh_DeleteTeamDiscussionCommentInput;
  gh_DeleteTeamDiscussionCommentPayload: ResolverTypeWrapper<gh_DeleteTeamDiscussionCommentPayload>;
  gh_DeleteTeamDiscussionInput: gh_DeleteTeamDiscussionInput;
  gh_DeleteTeamDiscussionPayload: ResolverTypeWrapper<gh_DeleteTeamDiscussionPayload>;
  gh_DeleteUserListInput: gh_DeleteUserListInput;
  gh_DeleteUserListPayload: ResolverTypeWrapper<gh_DeleteUserListPayload>;
  gh_DeleteVerifiableDomainInput: gh_DeleteVerifiableDomainInput;
  gh_DeleteVerifiableDomainPayload: ResolverTypeWrapper<Omit<gh_DeleteVerifiableDomainPayload, 'owner'> & { owner?: Maybe<ResolversTypes['gh_VerifiableDomainOwner']> }>;
  gh_DemilestonedEvent: ResolverTypeWrapper<Omit<gh_DemilestonedEvent, 'subject'> & { subject: ResolversTypes['gh_MilestoneItem'] }>;
  gh_DependabotUpdate: ResolverTypeWrapper<gh_DependabotUpdate>;
  gh_DependabotUpdateError: ResolverTypeWrapper<gh_DependabotUpdateError>;
  gh_DependencyGraphDependency: ResolverTypeWrapper<gh_DependencyGraphDependency>;
  gh_DependencyGraphDependencyConnection: ResolverTypeWrapper<gh_DependencyGraphDependencyConnection>;
  gh_DependencyGraphDependencyEdge: ResolverTypeWrapper<gh_DependencyGraphDependencyEdge>;
  gh_DependencyGraphEcosystem: gh_DependencyGraphEcosystem;
  gh_DependencyGraphManifest: ResolverTypeWrapper<gh_DependencyGraphManifest>;
  gh_DependencyGraphManifestConnection: ResolverTypeWrapper<gh_DependencyGraphManifestConnection>;
  gh_DependencyGraphManifestEdge: ResolverTypeWrapper<gh_DependencyGraphManifestEdge>;
  gh_DeployKey: ResolverTypeWrapper<gh_DeployKey>;
  gh_DeployKeyConnection: ResolverTypeWrapper<gh_DeployKeyConnection>;
  gh_DeployKeyEdge: ResolverTypeWrapper<gh_DeployKeyEdge>;
  gh_DeployedEvent: ResolverTypeWrapper<gh_DeployedEvent>;
  gh_Deployment: ResolverTypeWrapper<gh_Deployment>;
  gh_DeploymentConnection: ResolverTypeWrapper<gh_DeploymentConnection>;
  gh_DeploymentEdge: ResolverTypeWrapper<gh_DeploymentEdge>;
  gh_DeploymentEnvironmentChangedEvent: ResolverTypeWrapper<gh_DeploymentEnvironmentChangedEvent>;
  gh_DeploymentOrder: gh_DeploymentOrder;
  gh_DeploymentOrderField: gh_DeploymentOrderField;
  gh_DeploymentProtectionRule: ResolverTypeWrapper<gh_DeploymentProtectionRule>;
  gh_DeploymentProtectionRuleConnection: ResolverTypeWrapper<gh_DeploymentProtectionRuleConnection>;
  gh_DeploymentProtectionRuleEdge: ResolverTypeWrapper<gh_DeploymentProtectionRuleEdge>;
  gh_DeploymentProtectionRuleType: gh_DeploymentProtectionRuleType;
  gh_DeploymentRequest: ResolverTypeWrapper<gh_DeploymentRequest>;
  gh_DeploymentRequestConnection: ResolverTypeWrapper<gh_DeploymentRequestConnection>;
  gh_DeploymentRequestEdge: ResolverTypeWrapper<gh_DeploymentRequestEdge>;
  gh_DeploymentReview: ResolverTypeWrapper<gh_DeploymentReview>;
  gh_DeploymentReviewConnection: ResolverTypeWrapper<gh_DeploymentReviewConnection>;
  gh_DeploymentReviewEdge: ResolverTypeWrapper<gh_DeploymentReviewEdge>;
  gh_DeploymentReviewState: gh_DeploymentReviewState;
  gh_DeploymentReviewer: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_DeploymentReviewer']>;
  gh_DeploymentReviewerConnection: ResolverTypeWrapper<Omit<gh_DeploymentReviewerConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_DeploymentReviewer']>>> }>;
  gh_DeploymentReviewerEdge: ResolverTypeWrapper<Omit<gh_DeploymentReviewerEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_DeploymentReviewer']> }>;
  gh_DeploymentState: gh_DeploymentState;
  gh_DeploymentStatus: ResolverTypeWrapper<gh_DeploymentStatus>;
  gh_DeploymentStatusConnection: ResolverTypeWrapper<gh_DeploymentStatusConnection>;
  gh_DeploymentStatusEdge: ResolverTypeWrapper<gh_DeploymentStatusEdge>;
  gh_DeploymentStatusState: gh_DeploymentStatusState;
  gh_DequeuePullRequestInput: gh_DequeuePullRequestInput;
  gh_DequeuePullRequestPayload: ResolverTypeWrapper<gh_DequeuePullRequestPayload>;
  gh_DiffSide: gh_DiffSide;
  gh_DisablePullRequestAutoMergeInput: gh_DisablePullRequestAutoMergeInput;
  gh_DisablePullRequestAutoMergePayload: ResolverTypeWrapper<gh_DisablePullRequestAutoMergePayload>;
  gh_DisconnectedEvent: ResolverTypeWrapper<Omit<gh_DisconnectedEvent, 'source' | 'subject'> & { source: ResolversTypes['gh_ReferencedSubject'], subject: ResolversTypes['gh_ReferencedSubject'] }>;
  gh_Discussion: ResolverTypeWrapper<gh_Discussion>;
  gh_DiscussionCategory: ResolverTypeWrapper<gh_DiscussionCategory>;
  gh_DiscussionCategoryConnection: ResolverTypeWrapper<gh_DiscussionCategoryConnection>;
  gh_DiscussionCategoryEdge: ResolverTypeWrapper<gh_DiscussionCategoryEdge>;
  gh_DiscussionCloseReason: gh_DiscussionCloseReason;
  gh_DiscussionComment: ResolverTypeWrapper<gh_DiscussionComment>;
  gh_DiscussionCommentConnection: ResolverTypeWrapper<gh_DiscussionCommentConnection>;
  gh_DiscussionCommentEdge: ResolverTypeWrapper<gh_DiscussionCommentEdge>;
  gh_DiscussionConnection: ResolverTypeWrapper<gh_DiscussionConnection>;
  gh_DiscussionEdge: ResolverTypeWrapper<gh_DiscussionEdge>;
  gh_DiscussionOrder: gh_DiscussionOrder;
  gh_DiscussionOrderField: gh_DiscussionOrderField;
  gh_DiscussionPoll: ResolverTypeWrapper<gh_DiscussionPoll>;
  gh_DiscussionPollOption: ResolverTypeWrapper<gh_DiscussionPollOption>;
  gh_DiscussionPollOptionConnection: ResolverTypeWrapper<gh_DiscussionPollOptionConnection>;
  gh_DiscussionPollOptionEdge: ResolverTypeWrapper<gh_DiscussionPollOptionEdge>;
  gh_DiscussionPollOptionOrder: gh_DiscussionPollOptionOrder;
  gh_DiscussionPollOptionOrderField: gh_DiscussionPollOptionOrderField;
  gh_DiscussionState: gh_DiscussionState;
  gh_DiscussionStateReason: gh_DiscussionStateReason;
  gh_DismissPullRequestReviewInput: gh_DismissPullRequestReviewInput;
  gh_DismissPullRequestReviewPayload: ResolverTypeWrapper<gh_DismissPullRequestReviewPayload>;
  gh_DismissReason: gh_DismissReason;
  gh_DismissRepositoryVulnerabilityAlertInput: gh_DismissRepositoryVulnerabilityAlertInput;
  gh_DismissRepositoryVulnerabilityAlertPayload: ResolverTypeWrapper<gh_DismissRepositoryVulnerabilityAlertPayload>;
  gh_DraftIssue: ResolverTypeWrapper<gh_DraftIssue>;
  gh_DraftPullRequestReviewComment: gh_DraftPullRequestReviewComment;
  gh_DraftPullRequestReviewThread: gh_DraftPullRequestReviewThread;
  gh_EnablePullRequestAutoMergeInput: gh_EnablePullRequestAutoMergeInput;
  gh_EnablePullRequestAutoMergePayload: ResolverTypeWrapper<gh_EnablePullRequestAutoMergePayload>;
  gh_EnqueuePullRequestInput: gh_EnqueuePullRequestInput;
  gh_EnqueuePullRequestPayload: ResolverTypeWrapper<gh_EnqueuePullRequestPayload>;
  gh_Enterprise: ResolverTypeWrapper<gh_Enterprise>;
  gh_EnterpriseAdministratorConnection: ResolverTypeWrapper<gh_EnterpriseAdministratorConnection>;
  gh_EnterpriseAdministratorEdge: ResolverTypeWrapper<gh_EnterpriseAdministratorEdge>;
  gh_EnterpriseAdministratorInvitation: ResolverTypeWrapper<gh_EnterpriseAdministratorInvitation>;
  gh_EnterpriseAdministratorInvitationConnection: ResolverTypeWrapper<gh_EnterpriseAdministratorInvitationConnection>;
  gh_EnterpriseAdministratorInvitationEdge: ResolverTypeWrapper<gh_EnterpriseAdministratorInvitationEdge>;
  gh_EnterpriseAdministratorInvitationOrder: gh_EnterpriseAdministratorInvitationOrder;
  gh_EnterpriseAdministratorInvitationOrderField: gh_EnterpriseAdministratorInvitationOrderField;
  gh_EnterpriseAdministratorRole: gh_EnterpriseAdministratorRole;
  gh_EnterpriseAllowPrivateRepositoryForkingPolicyValue: gh_EnterpriseAllowPrivateRepositoryForkingPolicyValue;
  gh_EnterpriseAuditEntryData: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_EnterpriseAuditEntryData']>;
  gh_EnterpriseBillingInfo: ResolverTypeWrapper<gh_EnterpriseBillingInfo>;
  gh_EnterpriseConnection: ResolverTypeWrapper<gh_EnterpriseConnection>;
  gh_EnterpriseDefaultRepositoryPermissionSettingValue: gh_EnterpriseDefaultRepositoryPermissionSettingValue;
  gh_EnterpriseEdge: ResolverTypeWrapper<gh_EnterpriseEdge>;
  gh_EnterpriseEnabledDisabledSettingValue: gh_EnterpriseEnabledDisabledSettingValue;
  gh_EnterpriseEnabledSettingValue: gh_EnterpriseEnabledSettingValue;
  gh_EnterpriseFailedInvitationConnection: ResolverTypeWrapper<gh_EnterpriseFailedInvitationConnection>;
  gh_EnterpriseFailedInvitationEdge: ResolverTypeWrapper<gh_EnterpriseFailedInvitationEdge>;
  gh_EnterpriseIdentityProvider: ResolverTypeWrapper<gh_EnterpriseIdentityProvider>;
  gh_EnterpriseMember: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_EnterpriseMember']>;
  gh_EnterpriseMemberConnection: ResolverTypeWrapper<Omit<gh_EnterpriseMemberConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseMember']>>> }>;
  gh_EnterpriseMemberEdge: ResolverTypeWrapper<Omit<gh_EnterpriseMemberEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_EnterpriseMember']> }>;
  gh_EnterpriseMemberOrder: gh_EnterpriseMemberOrder;
  gh_EnterpriseMemberOrderField: gh_EnterpriseMemberOrderField;
  gh_EnterpriseMembersCanCreateRepositoriesSettingValue: gh_EnterpriseMembersCanCreateRepositoriesSettingValue;
  gh_EnterpriseMembersCanMakePurchasesSettingValue: gh_EnterpriseMembersCanMakePurchasesSettingValue;
  gh_EnterpriseMembershipType: gh_EnterpriseMembershipType;
  gh_EnterpriseOrder: gh_EnterpriseOrder;
  gh_EnterpriseOrderField: gh_EnterpriseOrderField;
  gh_EnterpriseOrganizationMembershipConnection: ResolverTypeWrapper<gh_EnterpriseOrganizationMembershipConnection>;
  gh_EnterpriseOrganizationMembershipEdge: ResolverTypeWrapper<gh_EnterpriseOrganizationMembershipEdge>;
  gh_EnterpriseOutsideCollaboratorConnection: ResolverTypeWrapper<gh_EnterpriseOutsideCollaboratorConnection>;
  gh_EnterpriseOutsideCollaboratorEdge: ResolverTypeWrapper<gh_EnterpriseOutsideCollaboratorEdge>;
  gh_EnterpriseOwnerInfo: ResolverTypeWrapper<gh_EnterpriseOwnerInfo>;
  gh_EnterprisePendingMemberInvitationConnection: ResolverTypeWrapper<gh_EnterprisePendingMemberInvitationConnection>;
  gh_EnterprisePendingMemberInvitationEdge: ResolverTypeWrapper<gh_EnterprisePendingMemberInvitationEdge>;
  gh_EnterpriseRepositoryInfo: ResolverTypeWrapper<gh_EnterpriseRepositoryInfo>;
  gh_EnterpriseRepositoryInfoConnection: ResolverTypeWrapper<gh_EnterpriseRepositoryInfoConnection>;
  gh_EnterpriseRepositoryInfoEdge: ResolverTypeWrapper<gh_EnterpriseRepositoryInfoEdge>;
  gh_EnterpriseServerInstallation: ResolverTypeWrapper<gh_EnterpriseServerInstallation>;
  gh_EnterpriseServerInstallationConnection: ResolverTypeWrapper<gh_EnterpriseServerInstallationConnection>;
  gh_EnterpriseServerInstallationEdge: ResolverTypeWrapper<gh_EnterpriseServerInstallationEdge>;
  gh_EnterpriseServerInstallationMembershipConnection: ResolverTypeWrapper<gh_EnterpriseServerInstallationMembershipConnection>;
  gh_EnterpriseServerInstallationMembershipEdge: ResolverTypeWrapper<gh_EnterpriseServerInstallationMembershipEdge>;
  gh_EnterpriseServerInstallationOrder: gh_EnterpriseServerInstallationOrder;
  gh_EnterpriseServerInstallationOrderField: gh_EnterpriseServerInstallationOrderField;
  gh_EnterpriseServerUserAccount: ResolverTypeWrapper<gh_EnterpriseServerUserAccount>;
  gh_EnterpriseServerUserAccountConnection: ResolverTypeWrapper<gh_EnterpriseServerUserAccountConnection>;
  gh_EnterpriseServerUserAccountEdge: ResolverTypeWrapper<gh_EnterpriseServerUserAccountEdge>;
  gh_EnterpriseServerUserAccountEmail: ResolverTypeWrapper<gh_EnterpriseServerUserAccountEmail>;
  gh_EnterpriseServerUserAccountEmailConnection: ResolverTypeWrapper<gh_EnterpriseServerUserAccountEmailConnection>;
  gh_EnterpriseServerUserAccountEmailEdge: ResolverTypeWrapper<gh_EnterpriseServerUserAccountEmailEdge>;
  gh_EnterpriseServerUserAccountEmailOrder: gh_EnterpriseServerUserAccountEmailOrder;
  gh_EnterpriseServerUserAccountEmailOrderField: gh_EnterpriseServerUserAccountEmailOrderField;
  gh_EnterpriseServerUserAccountOrder: gh_EnterpriseServerUserAccountOrder;
  gh_EnterpriseServerUserAccountOrderField: gh_EnterpriseServerUserAccountOrderField;
  gh_EnterpriseServerUserAccountsUpload: ResolverTypeWrapper<gh_EnterpriseServerUserAccountsUpload>;
  gh_EnterpriseServerUserAccountsUploadConnection: ResolverTypeWrapper<gh_EnterpriseServerUserAccountsUploadConnection>;
  gh_EnterpriseServerUserAccountsUploadEdge: ResolverTypeWrapper<gh_EnterpriseServerUserAccountsUploadEdge>;
  gh_EnterpriseServerUserAccountsUploadOrder: gh_EnterpriseServerUserAccountsUploadOrder;
  gh_EnterpriseServerUserAccountsUploadOrderField: gh_EnterpriseServerUserAccountsUploadOrderField;
  gh_EnterpriseServerUserAccountsUploadSyncState: gh_EnterpriseServerUserAccountsUploadSyncState;
  gh_EnterpriseUserAccount: ResolverTypeWrapper<gh_EnterpriseUserAccount>;
  gh_EnterpriseUserAccountMembershipRole: gh_EnterpriseUserAccountMembershipRole;
  gh_EnterpriseUserDeployment: gh_EnterpriseUserDeployment;
  gh_Environment: ResolverTypeWrapper<gh_Environment>;
  gh_EnvironmentConnection: ResolverTypeWrapper<gh_EnvironmentConnection>;
  gh_EnvironmentEdge: ResolverTypeWrapper<gh_EnvironmentEdge>;
  gh_EnvironmentOrderField: gh_EnvironmentOrderField;
  gh_Environments: gh_Environments;
  gh_ExternalIdentity: ResolverTypeWrapper<gh_ExternalIdentity>;
  gh_ExternalIdentityAttribute: ResolverTypeWrapper<gh_ExternalIdentityAttribute>;
  gh_ExternalIdentityConnection: ResolverTypeWrapper<gh_ExternalIdentityConnection>;
  gh_ExternalIdentityEdge: ResolverTypeWrapper<gh_ExternalIdentityEdge>;
  gh_ExternalIdentitySamlAttributes: ResolverTypeWrapper<gh_ExternalIdentitySamlAttributes>;
  gh_ExternalIdentityScimAttributes: ResolverTypeWrapper<gh_ExternalIdentityScimAttributes>;
  gh_FileAddition: gh_FileAddition;
  gh_FileChanges: gh_FileChanges;
  gh_FileDeletion: gh_FileDeletion;
  gh_FileViewedState: gh_FileViewedState;
  gh_FollowOrganizationInput: gh_FollowOrganizationInput;
  gh_FollowOrganizationPayload: ResolverTypeWrapper<gh_FollowOrganizationPayload>;
  gh_FollowUserInput: gh_FollowUserInput;
  gh_FollowUserPayload: ResolverTypeWrapper<gh_FollowUserPayload>;
  gh_FollowerConnection: ResolverTypeWrapper<gh_FollowerConnection>;
  gh_FollowingConnection: ResolverTypeWrapper<gh_FollowingConnection>;
  gh_FundingLink: ResolverTypeWrapper<gh_FundingLink>;
  gh_FundingPlatform: gh_FundingPlatform;
  gh_GenericHovercardContext: ResolverTypeWrapper<gh_GenericHovercardContext>;
  gh_Gist: ResolverTypeWrapper<gh_Gist>;
  gh_GistComment: ResolverTypeWrapper<gh_GistComment>;
  gh_GistCommentConnection: ResolverTypeWrapper<gh_GistCommentConnection>;
  gh_GistCommentEdge: ResolverTypeWrapper<gh_GistCommentEdge>;
  gh_GistConnection: ResolverTypeWrapper<gh_GistConnection>;
  gh_GistEdge: ResolverTypeWrapper<gh_GistEdge>;
  gh_GistFile: ResolverTypeWrapper<gh_GistFile>;
  gh_GistOrder: gh_GistOrder;
  gh_GistOrderField: gh_GistOrderField;
  gh_GistPrivacy: gh_GistPrivacy;
  gh_GitActor: ResolverTypeWrapper<gh_GitActor>;
  gh_GitActorConnection: ResolverTypeWrapper<gh_GitActorConnection>;
  gh_GitActorEdge: ResolverTypeWrapper<gh_GitActorEdge>;
  gh_GitHubMetadata: ResolverTypeWrapper<gh_GitHubMetadata>;
  gh_GitObject: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_GitObject']>;
  gh_GitObjectID: ResolverTypeWrapper<Scalars['gh_GitObjectID']['output']>;
  gh_GitRefname: ResolverTypeWrapper<Scalars['gh_GitRefname']['output']>;
  gh_GitSSHRemote: ResolverTypeWrapper<Scalars['gh_GitSSHRemote']['output']>;
  gh_GitSignature: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_GitSignature']>;
  gh_GitSignatureState: gh_GitSignatureState;
  gh_GitTimestamp: ResolverTypeWrapper<Scalars['gh_GitTimestamp']['output']>;
  gh_GpgSignature: ResolverTypeWrapper<gh_GpgSignature>;
  gh_GrantEnterpriseOrganizationsMigratorRoleInput: gh_GrantEnterpriseOrganizationsMigratorRoleInput;
  gh_GrantEnterpriseOrganizationsMigratorRolePayload: ResolverTypeWrapper<gh_GrantEnterpriseOrganizationsMigratorRolePayload>;
  gh_GrantMigratorRoleInput: gh_GrantMigratorRoleInput;
  gh_GrantMigratorRolePayload: ResolverTypeWrapper<gh_GrantMigratorRolePayload>;
  gh_HTML: ResolverTypeWrapper<Scalars['gh_HTML']['output']>;
  gh_HeadRefDeletedEvent: ResolverTypeWrapper<gh_HeadRefDeletedEvent>;
  gh_HeadRefForcePushedEvent: ResolverTypeWrapper<gh_HeadRefForcePushedEvent>;
  gh_HeadRefRestoredEvent: ResolverTypeWrapper<gh_HeadRefRestoredEvent>;
  gh_Hovercard: ResolverTypeWrapper<gh_Hovercard>;
  gh_HovercardContext: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_HovercardContext']>;
  gh_IdentityProviderConfigurationState: gh_IdentityProviderConfigurationState;
  gh_ImportProjectInput: gh_ImportProjectInput;
  gh_ImportProjectPayload: ResolverTypeWrapper<gh_ImportProjectPayload>;
  gh_InviteEnterpriseAdminInput: gh_InviteEnterpriseAdminInput;
  gh_InviteEnterpriseAdminPayload: ResolverTypeWrapper<gh_InviteEnterpriseAdminPayload>;
  gh_IpAllowListEnabledSettingValue: gh_IpAllowListEnabledSettingValue;
  gh_IpAllowListEntry: ResolverTypeWrapper<Omit<gh_IpAllowListEntry, 'owner'> & { owner: ResolversTypes['gh_IpAllowListOwner'] }>;
  gh_IpAllowListEntryConnection: ResolverTypeWrapper<gh_IpAllowListEntryConnection>;
  gh_IpAllowListEntryEdge: ResolverTypeWrapper<gh_IpAllowListEntryEdge>;
  gh_IpAllowListEntryOrder: gh_IpAllowListEntryOrder;
  gh_IpAllowListEntryOrderField: gh_IpAllowListEntryOrderField;
  gh_IpAllowListForInstalledAppsEnabledSettingValue: gh_IpAllowListForInstalledAppsEnabledSettingValue;
  gh_IpAllowListOwner: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_IpAllowListOwner']>;
  gh_Issue: ResolverTypeWrapper<gh_Issue>;
  gh_IssueClosedStateReason: gh_IssueClosedStateReason;
  gh_IssueComment: ResolverTypeWrapper<gh_IssueComment>;
  gh_IssueCommentConnection: ResolverTypeWrapper<gh_IssueCommentConnection>;
  gh_IssueCommentEdge: ResolverTypeWrapper<gh_IssueCommentEdge>;
  gh_IssueCommentOrder: gh_IssueCommentOrder;
  gh_IssueCommentOrderField: gh_IssueCommentOrderField;
  gh_IssueConnection: ResolverTypeWrapper<gh_IssueConnection>;
  gh_IssueContributionsByRepository: ResolverTypeWrapper<gh_IssueContributionsByRepository>;
  gh_IssueEdge: ResolverTypeWrapper<gh_IssueEdge>;
  gh_IssueFilters: gh_IssueFilters;
  gh_IssueOrPullRequest: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_IssueOrPullRequest']>;
  gh_IssueOrder: gh_IssueOrder;
  gh_IssueOrderField: gh_IssueOrderField;
  gh_IssueState: gh_IssueState;
  gh_IssueStateReason: gh_IssueStateReason;
  gh_IssueTemplate: ResolverTypeWrapper<gh_IssueTemplate>;
  gh_IssueTimelineConnection: ResolverTypeWrapper<Omit<gh_IssueTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_IssueTimelineItem']>>> }>;
  gh_IssueTimelineItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_IssueTimelineItem']>;
  gh_IssueTimelineItemEdge: ResolverTypeWrapper<Omit<gh_IssueTimelineItemEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_IssueTimelineItem']> }>;
  gh_IssueTimelineItems: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_IssueTimelineItems']>;
  gh_IssueTimelineItemsConnection: ResolverTypeWrapper<Omit<gh_IssueTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_IssueTimelineItems']>>> }>;
  gh_IssueTimelineItemsEdge: ResolverTypeWrapper<Omit<gh_IssueTimelineItemsEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_IssueTimelineItems']> }>;
  gh_IssueTimelineItemsItemType: gh_IssueTimelineItemsItemType;
  gh_JoinedGitHubContribution: ResolverTypeWrapper<gh_JoinedGitHubContribution>;
  gh_Label: ResolverTypeWrapper<gh_Label>;
  gh_LabelConnection: ResolverTypeWrapper<gh_LabelConnection>;
  gh_LabelEdge: ResolverTypeWrapper<gh_LabelEdge>;
  gh_LabelOrder: gh_LabelOrder;
  gh_LabelOrderField: gh_LabelOrderField;
  gh_Labelable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Labelable']>;
  gh_LabeledEvent: ResolverTypeWrapper<gh_LabeledEvent>;
  gh_Language: ResolverTypeWrapper<gh_Language>;
  gh_LanguageConnection: ResolverTypeWrapper<gh_LanguageConnection>;
  gh_LanguageEdge: ResolverTypeWrapper<gh_LanguageEdge>;
  gh_LanguageOrder: gh_LanguageOrder;
  gh_LanguageOrderField: gh_LanguageOrderField;
  gh_License: ResolverTypeWrapper<gh_License>;
  gh_LicenseRule: ResolverTypeWrapper<gh_LicenseRule>;
  gh_LinkProjectV2ToRepositoryInput: gh_LinkProjectV2ToRepositoryInput;
  gh_LinkProjectV2ToRepositoryPayload: ResolverTypeWrapper<gh_LinkProjectV2ToRepositoryPayload>;
  gh_LinkProjectV2ToTeamInput: gh_LinkProjectV2ToTeamInput;
  gh_LinkProjectV2ToTeamPayload: ResolverTypeWrapper<gh_LinkProjectV2ToTeamPayload>;
  gh_LinkRepositoryToProjectInput: gh_LinkRepositoryToProjectInput;
  gh_LinkRepositoryToProjectPayload: ResolverTypeWrapper<gh_LinkRepositoryToProjectPayload>;
  gh_LinkedBranch: ResolverTypeWrapper<gh_LinkedBranch>;
  gh_LinkedBranchConnection: ResolverTypeWrapper<gh_LinkedBranchConnection>;
  gh_LinkedBranchEdge: ResolverTypeWrapper<gh_LinkedBranchEdge>;
  gh_LockLockableInput: gh_LockLockableInput;
  gh_LockLockablePayload: ResolverTypeWrapper<gh_LockLockablePayload>;
  gh_LockReason: gh_LockReason;
  gh_Lockable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Lockable']>;
  gh_LockedEvent: ResolverTypeWrapper<gh_LockedEvent>;
  gh_Mannequin: ResolverTypeWrapper<gh_Mannequin>;
  gh_MannequinConnection: ResolverTypeWrapper<gh_MannequinConnection>;
  gh_MannequinEdge: ResolverTypeWrapper<gh_MannequinEdge>;
  gh_MannequinOrder: gh_MannequinOrder;
  gh_MannequinOrderField: gh_MannequinOrderField;
  gh_MarkDiscussionCommentAsAnswerInput: gh_MarkDiscussionCommentAsAnswerInput;
  gh_MarkDiscussionCommentAsAnswerPayload: ResolverTypeWrapper<gh_MarkDiscussionCommentAsAnswerPayload>;
  gh_MarkFileAsViewedInput: gh_MarkFileAsViewedInput;
  gh_MarkFileAsViewedPayload: ResolverTypeWrapper<gh_MarkFileAsViewedPayload>;
  gh_MarkProjectV2AsTemplateInput: gh_MarkProjectV2AsTemplateInput;
  gh_MarkProjectV2AsTemplatePayload: ResolverTypeWrapper<gh_MarkProjectV2AsTemplatePayload>;
  gh_MarkPullRequestReadyForReviewInput: gh_MarkPullRequestReadyForReviewInput;
  gh_MarkPullRequestReadyForReviewPayload: ResolverTypeWrapper<gh_MarkPullRequestReadyForReviewPayload>;
  gh_MarkedAsDuplicateEvent: ResolverTypeWrapper<Omit<gh_MarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<ResolversTypes['gh_IssueOrPullRequest']>, duplicate?: Maybe<ResolversTypes['gh_IssueOrPullRequest']> }>;
  gh_MarketplaceCategory: ResolverTypeWrapper<gh_MarketplaceCategory>;
  gh_MarketplaceListing: ResolverTypeWrapper<gh_MarketplaceListing>;
  gh_MarketplaceListingConnection: ResolverTypeWrapper<gh_MarketplaceListingConnection>;
  gh_MarketplaceListingEdge: ResolverTypeWrapper<gh_MarketplaceListingEdge>;
  gh_MemberFeatureRequestNotification: ResolverTypeWrapper<gh_MemberFeatureRequestNotification>;
  gh_MemberStatusable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_MemberStatusable']>;
  gh_MembersCanDeleteReposClearAuditEntry: ResolverTypeWrapper<Omit<gh_MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_MembersCanDeleteReposDisableAuditEntry: ResolverTypeWrapper<Omit<gh_MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_MembersCanDeleteReposEnableAuditEntry: ResolverTypeWrapper<Omit<gh_MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_MentionedEvent: ResolverTypeWrapper<gh_MentionedEvent>;
  gh_MergeBranchInput: gh_MergeBranchInput;
  gh_MergeBranchPayload: ResolverTypeWrapper<gh_MergeBranchPayload>;
  gh_MergeCommitMessage: gh_MergeCommitMessage;
  gh_MergeCommitTitle: gh_MergeCommitTitle;
  gh_MergePullRequestInput: gh_MergePullRequestInput;
  gh_MergePullRequestPayload: ResolverTypeWrapper<gh_MergePullRequestPayload>;
  gh_MergeQueue: ResolverTypeWrapper<gh_MergeQueue>;
  gh_MergeQueueConfiguration: ResolverTypeWrapper<gh_MergeQueueConfiguration>;
  gh_MergeQueueEntry: ResolverTypeWrapper<gh_MergeQueueEntry>;
  gh_MergeQueueEntryConnection: ResolverTypeWrapper<gh_MergeQueueEntryConnection>;
  gh_MergeQueueEntryEdge: ResolverTypeWrapper<gh_MergeQueueEntryEdge>;
  gh_MergeQueueEntryState: gh_MergeQueueEntryState;
  gh_MergeQueueMergingStrategy: gh_MergeQueueMergingStrategy;
  gh_MergeStateStatus: gh_MergeStateStatus;
  gh_MergeableState: gh_MergeableState;
  gh_MergedEvent: ResolverTypeWrapper<gh_MergedEvent>;
  gh_Migration: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Migration']>;
  gh_MigrationSource: ResolverTypeWrapper<gh_MigrationSource>;
  gh_MigrationSourceType: gh_MigrationSourceType;
  gh_MigrationState: gh_MigrationState;
  gh_Milestone: ResolverTypeWrapper<gh_Milestone>;
  gh_MilestoneConnection: ResolverTypeWrapper<gh_MilestoneConnection>;
  gh_MilestoneEdge: ResolverTypeWrapper<gh_MilestoneEdge>;
  gh_MilestoneItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_MilestoneItem']>;
  gh_MilestoneOrder: gh_MilestoneOrder;
  gh_MilestoneOrderField: gh_MilestoneOrderField;
  gh_MilestoneState: gh_MilestoneState;
  gh_MilestonedEvent: ResolverTypeWrapper<Omit<gh_MilestonedEvent, 'subject'> & { subject: ResolversTypes['gh_MilestoneItem'] }>;
  gh_Minimizable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Minimizable']>;
  gh_MinimizeCommentInput: gh_MinimizeCommentInput;
  gh_MinimizeCommentPayload: ResolverTypeWrapper<gh_MinimizeCommentPayload>;
  gh_MoveProjectCardInput: gh_MoveProjectCardInput;
  gh_MoveProjectCardPayload: ResolverTypeWrapper<gh_MoveProjectCardPayload>;
  gh_MoveProjectColumnInput: gh_MoveProjectColumnInput;
  gh_MoveProjectColumnPayload: ResolverTypeWrapper<gh_MoveProjectColumnPayload>;
  gh_MovedColumnsInProjectEvent: ResolverTypeWrapper<gh_MovedColumnsInProjectEvent>;
  gh_Node: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Node']>;
  gh_NotificationRestrictionSettingValue: gh_NotificationRestrictionSettingValue;
  gh_OIDCProvider: ResolverTypeWrapper<gh_OIDCProvider>;
  gh_OIDCProviderType: gh_OIDCProviderType;
  gh_OauthApplicationAuditEntryData: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_OauthApplicationAuditEntryData']>;
  gh_OauthApplicationCreateAuditEntry: ResolverTypeWrapper<Omit<gh_OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OauthApplicationCreateAuditEntryState: gh_OauthApplicationCreateAuditEntryState;
  gh_OperationType: gh_OperationType;
  gh_OrderDirection: gh_OrderDirection;
  gh_OrgAddBillingManagerAuditEntry: ResolverTypeWrapper<Omit<gh_OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgAddMemberAuditEntry: ResolverTypeWrapper<Omit<gh_OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgAddMemberAuditEntryPermission: gh_OrgAddMemberAuditEntryPermission;
  gh_OrgBlockUserAuditEntry: ResolverTypeWrapper<Omit<gh_OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgConfigDisableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<gh_OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgConfigEnableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<gh_OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgCreateAuditEntry: ResolverTypeWrapper<Omit<gh_OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgCreateAuditEntryBillingPlan: gh_OrgCreateAuditEntryBillingPlan;
  gh_OrgDisableOauthAppRestrictionsAuditEntry: ResolverTypeWrapper<Omit<gh_OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgDisableSamlAuditEntry: ResolverTypeWrapper<Omit<gh_OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgDisableTwoFactorRequirementAuditEntry: ResolverTypeWrapper<Omit<gh_OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgEnableOauthAppRestrictionsAuditEntry: ResolverTypeWrapper<Omit<gh_OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgEnableSamlAuditEntry: ResolverTypeWrapper<Omit<gh_OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgEnableTwoFactorRequirementAuditEntry: ResolverTypeWrapper<Omit<gh_OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgEnterpriseOwnerOrder: gh_OrgEnterpriseOwnerOrder;
  gh_OrgEnterpriseOwnerOrderField: gh_OrgEnterpriseOwnerOrderField;
  gh_OrgInviteMemberAuditEntry: ResolverTypeWrapper<Omit<gh_OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgInviteToBusinessAuditEntry: ResolverTypeWrapper<Omit<gh_OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgOauthAppAccessApprovedAuditEntry: ResolverTypeWrapper<Omit<gh_OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgOauthAppAccessBlockedAuditEntry: ResolverTypeWrapper<Omit<gh_OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgOauthAppAccessDeniedAuditEntry: ResolverTypeWrapper<Omit<gh_OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgOauthAppAccessRequestedAuditEntry: ResolverTypeWrapper<Omit<gh_OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgOauthAppAccessUnblockedAuditEntry: ResolverTypeWrapper<Omit<gh_OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgRemoveBillingManagerAuditEntry: ResolverTypeWrapper<Omit<gh_OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgRemoveBillingManagerAuditEntryReason: gh_OrgRemoveBillingManagerAuditEntryReason;
  gh_OrgRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<gh_OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgRemoveMemberAuditEntryMembershipType: gh_OrgRemoveMemberAuditEntryMembershipType;
  gh_OrgRemoveMemberAuditEntryReason: gh_OrgRemoveMemberAuditEntryReason;
  gh_OrgRemoveOutsideCollaboratorAuditEntry: ResolverTypeWrapper<Omit<gh_OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgRemoveOutsideCollaboratorAuditEntryMembershipType: gh_OrgRemoveOutsideCollaboratorAuditEntryMembershipType;
  gh_OrgRemoveOutsideCollaboratorAuditEntryReason: gh_OrgRemoveOutsideCollaboratorAuditEntryReason;
  gh_OrgRestoreMemberAuditEntry: ResolverTypeWrapper<Omit<gh_OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']>, restoredMemberships?: Maybe<Array<ResolversTypes['gh_OrgRestoreMemberAuditEntryMembership']>> }>;
  gh_OrgRestoreMemberAuditEntryMembership: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_OrgRestoreMemberAuditEntryMembership']>;
  gh_OrgRestoreMemberMembershipOrganizationAuditEntryData: ResolverTypeWrapper<gh_OrgRestoreMemberMembershipOrganizationAuditEntryData>;
  gh_OrgRestoreMemberMembershipRepositoryAuditEntryData: ResolverTypeWrapper<gh_OrgRestoreMemberMembershipRepositoryAuditEntryData>;
  gh_OrgRestoreMemberMembershipTeamAuditEntryData: ResolverTypeWrapper<gh_OrgRestoreMemberMembershipTeamAuditEntryData>;
  gh_OrgUnblockUserAuditEntry: ResolverTypeWrapper<Omit<gh_OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgUpdateDefaultRepositoryPermissionAuditEntry: ResolverTypeWrapper<Omit<gh_OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission: gh_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission;
  gh_OrgUpdateMemberAuditEntry: ResolverTypeWrapper<Omit<gh_OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgUpdateMemberAuditEntryPermission: gh_OrgUpdateMemberAuditEntryPermission;
  gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry: ResolverTypeWrapper<Omit<gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility: gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility;
  gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: ResolverTypeWrapper<Omit<gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_Organization: ResolverTypeWrapper<gh_Organization>;
  gh_OrganizationAuditEntry: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_OrganizationAuditEntry']>;
  gh_OrganizationAuditEntryConnection: ResolverTypeWrapper<Omit<gh_OrganizationAuditEntryConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_OrganizationAuditEntry']>>> }>;
  gh_OrganizationAuditEntryData: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_OrganizationAuditEntryData']>;
  gh_OrganizationAuditEntryEdge: ResolverTypeWrapper<Omit<gh_OrganizationAuditEntryEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_OrganizationAuditEntry']> }>;
  gh_OrganizationConnection: ResolverTypeWrapper<gh_OrganizationConnection>;
  gh_OrganizationEdge: ResolverTypeWrapper<gh_OrganizationEdge>;
  gh_OrganizationEnterpriseOwnerConnection: ResolverTypeWrapper<gh_OrganizationEnterpriseOwnerConnection>;
  gh_OrganizationEnterpriseOwnerEdge: ResolverTypeWrapper<gh_OrganizationEnterpriseOwnerEdge>;
  gh_OrganizationIdentityProvider: ResolverTypeWrapper<gh_OrganizationIdentityProvider>;
  gh_OrganizationInvitation: ResolverTypeWrapper<gh_OrganizationInvitation>;
  gh_OrganizationInvitationConnection: ResolverTypeWrapper<gh_OrganizationInvitationConnection>;
  gh_OrganizationInvitationEdge: ResolverTypeWrapper<gh_OrganizationInvitationEdge>;
  gh_OrganizationInvitationRole: gh_OrganizationInvitationRole;
  gh_OrganizationInvitationSource: gh_OrganizationInvitationSource;
  gh_OrganizationInvitationType: gh_OrganizationInvitationType;
  gh_OrganizationMemberConnection: ResolverTypeWrapper<gh_OrganizationMemberConnection>;
  gh_OrganizationMemberEdge: ResolverTypeWrapper<gh_OrganizationMemberEdge>;
  gh_OrganizationMemberRole: gh_OrganizationMemberRole;
  gh_OrganizationMembersCanCreateRepositoriesSettingValue: gh_OrganizationMembersCanCreateRepositoriesSettingValue;
  gh_OrganizationMigration: ResolverTypeWrapper<gh_OrganizationMigration>;
  gh_OrganizationMigrationState: gh_OrganizationMigrationState;
  gh_OrganizationOrUser: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_OrganizationOrUser']>;
  gh_OrganizationOrder: gh_OrganizationOrder;
  gh_OrganizationOrderField: gh_OrganizationOrderField;
  gh_OrganizationTeamsHovercardContext: ResolverTypeWrapper<gh_OrganizationTeamsHovercardContext>;
  gh_OrganizationsHovercardContext: ResolverTypeWrapper<gh_OrganizationsHovercardContext>;
  gh_Package: ResolverTypeWrapper<gh_Package>;
  gh_PackageConnection: ResolverTypeWrapper<gh_PackageConnection>;
  gh_PackageEdge: ResolverTypeWrapper<gh_PackageEdge>;
  gh_PackageFile: ResolverTypeWrapper<gh_PackageFile>;
  gh_PackageFileConnection: ResolverTypeWrapper<gh_PackageFileConnection>;
  gh_PackageFileEdge: ResolverTypeWrapper<gh_PackageFileEdge>;
  gh_PackageFileOrder: gh_PackageFileOrder;
  gh_PackageFileOrderField: gh_PackageFileOrderField;
  gh_PackageOrder: gh_PackageOrder;
  gh_PackageOrderField: gh_PackageOrderField;
  gh_PackageOwner: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_PackageOwner']>;
  gh_PackageStatistics: ResolverTypeWrapper<gh_PackageStatistics>;
  gh_PackageTag: ResolverTypeWrapper<gh_PackageTag>;
  gh_PackageType: gh_PackageType;
  gh_PackageVersion: ResolverTypeWrapper<gh_PackageVersion>;
  gh_PackageVersionConnection: ResolverTypeWrapper<gh_PackageVersionConnection>;
  gh_PackageVersionEdge: ResolverTypeWrapper<gh_PackageVersionEdge>;
  gh_PackageVersionOrder: gh_PackageVersionOrder;
  gh_PackageVersionOrderField: gh_PackageVersionOrderField;
  gh_PackageVersionStatistics: ResolverTypeWrapper<gh_PackageVersionStatistics>;
  gh_PageInfo: ResolverTypeWrapper<gh_PageInfo>;
  gh_PatchStatus: gh_PatchStatus;
  gh_PermissionGranter: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_PermissionGranter']>;
  gh_PermissionSource: ResolverTypeWrapper<Omit<gh_PermissionSource, 'source'> & { source: ResolversTypes['gh_PermissionGranter'] }>;
  gh_PinIssueInput: gh_PinIssueInput;
  gh_PinIssuePayload: ResolverTypeWrapper<gh_PinIssuePayload>;
  gh_PinnableItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_PinnableItem']>;
  gh_PinnableItemConnection: ResolverTypeWrapper<Omit<gh_PinnableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_PinnableItem']>>> }>;
  gh_PinnableItemEdge: ResolverTypeWrapper<Omit<gh_PinnableItemEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_PinnableItem']> }>;
  gh_PinnableItemType: gh_PinnableItemType;
  gh_PinnedDiscussion: ResolverTypeWrapper<gh_PinnedDiscussion>;
  gh_PinnedDiscussionConnection: ResolverTypeWrapper<gh_PinnedDiscussionConnection>;
  gh_PinnedDiscussionEdge: ResolverTypeWrapper<gh_PinnedDiscussionEdge>;
  gh_PinnedDiscussionGradient: gh_PinnedDiscussionGradient;
  gh_PinnedDiscussionPattern: gh_PinnedDiscussionPattern;
  gh_PinnedEvent: ResolverTypeWrapper<gh_PinnedEvent>;
  gh_PinnedIssue: ResolverTypeWrapper<gh_PinnedIssue>;
  gh_PinnedIssueConnection: ResolverTypeWrapper<gh_PinnedIssueConnection>;
  gh_PinnedIssueEdge: ResolverTypeWrapper<gh_PinnedIssueEdge>;
  gh_PreciseDateTime: ResolverTypeWrapper<Scalars['gh_PreciseDateTime']['output']>;
  gh_PrivateRepositoryForkingDisableAuditEntry: ResolverTypeWrapper<Omit<gh_PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_PrivateRepositoryForkingEnableAuditEntry: ResolverTypeWrapper<Omit<gh_PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_ProfileItemShowcase: ResolverTypeWrapper<gh_ProfileItemShowcase>;
  gh_ProfileOwner: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_ProfileOwner']>;
  gh_Project: ResolverTypeWrapper<gh_Project>;
  gh_ProjectCard: ResolverTypeWrapper<Omit<gh_ProjectCard, 'content'> & { content?: Maybe<ResolversTypes['gh_ProjectCardItem']> }>;
  gh_ProjectCardArchivedState: gh_ProjectCardArchivedState;
  gh_ProjectCardConnection: ResolverTypeWrapper<gh_ProjectCardConnection>;
  gh_ProjectCardEdge: ResolverTypeWrapper<gh_ProjectCardEdge>;
  gh_ProjectCardImport: gh_ProjectCardImport;
  gh_ProjectCardItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_ProjectCardItem']>;
  gh_ProjectCardState: gh_ProjectCardState;
  gh_ProjectColumn: ResolverTypeWrapper<gh_ProjectColumn>;
  gh_ProjectColumnConnection: ResolverTypeWrapper<gh_ProjectColumnConnection>;
  gh_ProjectColumnEdge: ResolverTypeWrapper<gh_ProjectColumnEdge>;
  gh_ProjectColumnImport: gh_ProjectColumnImport;
  gh_ProjectColumnPurpose: gh_ProjectColumnPurpose;
  gh_ProjectConnection: ResolverTypeWrapper<gh_ProjectConnection>;
  gh_ProjectEdge: ResolverTypeWrapper<gh_ProjectEdge>;
  gh_ProjectOrder: gh_ProjectOrder;
  gh_ProjectOrderField: gh_ProjectOrderField;
  gh_ProjectOwner: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_ProjectOwner']>;
  gh_ProjectProgress: ResolverTypeWrapper<gh_ProjectProgress>;
  gh_ProjectState: gh_ProjectState;
  gh_ProjectTemplate: gh_ProjectTemplate;
  gh_ProjectV2: ResolverTypeWrapper<Omit<gh_ProjectV2, 'field'> & { field?: Maybe<ResolversTypes['gh_ProjectV2FieldConfiguration']> }>;
  gh_ProjectV2Actor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_ProjectV2Actor']>;
  gh_ProjectV2ActorConnection: ResolverTypeWrapper<Omit<gh_ProjectV2ActorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2Actor']>>> }>;
  gh_ProjectV2ActorEdge: ResolverTypeWrapper<Omit<gh_ProjectV2ActorEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_ProjectV2Actor']> }>;
  gh_ProjectV2Collaborator: gh_ProjectV2Collaborator;
  gh_ProjectV2Connection: ResolverTypeWrapper<gh_ProjectV2Connection>;
  gh_ProjectV2CustomFieldType: gh_ProjectV2CustomFieldType;
  gh_ProjectV2Edge: ResolverTypeWrapper<gh_ProjectV2Edge>;
  gh_ProjectV2Field: ResolverTypeWrapper<gh_ProjectV2Field>;
  gh_ProjectV2FieldCommon: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_ProjectV2FieldCommon']>;
  gh_ProjectV2FieldConfiguration: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_ProjectV2FieldConfiguration']>;
  gh_ProjectV2FieldConfigurationConnection: ResolverTypeWrapper<Omit<gh_ProjectV2FieldConfigurationConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2FieldConfiguration']>>> }>;
  gh_ProjectV2FieldConfigurationEdge: ResolverTypeWrapper<Omit<gh_ProjectV2FieldConfigurationEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_ProjectV2FieldConfiguration']> }>;
  gh_ProjectV2FieldConnection: ResolverTypeWrapper<gh_ProjectV2FieldConnection>;
  gh_ProjectV2FieldEdge: ResolverTypeWrapper<gh_ProjectV2FieldEdge>;
  gh_ProjectV2FieldOrder: gh_ProjectV2FieldOrder;
  gh_ProjectV2FieldOrderField: gh_ProjectV2FieldOrderField;
  gh_ProjectV2FieldType: gh_ProjectV2FieldType;
  gh_ProjectV2FieldValue: gh_ProjectV2FieldValue;
  gh_ProjectV2Filters: gh_ProjectV2Filters;
  gh_ProjectV2Item: ResolverTypeWrapper<Omit<gh_ProjectV2Item, 'content' | 'fieldValueByName'> & { content?: Maybe<ResolversTypes['gh_ProjectV2ItemContent']>, fieldValueByName?: Maybe<ResolversTypes['gh_ProjectV2ItemFieldValue']> }>;
  gh_ProjectV2ItemConnection: ResolverTypeWrapper<gh_ProjectV2ItemConnection>;
  gh_ProjectV2ItemContent: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_ProjectV2ItemContent']>;
  gh_ProjectV2ItemEdge: ResolverTypeWrapper<gh_ProjectV2ItemEdge>;
  gh_ProjectV2ItemFieldDateValue: ResolverTypeWrapper<Omit<gh_ProjectV2ItemFieldDateValue, 'field'> & { field: ResolversTypes['gh_ProjectV2FieldConfiguration'] }>;
  gh_ProjectV2ItemFieldIterationValue: ResolverTypeWrapper<Omit<gh_ProjectV2ItemFieldIterationValue, 'field'> & { field: ResolversTypes['gh_ProjectV2FieldConfiguration'] }>;
  gh_ProjectV2ItemFieldLabelValue: ResolverTypeWrapper<Omit<gh_ProjectV2ItemFieldLabelValue, 'field'> & { field: ResolversTypes['gh_ProjectV2FieldConfiguration'] }>;
  gh_ProjectV2ItemFieldMilestoneValue: ResolverTypeWrapper<Omit<gh_ProjectV2ItemFieldMilestoneValue, 'field'> & { field: ResolversTypes['gh_ProjectV2FieldConfiguration'] }>;
  gh_ProjectV2ItemFieldNumberValue: ResolverTypeWrapper<Omit<gh_ProjectV2ItemFieldNumberValue, 'field'> & { field: ResolversTypes['gh_ProjectV2FieldConfiguration'] }>;
  gh_ProjectV2ItemFieldPullRequestValue: ResolverTypeWrapper<Omit<gh_ProjectV2ItemFieldPullRequestValue, 'field'> & { field: ResolversTypes['gh_ProjectV2FieldConfiguration'] }>;
  gh_ProjectV2ItemFieldRepositoryValue: ResolverTypeWrapper<Omit<gh_ProjectV2ItemFieldRepositoryValue, 'field'> & { field: ResolversTypes['gh_ProjectV2FieldConfiguration'] }>;
  gh_ProjectV2ItemFieldReviewerValue: ResolverTypeWrapper<Omit<gh_ProjectV2ItemFieldReviewerValue, 'field'> & { field: ResolversTypes['gh_ProjectV2FieldConfiguration'] }>;
  gh_ProjectV2ItemFieldSingleSelectValue: ResolverTypeWrapper<Omit<gh_ProjectV2ItemFieldSingleSelectValue, 'field'> & { field: ResolversTypes['gh_ProjectV2FieldConfiguration'] }>;
  gh_ProjectV2ItemFieldTextValue: ResolverTypeWrapper<Omit<gh_ProjectV2ItemFieldTextValue, 'field'> & { field: ResolversTypes['gh_ProjectV2FieldConfiguration'] }>;
  gh_ProjectV2ItemFieldUserValue: ResolverTypeWrapper<Omit<gh_ProjectV2ItemFieldUserValue, 'field'> & { field: ResolversTypes['gh_ProjectV2FieldConfiguration'] }>;
  gh_ProjectV2ItemFieldValue: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_ProjectV2ItemFieldValue']>;
  gh_ProjectV2ItemFieldValueCommon: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_ProjectV2ItemFieldValueCommon']>;
  gh_ProjectV2ItemFieldValueConnection: ResolverTypeWrapper<Omit<gh_ProjectV2ItemFieldValueConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2ItemFieldValue']>>> }>;
  gh_ProjectV2ItemFieldValueEdge: ResolverTypeWrapper<Omit<gh_ProjectV2ItemFieldValueEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_ProjectV2ItemFieldValue']> }>;
  gh_ProjectV2ItemFieldValueOrder: gh_ProjectV2ItemFieldValueOrder;
  gh_ProjectV2ItemFieldValueOrderField: gh_ProjectV2ItemFieldValueOrderField;
  gh_ProjectV2ItemOrder: gh_ProjectV2ItemOrder;
  gh_ProjectV2ItemOrderField: gh_ProjectV2ItemOrderField;
  gh_ProjectV2ItemType: gh_ProjectV2ItemType;
  gh_ProjectV2IterationField: ResolverTypeWrapper<gh_ProjectV2IterationField>;
  gh_ProjectV2IterationFieldConfiguration: ResolverTypeWrapper<gh_ProjectV2IterationFieldConfiguration>;
  gh_ProjectV2IterationFieldIteration: ResolverTypeWrapper<gh_ProjectV2IterationFieldIteration>;
  gh_ProjectV2Order: gh_ProjectV2Order;
  gh_ProjectV2OrderField: gh_ProjectV2OrderField;
  gh_ProjectV2Owner: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_ProjectV2Owner']>;
  gh_ProjectV2Recent: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_ProjectV2Recent']>;
  gh_ProjectV2Roles: gh_ProjectV2Roles;
  gh_ProjectV2SingleSelectField: ResolverTypeWrapper<gh_ProjectV2SingleSelectField>;
  gh_ProjectV2SingleSelectFieldOption: ResolverTypeWrapper<gh_ProjectV2SingleSelectFieldOption>;
  gh_ProjectV2SingleSelectFieldOptionColor: gh_ProjectV2SingleSelectFieldOptionColor;
  gh_ProjectV2SingleSelectFieldOptionInput: gh_ProjectV2SingleSelectFieldOptionInput;
  gh_ProjectV2SortBy: ResolverTypeWrapper<gh_ProjectV2SortBy>;
  gh_ProjectV2SortByConnection: ResolverTypeWrapper<gh_ProjectV2SortByConnection>;
  gh_ProjectV2SortByEdge: ResolverTypeWrapper<gh_ProjectV2SortByEdge>;
  gh_ProjectV2SortByField: ResolverTypeWrapper<Omit<gh_ProjectV2SortByField, 'field'> & { field: ResolversTypes['gh_ProjectV2FieldConfiguration'] }>;
  gh_ProjectV2SortByFieldConnection: ResolverTypeWrapper<gh_ProjectV2SortByFieldConnection>;
  gh_ProjectV2SortByFieldEdge: ResolverTypeWrapper<gh_ProjectV2SortByFieldEdge>;
  gh_ProjectV2State: gh_ProjectV2State;
  gh_ProjectV2View: ResolverTypeWrapper<gh_ProjectV2View>;
  gh_ProjectV2ViewConnection: ResolverTypeWrapper<gh_ProjectV2ViewConnection>;
  gh_ProjectV2ViewEdge: ResolverTypeWrapper<gh_ProjectV2ViewEdge>;
  gh_ProjectV2ViewLayout: gh_ProjectV2ViewLayout;
  gh_ProjectV2ViewOrder: gh_ProjectV2ViewOrder;
  gh_ProjectV2ViewOrderField: gh_ProjectV2ViewOrderField;
  gh_ProjectV2Workflow: ResolverTypeWrapper<gh_ProjectV2Workflow>;
  gh_ProjectV2WorkflowConnection: ResolverTypeWrapper<gh_ProjectV2WorkflowConnection>;
  gh_ProjectV2WorkflowEdge: ResolverTypeWrapper<gh_ProjectV2WorkflowEdge>;
  gh_ProjectV2WorkflowOrder: gh_ProjectV2WorkflowOrder;
  gh_ProjectV2WorkflowsOrderField: gh_ProjectV2WorkflowsOrderField;
  gh_PublicKey: ResolverTypeWrapper<gh_PublicKey>;
  gh_PublicKeyConnection: ResolverTypeWrapper<gh_PublicKeyConnection>;
  gh_PublicKeyEdge: ResolverTypeWrapper<gh_PublicKeyEdge>;
  gh_PublishSponsorsTierInput: gh_PublishSponsorsTierInput;
  gh_PublishSponsorsTierPayload: ResolverTypeWrapper<gh_PublishSponsorsTierPayload>;
  gh_PullRequest: ResolverTypeWrapper<gh_PullRequest>;
  gh_PullRequestBranchUpdateMethod: gh_PullRequestBranchUpdateMethod;
  gh_PullRequestChangedFile: ResolverTypeWrapper<gh_PullRequestChangedFile>;
  gh_PullRequestChangedFileConnection: ResolverTypeWrapper<gh_PullRequestChangedFileConnection>;
  gh_PullRequestChangedFileEdge: ResolverTypeWrapper<gh_PullRequestChangedFileEdge>;
  gh_PullRequestCommit: ResolverTypeWrapper<gh_PullRequestCommit>;
  gh_PullRequestCommitCommentThread: ResolverTypeWrapper<gh_PullRequestCommitCommentThread>;
  gh_PullRequestCommitConnection: ResolverTypeWrapper<gh_PullRequestCommitConnection>;
  gh_PullRequestCommitEdge: ResolverTypeWrapper<gh_PullRequestCommitEdge>;
  gh_PullRequestConnection: ResolverTypeWrapper<gh_PullRequestConnection>;
  gh_PullRequestContributionsByRepository: ResolverTypeWrapper<gh_PullRequestContributionsByRepository>;
  gh_PullRequestEdge: ResolverTypeWrapper<gh_PullRequestEdge>;
  gh_PullRequestMergeMethod: gh_PullRequestMergeMethod;
  gh_PullRequestOrder: gh_PullRequestOrder;
  gh_PullRequestOrderField: gh_PullRequestOrderField;
  gh_PullRequestParameters: ResolverTypeWrapper<gh_PullRequestParameters>;
  gh_PullRequestParametersInput: gh_PullRequestParametersInput;
  gh_PullRequestReview: ResolverTypeWrapper<gh_PullRequestReview>;
  gh_PullRequestReviewComment: ResolverTypeWrapper<gh_PullRequestReviewComment>;
  gh_PullRequestReviewCommentConnection: ResolverTypeWrapper<gh_PullRequestReviewCommentConnection>;
  gh_PullRequestReviewCommentEdge: ResolverTypeWrapper<gh_PullRequestReviewCommentEdge>;
  gh_PullRequestReviewCommentState: gh_PullRequestReviewCommentState;
  gh_PullRequestReviewConnection: ResolverTypeWrapper<gh_PullRequestReviewConnection>;
  gh_PullRequestReviewContributionsByRepository: ResolverTypeWrapper<gh_PullRequestReviewContributionsByRepository>;
  gh_PullRequestReviewDecision: gh_PullRequestReviewDecision;
  gh_PullRequestReviewEdge: ResolverTypeWrapper<gh_PullRequestReviewEdge>;
  gh_PullRequestReviewEvent: gh_PullRequestReviewEvent;
  gh_PullRequestReviewState: gh_PullRequestReviewState;
  gh_PullRequestReviewThread: ResolverTypeWrapper<gh_PullRequestReviewThread>;
  gh_PullRequestReviewThreadConnection: ResolverTypeWrapper<gh_PullRequestReviewThreadConnection>;
  gh_PullRequestReviewThreadEdge: ResolverTypeWrapper<gh_PullRequestReviewThreadEdge>;
  gh_PullRequestReviewThreadSubjectType: gh_PullRequestReviewThreadSubjectType;
  gh_PullRequestRevisionMarker: ResolverTypeWrapper<gh_PullRequestRevisionMarker>;
  gh_PullRequestState: gh_PullRequestState;
  gh_PullRequestTemplate: ResolverTypeWrapper<gh_PullRequestTemplate>;
  gh_PullRequestThread: ResolverTypeWrapper<gh_PullRequestThread>;
  gh_PullRequestTimelineConnection: ResolverTypeWrapper<Omit<gh_PullRequestTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_PullRequestTimelineItem']>>> }>;
  gh_PullRequestTimelineItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_PullRequestTimelineItem']>;
  gh_PullRequestTimelineItemEdge: ResolverTypeWrapper<Omit<gh_PullRequestTimelineItemEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_PullRequestTimelineItem']> }>;
  gh_PullRequestTimelineItems: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_PullRequestTimelineItems']>;
  gh_PullRequestTimelineItemsConnection: ResolverTypeWrapper<Omit<gh_PullRequestTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_PullRequestTimelineItems']>>> }>;
  gh_PullRequestTimelineItemsEdge: ResolverTypeWrapper<Omit<gh_PullRequestTimelineItemsEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_PullRequestTimelineItems']> }>;
  gh_PullRequestTimelineItemsItemType: gh_PullRequestTimelineItemsItemType;
  gh_PullRequestUpdateState: gh_PullRequestUpdateState;
  gh_Push: ResolverTypeWrapper<gh_Push>;
  gh_PushAllowance: ResolverTypeWrapper<Omit<gh_PushAllowance, 'actor'> & { actor?: Maybe<ResolversTypes['gh_PushAllowanceActor']> }>;
  gh_PushAllowanceActor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_PushAllowanceActor']>;
  gh_PushAllowanceConnection: ResolverTypeWrapper<gh_PushAllowanceConnection>;
  gh_PushAllowanceEdge: ResolverTypeWrapper<gh_PushAllowanceEdge>;
  gh_RateLimit: ResolverTypeWrapper<gh_RateLimit>;
  gh_Reactable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Reactable']>;
  gh_ReactingUserConnection: ResolverTypeWrapper<gh_ReactingUserConnection>;
  gh_ReactingUserEdge: ResolverTypeWrapper<gh_ReactingUserEdge>;
  gh_Reaction: ResolverTypeWrapper<gh_Reaction>;
  gh_ReactionConnection: ResolverTypeWrapper<gh_ReactionConnection>;
  gh_ReactionContent: gh_ReactionContent;
  gh_ReactionEdge: ResolverTypeWrapper<gh_ReactionEdge>;
  gh_ReactionGroup: ResolverTypeWrapper<gh_ReactionGroup>;
  gh_ReactionOrder: gh_ReactionOrder;
  gh_ReactionOrderField: gh_ReactionOrderField;
  gh_Reactor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_Reactor']>;
  gh_ReactorConnection: ResolverTypeWrapper<Omit<gh_ReactorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_Reactor']>>> }>;
  gh_ReactorEdge: ResolverTypeWrapper<Omit<gh_ReactorEdge, 'node'> & { node: ResolversTypes['gh_Reactor'] }>;
  gh_ReadyForReviewEvent: ResolverTypeWrapper<gh_ReadyForReviewEvent>;
  gh_Ref: ResolverTypeWrapper<gh_Ref>;
  gh_RefConnection: ResolverTypeWrapper<gh_RefConnection>;
  gh_RefEdge: ResolverTypeWrapper<gh_RefEdge>;
  gh_RefNameConditionTarget: ResolverTypeWrapper<gh_RefNameConditionTarget>;
  gh_RefNameConditionTargetInput: gh_RefNameConditionTargetInput;
  gh_RefOrder: gh_RefOrder;
  gh_RefOrderField: gh_RefOrderField;
  gh_RefUpdate: gh_RefUpdate;
  gh_RefUpdateRule: ResolverTypeWrapper<gh_RefUpdateRule>;
  gh_ReferencedEvent: ResolverTypeWrapper<Omit<gh_ReferencedEvent, 'subject'> & { subject: ResolversTypes['gh_ReferencedSubject'] }>;
  gh_ReferencedSubject: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_ReferencedSubject']>;
  gh_RegenerateEnterpriseIdentityProviderRecoveryCodesInput: gh_RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
  gh_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: ResolverTypeWrapper<gh_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;
  gh_RegenerateVerifiableDomainTokenInput: gh_RegenerateVerifiableDomainTokenInput;
  gh_RegenerateVerifiableDomainTokenPayload: ResolverTypeWrapper<gh_RegenerateVerifiableDomainTokenPayload>;
  gh_RejectDeploymentsInput: gh_RejectDeploymentsInput;
  gh_RejectDeploymentsPayload: ResolverTypeWrapper<gh_RejectDeploymentsPayload>;
  gh_Release: ResolverTypeWrapper<gh_Release>;
  gh_ReleaseAsset: ResolverTypeWrapper<gh_ReleaseAsset>;
  gh_ReleaseAssetConnection: ResolverTypeWrapper<gh_ReleaseAssetConnection>;
  gh_ReleaseAssetEdge: ResolverTypeWrapper<gh_ReleaseAssetEdge>;
  gh_ReleaseConnection: ResolverTypeWrapper<gh_ReleaseConnection>;
  gh_ReleaseEdge: ResolverTypeWrapper<gh_ReleaseEdge>;
  gh_ReleaseOrder: gh_ReleaseOrder;
  gh_ReleaseOrderField: gh_ReleaseOrderField;
  gh_RemoveAssigneesFromAssignableInput: gh_RemoveAssigneesFromAssignableInput;
  gh_RemoveAssigneesFromAssignablePayload: ResolverTypeWrapper<gh_RemoveAssigneesFromAssignablePayload>;
  gh_RemoveEnterpriseAdminInput: gh_RemoveEnterpriseAdminInput;
  gh_RemoveEnterpriseAdminPayload: ResolverTypeWrapper<gh_RemoveEnterpriseAdminPayload>;
  gh_RemoveEnterpriseIdentityProviderInput: gh_RemoveEnterpriseIdentityProviderInput;
  gh_RemoveEnterpriseIdentityProviderPayload: ResolverTypeWrapper<gh_RemoveEnterpriseIdentityProviderPayload>;
  gh_RemoveEnterpriseMemberInput: gh_RemoveEnterpriseMemberInput;
  gh_RemoveEnterpriseMemberPayload: ResolverTypeWrapper<gh_RemoveEnterpriseMemberPayload>;
  gh_RemoveEnterpriseOrganizationInput: gh_RemoveEnterpriseOrganizationInput;
  gh_RemoveEnterpriseOrganizationPayload: ResolverTypeWrapper<gh_RemoveEnterpriseOrganizationPayload>;
  gh_RemoveEnterpriseSupportEntitlementInput: gh_RemoveEnterpriseSupportEntitlementInput;
  gh_RemoveEnterpriseSupportEntitlementPayload: ResolverTypeWrapper<gh_RemoveEnterpriseSupportEntitlementPayload>;
  gh_RemoveLabelsFromLabelableInput: gh_RemoveLabelsFromLabelableInput;
  gh_RemoveLabelsFromLabelablePayload: ResolverTypeWrapper<gh_RemoveLabelsFromLabelablePayload>;
  gh_RemoveOutsideCollaboratorInput: gh_RemoveOutsideCollaboratorInput;
  gh_RemoveOutsideCollaboratorPayload: ResolverTypeWrapper<gh_RemoveOutsideCollaboratorPayload>;
  gh_RemoveReactionInput: gh_RemoveReactionInput;
  gh_RemoveReactionPayload: ResolverTypeWrapper<gh_RemoveReactionPayload>;
  gh_RemoveStarInput: gh_RemoveStarInput;
  gh_RemoveStarPayload: ResolverTypeWrapper<gh_RemoveStarPayload>;
  gh_RemoveUpvoteInput: gh_RemoveUpvoteInput;
  gh_RemoveUpvotePayload: ResolverTypeWrapper<gh_RemoveUpvotePayload>;
  gh_RemovedFromMergeQueueEvent: ResolverTypeWrapper<gh_RemovedFromMergeQueueEvent>;
  gh_RemovedFromProjectEvent: ResolverTypeWrapper<gh_RemovedFromProjectEvent>;
  gh_RenamedTitleEvent: ResolverTypeWrapper<Omit<gh_RenamedTitleEvent, 'subject'> & { subject: ResolversTypes['gh_RenamedTitleSubject'] }>;
  gh_RenamedTitleSubject: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_RenamedTitleSubject']>;
  gh_ReopenDiscussionInput: gh_ReopenDiscussionInput;
  gh_ReopenDiscussionPayload: ResolverTypeWrapper<gh_ReopenDiscussionPayload>;
  gh_ReopenIssueInput: gh_ReopenIssueInput;
  gh_ReopenIssuePayload: ResolverTypeWrapper<gh_ReopenIssuePayload>;
  gh_ReopenPullRequestInput: gh_ReopenPullRequestInput;
  gh_ReopenPullRequestPayload: ResolverTypeWrapper<gh_ReopenPullRequestPayload>;
  gh_ReopenedEvent: ResolverTypeWrapper<gh_ReopenedEvent>;
  gh_RepoAccessAuditEntry: ResolverTypeWrapper<Omit<gh_RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoAccessAuditEntryVisibility: gh_RepoAccessAuditEntryVisibility;
  gh_RepoAddMemberAuditEntry: ResolverTypeWrapper<Omit<gh_RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoAddMemberAuditEntryVisibility: gh_RepoAddMemberAuditEntryVisibility;
  gh_RepoAddTopicAuditEntry: ResolverTypeWrapper<Omit<gh_RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoArchivedAuditEntry: ResolverTypeWrapper<Omit<gh_RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoArchivedAuditEntryVisibility: gh_RepoArchivedAuditEntryVisibility;
  gh_RepoChangeMergeSettingAuditEntry: ResolverTypeWrapper<Omit<gh_RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoChangeMergeSettingAuditEntryMergeType: gh_RepoChangeMergeSettingAuditEntryMergeType;
  gh_RepoConfigDisableAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<gh_RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoConfigDisableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<gh_RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoConfigDisableContributorsOnlyAuditEntry: ResolverTypeWrapper<Omit<gh_RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoConfigDisableSockpuppetDisallowedAuditEntry: ResolverTypeWrapper<Omit<gh_RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoConfigEnableAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<gh_RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoConfigEnableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<gh_RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoConfigEnableContributorsOnlyAuditEntry: ResolverTypeWrapper<Omit<gh_RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoConfigEnableSockpuppetDisallowedAuditEntry: ResolverTypeWrapper<Omit<gh_RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoConfigLockAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<gh_RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoConfigUnlockAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<gh_RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoCreateAuditEntry: ResolverTypeWrapper<Omit<gh_RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoCreateAuditEntryVisibility: gh_RepoCreateAuditEntryVisibility;
  gh_RepoDestroyAuditEntry: ResolverTypeWrapper<Omit<gh_RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoDestroyAuditEntryVisibility: gh_RepoDestroyAuditEntryVisibility;
  gh_RepoRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<gh_RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepoRemoveMemberAuditEntryVisibility: gh_RepoRemoveMemberAuditEntryVisibility;
  gh_RepoRemoveTopicAuditEntry: ResolverTypeWrapper<Omit<gh_RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_ReportedContentClassifiers: gh_ReportedContentClassifiers;
  gh_Repository: ResolverTypeWrapper<Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<ResolversTypes['gh_IssueOrPullRequest']> }>;
  gh_RepositoryAffiliation: gh_RepositoryAffiliation;
  gh_RepositoryAuditEntryData: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_RepositoryAuditEntryData']>;
  gh_RepositoryCodeowners: ResolverTypeWrapper<gh_RepositoryCodeowners>;
  gh_RepositoryCodeownersError: ResolverTypeWrapper<gh_RepositoryCodeownersError>;
  gh_RepositoryCollaboratorConnection: ResolverTypeWrapper<gh_RepositoryCollaboratorConnection>;
  gh_RepositoryCollaboratorEdge: ResolverTypeWrapper<gh_RepositoryCollaboratorEdge>;
  gh_RepositoryConnection: ResolverTypeWrapper<gh_RepositoryConnection>;
  gh_RepositoryContactLink: ResolverTypeWrapper<gh_RepositoryContactLink>;
  gh_RepositoryContributionType: gh_RepositoryContributionType;
  gh_RepositoryDiscussionAuthor: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_RepositoryDiscussionAuthor']>;
  gh_RepositoryDiscussionCommentAuthor: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_RepositoryDiscussionCommentAuthor']>;
  gh_RepositoryEdge: ResolverTypeWrapper<gh_RepositoryEdge>;
  gh_RepositoryIdConditionTarget: ResolverTypeWrapper<gh_RepositoryIdConditionTarget>;
  gh_RepositoryIdConditionTargetInput: gh_RepositoryIdConditionTargetInput;
  gh_RepositoryInfo: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_RepositoryInfo']>;
  gh_RepositoryInteractionAbility: ResolverTypeWrapper<gh_RepositoryInteractionAbility>;
  gh_RepositoryInteractionLimit: gh_RepositoryInteractionLimit;
  gh_RepositoryInteractionLimitExpiry: gh_RepositoryInteractionLimitExpiry;
  gh_RepositoryInteractionLimitOrigin: gh_RepositoryInteractionLimitOrigin;
  gh_RepositoryInvitation: ResolverTypeWrapper<gh_RepositoryInvitation>;
  gh_RepositoryInvitationConnection: ResolverTypeWrapper<gh_RepositoryInvitationConnection>;
  gh_RepositoryInvitationEdge: ResolverTypeWrapper<gh_RepositoryInvitationEdge>;
  gh_RepositoryInvitationOrder: gh_RepositoryInvitationOrder;
  gh_RepositoryInvitationOrderField: gh_RepositoryInvitationOrderField;
  gh_RepositoryLockReason: gh_RepositoryLockReason;
  gh_RepositoryMigration: ResolverTypeWrapper<gh_RepositoryMigration>;
  gh_RepositoryMigrationConnection: ResolverTypeWrapper<gh_RepositoryMigrationConnection>;
  gh_RepositoryMigrationEdge: ResolverTypeWrapper<gh_RepositoryMigrationEdge>;
  gh_RepositoryMigrationOrder: gh_RepositoryMigrationOrder;
  gh_RepositoryMigrationOrderDirection: gh_RepositoryMigrationOrderDirection;
  gh_RepositoryMigrationOrderField: gh_RepositoryMigrationOrderField;
  gh_RepositoryNameConditionTarget: ResolverTypeWrapper<gh_RepositoryNameConditionTarget>;
  gh_RepositoryNameConditionTargetInput: gh_RepositoryNameConditionTargetInput;
  gh_RepositoryNode: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_RepositoryNode']>;
  gh_RepositoryOrder: gh_RepositoryOrder;
  gh_RepositoryOrderField: gh_RepositoryOrderField;
  gh_RepositoryOwner: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_RepositoryOwner']>;
  gh_RepositoryPermission: gh_RepositoryPermission;
  gh_RepositoryPrivacy: gh_RepositoryPrivacy;
  gh_RepositoryRule: ResolverTypeWrapper<Omit<gh_RepositoryRule, 'parameters'> & { parameters?: Maybe<ResolversTypes['gh_RuleParameters']> }>;
  gh_RepositoryRuleConditions: ResolverTypeWrapper<gh_RepositoryRuleConditions>;
  gh_RepositoryRuleConditionsInput: gh_RepositoryRuleConditionsInput;
  gh_RepositoryRuleConnection: ResolverTypeWrapper<gh_RepositoryRuleConnection>;
  gh_RepositoryRuleEdge: ResolverTypeWrapper<gh_RepositoryRuleEdge>;
  gh_RepositoryRuleInput: gh_RepositoryRuleInput;
  gh_RepositoryRuleType: gh_RepositoryRuleType;
  gh_RepositoryRuleset: ResolverTypeWrapper<Omit<gh_RepositoryRuleset, 'source'> & { source: ResolversTypes['gh_RuleSource'] }>;
  gh_RepositoryRulesetBypassActor: ResolverTypeWrapper<Omit<gh_RepositoryRulesetBypassActor, 'actor'> & { actor?: Maybe<ResolversTypes['gh_BypassActor']> }>;
  gh_RepositoryRulesetBypassActorBypassMode: gh_RepositoryRulesetBypassActorBypassMode;
  gh_RepositoryRulesetBypassActorConnection: ResolverTypeWrapper<gh_RepositoryRulesetBypassActorConnection>;
  gh_RepositoryRulesetBypassActorEdge: ResolverTypeWrapper<gh_RepositoryRulesetBypassActorEdge>;
  gh_RepositoryRulesetBypassActorInput: gh_RepositoryRulesetBypassActorInput;
  gh_RepositoryRulesetConnection: ResolverTypeWrapper<gh_RepositoryRulesetConnection>;
  gh_RepositoryRulesetEdge: ResolverTypeWrapper<gh_RepositoryRulesetEdge>;
  gh_RepositoryRulesetTarget: gh_RepositoryRulesetTarget;
  gh_RepositoryTopic: ResolverTypeWrapper<gh_RepositoryTopic>;
  gh_RepositoryTopicConnection: ResolverTypeWrapper<gh_RepositoryTopicConnection>;
  gh_RepositoryTopicEdge: ResolverTypeWrapper<gh_RepositoryTopicEdge>;
  gh_RepositoryVisibility: gh_RepositoryVisibility;
  gh_RepositoryVisibilityChangeDisableAuditEntry: ResolverTypeWrapper<Omit<gh_RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepositoryVisibilityChangeEnableAuditEntry: ResolverTypeWrapper<Omit<gh_RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_RepositoryVulnerabilityAlert: ResolverTypeWrapper<gh_RepositoryVulnerabilityAlert>;
  gh_RepositoryVulnerabilityAlertConnection: ResolverTypeWrapper<gh_RepositoryVulnerabilityAlertConnection>;
  gh_RepositoryVulnerabilityAlertDependencyScope: gh_RepositoryVulnerabilityAlertDependencyScope;
  gh_RepositoryVulnerabilityAlertEdge: ResolverTypeWrapper<gh_RepositoryVulnerabilityAlertEdge>;
  gh_RepositoryVulnerabilityAlertState: gh_RepositoryVulnerabilityAlertState;
  gh_RequestReviewsInput: gh_RequestReviewsInput;
  gh_RequestReviewsPayload: ResolverTypeWrapper<gh_RequestReviewsPayload>;
  gh_RequestableCheckStatusState: gh_RequestableCheckStatusState;
  gh_RequestedReviewer: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_RequestedReviewer']>;
  gh_RequestedReviewerConnection: ResolverTypeWrapper<Omit<gh_RequestedReviewerConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_RequestedReviewer']>>> }>;
  gh_RequestedReviewerEdge: ResolverTypeWrapper<Omit<gh_RequestedReviewerEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_RequestedReviewer']> }>;
  gh_RequirableByPullRequest: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_RequirableByPullRequest']>;
  gh_RequiredDeploymentsParameters: ResolverTypeWrapper<gh_RequiredDeploymentsParameters>;
  gh_RequiredDeploymentsParametersInput: gh_RequiredDeploymentsParametersInput;
  gh_RequiredStatusCheckDescription: ResolverTypeWrapper<gh_RequiredStatusCheckDescription>;
  gh_RequiredStatusCheckInput: gh_RequiredStatusCheckInput;
  gh_RequiredStatusChecksParameters: ResolverTypeWrapper<gh_RequiredStatusChecksParameters>;
  gh_RequiredStatusChecksParametersInput: gh_RequiredStatusChecksParametersInput;
  gh_RerequestCheckSuiteInput: gh_RerequestCheckSuiteInput;
  gh_RerequestCheckSuitePayload: ResolverTypeWrapper<gh_RerequestCheckSuitePayload>;
  gh_ResolveReviewThreadInput: gh_ResolveReviewThreadInput;
  gh_ResolveReviewThreadPayload: ResolverTypeWrapper<gh_ResolveReviewThreadPayload>;
  gh_RestrictedContribution: ResolverTypeWrapper<gh_RestrictedContribution>;
  gh_RetireSponsorsTierInput: gh_RetireSponsorsTierInput;
  gh_RetireSponsorsTierPayload: ResolverTypeWrapper<gh_RetireSponsorsTierPayload>;
  gh_RevertPullRequestInput: gh_RevertPullRequestInput;
  gh_RevertPullRequestPayload: ResolverTypeWrapper<gh_RevertPullRequestPayload>;
  gh_ReviewDismissalAllowance: ResolverTypeWrapper<Omit<gh_ReviewDismissalAllowance, 'actor'> & { actor?: Maybe<ResolversTypes['gh_ReviewDismissalAllowanceActor']> }>;
  gh_ReviewDismissalAllowanceActor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_ReviewDismissalAllowanceActor']>;
  gh_ReviewDismissalAllowanceConnection: ResolverTypeWrapper<gh_ReviewDismissalAllowanceConnection>;
  gh_ReviewDismissalAllowanceEdge: ResolverTypeWrapper<gh_ReviewDismissalAllowanceEdge>;
  gh_ReviewDismissedEvent: ResolverTypeWrapper<gh_ReviewDismissedEvent>;
  gh_ReviewRequest: ResolverTypeWrapper<Omit<gh_ReviewRequest, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversTypes['gh_RequestedReviewer']> }>;
  gh_ReviewRequestConnection: ResolverTypeWrapper<gh_ReviewRequestConnection>;
  gh_ReviewRequestEdge: ResolverTypeWrapper<gh_ReviewRequestEdge>;
  gh_ReviewRequestRemovedEvent: ResolverTypeWrapper<Omit<gh_ReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversTypes['gh_RequestedReviewer']> }>;
  gh_ReviewRequestedEvent: ResolverTypeWrapper<Omit<gh_ReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversTypes['gh_RequestedReviewer']> }>;
  gh_ReviewStatusHovercardContext: ResolverTypeWrapper<gh_ReviewStatusHovercardContext>;
  gh_RevokeEnterpriseOrganizationsMigratorRoleInput: gh_RevokeEnterpriseOrganizationsMigratorRoleInput;
  gh_RevokeEnterpriseOrganizationsMigratorRolePayload: ResolverTypeWrapper<gh_RevokeEnterpriseOrganizationsMigratorRolePayload>;
  gh_RevokeMigratorRoleInput: gh_RevokeMigratorRoleInput;
  gh_RevokeMigratorRolePayload: ResolverTypeWrapper<gh_RevokeMigratorRolePayload>;
  gh_RoleInOrganization: gh_RoleInOrganization;
  gh_RuleEnforcement: gh_RuleEnforcement;
  gh_RuleParameters: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_RuleParameters']>;
  gh_RuleParametersInput: gh_RuleParametersInput;
  gh_RuleSource: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_RuleSource']>;
  gh_SamlDigestAlgorithm: gh_SamlDigestAlgorithm;
  gh_SamlSignatureAlgorithm: gh_SamlSignatureAlgorithm;
  gh_SavedReply: ResolverTypeWrapper<gh_SavedReply>;
  gh_SavedReplyConnection: ResolverTypeWrapper<gh_SavedReplyConnection>;
  gh_SavedReplyEdge: ResolverTypeWrapper<gh_SavedReplyEdge>;
  gh_SavedReplyOrder: gh_SavedReplyOrder;
  gh_SavedReplyOrderField: gh_SavedReplyOrderField;
  gh_SearchResultItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_SearchResultItem']>;
  gh_SearchResultItemConnection: ResolverTypeWrapper<Omit<gh_SearchResultItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_SearchResultItem']>>> }>;
  gh_SearchResultItemEdge: ResolverTypeWrapper<Omit<gh_SearchResultItemEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_SearchResultItem']> }>;
  gh_SearchType: gh_SearchType;
  gh_SecurityAdvisory: ResolverTypeWrapper<gh_SecurityAdvisory>;
  gh_SecurityAdvisoryClassification: gh_SecurityAdvisoryClassification;
  gh_SecurityAdvisoryConnection: ResolverTypeWrapper<gh_SecurityAdvisoryConnection>;
  gh_SecurityAdvisoryEcosystem: gh_SecurityAdvisoryEcosystem;
  gh_SecurityAdvisoryEdge: ResolverTypeWrapper<gh_SecurityAdvisoryEdge>;
  gh_SecurityAdvisoryIdentifier: ResolverTypeWrapper<gh_SecurityAdvisoryIdentifier>;
  gh_SecurityAdvisoryIdentifierFilter: gh_SecurityAdvisoryIdentifierFilter;
  gh_SecurityAdvisoryIdentifierType: gh_SecurityAdvisoryIdentifierType;
  gh_SecurityAdvisoryOrder: gh_SecurityAdvisoryOrder;
  gh_SecurityAdvisoryOrderField: gh_SecurityAdvisoryOrderField;
  gh_SecurityAdvisoryPackage: ResolverTypeWrapper<gh_SecurityAdvisoryPackage>;
  gh_SecurityAdvisoryPackageVersion: ResolverTypeWrapper<gh_SecurityAdvisoryPackageVersion>;
  gh_SecurityAdvisoryReference: ResolverTypeWrapper<gh_SecurityAdvisoryReference>;
  gh_SecurityAdvisorySeverity: gh_SecurityAdvisorySeverity;
  gh_SecurityVulnerability: ResolverTypeWrapper<gh_SecurityVulnerability>;
  gh_SecurityVulnerabilityConnection: ResolverTypeWrapper<gh_SecurityVulnerabilityConnection>;
  gh_SecurityVulnerabilityEdge: ResolverTypeWrapper<gh_SecurityVulnerabilityEdge>;
  gh_SecurityVulnerabilityOrder: gh_SecurityVulnerabilityOrder;
  gh_SecurityVulnerabilityOrderField: gh_SecurityVulnerabilityOrderField;
  gh_SetEnterpriseIdentityProviderInput: gh_SetEnterpriseIdentityProviderInput;
  gh_SetEnterpriseIdentityProviderPayload: ResolverTypeWrapper<gh_SetEnterpriseIdentityProviderPayload>;
  gh_SetOrganizationInteractionLimitInput: gh_SetOrganizationInteractionLimitInput;
  gh_SetOrganizationInteractionLimitPayload: ResolverTypeWrapper<gh_SetOrganizationInteractionLimitPayload>;
  gh_SetRepositoryInteractionLimitInput: gh_SetRepositoryInteractionLimitInput;
  gh_SetRepositoryInteractionLimitPayload: ResolverTypeWrapper<gh_SetRepositoryInteractionLimitPayload>;
  gh_SetUserInteractionLimitInput: gh_SetUserInteractionLimitInput;
  gh_SetUserInteractionLimitPayload: ResolverTypeWrapper<gh_SetUserInteractionLimitPayload>;
  gh_SmimeSignature: ResolverTypeWrapper<gh_SmimeSignature>;
  gh_SocialAccount: ResolverTypeWrapper<gh_SocialAccount>;
  gh_SocialAccountConnection: ResolverTypeWrapper<gh_SocialAccountConnection>;
  gh_SocialAccountEdge: ResolverTypeWrapper<gh_SocialAccountEdge>;
  gh_SocialAccountProvider: gh_SocialAccountProvider;
  gh_Sponsor: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_Sponsor']>;
  gh_SponsorConnection: ResolverTypeWrapper<Omit<gh_SponsorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_Sponsor']>>> }>;
  gh_SponsorEdge: ResolverTypeWrapper<Omit<gh_SponsorEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_Sponsor']> }>;
  gh_SponsorOrder: gh_SponsorOrder;
  gh_SponsorOrderField: gh_SponsorOrderField;
  gh_Sponsorable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Sponsorable']>;
  gh_SponsorableItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_SponsorableItem']>;
  gh_SponsorableItemConnection: ResolverTypeWrapper<Omit<gh_SponsorableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_SponsorableItem']>>> }>;
  gh_SponsorableItemEdge: ResolverTypeWrapper<Omit<gh_SponsorableItemEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_SponsorableItem']> }>;
  gh_SponsorableOrder: gh_SponsorableOrder;
  gh_SponsorableOrderField: gh_SponsorableOrderField;
  gh_SponsorsActivity: ResolverTypeWrapper<Omit<gh_SponsorsActivity, 'sponsor'> & { sponsor?: Maybe<ResolversTypes['gh_Sponsor']> }>;
  gh_SponsorsActivityAction: gh_SponsorsActivityAction;
  gh_SponsorsActivityConnection: ResolverTypeWrapper<gh_SponsorsActivityConnection>;
  gh_SponsorsActivityEdge: ResolverTypeWrapper<gh_SponsorsActivityEdge>;
  gh_SponsorsActivityOrder: gh_SponsorsActivityOrder;
  gh_SponsorsActivityOrderField: gh_SponsorsActivityOrderField;
  gh_SponsorsActivityPeriod: gh_SponsorsActivityPeriod;
  gh_SponsorsCountryOrRegionCode: gh_SponsorsCountryOrRegionCode;
  gh_SponsorsGoal: ResolverTypeWrapper<gh_SponsorsGoal>;
  gh_SponsorsGoalKind: gh_SponsorsGoalKind;
  gh_SponsorsListing: ResolverTypeWrapper<gh_SponsorsListing>;
  gh_SponsorsListingFeatureableItem: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_SponsorsListingFeatureableItem']>;
  gh_SponsorsListingFeaturedItem: ResolverTypeWrapper<Omit<gh_SponsorsListingFeaturedItem, 'featureable'> & { featureable: ResolversTypes['gh_SponsorsListingFeatureableItem'] }>;
  gh_SponsorsListingFeaturedItemFeatureableType: gh_SponsorsListingFeaturedItemFeatureableType;
  gh_SponsorsTier: ResolverTypeWrapper<gh_SponsorsTier>;
  gh_SponsorsTierAdminInfo: ResolverTypeWrapper<gh_SponsorsTierAdminInfo>;
  gh_SponsorsTierConnection: ResolverTypeWrapper<gh_SponsorsTierConnection>;
  gh_SponsorsTierEdge: ResolverTypeWrapper<gh_SponsorsTierEdge>;
  gh_SponsorsTierOrder: gh_SponsorsTierOrder;
  gh_SponsorsTierOrderField: gh_SponsorsTierOrderField;
  gh_Sponsorship: ResolverTypeWrapper<Omit<gh_Sponsorship, 'sponsorEntity'> & { sponsorEntity?: Maybe<ResolversTypes['gh_Sponsor']> }>;
  gh_SponsorshipConnection: ResolverTypeWrapper<gh_SponsorshipConnection>;
  gh_SponsorshipEdge: ResolverTypeWrapper<gh_SponsorshipEdge>;
  gh_SponsorshipNewsletter: ResolverTypeWrapper<gh_SponsorshipNewsletter>;
  gh_SponsorshipNewsletterConnection: ResolverTypeWrapper<gh_SponsorshipNewsletterConnection>;
  gh_SponsorshipNewsletterEdge: ResolverTypeWrapper<gh_SponsorshipNewsletterEdge>;
  gh_SponsorshipNewsletterOrder: gh_SponsorshipNewsletterOrder;
  gh_SponsorshipNewsletterOrderField: gh_SponsorshipNewsletterOrderField;
  gh_SponsorshipOrder: gh_SponsorshipOrder;
  gh_SponsorshipOrderField: gh_SponsorshipOrderField;
  gh_SponsorshipPaymentSource: gh_SponsorshipPaymentSource;
  gh_SponsorshipPrivacy: gh_SponsorshipPrivacy;
  gh_SquashMergeCommitMessage: gh_SquashMergeCommitMessage;
  gh_SquashMergeCommitTitle: gh_SquashMergeCommitTitle;
  gh_SshSignature: ResolverTypeWrapper<gh_SshSignature>;
  gh_StarOrder: gh_StarOrder;
  gh_StarOrderField: gh_StarOrderField;
  gh_StargazerConnection: ResolverTypeWrapper<gh_StargazerConnection>;
  gh_StargazerEdge: ResolverTypeWrapper<gh_StargazerEdge>;
  gh_Starrable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Starrable']>;
  gh_StarredRepositoryConnection: ResolverTypeWrapper<gh_StarredRepositoryConnection>;
  gh_StarredRepositoryEdge: ResolverTypeWrapper<gh_StarredRepositoryEdge>;
  gh_StartOrganizationMigrationInput: gh_StartOrganizationMigrationInput;
  gh_StartOrganizationMigrationPayload: ResolverTypeWrapper<gh_StartOrganizationMigrationPayload>;
  gh_StartRepositoryMigrationInput: gh_StartRepositoryMigrationInput;
  gh_StartRepositoryMigrationPayload: ResolverTypeWrapper<gh_StartRepositoryMigrationPayload>;
  gh_Status: ResolverTypeWrapper<gh_Status>;
  gh_StatusCheckConfiguration: ResolverTypeWrapper<gh_StatusCheckConfiguration>;
  gh_StatusCheckConfigurationInput: gh_StatusCheckConfigurationInput;
  gh_StatusCheckRollup: ResolverTypeWrapper<gh_StatusCheckRollup>;
  gh_StatusCheckRollupContext: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_StatusCheckRollupContext']>;
  gh_StatusCheckRollupContextConnection: ResolverTypeWrapper<Omit<gh_StatusCheckRollupContextConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_StatusCheckRollupContext']>>> }>;
  gh_StatusCheckRollupContextEdge: ResolverTypeWrapper<Omit<gh_StatusCheckRollupContextEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_StatusCheckRollupContext']> }>;
  gh_StatusContext: ResolverTypeWrapper<gh_StatusContext>;
  gh_StatusContextStateCount: ResolverTypeWrapper<gh_StatusContextStateCount>;
  gh_StatusState: gh_StatusState;
  gh_StripeConnectAccount: ResolverTypeWrapper<gh_StripeConnectAccount>;
  gh_SubmitPullRequestReviewInput: gh_SubmitPullRequestReviewInput;
  gh_SubmitPullRequestReviewPayload: ResolverTypeWrapper<gh_SubmitPullRequestReviewPayload>;
  gh_Submodule: ResolverTypeWrapper<gh_Submodule>;
  gh_SubmoduleConnection: ResolverTypeWrapper<gh_SubmoduleConnection>;
  gh_SubmoduleEdge: ResolverTypeWrapper<gh_SubmoduleEdge>;
  gh_Subscribable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Subscribable']>;
  gh_SubscribableThread: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_SubscribableThread']>;
  gh_SubscribedEvent: ResolverTypeWrapper<gh_SubscribedEvent>;
  gh_SubscriptionState: gh_SubscriptionState;
  gh_SuggestedReviewer: ResolverTypeWrapper<gh_SuggestedReviewer>;
  gh_Tag: ResolverTypeWrapper<gh_Tag>;
  gh_TagNamePatternParameters: ResolverTypeWrapper<gh_TagNamePatternParameters>;
  gh_TagNamePatternParametersInput: gh_TagNamePatternParametersInput;
  gh_Team: ResolverTypeWrapper<gh_Team>;
  gh_TeamAddMemberAuditEntry: ResolverTypeWrapper<Omit<gh_TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_TeamAddRepositoryAuditEntry: ResolverTypeWrapper<Omit<gh_TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_TeamAuditEntryData: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_TeamAuditEntryData']>;
  gh_TeamChangeParentTeamAuditEntry: ResolverTypeWrapper<Omit<gh_TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_TeamConnection: ResolverTypeWrapper<gh_TeamConnection>;
  gh_TeamDiscussion: ResolverTypeWrapper<gh_TeamDiscussion>;
  gh_TeamDiscussionComment: ResolverTypeWrapper<gh_TeamDiscussionComment>;
  gh_TeamDiscussionCommentConnection: ResolverTypeWrapper<gh_TeamDiscussionCommentConnection>;
  gh_TeamDiscussionCommentEdge: ResolverTypeWrapper<gh_TeamDiscussionCommentEdge>;
  gh_TeamDiscussionCommentOrder: gh_TeamDiscussionCommentOrder;
  gh_TeamDiscussionCommentOrderField: gh_TeamDiscussionCommentOrderField;
  gh_TeamDiscussionConnection: ResolverTypeWrapper<gh_TeamDiscussionConnection>;
  gh_TeamDiscussionEdge: ResolverTypeWrapper<gh_TeamDiscussionEdge>;
  gh_TeamDiscussionOrder: gh_TeamDiscussionOrder;
  gh_TeamDiscussionOrderField: gh_TeamDiscussionOrderField;
  gh_TeamEdge: ResolverTypeWrapper<gh_TeamEdge>;
  gh_TeamMemberConnection: ResolverTypeWrapper<gh_TeamMemberConnection>;
  gh_TeamMemberEdge: ResolverTypeWrapper<gh_TeamMemberEdge>;
  gh_TeamMemberOrder: gh_TeamMemberOrder;
  gh_TeamMemberOrderField: gh_TeamMemberOrderField;
  gh_TeamMemberRole: gh_TeamMemberRole;
  gh_TeamMembershipType: gh_TeamMembershipType;
  gh_TeamNotificationSetting: gh_TeamNotificationSetting;
  gh_TeamOrder: gh_TeamOrder;
  gh_TeamOrderField: gh_TeamOrderField;
  gh_TeamPrivacy: gh_TeamPrivacy;
  gh_TeamRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<gh_TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_TeamRemoveRepositoryAuditEntry: ResolverTypeWrapper<Omit<gh_TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['gh_AuditEntryActor']> }>;
  gh_TeamRepositoryConnection: ResolverTypeWrapper<gh_TeamRepositoryConnection>;
  gh_TeamRepositoryEdge: ResolverTypeWrapper<gh_TeamRepositoryEdge>;
  gh_TeamRepositoryOrder: gh_TeamRepositoryOrder;
  gh_TeamRepositoryOrderField: gh_TeamRepositoryOrderField;
  gh_TeamReviewAssignmentAlgorithm: gh_TeamReviewAssignmentAlgorithm;
  gh_TeamRole: gh_TeamRole;
  gh_TextMatch: ResolverTypeWrapper<gh_TextMatch>;
  gh_TextMatchHighlight: ResolverTypeWrapper<gh_TextMatchHighlight>;
  gh_ThreadSubscriptionFormAction: gh_ThreadSubscriptionFormAction;
  gh_ThreadSubscriptionState: gh_ThreadSubscriptionState;
  gh_Topic: ResolverTypeWrapper<gh_Topic>;
  gh_TopicAuditEntryData: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_TopicAuditEntryData']>;
  gh_TopicSuggestionDeclineReason: gh_TopicSuggestionDeclineReason;
  gh_TrackedIssueStates: gh_TrackedIssueStates;
  gh_TransferEnterpriseOrganizationInput: gh_TransferEnterpriseOrganizationInput;
  gh_TransferEnterpriseOrganizationPayload: ResolverTypeWrapper<gh_TransferEnterpriseOrganizationPayload>;
  gh_TransferIssueInput: gh_TransferIssueInput;
  gh_TransferIssuePayload: ResolverTypeWrapper<gh_TransferIssuePayload>;
  gh_TransferredEvent: ResolverTypeWrapper<gh_TransferredEvent>;
  gh_Tree: ResolverTypeWrapper<gh_Tree>;
  gh_TreeEntry: ResolverTypeWrapper<gh_TreeEntry>;
  gh_URI: ResolverTypeWrapper<Scalars['gh_URI']['output']>;
  gh_UnarchiveProjectV2ItemInput: gh_UnarchiveProjectV2ItemInput;
  gh_UnarchiveProjectV2ItemPayload: ResolverTypeWrapper<gh_UnarchiveProjectV2ItemPayload>;
  gh_UnarchiveRepositoryInput: gh_UnarchiveRepositoryInput;
  gh_UnarchiveRepositoryPayload: ResolverTypeWrapper<gh_UnarchiveRepositoryPayload>;
  gh_UnassignedEvent: ResolverTypeWrapper<Omit<gh_UnassignedEvent, 'assignee'> & { assignee?: Maybe<ResolversTypes['gh_Assignee']> }>;
  gh_UnfollowOrganizationInput: gh_UnfollowOrganizationInput;
  gh_UnfollowOrganizationPayload: ResolverTypeWrapper<gh_UnfollowOrganizationPayload>;
  gh_UnfollowUserInput: gh_UnfollowUserInput;
  gh_UnfollowUserPayload: ResolverTypeWrapper<gh_UnfollowUserPayload>;
  gh_UniformResourceLocatable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_UniformResourceLocatable']>;
  gh_UnknownSignature: ResolverTypeWrapper<gh_UnknownSignature>;
  gh_UnlabeledEvent: ResolverTypeWrapper<gh_UnlabeledEvent>;
  gh_UnlinkProjectV2FromRepositoryInput: gh_UnlinkProjectV2FromRepositoryInput;
  gh_UnlinkProjectV2FromRepositoryPayload: ResolverTypeWrapper<gh_UnlinkProjectV2FromRepositoryPayload>;
  gh_UnlinkProjectV2FromTeamInput: gh_UnlinkProjectV2FromTeamInput;
  gh_UnlinkProjectV2FromTeamPayload: ResolverTypeWrapper<gh_UnlinkProjectV2FromTeamPayload>;
  gh_UnlinkRepositoryFromProjectInput: gh_UnlinkRepositoryFromProjectInput;
  gh_UnlinkRepositoryFromProjectPayload: ResolverTypeWrapper<gh_UnlinkRepositoryFromProjectPayload>;
  gh_UnlockLockableInput: gh_UnlockLockableInput;
  gh_UnlockLockablePayload: ResolverTypeWrapper<gh_UnlockLockablePayload>;
  gh_UnlockedEvent: ResolverTypeWrapper<gh_UnlockedEvent>;
  gh_UnmarkDiscussionCommentAsAnswerInput: gh_UnmarkDiscussionCommentAsAnswerInput;
  gh_UnmarkDiscussionCommentAsAnswerPayload: ResolverTypeWrapper<gh_UnmarkDiscussionCommentAsAnswerPayload>;
  gh_UnmarkFileAsViewedInput: gh_UnmarkFileAsViewedInput;
  gh_UnmarkFileAsViewedPayload: ResolverTypeWrapper<gh_UnmarkFileAsViewedPayload>;
  gh_UnmarkIssueAsDuplicateInput: gh_UnmarkIssueAsDuplicateInput;
  gh_UnmarkIssueAsDuplicatePayload: ResolverTypeWrapper<Omit<gh_UnmarkIssueAsDuplicatePayload, 'duplicate'> & { duplicate?: Maybe<ResolversTypes['gh_IssueOrPullRequest']> }>;
  gh_UnmarkProjectV2AsTemplateInput: gh_UnmarkProjectV2AsTemplateInput;
  gh_UnmarkProjectV2AsTemplatePayload: ResolverTypeWrapper<gh_UnmarkProjectV2AsTemplatePayload>;
  gh_UnmarkedAsDuplicateEvent: ResolverTypeWrapper<Omit<gh_UnmarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<ResolversTypes['gh_IssueOrPullRequest']>, duplicate?: Maybe<ResolversTypes['gh_IssueOrPullRequest']> }>;
  gh_UnminimizeCommentInput: gh_UnminimizeCommentInput;
  gh_UnminimizeCommentPayload: ResolverTypeWrapper<gh_UnminimizeCommentPayload>;
  gh_UnpinIssueInput: gh_UnpinIssueInput;
  gh_UnpinIssuePayload: ResolverTypeWrapper<gh_UnpinIssuePayload>;
  gh_UnpinnedEvent: ResolverTypeWrapper<gh_UnpinnedEvent>;
  gh_UnresolveReviewThreadInput: gh_UnresolveReviewThreadInput;
  gh_UnresolveReviewThreadPayload: ResolverTypeWrapper<gh_UnresolveReviewThreadPayload>;
  gh_UnsubscribeFromNotificationsInput: gh_UnsubscribeFromNotificationsInput;
  gh_UnsubscribeFromNotificationsPayload: ResolverTypeWrapper<gh_UnsubscribeFromNotificationsPayload>;
  gh_UnsubscribedEvent: ResolverTypeWrapper<gh_UnsubscribedEvent>;
  gh_Updatable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Updatable']>;
  gh_UpdatableComment: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_UpdatableComment']>;
  gh_UpdateBranchProtectionRuleInput: gh_UpdateBranchProtectionRuleInput;
  gh_UpdateBranchProtectionRulePayload: ResolverTypeWrapper<gh_UpdateBranchProtectionRulePayload>;
  gh_UpdateCheckRunInput: gh_UpdateCheckRunInput;
  gh_UpdateCheckRunPayload: ResolverTypeWrapper<gh_UpdateCheckRunPayload>;
  gh_UpdateCheckSuitePreferencesInput: gh_UpdateCheckSuitePreferencesInput;
  gh_UpdateCheckSuitePreferencesPayload: ResolverTypeWrapper<gh_UpdateCheckSuitePreferencesPayload>;
  gh_UpdateDiscussionCommentInput: gh_UpdateDiscussionCommentInput;
  gh_UpdateDiscussionCommentPayload: ResolverTypeWrapper<gh_UpdateDiscussionCommentPayload>;
  gh_UpdateDiscussionInput: gh_UpdateDiscussionInput;
  gh_UpdateDiscussionPayload: ResolverTypeWrapper<gh_UpdateDiscussionPayload>;
  gh_UpdateEnterpriseAdministratorRoleInput: gh_UpdateEnterpriseAdministratorRoleInput;
  gh_UpdateEnterpriseAdministratorRolePayload: ResolverTypeWrapper<gh_UpdateEnterpriseAdministratorRolePayload>;
  gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput: gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
  gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;
  gh_UpdateEnterpriseDefaultRepositoryPermissionSettingInput: gh_UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
  gh_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;
  gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput: gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
  gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;
  gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput: gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
  gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;
  gh_UpdateEnterpriseMembersCanDeleteIssuesSettingInput: gh_UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
  gh_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;
  gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput: gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
  gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;
  gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput: gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
  gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;
  gh_UpdateEnterpriseMembersCanMakePurchasesSettingInput: gh_UpdateEnterpriseMembersCanMakePurchasesSettingInput;
  gh_UpdateEnterpriseMembersCanMakePurchasesSettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseMembersCanMakePurchasesSettingPayload>;
  gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput: gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
  gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;
  gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput: gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
  gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;
  gh_UpdateEnterpriseOrganizationProjectsSettingInput: gh_UpdateEnterpriseOrganizationProjectsSettingInput;
  gh_UpdateEnterpriseOrganizationProjectsSettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseOrganizationProjectsSettingPayload>;
  gh_UpdateEnterpriseOwnerOrganizationRoleInput: gh_UpdateEnterpriseOwnerOrganizationRoleInput;
  gh_UpdateEnterpriseOwnerOrganizationRolePayload: ResolverTypeWrapper<gh_UpdateEnterpriseOwnerOrganizationRolePayload>;
  gh_UpdateEnterpriseProfileInput: gh_UpdateEnterpriseProfileInput;
  gh_UpdateEnterpriseProfilePayload: ResolverTypeWrapper<gh_UpdateEnterpriseProfilePayload>;
  gh_UpdateEnterpriseRepositoryProjectsSettingInput: gh_UpdateEnterpriseRepositoryProjectsSettingInput;
  gh_UpdateEnterpriseRepositoryProjectsSettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseRepositoryProjectsSettingPayload>;
  gh_UpdateEnterpriseTeamDiscussionsSettingInput: gh_UpdateEnterpriseTeamDiscussionsSettingInput;
  gh_UpdateEnterpriseTeamDiscussionsSettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseTeamDiscussionsSettingPayload>;
  gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput: gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
  gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: ResolverTypeWrapper<gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;
  gh_UpdateEnvironmentInput: gh_UpdateEnvironmentInput;
  gh_UpdateEnvironmentPayload: ResolverTypeWrapper<gh_UpdateEnvironmentPayload>;
  gh_UpdateIpAllowListEnabledSettingInput: gh_UpdateIpAllowListEnabledSettingInput;
  gh_UpdateIpAllowListEnabledSettingPayload: ResolverTypeWrapper<Omit<gh_UpdateIpAllowListEnabledSettingPayload, 'owner'> & { owner?: Maybe<ResolversTypes['gh_IpAllowListOwner']> }>;
  gh_UpdateIpAllowListEntryInput: gh_UpdateIpAllowListEntryInput;
  gh_UpdateIpAllowListEntryPayload: ResolverTypeWrapper<gh_UpdateIpAllowListEntryPayload>;
  gh_UpdateIpAllowListForInstalledAppsEnabledSettingInput: gh_UpdateIpAllowListForInstalledAppsEnabledSettingInput;
  gh_UpdateIpAllowListForInstalledAppsEnabledSettingPayload: ResolverTypeWrapper<Omit<gh_UpdateIpAllowListForInstalledAppsEnabledSettingPayload, 'owner'> & { owner?: Maybe<ResolversTypes['gh_IpAllowListOwner']> }>;
  gh_UpdateIssueCommentInput: gh_UpdateIssueCommentInput;
  gh_UpdateIssueCommentPayload: ResolverTypeWrapper<gh_UpdateIssueCommentPayload>;
  gh_UpdateIssueInput: gh_UpdateIssueInput;
  gh_UpdateIssuePayload: ResolverTypeWrapper<gh_UpdateIssuePayload>;
  gh_UpdateLabelInput: gh_UpdateLabelInput;
  gh_UpdateLabelPayload: ResolverTypeWrapper<gh_UpdateLabelPayload>;
  gh_UpdateNotificationRestrictionSettingInput: gh_UpdateNotificationRestrictionSettingInput;
  gh_UpdateNotificationRestrictionSettingPayload: ResolverTypeWrapper<Omit<gh_UpdateNotificationRestrictionSettingPayload, 'owner'> & { owner?: Maybe<ResolversTypes['gh_VerifiableDomainOwner']> }>;
  gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput: gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
  gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload: ResolverTypeWrapper<gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload>;
  gh_UpdateOrganizationWebCommitSignoffSettingInput: gh_UpdateOrganizationWebCommitSignoffSettingInput;
  gh_UpdateOrganizationWebCommitSignoffSettingPayload: ResolverTypeWrapper<gh_UpdateOrganizationWebCommitSignoffSettingPayload>;
  gh_UpdateParameters: ResolverTypeWrapper<gh_UpdateParameters>;
  gh_UpdateParametersInput: gh_UpdateParametersInput;
  gh_UpdatePatreonSponsorabilityInput: gh_UpdatePatreonSponsorabilityInput;
  gh_UpdatePatreonSponsorabilityPayload: ResolverTypeWrapper<gh_UpdatePatreonSponsorabilityPayload>;
  gh_UpdateProjectCardInput: gh_UpdateProjectCardInput;
  gh_UpdateProjectCardPayload: ResolverTypeWrapper<gh_UpdateProjectCardPayload>;
  gh_UpdateProjectColumnInput: gh_UpdateProjectColumnInput;
  gh_UpdateProjectColumnPayload: ResolverTypeWrapper<gh_UpdateProjectColumnPayload>;
  gh_UpdateProjectInput: gh_UpdateProjectInput;
  gh_UpdateProjectPayload: ResolverTypeWrapper<gh_UpdateProjectPayload>;
  gh_UpdateProjectV2CollaboratorsInput: gh_UpdateProjectV2CollaboratorsInput;
  gh_UpdateProjectV2CollaboratorsPayload: ResolverTypeWrapper<gh_UpdateProjectV2CollaboratorsPayload>;
  gh_UpdateProjectV2DraftIssueInput: gh_UpdateProjectV2DraftIssueInput;
  gh_UpdateProjectV2DraftIssuePayload: ResolverTypeWrapper<gh_UpdateProjectV2DraftIssuePayload>;
  gh_UpdateProjectV2Input: gh_UpdateProjectV2Input;
  gh_UpdateProjectV2ItemFieldValueInput: gh_UpdateProjectV2ItemFieldValueInput;
  gh_UpdateProjectV2ItemFieldValuePayload: ResolverTypeWrapper<gh_UpdateProjectV2ItemFieldValuePayload>;
  gh_UpdateProjectV2ItemPositionInput: gh_UpdateProjectV2ItemPositionInput;
  gh_UpdateProjectV2ItemPositionPayload: ResolverTypeWrapper<gh_UpdateProjectV2ItemPositionPayload>;
  gh_UpdateProjectV2Payload: ResolverTypeWrapper<gh_UpdateProjectV2Payload>;
  gh_UpdatePullRequestBranchInput: gh_UpdatePullRequestBranchInput;
  gh_UpdatePullRequestBranchPayload: ResolverTypeWrapper<gh_UpdatePullRequestBranchPayload>;
  gh_UpdatePullRequestInput: gh_UpdatePullRequestInput;
  gh_UpdatePullRequestPayload: ResolverTypeWrapper<gh_UpdatePullRequestPayload>;
  gh_UpdatePullRequestReviewCommentInput: gh_UpdatePullRequestReviewCommentInput;
  gh_UpdatePullRequestReviewCommentPayload: ResolverTypeWrapper<gh_UpdatePullRequestReviewCommentPayload>;
  gh_UpdatePullRequestReviewInput: gh_UpdatePullRequestReviewInput;
  gh_UpdatePullRequestReviewPayload: ResolverTypeWrapper<gh_UpdatePullRequestReviewPayload>;
  gh_UpdateRefInput: gh_UpdateRefInput;
  gh_UpdateRefPayload: ResolverTypeWrapper<gh_UpdateRefPayload>;
  gh_UpdateRefsInput: gh_UpdateRefsInput;
  gh_UpdateRefsPayload: ResolverTypeWrapper<gh_UpdateRefsPayload>;
  gh_UpdateRepositoryInput: gh_UpdateRepositoryInput;
  gh_UpdateRepositoryPayload: ResolverTypeWrapper<gh_UpdateRepositoryPayload>;
  gh_UpdateRepositoryRulesetInput: gh_UpdateRepositoryRulesetInput;
  gh_UpdateRepositoryRulesetPayload: ResolverTypeWrapper<gh_UpdateRepositoryRulesetPayload>;
  gh_UpdateRepositoryWebCommitSignoffSettingInput: gh_UpdateRepositoryWebCommitSignoffSettingInput;
  gh_UpdateRepositoryWebCommitSignoffSettingPayload: ResolverTypeWrapper<gh_UpdateRepositoryWebCommitSignoffSettingPayload>;
  gh_UpdateSponsorshipPreferencesInput: gh_UpdateSponsorshipPreferencesInput;
  gh_UpdateSponsorshipPreferencesPayload: ResolverTypeWrapper<gh_UpdateSponsorshipPreferencesPayload>;
  gh_UpdateSubscriptionInput: gh_UpdateSubscriptionInput;
  gh_UpdateSubscriptionPayload: ResolverTypeWrapper<gh_UpdateSubscriptionPayload>;
  gh_UpdateTeamDiscussionCommentInput: gh_UpdateTeamDiscussionCommentInput;
  gh_UpdateTeamDiscussionCommentPayload: ResolverTypeWrapper<gh_UpdateTeamDiscussionCommentPayload>;
  gh_UpdateTeamDiscussionInput: gh_UpdateTeamDiscussionInput;
  gh_UpdateTeamDiscussionPayload: ResolverTypeWrapper<gh_UpdateTeamDiscussionPayload>;
  gh_UpdateTeamReviewAssignmentInput: gh_UpdateTeamReviewAssignmentInput;
  gh_UpdateTeamReviewAssignmentPayload: ResolverTypeWrapper<gh_UpdateTeamReviewAssignmentPayload>;
  gh_UpdateTeamsRepositoryInput: gh_UpdateTeamsRepositoryInput;
  gh_UpdateTeamsRepositoryPayload: ResolverTypeWrapper<gh_UpdateTeamsRepositoryPayload>;
  gh_UpdateTopicsInput: gh_UpdateTopicsInput;
  gh_UpdateTopicsPayload: ResolverTypeWrapper<gh_UpdateTopicsPayload>;
  gh_UpdateUserListInput: gh_UpdateUserListInput;
  gh_UpdateUserListPayload: ResolverTypeWrapper<gh_UpdateUserListPayload>;
  gh_UpdateUserListsForItemInput: gh_UpdateUserListsForItemInput;
  gh_UpdateUserListsForItemPayload: ResolverTypeWrapper<Omit<gh_UpdateUserListsForItemPayload, 'item'> & { item?: Maybe<ResolversTypes['gh_UserListItems']> }>;
  gh_User: ResolverTypeWrapper<gh_User>;
  gh_UserBlockDuration: gh_UserBlockDuration;
  gh_UserBlockedEvent: ResolverTypeWrapper<gh_UserBlockedEvent>;
  gh_UserConnection: ResolverTypeWrapper<gh_UserConnection>;
  gh_UserContentEdit: ResolverTypeWrapper<gh_UserContentEdit>;
  gh_UserContentEditConnection: ResolverTypeWrapper<gh_UserContentEditConnection>;
  gh_UserContentEditEdge: ResolverTypeWrapper<gh_UserContentEditEdge>;
  gh_UserEdge: ResolverTypeWrapper<gh_UserEdge>;
  gh_UserEmailMetadata: ResolverTypeWrapper<gh_UserEmailMetadata>;
  gh_UserList: ResolverTypeWrapper<gh_UserList>;
  gh_UserListConnection: ResolverTypeWrapper<gh_UserListConnection>;
  gh_UserListEdge: ResolverTypeWrapper<gh_UserListEdge>;
  gh_UserListItems: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_UserListItems']>;
  gh_UserListItemsConnection: ResolverTypeWrapper<Omit<gh_UserListItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['gh_UserListItems']>>> }>;
  gh_UserListItemsEdge: ResolverTypeWrapper<Omit<gh_UserListItemsEdge, 'node'> & { node?: Maybe<ResolversTypes['gh_UserListItems']> }>;
  gh_UserListSuggestion: ResolverTypeWrapper<gh_UserListSuggestion>;
  gh_UserStatus: ResolverTypeWrapper<gh_UserStatus>;
  gh_UserStatusConnection: ResolverTypeWrapper<gh_UserStatusConnection>;
  gh_UserStatusEdge: ResolverTypeWrapper<gh_UserStatusEdge>;
  gh_UserStatusOrder: gh_UserStatusOrder;
  gh_UserStatusOrderField: gh_UserStatusOrderField;
  gh_VerifiableDomain: ResolverTypeWrapper<Omit<gh_VerifiableDomain, 'owner'> & { owner: ResolversTypes['gh_VerifiableDomainOwner'] }>;
  gh_VerifiableDomainConnection: ResolverTypeWrapper<gh_VerifiableDomainConnection>;
  gh_VerifiableDomainEdge: ResolverTypeWrapper<gh_VerifiableDomainEdge>;
  gh_VerifiableDomainOrder: gh_VerifiableDomainOrder;
  gh_VerifiableDomainOrderField: gh_VerifiableDomainOrderField;
  gh_VerifiableDomainOwner: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['gh_VerifiableDomainOwner']>;
  gh_VerifyVerifiableDomainInput: gh_VerifyVerifiableDomainInput;
  gh_VerifyVerifiableDomainPayload: ResolverTypeWrapper<gh_VerifyVerifiableDomainPayload>;
  gh_ViewerHovercardContext: ResolverTypeWrapper<gh_ViewerHovercardContext>;
  gh_Votable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['gh_Votable']>;
  gh_Workflow: ResolverTypeWrapper<gh_Workflow>;
  gh_WorkflowFileReference: ResolverTypeWrapper<gh_WorkflowFileReference>;
  gh_WorkflowFileReferenceInput: gh_WorkflowFileReferenceInput;
  gh_WorkflowRun: ResolverTypeWrapper<gh_WorkflowRun>;
  gh_WorkflowRunConnection: ResolverTypeWrapper<gh_WorkflowRunConnection>;
  gh_WorkflowRunEdge: ResolverTypeWrapper<gh_WorkflowRunEdge>;
  gh_WorkflowRunFile: ResolverTypeWrapper<gh_WorkflowRunFile>;
  gh_WorkflowRunOrder: gh_WorkflowRunOrder;
  gh_WorkflowRunOrderField: gh_WorkflowRunOrderField;
  gh_WorkflowState: gh_WorkflowState;
  gh_WorkflowsParameters: ResolverTypeWrapper<gh_WorkflowsParameters>;
  gh_WorkflowsParametersInput: gh_WorkflowsParametersInput;
  gh_X509Certificate: ResolverTypeWrapper<Scalars['gh_X509Certificate']['output']>;
  GithubQuery: ResolverTypeWrapper<GithubQuery>;
  GithubMutation: ResolverTypeWrapper<GithubMutation>;
  hn_ObjectId: ResolverTypeWrapper<Scalars['hn_ObjectId']['output']>;
  hn_Scope: hn_Scope;
  hn_SortOrder: hn_SortOrder;
  hn_Node: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['hn_Node']>;
  hn_Connection: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['hn_Connection']>;
  hn_Edge: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['hn_Edge']>;
  hn_PageConnection: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['hn_PageConnection']>;
  hn_Feature: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['hn_Feature']>;
  hn_PageInfo: ResolverTypeWrapper<hn_PageInfo>;
  hn_OffsetPageInfo: ResolverTypeWrapper<hn_OffsetPageInfo>;
  hn_Content: ResolverTypeWrapper<hn_Content>;
  hn_SEO: ResolverTypeWrapper<hn_SEO>;
  hn_OpenGraphMetaData: ResolverTypeWrapper<hn_OpenGraphMetaData>;
  hn_UserConnection: ResolverTypeWrapper<hn_UserConnection>;
  hn_IUser: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['hn_IUser']>;
  hn_User: ResolverTypeWrapper<hn_User>;
  hn_MyUser: ResolverTypeWrapper<hn_MyUser>;
  hn_UserPublicationsConnection: ResolverTypeWrapper<hn_UserPublicationsConnection>;
  hn_UserPublicationsEdge: ResolverTypeWrapper<hn_UserPublicationsEdge>;
  hn_UserPublicationRole: hn_UserPublicationRole;
  hn_SocialMediaLinks: ResolverTypeWrapper<hn_SocialMediaLinks>;
  hn_Badge: ResolverTypeWrapper<hn_Badge>;
  hn_UserPublicationsConnectionFilter: hn_UserPublicationsConnectionFilter;
  hn_ToggleFollowUserPayload: ResolverTypeWrapper<hn_ToggleFollowUserPayload>;
  hn_CommenterUserConnection: ResolverTypeWrapper<hn_CommenterUserConnection>;
  hn_UserEdge: ResolverTypeWrapper<hn_UserEdge>;
  hn_UserPostsAuthorTypeFilter: hn_UserPostsAuthorTypeFilter;
  hn_UserPostsSort: hn_UserPostsSort;
  hn_UserPostConnectionFilter: hn_UserPostConnectionFilter;
  hn_ITag: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['hn_ITag']>;
  hn_Tag: ResolverTypeWrapper<hn_Tag>;
  hn_PopularTag: ResolverTypeWrapper<hn_PopularTag>;
  hn_TagPostsSort: hn_TagPostsSort;
  hn_TagPostConnectionFilter: hn_TagPostConnectionFilter;
  hn_PopularTagEdge: ResolverTypeWrapper<hn_PopularTagEdge>;
  hn_TagEdge: ResolverTypeWrapper<hn_TagEdge>;
  hn_Publication: ResolverTypeWrapper<hn_Publication>;
  hn_UserRecommendedPublicationEdge: ResolverTypeWrapper<hn_UserRecommendedPublicationEdge>;
  hn_PublicationUserRecommendingPublicationConnection: ResolverTypeWrapper<hn_PublicationUserRecommendingPublicationConnection>;
  hn_UserRecommendingPublicationEdge: ResolverTypeWrapper<hn_UserRecommendingPublicationEdge>;
  hn_RSSImport: ResolverTypeWrapper<hn_RSSImport>;
  hn_PublicationSponsorship: ResolverTypeWrapper<hn_PublicationSponsorship>;
  hn_StripeConfiguration: ResolverTypeWrapper<hn_StripeConfiguration>;
  hn_RedirectionRule: ResolverTypeWrapper<hn_RedirectionRule>;
  hn_HttpRedirectionType: hn_HttpRedirectionType;
  hn_PublicationPostConnectionFilter: hn_PublicationPostConnectionFilter;
  hn_PublicationDraftConnectionFilter: hn_PublicationDraftConnectionFilter;
  hn_PublicationFeatures: ResolverTypeWrapper<hn_PublicationFeatures>;
  hn_NewsletterFeature: ResolverTypeWrapper<hn_NewsletterFeature>;
  hn_NewsletterFrequency: hn_NewsletterFrequency;
  hn_ViewCountFeature: ResolverTypeWrapper<hn_ViewCountFeature>;
  hn_ReadTimeFeature: ResolverTypeWrapper<hn_ReadTimeFeature>;
  hn_AudioBlogFeature: ResolverTypeWrapper<hn_AudioBlogFeature>;
  hn_TextSelectionSharerFeature: ResolverTypeWrapper<hn_TextSelectionSharerFeature>;
  hn_CustomCSSFeature: ResolverTypeWrapper<hn_CustomCSSFeature>;
  hn_CustomCSS: ResolverTypeWrapper<hn_CustomCSS>;
  hn_UrlPattern: hn_UrlPattern;
  hn_PublicationLayout: hn_PublicationLayout;
  hn_DomainInfo: ResolverTypeWrapper<hn_DomainInfo>;
  hn_DomainStatus: ResolverTypeWrapper<hn_DomainStatus>;
  hn_Preferences: ResolverTypeWrapper<hn_Preferences>;
  hn_PublicationNavbarItem: ResolverTypeWrapper<hn_PublicationNavbarItem>;
  hn_PublicationNavigationType: hn_PublicationNavigationType;
  hn_PagesPreferences: ResolverTypeWrapper<hn_PagesPreferences>;
  hn_DarkModePreferences: ResolverTypeWrapper<hn_DarkModePreferences>;
  hn_PublicationIntegrations: ResolverTypeWrapper<hn_PublicationIntegrations>;
  hn_PublicationLinks: ResolverTypeWrapper<hn_PublicationLinks>;
  hn_AudioBlogVoiceType: hn_AudioBlogVoiceType;
  hn_EmailImportStatus: hn_EmailImportStatus;
  hn_EmailImport: ResolverTypeWrapper<hn_EmailImport>;
  hn_EmailCurrentImport: ResolverTypeWrapper<hn_EmailCurrentImport>;
  hn_RecommendedPublicationEdge: ResolverTypeWrapper<hn_RecommendedPublicationEdge>;
  hn_SubscribeToNewsletterInput: hn_SubscribeToNewsletterInput;
  hn_UnsubscribeFromNewsletterInput: hn_UnsubscribeFromNewsletterInput;
  hn_NewsletterSubscribeStatus: hn_NewsletterSubscribeStatus;
  hn_SubscribeToNewsletterPayload: ResolverTypeWrapper<hn_SubscribeToNewsletterPayload>;
  hn_NewsletterUnsubscribeStatus: hn_NewsletterUnsubscribeStatus;
  hn_UnsubscribeFromNewsletterPayload: ResolverTypeWrapper<hn_UnsubscribeFromNewsletterPayload>;
  hn_Post: ResolverTypeWrapper<hn_Post>;
  hn_PostFeatures: ResolverTypeWrapper<hn_PostFeatures>;
  hn_TableOfContentsFeature: ResolverTypeWrapper<hn_TableOfContentsFeature>;
  hn_PostBadgesFeature: ResolverTypeWrapper<hn_PostBadgesFeature>;
  hn_TableOfContentsItem: ResolverTypeWrapper<hn_TableOfContentsItem>;
  hn_PostBadge: ResolverTypeWrapper<hn_PostBadge>;
  hn_PostBadgeType: hn_PostBadgeType;
  hn_PostLikerFilter: hn_PostLikerFilter;
  hn_AudioUrls: ResolverTypeWrapper<hn_AudioUrls>;
  hn_PostPreferences: ResolverTypeWrapper<hn_PostPreferences>;
  hn_PostCommenterSortBy: hn_PostCommenterSortBy;
  hn_PostCommenterConnection: ResolverTypeWrapper<hn_PostCommenterConnection>;
  hn_PostCommenterEdge: ResolverTypeWrapper<hn_PostCommenterEdge>;
  hn_PostCommentSortBy: hn_PostCommentSortBy;
  hn_PostCommentConnection: ResolverTypeWrapper<hn_PostCommentConnection>;
  hn_PostCommentEdge: ResolverTypeWrapper<hn_PostCommentEdge>;
  hn_PostLikerEdge: ResolverTypeWrapper<hn_PostLikerEdge>;
  hn_PostLikerConnection: ResolverTypeWrapper<hn_PostLikerConnection>;
  hn_PostCoverImage: ResolverTypeWrapper<hn_PostCoverImage>;
  hn_PostEdge: ResolverTypeWrapper<hn_PostEdge>;
  hn_PostAuthorType: hn_PostAuthorType;
  hn_UserPostEdge: ResolverTypeWrapper<hn_UserPostEdge>;
  hn_FeedPostConnection: ResolverTypeWrapper<hn_FeedPostConnection>;
  hn_SearchPostConnection: ResolverTypeWrapper<hn_SearchPostConnection>;
  hn_SeriesPostConnection: ResolverTypeWrapper<hn_SeriesPostConnection>;
  hn_PublicationPostConnection: ResolverTypeWrapper<hn_PublicationPostConnection>;
  hn_UserPostConnection: ResolverTypeWrapper<hn_UserPostConnection>;
  hn_PublishPostPayload: ResolverTypeWrapper<hn_PublishPostPayload>;
  hn_UpdatePostPayload: ResolverTypeWrapper<hn_UpdatePostPayload>;
  hn_RemovePostPayload: ResolverTypeWrapper<hn_RemovePostPayload>;
  hn_RemovePostInput: hn_RemovePostInput;
  hn_CoverImageOptionsInput: hn_CoverImageOptionsInput;
  hn_MetaTagsInput: hn_MetaTagsInput;
  hn_PublishPostTagInput: hn_PublishPostTagInput;
  hn_UpdatePostSettingsInput: hn_UpdatePostSettingsInput;
  hn_PublishPostSettingsInput: hn_PublishPostSettingsInput;
  hn_PublishPostInput: hn_PublishPostInput;
  hn_UpdatePostInput: hn_UpdatePostInput;
  hn_AddPostToSeriesInput: hn_AddPostToSeriesInput;
  hn_AddPostToSeriesPayload: ResolverTypeWrapper<hn_AddPostToSeriesPayload>;
  hn_FeedType: hn_FeedType;
  hn_FeedFilter: hn_FeedFilter;
  hn_SearchPostsOfPublicationFilter: hn_SearchPostsOfPublicationFilter;
  hn_Comment: ResolverTypeWrapper<hn_Comment>;
  hn_CommentReplyConnection: ResolverTypeWrapper<hn_CommentReplyConnection>;
  hn_CommentReplyEdge: ResolverTypeWrapper<hn_CommentReplyEdge>;
  hn_Reply: ResolverTypeWrapper<hn_Reply>;
  hn_Series: ResolverTypeWrapper<hn_Series>;
  hn_SeriesEdge: ResolverTypeWrapper<hn_SeriesEdge>;
  hn_SeriesConnection: ResolverTypeWrapper<hn_SeriesConnection>;
  hn_Draft: ResolverTypeWrapper<hn_Draft>;
  hn_DraftSettings: ResolverTypeWrapper<hn_DraftSettings>;
  hn_DraftFeatures: ResolverTypeWrapper<hn_DraftFeatures>;
  hn_DraftBackup: ResolverTypeWrapper<hn_DraftBackup>;
  hn_BackupStatus: hn_BackupStatus;
  hn_DraftConnection: ResolverTypeWrapper<hn_DraftConnection>;
  hn_DraftCoverImage: ResolverTypeWrapper<hn_DraftCoverImage>;
  hn_DraftEdge: ResolverTypeWrapper<hn_DraftEdge>;
  hn_BetaFeature: ResolverTypeWrapper<hn_BetaFeature>;
  hn_ScheduledPost: ResolverTypeWrapper<hn_ScheduledPost>;
  hn_ReschedulePostInput: hn_ReschedulePostInput;
  hn_ScheduledPostPayload: ResolverTypeWrapper<hn_ScheduledPostPayload>;
  hn_StaticPage: ResolverTypeWrapper<hn_StaticPage>;
  hn_StaticPageConnection: ResolverTypeWrapper<hn_StaticPageConnection>;
  hn_StaticPageEdge: ResolverTypeWrapper<hn_StaticPageEdge>;
  hn_Webhook: ResolverTypeWrapper<hn_Webhook>;
  hn_WebhookEvent: hn_WebhookEvent;
  hn_WebhookMessageConnection: ResolverTypeWrapper<hn_WebhookMessageConnection>;
  hn_WebhookMessageEdge: ResolverTypeWrapper<hn_WebhookMessageEdge>;
  hn_WebhookMessage: ResolverTypeWrapper<hn_WebhookMessage>;
  hn_WebhookMessageRequest: ResolverTypeWrapper<hn_WebhookMessageRequest>;
  hn_WebhookMessageRequestError: ResolverTypeWrapper<hn_WebhookMessageRequestError>;
  hn_WebhookMessageResponse: ResolverTypeWrapper<hn_WebhookMessageResponse>;
  HashnodeQuery: ResolverTypeWrapper<HashnodeQuery>;
  HashnodeMutation: ResolverTypeWrapper<HashnodeMutation>;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  Query: {};
  Mutation: {};
  gh_AbortQueuedMigrationsInput: gh_AbortQueuedMigrationsInput;
  String: Scalars['String']['output'];
  ID: Scalars['ID']['output'];
  gh_AbortQueuedMigrationsPayload: gh_AbortQueuedMigrationsPayload;
  Boolean: Scalars['Boolean']['output'];
  gh_AbortRepositoryMigrationInput: gh_AbortRepositoryMigrationInput;
  gh_AbortRepositoryMigrationPayload: gh_AbortRepositoryMigrationPayload;
  gh_AcceptEnterpriseAdministratorInvitationInput: gh_AcceptEnterpriseAdministratorInvitationInput;
  gh_AcceptEnterpriseAdministratorInvitationPayload: gh_AcceptEnterpriseAdministratorInvitationPayload;
  gh_AcceptTopicSuggestionInput: gh_AcceptTopicSuggestionInput;
  gh_AcceptTopicSuggestionPayload: gh_AcceptTopicSuggestionPayload;
  gh_Actor: ResolversInterfaceTypes<ResolversParentTypes>['gh_Actor'];
  Int: Scalars['Int']['output'];
  gh_ActorLocation: gh_ActorLocation;
  gh_AddAssigneesToAssignableInput: gh_AddAssigneesToAssignableInput;
  gh_AddAssigneesToAssignablePayload: gh_AddAssigneesToAssignablePayload;
  gh_AddCommentInput: gh_AddCommentInput;
  gh_AddCommentPayload: gh_AddCommentPayload;
  gh_AddDiscussionCommentInput: gh_AddDiscussionCommentInput;
  gh_AddDiscussionCommentPayload: gh_AddDiscussionCommentPayload;
  gh_AddDiscussionPollVoteInput: gh_AddDiscussionPollVoteInput;
  gh_AddDiscussionPollVotePayload: gh_AddDiscussionPollVotePayload;
  gh_AddEnterpriseOrganizationMemberInput: gh_AddEnterpriseOrganizationMemberInput;
  gh_AddEnterpriseOrganizationMemberPayload: gh_AddEnterpriseOrganizationMemberPayload;
  gh_AddEnterpriseSupportEntitlementInput: gh_AddEnterpriseSupportEntitlementInput;
  gh_AddEnterpriseSupportEntitlementPayload: gh_AddEnterpriseSupportEntitlementPayload;
  gh_AddLabelsToLabelableInput: gh_AddLabelsToLabelableInput;
  gh_AddLabelsToLabelablePayload: gh_AddLabelsToLabelablePayload;
  gh_AddProjectCardInput: gh_AddProjectCardInput;
  gh_AddProjectCardPayload: gh_AddProjectCardPayload;
  gh_AddProjectColumnInput: gh_AddProjectColumnInput;
  gh_AddProjectColumnPayload: gh_AddProjectColumnPayload;
  gh_AddProjectV2DraftIssueInput: gh_AddProjectV2DraftIssueInput;
  gh_AddProjectV2DraftIssuePayload: gh_AddProjectV2DraftIssuePayload;
  gh_AddProjectV2ItemByIdInput: gh_AddProjectV2ItemByIdInput;
  gh_AddProjectV2ItemByIdPayload: gh_AddProjectV2ItemByIdPayload;
  gh_AddPullRequestReviewCommentInput: gh_AddPullRequestReviewCommentInput;
  gh_AddPullRequestReviewCommentPayload: gh_AddPullRequestReviewCommentPayload;
  gh_AddPullRequestReviewInput: gh_AddPullRequestReviewInput;
  gh_AddPullRequestReviewPayload: gh_AddPullRequestReviewPayload;
  gh_AddPullRequestReviewThreadInput: gh_AddPullRequestReviewThreadInput;
  gh_AddPullRequestReviewThreadPayload: gh_AddPullRequestReviewThreadPayload;
  gh_AddPullRequestReviewThreadReplyInput: gh_AddPullRequestReviewThreadReplyInput;
  gh_AddPullRequestReviewThreadReplyPayload: gh_AddPullRequestReviewThreadReplyPayload;
  gh_AddReactionInput: gh_AddReactionInput;
  gh_AddReactionPayload: gh_AddReactionPayload;
  gh_AddStarInput: gh_AddStarInput;
  gh_AddStarPayload: gh_AddStarPayload;
  gh_AddUpvoteInput: gh_AddUpvoteInput;
  gh_AddUpvotePayload: gh_AddUpvotePayload;
  gh_AddVerifiableDomainInput: gh_AddVerifiableDomainInput;
  gh_AddVerifiableDomainPayload: gh_AddVerifiableDomainPayload;
  gh_AddedToMergeQueueEvent: gh_AddedToMergeQueueEvent;
  gh_AddedToProjectEvent: gh_AddedToProjectEvent;
  gh_AnnouncementBanner: ResolversInterfaceTypes<ResolversParentTypes>['gh_AnnouncementBanner'];
  gh_App: gh_App;
  gh_ApproveDeploymentsInput: gh_ApproveDeploymentsInput;
  gh_ApproveDeploymentsPayload: gh_ApproveDeploymentsPayload;
  gh_ApproveVerifiableDomainInput: gh_ApproveVerifiableDomainInput;
  gh_ApproveVerifiableDomainPayload: gh_ApproveVerifiableDomainPayload;
  gh_ArchiveProjectV2ItemInput: gh_ArchiveProjectV2ItemInput;
  gh_ArchiveProjectV2ItemPayload: gh_ArchiveProjectV2ItemPayload;
  gh_ArchiveRepositoryInput: gh_ArchiveRepositoryInput;
  gh_ArchiveRepositoryPayload: gh_ArchiveRepositoryPayload;
  gh_Assignable: ResolversInterfaceTypes<ResolversParentTypes>['gh_Assignable'];
  gh_AssignedEvent: Omit<gh_AssignedEvent, 'assignee'> & { assignee?: Maybe<ResolversParentTypes['gh_Assignee']> };
  gh_Assignee: ResolversUnionTypes<ResolversParentTypes>['gh_Assignee'];
  gh_AuditEntry: ResolversInterfaceTypes<ResolversParentTypes>['gh_AuditEntry'];
  gh_AuditEntryActor: ResolversUnionTypes<ResolversParentTypes>['gh_AuditEntryActor'];
  gh_AuditLogOrder: gh_AuditLogOrder;
  gh_AutoMergeDisabledEvent: gh_AutoMergeDisabledEvent;
  gh_AutoMergeEnabledEvent: gh_AutoMergeEnabledEvent;
  gh_AutoMergeRequest: gh_AutoMergeRequest;
  gh_AutoRebaseEnabledEvent: gh_AutoRebaseEnabledEvent;
  gh_AutoSquashEnabledEvent: gh_AutoSquashEnabledEvent;
  gh_AutomaticBaseChangeFailedEvent: gh_AutomaticBaseChangeFailedEvent;
  gh_AutomaticBaseChangeSucceededEvent: gh_AutomaticBaseChangeSucceededEvent;
  gh_Base64String: Scalars['gh_Base64String']['output'];
  gh_BaseRefChangedEvent: gh_BaseRefChangedEvent;
  gh_BaseRefDeletedEvent: gh_BaseRefDeletedEvent;
  gh_BaseRefForcePushedEvent: gh_BaseRefForcePushedEvent;
  BigInt: Scalars['BigInt']['output'];
  gh_Blame: gh_Blame;
  gh_BlameRange: gh_BlameRange;
  gh_Blob: gh_Blob;
  gh_Bot: gh_Bot;
  gh_BranchActorAllowanceActor: ResolversUnionTypes<ResolversParentTypes>['gh_BranchActorAllowanceActor'];
  gh_BranchNamePatternParameters: gh_BranchNamePatternParameters;
  gh_BranchNamePatternParametersInput: gh_BranchNamePatternParametersInput;
  gh_BranchProtectionRule: gh_BranchProtectionRule;
  gh_BranchProtectionRuleConflict: gh_BranchProtectionRuleConflict;
  gh_BranchProtectionRuleConflictConnection: gh_BranchProtectionRuleConflictConnection;
  gh_BranchProtectionRuleConflictEdge: gh_BranchProtectionRuleConflictEdge;
  gh_BranchProtectionRuleConnection: gh_BranchProtectionRuleConnection;
  gh_BranchProtectionRuleEdge: gh_BranchProtectionRuleEdge;
  gh_BulkSponsorship: gh_BulkSponsorship;
  gh_BypassActor: ResolversUnionTypes<ResolversParentTypes>['gh_BypassActor'];
  gh_BypassForcePushAllowance: Omit<gh_BypassForcePushAllowance, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_BranchActorAllowanceActor']> };
  gh_BypassForcePushAllowanceConnection: gh_BypassForcePushAllowanceConnection;
  gh_BypassForcePushAllowanceEdge: gh_BypassForcePushAllowanceEdge;
  gh_BypassPullRequestAllowance: Omit<gh_BypassPullRequestAllowance, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_BranchActorAllowanceActor']> };
  gh_BypassPullRequestAllowanceConnection: gh_BypassPullRequestAllowanceConnection;
  gh_BypassPullRequestAllowanceEdge: gh_BypassPullRequestAllowanceEdge;
  gh_CVSS: gh_CVSS;
  Float: Scalars['Float']['output'];
  gh_CWE: gh_CWE;
  gh_CWEConnection: gh_CWEConnection;
  gh_CWEEdge: gh_CWEEdge;
  gh_CancelEnterpriseAdminInvitationInput: gh_CancelEnterpriseAdminInvitationInput;
  gh_CancelEnterpriseAdminInvitationPayload: gh_CancelEnterpriseAdminInvitationPayload;
  gh_CancelSponsorshipInput: gh_CancelSponsorshipInput;
  gh_CancelSponsorshipPayload: gh_CancelSponsorshipPayload;
  gh_ChangeUserStatusInput: gh_ChangeUserStatusInput;
  gh_ChangeUserStatusPayload: gh_ChangeUserStatusPayload;
  gh_CheckAnnotation: gh_CheckAnnotation;
  gh_CheckAnnotationConnection: gh_CheckAnnotationConnection;
  gh_CheckAnnotationData: gh_CheckAnnotationData;
  gh_CheckAnnotationEdge: gh_CheckAnnotationEdge;
  gh_CheckAnnotationPosition: gh_CheckAnnotationPosition;
  gh_CheckAnnotationRange: gh_CheckAnnotationRange;
  gh_CheckAnnotationSpan: gh_CheckAnnotationSpan;
  gh_CheckRun: gh_CheckRun;
  gh_CheckRunAction: gh_CheckRunAction;
  gh_CheckRunConnection: gh_CheckRunConnection;
  gh_CheckRunEdge: gh_CheckRunEdge;
  gh_CheckRunFilter: gh_CheckRunFilter;
  gh_CheckRunOutput: gh_CheckRunOutput;
  gh_CheckRunOutputImage: gh_CheckRunOutputImage;
  gh_CheckRunStateCount: gh_CheckRunStateCount;
  gh_CheckStep: gh_CheckStep;
  gh_CheckStepConnection: gh_CheckStepConnection;
  gh_CheckStepEdge: gh_CheckStepEdge;
  gh_CheckSuite: gh_CheckSuite;
  gh_CheckSuiteAutoTriggerPreference: gh_CheckSuiteAutoTriggerPreference;
  gh_CheckSuiteConnection: gh_CheckSuiteConnection;
  gh_CheckSuiteEdge: gh_CheckSuiteEdge;
  gh_CheckSuiteFilter: gh_CheckSuiteFilter;
  gh_Claimable: ResolversUnionTypes<ResolversParentTypes>['gh_Claimable'];
  gh_ClearLabelsFromLabelableInput: gh_ClearLabelsFromLabelableInput;
  gh_ClearLabelsFromLabelablePayload: gh_ClearLabelsFromLabelablePayload;
  gh_ClearProjectV2ItemFieldValueInput: gh_ClearProjectV2ItemFieldValueInput;
  gh_ClearProjectV2ItemFieldValuePayload: gh_ClearProjectV2ItemFieldValuePayload;
  gh_CloneProjectInput: gh_CloneProjectInput;
  gh_CloneProjectPayload: gh_CloneProjectPayload;
  gh_CloneTemplateRepositoryInput: gh_CloneTemplateRepositoryInput;
  gh_CloneTemplateRepositoryPayload: gh_CloneTemplateRepositoryPayload;
  gh_Closable: ResolversInterfaceTypes<ResolversParentTypes>['gh_Closable'];
  gh_CloseDiscussionInput: gh_CloseDiscussionInput;
  gh_CloseDiscussionPayload: gh_CloseDiscussionPayload;
  gh_CloseIssueInput: gh_CloseIssueInput;
  gh_CloseIssuePayload: gh_CloseIssuePayload;
  gh_ClosePullRequestInput: gh_ClosePullRequestInput;
  gh_ClosePullRequestPayload: gh_ClosePullRequestPayload;
  gh_ClosedEvent: Omit<gh_ClosedEvent, 'closer'> & { closer?: Maybe<ResolversParentTypes['gh_Closer']> };
  gh_Closer: ResolversUnionTypes<ResolversParentTypes>['gh_Closer'];
  gh_CodeOfConduct: gh_CodeOfConduct;
  gh_Comment: ResolversInterfaceTypes<ResolversParentTypes>['gh_Comment'];
  gh_CommentDeletedEvent: gh_CommentDeletedEvent;
  gh_Commit: gh_Commit;
  gh_CommitAuthor: gh_CommitAuthor;
  gh_CommitAuthorEmailPatternParameters: gh_CommitAuthorEmailPatternParameters;
  gh_CommitAuthorEmailPatternParametersInput: gh_CommitAuthorEmailPatternParametersInput;
  gh_CommitComment: gh_CommitComment;
  gh_CommitCommentConnection: gh_CommitCommentConnection;
  gh_CommitCommentEdge: gh_CommitCommentEdge;
  gh_CommitCommentThread: gh_CommitCommentThread;
  gh_CommitConnection: gh_CommitConnection;
  gh_CommitContributionOrder: gh_CommitContributionOrder;
  gh_CommitContributionsByRepository: gh_CommitContributionsByRepository;
  gh_CommitEdge: gh_CommitEdge;
  gh_CommitHistoryConnection: gh_CommitHistoryConnection;
  gh_CommitMessage: gh_CommitMessage;
  gh_CommitMessagePatternParameters: gh_CommitMessagePatternParameters;
  gh_CommitMessagePatternParametersInput: gh_CommitMessagePatternParametersInput;
  gh_CommittableBranch: gh_CommittableBranch;
  gh_CommitterEmailPatternParameters: gh_CommitterEmailPatternParameters;
  gh_CommitterEmailPatternParametersInput: gh_CommitterEmailPatternParametersInput;
  gh_Comparison: gh_Comparison;
  gh_ComparisonCommitConnection: gh_ComparisonCommitConnection;
  gh_ConnectedEvent: Omit<gh_ConnectedEvent, 'source' | 'subject'> & { source: ResolversParentTypes['gh_ReferencedSubject'], subject: ResolversParentTypes['gh_ReferencedSubject'] };
  gh_ContributingGuidelines: gh_ContributingGuidelines;
  gh_Contribution: ResolversInterfaceTypes<ResolversParentTypes>['gh_Contribution'];
  gh_ContributionCalendar: gh_ContributionCalendar;
  gh_ContributionCalendarDay: gh_ContributionCalendarDay;
  gh_ContributionCalendarMonth: gh_ContributionCalendarMonth;
  gh_ContributionCalendarWeek: gh_ContributionCalendarWeek;
  gh_ContributionOrder: gh_ContributionOrder;
  gh_ContributionsCollection: Omit<gh_ContributionsCollection, 'firstIssueContribution' | 'firstPullRequestContribution' | 'firstRepositoryContribution'> & { firstIssueContribution?: Maybe<ResolversParentTypes['gh_CreatedIssueOrRestrictedContribution']>, firstPullRequestContribution?: Maybe<ResolversParentTypes['gh_CreatedPullRequestOrRestrictedContribution']>, firstRepositoryContribution?: Maybe<ResolversParentTypes['gh_CreatedRepositoryOrRestrictedContribution']> };
  gh_ConvertProjectCardNoteToIssueInput: gh_ConvertProjectCardNoteToIssueInput;
  gh_ConvertProjectCardNoteToIssuePayload: gh_ConvertProjectCardNoteToIssuePayload;
  gh_ConvertPullRequestToDraftInput: gh_ConvertPullRequestToDraftInput;
  gh_ConvertPullRequestToDraftPayload: gh_ConvertPullRequestToDraftPayload;
  gh_ConvertToDraftEvent: gh_ConvertToDraftEvent;
  gh_ConvertedNoteToIssueEvent: gh_ConvertedNoteToIssueEvent;
  gh_ConvertedToDiscussionEvent: gh_ConvertedToDiscussionEvent;
  gh_CopyProjectV2Input: gh_CopyProjectV2Input;
  gh_CopyProjectV2Payload: gh_CopyProjectV2Payload;
  gh_CreateAttributionInvitationInput: gh_CreateAttributionInvitationInput;
  gh_CreateAttributionInvitationPayload: Omit<gh_CreateAttributionInvitationPayload, 'source' | 'target'> & { source?: Maybe<ResolversParentTypes['gh_Claimable']>, target?: Maybe<ResolversParentTypes['gh_Claimable']> };
  gh_CreateBranchProtectionRuleInput: gh_CreateBranchProtectionRuleInput;
  gh_CreateBranchProtectionRulePayload: gh_CreateBranchProtectionRulePayload;
  gh_CreateCheckRunInput: gh_CreateCheckRunInput;
  gh_CreateCheckRunPayload: gh_CreateCheckRunPayload;
  gh_CreateCheckSuiteInput: gh_CreateCheckSuiteInput;
  gh_CreateCheckSuitePayload: gh_CreateCheckSuitePayload;
  gh_CreateCommitOnBranchInput: gh_CreateCommitOnBranchInput;
  gh_CreateCommitOnBranchPayload: gh_CreateCommitOnBranchPayload;
  gh_CreateDeploymentInput: gh_CreateDeploymentInput;
  gh_CreateDeploymentPayload: gh_CreateDeploymentPayload;
  gh_CreateDeploymentStatusInput: gh_CreateDeploymentStatusInput;
  gh_CreateDeploymentStatusPayload: gh_CreateDeploymentStatusPayload;
  gh_CreateDiscussionInput: gh_CreateDiscussionInput;
  gh_CreateDiscussionPayload: gh_CreateDiscussionPayload;
  gh_CreateEnterpriseOrganizationInput: gh_CreateEnterpriseOrganizationInput;
  gh_CreateEnterpriseOrganizationPayload: gh_CreateEnterpriseOrganizationPayload;
  gh_CreateEnvironmentInput: gh_CreateEnvironmentInput;
  gh_CreateEnvironmentPayload: gh_CreateEnvironmentPayload;
  gh_CreateIpAllowListEntryInput: gh_CreateIpAllowListEntryInput;
  gh_CreateIpAllowListEntryPayload: gh_CreateIpAllowListEntryPayload;
  gh_CreateIssueInput: gh_CreateIssueInput;
  gh_CreateIssuePayload: gh_CreateIssuePayload;
  gh_CreateLabelInput: gh_CreateLabelInput;
  gh_CreateLabelPayload: gh_CreateLabelPayload;
  gh_CreateLinkedBranchInput: gh_CreateLinkedBranchInput;
  gh_CreateLinkedBranchPayload: gh_CreateLinkedBranchPayload;
  gh_CreateMigrationSourceInput: gh_CreateMigrationSourceInput;
  gh_CreateMigrationSourcePayload: gh_CreateMigrationSourcePayload;
  gh_CreateProjectInput: gh_CreateProjectInput;
  gh_CreateProjectPayload: gh_CreateProjectPayload;
  gh_CreateProjectV2FieldInput: gh_CreateProjectV2FieldInput;
  gh_CreateProjectV2FieldPayload: Omit<gh_CreateProjectV2FieldPayload, 'projectV2Field'> & { projectV2Field?: Maybe<ResolversParentTypes['gh_ProjectV2FieldConfiguration']> };
  gh_CreateProjectV2Input: gh_CreateProjectV2Input;
  gh_CreateProjectV2Payload: gh_CreateProjectV2Payload;
  gh_CreatePullRequestInput: gh_CreatePullRequestInput;
  gh_CreatePullRequestPayload: gh_CreatePullRequestPayload;
  gh_CreateRefInput: gh_CreateRefInput;
  gh_CreateRefPayload: gh_CreateRefPayload;
  gh_CreateRepositoryInput: gh_CreateRepositoryInput;
  gh_CreateRepositoryPayload: gh_CreateRepositoryPayload;
  gh_CreateRepositoryRulesetInput: gh_CreateRepositoryRulesetInput;
  gh_CreateRepositoryRulesetPayload: gh_CreateRepositoryRulesetPayload;
  gh_CreateSponsorsListingInput: gh_CreateSponsorsListingInput;
  gh_CreateSponsorsListingPayload: gh_CreateSponsorsListingPayload;
  gh_CreateSponsorsTierInput: gh_CreateSponsorsTierInput;
  gh_CreateSponsorsTierPayload: gh_CreateSponsorsTierPayload;
  gh_CreateSponsorshipInput: gh_CreateSponsorshipInput;
  gh_CreateSponsorshipPayload: gh_CreateSponsorshipPayload;
  gh_CreateSponsorshipsInput: gh_CreateSponsorshipsInput;
  gh_CreateSponsorshipsPayload: gh_CreateSponsorshipsPayload;
  gh_CreateTeamDiscussionCommentInput: gh_CreateTeamDiscussionCommentInput;
  gh_CreateTeamDiscussionCommentPayload: gh_CreateTeamDiscussionCommentPayload;
  gh_CreateTeamDiscussionInput: gh_CreateTeamDiscussionInput;
  gh_CreateTeamDiscussionPayload: gh_CreateTeamDiscussionPayload;
  gh_CreateUserListInput: gh_CreateUserListInput;
  gh_CreateUserListPayload: gh_CreateUserListPayload;
  gh_CreatedCommitContribution: gh_CreatedCommitContribution;
  gh_CreatedCommitContributionConnection: gh_CreatedCommitContributionConnection;
  gh_CreatedCommitContributionEdge: gh_CreatedCommitContributionEdge;
  gh_CreatedIssueContribution: gh_CreatedIssueContribution;
  gh_CreatedIssueContributionConnection: gh_CreatedIssueContributionConnection;
  gh_CreatedIssueContributionEdge: gh_CreatedIssueContributionEdge;
  gh_CreatedIssueOrRestrictedContribution: ResolversUnionTypes<ResolversParentTypes>['gh_CreatedIssueOrRestrictedContribution'];
  gh_CreatedPullRequestContribution: gh_CreatedPullRequestContribution;
  gh_CreatedPullRequestContributionConnection: gh_CreatedPullRequestContributionConnection;
  gh_CreatedPullRequestContributionEdge: gh_CreatedPullRequestContributionEdge;
  gh_CreatedPullRequestOrRestrictedContribution: ResolversUnionTypes<ResolversParentTypes>['gh_CreatedPullRequestOrRestrictedContribution'];
  gh_CreatedPullRequestReviewContribution: gh_CreatedPullRequestReviewContribution;
  gh_CreatedPullRequestReviewContributionConnection: gh_CreatedPullRequestReviewContributionConnection;
  gh_CreatedPullRequestReviewContributionEdge: gh_CreatedPullRequestReviewContributionEdge;
  gh_CreatedRepositoryContribution: gh_CreatedRepositoryContribution;
  gh_CreatedRepositoryContributionConnection: gh_CreatedRepositoryContributionConnection;
  gh_CreatedRepositoryContributionEdge: gh_CreatedRepositoryContributionEdge;
  gh_CreatedRepositoryOrRestrictedContribution: ResolversUnionTypes<ResolversParentTypes>['gh_CreatedRepositoryOrRestrictedContribution'];
  gh_CrossReferencedEvent: Omit<gh_CrossReferencedEvent, 'source' | 'target'> & { source: ResolversParentTypes['gh_ReferencedSubject'], target: ResolversParentTypes['gh_ReferencedSubject'] };
  Date: Scalars['Date']['output'];
  DateTime: Scalars['DateTime']['output'];
  gh_DeclineTopicSuggestionInput: gh_DeclineTopicSuggestionInput;
  gh_DeclineTopicSuggestionPayload: gh_DeclineTopicSuggestionPayload;
  gh_Deletable: ResolversInterfaceTypes<ResolversParentTypes>['gh_Deletable'];
  gh_DeleteBranchProtectionRuleInput: gh_DeleteBranchProtectionRuleInput;
  gh_DeleteBranchProtectionRulePayload: gh_DeleteBranchProtectionRulePayload;
  gh_DeleteDeploymentInput: gh_DeleteDeploymentInput;
  gh_DeleteDeploymentPayload: gh_DeleteDeploymentPayload;
  gh_DeleteDiscussionCommentInput: gh_DeleteDiscussionCommentInput;
  gh_DeleteDiscussionCommentPayload: gh_DeleteDiscussionCommentPayload;
  gh_DeleteDiscussionInput: gh_DeleteDiscussionInput;
  gh_DeleteDiscussionPayload: gh_DeleteDiscussionPayload;
  gh_DeleteEnvironmentInput: gh_DeleteEnvironmentInput;
  gh_DeleteEnvironmentPayload: gh_DeleteEnvironmentPayload;
  gh_DeleteIpAllowListEntryInput: gh_DeleteIpAllowListEntryInput;
  gh_DeleteIpAllowListEntryPayload: gh_DeleteIpAllowListEntryPayload;
  gh_DeleteIssueCommentInput: gh_DeleteIssueCommentInput;
  gh_DeleteIssueCommentPayload: gh_DeleteIssueCommentPayload;
  gh_DeleteIssueInput: gh_DeleteIssueInput;
  gh_DeleteIssuePayload: gh_DeleteIssuePayload;
  gh_DeleteLabelInput: gh_DeleteLabelInput;
  gh_DeleteLabelPayload: gh_DeleteLabelPayload;
  gh_DeleteLinkedBranchInput: gh_DeleteLinkedBranchInput;
  gh_DeleteLinkedBranchPayload: gh_DeleteLinkedBranchPayload;
  gh_DeletePackageVersionInput: gh_DeletePackageVersionInput;
  gh_DeletePackageVersionPayload: gh_DeletePackageVersionPayload;
  gh_DeleteProjectCardInput: gh_DeleteProjectCardInput;
  gh_DeleteProjectCardPayload: gh_DeleteProjectCardPayload;
  gh_DeleteProjectColumnInput: gh_DeleteProjectColumnInput;
  gh_DeleteProjectColumnPayload: gh_DeleteProjectColumnPayload;
  gh_DeleteProjectInput: gh_DeleteProjectInput;
  gh_DeleteProjectPayload: gh_DeleteProjectPayload;
  gh_DeleteProjectV2FieldInput: gh_DeleteProjectV2FieldInput;
  gh_DeleteProjectV2FieldPayload: Omit<gh_DeleteProjectV2FieldPayload, 'projectV2Field'> & { projectV2Field?: Maybe<ResolversParentTypes['gh_ProjectV2FieldConfiguration']> };
  gh_DeleteProjectV2Input: gh_DeleteProjectV2Input;
  gh_DeleteProjectV2ItemInput: gh_DeleteProjectV2ItemInput;
  gh_DeleteProjectV2ItemPayload: gh_DeleteProjectV2ItemPayload;
  gh_DeleteProjectV2Payload: gh_DeleteProjectV2Payload;
  gh_DeleteProjectV2WorkflowInput: gh_DeleteProjectV2WorkflowInput;
  gh_DeleteProjectV2WorkflowPayload: gh_DeleteProjectV2WorkflowPayload;
  gh_DeletePullRequestReviewCommentInput: gh_DeletePullRequestReviewCommentInput;
  gh_DeletePullRequestReviewCommentPayload: gh_DeletePullRequestReviewCommentPayload;
  gh_DeletePullRequestReviewInput: gh_DeletePullRequestReviewInput;
  gh_DeletePullRequestReviewPayload: gh_DeletePullRequestReviewPayload;
  gh_DeleteRefInput: gh_DeleteRefInput;
  gh_DeleteRefPayload: gh_DeleteRefPayload;
  gh_DeleteRepositoryRulesetInput: gh_DeleteRepositoryRulesetInput;
  gh_DeleteRepositoryRulesetPayload: gh_DeleteRepositoryRulesetPayload;
  gh_DeleteTeamDiscussionCommentInput: gh_DeleteTeamDiscussionCommentInput;
  gh_DeleteTeamDiscussionCommentPayload: gh_DeleteTeamDiscussionCommentPayload;
  gh_DeleteTeamDiscussionInput: gh_DeleteTeamDiscussionInput;
  gh_DeleteTeamDiscussionPayload: gh_DeleteTeamDiscussionPayload;
  gh_DeleteUserListInput: gh_DeleteUserListInput;
  gh_DeleteUserListPayload: gh_DeleteUserListPayload;
  gh_DeleteVerifiableDomainInput: gh_DeleteVerifiableDomainInput;
  gh_DeleteVerifiableDomainPayload: Omit<gh_DeleteVerifiableDomainPayload, 'owner'> & { owner?: Maybe<ResolversParentTypes['gh_VerifiableDomainOwner']> };
  gh_DemilestonedEvent: Omit<gh_DemilestonedEvent, 'subject'> & { subject: ResolversParentTypes['gh_MilestoneItem'] };
  gh_DependabotUpdate: gh_DependabotUpdate;
  gh_DependabotUpdateError: gh_DependabotUpdateError;
  gh_DependencyGraphDependency: gh_DependencyGraphDependency;
  gh_DependencyGraphDependencyConnection: gh_DependencyGraphDependencyConnection;
  gh_DependencyGraphDependencyEdge: gh_DependencyGraphDependencyEdge;
  gh_DependencyGraphManifest: gh_DependencyGraphManifest;
  gh_DependencyGraphManifestConnection: gh_DependencyGraphManifestConnection;
  gh_DependencyGraphManifestEdge: gh_DependencyGraphManifestEdge;
  gh_DeployKey: gh_DeployKey;
  gh_DeployKeyConnection: gh_DeployKeyConnection;
  gh_DeployKeyEdge: gh_DeployKeyEdge;
  gh_DeployedEvent: gh_DeployedEvent;
  gh_Deployment: gh_Deployment;
  gh_DeploymentConnection: gh_DeploymentConnection;
  gh_DeploymentEdge: gh_DeploymentEdge;
  gh_DeploymentEnvironmentChangedEvent: gh_DeploymentEnvironmentChangedEvent;
  gh_DeploymentOrder: gh_DeploymentOrder;
  gh_DeploymentProtectionRule: gh_DeploymentProtectionRule;
  gh_DeploymentProtectionRuleConnection: gh_DeploymentProtectionRuleConnection;
  gh_DeploymentProtectionRuleEdge: gh_DeploymentProtectionRuleEdge;
  gh_DeploymentRequest: gh_DeploymentRequest;
  gh_DeploymentRequestConnection: gh_DeploymentRequestConnection;
  gh_DeploymentRequestEdge: gh_DeploymentRequestEdge;
  gh_DeploymentReview: gh_DeploymentReview;
  gh_DeploymentReviewConnection: gh_DeploymentReviewConnection;
  gh_DeploymentReviewEdge: gh_DeploymentReviewEdge;
  gh_DeploymentReviewer: ResolversUnionTypes<ResolversParentTypes>['gh_DeploymentReviewer'];
  gh_DeploymentReviewerConnection: Omit<gh_DeploymentReviewerConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_DeploymentReviewer']>>> };
  gh_DeploymentReviewerEdge: Omit<gh_DeploymentReviewerEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_DeploymentReviewer']> };
  gh_DeploymentStatus: gh_DeploymentStatus;
  gh_DeploymentStatusConnection: gh_DeploymentStatusConnection;
  gh_DeploymentStatusEdge: gh_DeploymentStatusEdge;
  gh_DequeuePullRequestInput: gh_DequeuePullRequestInput;
  gh_DequeuePullRequestPayload: gh_DequeuePullRequestPayload;
  gh_DisablePullRequestAutoMergeInput: gh_DisablePullRequestAutoMergeInput;
  gh_DisablePullRequestAutoMergePayload: gh_DisablePullRequestAutoMergePayload;
  gh_DisconnectedEvent: Omit<gh_DisconnectedEvent, 'source' | 'subject'> & { source: ResolversParentTypes['gh_ReferencedSubject'], subject: ResolversParentTypes['gh_ReferencedSubject'] };
  gh_Discussion: gh_Discussion;
  gh_DiscussionCategory: gh_DiscussionCategory;
  gh_DiscussionCategoryConnection: gh_DiscussionCategoryConnection;
  gh_DiscussionCategoryEdge: gh_DiscussionCategoryEdge;
  gh_DiscussionComment: gh_DiscussionComment;
  gh_DiscussionCommentConnection: gh_DiscussionCommentConnection;
  gh_DiscussionCommentEdge: gh_DiscussionCommentEdge;
  gh_DiscussionConnection: gh_DiscussionConnection;
  gh_DiscussionEdge: gh_DiscussionEdge;
  gh_DiscussionOrder: gh_DiscussionOrder;
  gh_DiscussionPoll: gh_DiscussionPoll;
  gh_DiscussionPollOption: gh_DiscussionPollOption;
  gh_DiscussionPollOptionConnection: gh_DiscussionPollOptionConnection;
  gh_DiscussionPollOptionEdge: gh_DiscussionPollOptionEdge;
  gh_DiscussionPollOptionOrder: gh_DiscussionPollOptionOrder;
  gh_DismissPullRequestReviewInput: gh_DismissPullRequestReviewInput;
  gh_DismissPullRequestReviewPayload: gh_DismissPullRequestReviewPayload;
  gh_DismissRepositoryVulnerabilityAlertInput: gh_DismissRepositoryVulnerabilityAlertInput;
  gh_DismissRepositoryVulnerabilityAlertPayload: gh_DismissRepositoryVulnerabilityAlertPayload;
  gh_DraftIssue: gh_DraftIssue;
  gh_DraftPullRequestReviewComment: gh_DraftPullRequestReviewComment;
  gh_DraftPullRequestReviewThread: gh_DraftPullRequestReviewThread;
  gh_EnablePullRequestAutoMergeInput: gh_EnablePullRequestAutoMergeInput;
  gh_EnablePullRequestAutoMergePayload: gh_EnablePullRequestAutoMergePayload;
  gh_EnqueuePullRequestInput: gh_EnqueuePullRequestInput;
  gh_EnqueuePullRequestPayload: gh_EnqueuePullRequestPayload;
  gh_Enterprise: gh_Enterprise;
  gh_EnterpriseAdministratorConnection: gh_EnterpriseAdministratorConnection;
  gh_EnterpriseAdministratorEdge: gh_EnterpriseAdministratorEdge;
  gh_EnterpriseAdministratorInvitation: gh_EnterpriseAdministratorInvitation;
  gh_EnterpriseAdministratorInvitationConnection: gh_EnterpriseAdministratorInvitationConnection;
  gh_EnterpriseAdministratorInvitationEdge: gh_EnterpriseAdministratorInvitationEdge;
  gh_EnterpriseAdministratorInvitationOrder: gh_EnterpriseAdministratorInvitationOrder;
  gh_EnterpriseAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>['gh_EnterpriseAuditEntryData'];
  gh_EnterpriseBillingInfo: gh_EnterpriseBillingInfo;
  gh_EnterpriseConnection: gh_EnterpriseConnection;
  gh_EnterpriseEdge: gh_EnterpriseEdge;
  gh_EnterpriseFailedInvitationConnection: gh_EnterpriseFailedInvitationConnection;
  gh_EnterpriseFailedInvitationEdge: gh_EnterpriseFailedInvitationEdge;
  gh_EnterpriseIdentityProvider: gh_EnterpriseIdentityProvider;
  gh_EnterpriseMember: ResolversUnionTypes<ResolversParentTypes>['gh_EnterpriseMember'];
  gh_EnterpriseMemberConnection: Omit<gh_EnterpriseMemberConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_EnterpriseMember']>>> };
  gh_EnterpriseMemberEdge: Omit<gh_EnterpriseMemberEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_EnterpriseMember']> };
  gh_EnterpriseMemberOrder: gh_EnterpriseMemberOrder;
  gh_EnterpriseOrder: gh_EnterpriseOrder;
  gh_EnterpriseOrganizationMembershipConnection: gh_EnterpriseOrganizationMembershipConnection;
  gh_EnterpriseOrganizationMembershipEdge: gh_EnterpriseOrganizationMembershipEdge;
  gh_EnterpriseOutsideCollaboratorConnection: gh_EnterpriseOutsideCollaboratorConnection;
  gh_EnterpriseOutsideCollaboratorEdge: gh_EnterpriseOutsideCollaboratorEdge;
  gh_EnterpriseOwnerInfo: gh_EnterpriseOwnerInfo;
  gh_EnterprisePendingMemberInvitationConnection: gh_EnterprisePendingMemberInvitationConnection;
  gh_EnterprisePendingMemberInvitationEdge: gh_EnterprisePendingMemberInvitationEdge;
  gh_EnterpriseRepositoryInfo: gh_EnterpriseRepositoryInfo;
  gh_EnterpriseRepositoryInfoConnection: gh_EnterpriseRepositoryInfoConnection;
  gh_EnterpriseRepositoryInfoEdge: gh_EnterpriseRepositoryInfoEdge;
  gh_EnterpriseServerInstallation: gh_EnterpriseServerInstallation;
  gh_EnterpriseServerInstallationConnection: gh_EnterpriseServerInstallationConnection;
  gh_EnterpriseServerInstallationEdge: gh_EnterpriseServerInstallationEdge;
  gh_EnterpriseServerInstallationMembershipConnection: gh_EnterpriseServerInstallationMembershipConnection;
  gh_EnterpriseServerInstallationMembershipEdge: gh_EnterpriseServerInstallationMembershipEdge;
  gh_EnterpriseServerInstallationOrder: gh_EnterpriseServerInstallationOrder;
  gh_EnterpriseServerUserAccount: gh_EnterpriseServerUserAccount;
  gh_EnterpriseServerUserAccountConnection: gh_EnterpriseServerUserAccountConnection;
  gh_EnterpriseServerUserAccountEdge: gh_EnterpriseServerUserAccountEdge;
  gh_EnterpriseServerUserAccountEmail: gh_EnterpriseServerUserAccountEmail;
  gh_EnterpriseServerUserAccountEmailConnection: gh_EnterpriseServerUserAccountEmailConnection;
  gh_EnterpriseServerUserAccountEmailEdge: gh_EnterpriseServerUserAccountEmailEdge;
  gh_EnterpriseServerUserAccountEmailOrder: gh_EnterpriseServerUserAccountEmailOrder;
  gh_EnterpriseServerUserAccountOrder: gh_EnterpriseServerUserAccountOrder;
  gh_EnterpriseServerUserAccountsUpload: gh_EnterpriseServerUserAccountsUpload;
  gh_EnterpriseServerUserAccountsUploadConnection: gh_EnterpriseServerUserAccountsUploadConnection;
  gh_EnterpriseServerUserAccountsUploadEdge: gh_EnterpriseServerUserAccountsUploadEdge;
  gh_EnterpriseServerUserAccountsUploadOrder: gh_EnterpriseServerUserAccountsUploadOrder;
  gh_EnterpriseUserAccount: gh_EnterpriseUserAccount;
  gh_Environment: gh_Environment;
  gh_EnvironmentConnection: gh_EnvironmentConnection;
  gh_EnvironmentEdge: gh_EnvironmentEdge;
  gh_Environments: gh_Environments;
  gh_ExternalIdentity: gh_ExternalIdentity;
  gh_ExternalIdentityAttribute: gh_ExternalIdentityAttribute;
  gh_ExternalIdentityConnection: gh_ExternalIdentityConnection;
  gh_ExternalIdentityEdge: gh_ExternalIdentityEdge;
  gh_ExternalIdentitySamlAttributes: gh_ExternalIdentitySamlAttributes;
  gh_ExternalIdentityScimAttributes: gh_ExternalIdentityScimAttributes;
  gh_FileAddition: gh_FileAddition;
  gh_FileChanges: gh_FileChanges;
  gh_FileDeletion: gh_FileDeletion;
  gh_FollowOrganizationInput: gh_FollowOrganizationInput;
  gh_FollowOrganizationPayload: gh_FollowOrganizationPayload;
  gh_FollowUserInput: gh_FollowUserInput;
  gh_FollowUserPayload: gh_FollowUserPayload;
  gh_FollowerConnection: gh_FollowerConnection;
  gh_FollowingConnection: gh_FollowingConnection;
  gh_FundingLink: gh_FundingLink;
  gh_GenericHovercardContext: gh_GenericHovercardContext;
  gh_Gist: gh_Gist;
  gh_GistComment: gh_GistComment;
  gh_GistCommentConnection: gh_GistCommentConnection;
  gh_GistCommentEdge: gh_GistCommentEdge;
  gh_GistConnection: gh_GistConnection;
  gh_GistEdge: gh_GistEdge;
  gh_GistFile: gh_GistFile;
  gh_GistOrder: gh_GistOrder;
  gh_GitActor: gh_GitActor;
  gh_GitActorConnection: gh_GitActorConnection;
  gh_GitActorEdge: gh_GitActorEdge;
  gh_GitHubMetadata: gh_GitHubMetadata;
  gh_GitObject: ResolversInterfaceTypes<ResolversParentTypes>['gh_GitObject'];
  gh_GitObjectID: Scalars['gh_GitObjectID']['output'];
  gh_GitRefname: Scalars['gh_GitRefname']['output'];
  gh_GitSSHRemote: Scalars['gh_GitSSHRemote']['output'];
  gh_GitSignature: ResolversInterfaceTypes<ResolversParentTypes>['gh_GitSignature'];
  gh_GitTimestamp: Scalars['gh_GitTimestamp']['output'];
  gh_GpgSignature: gh_GpgSignature;
  gh_GrantEnterpriseOrganizationsMigratorRoleInput: gh_GrantEnterpriseOrganizationsMigratorRoleInput;
  gh_GrantEnterpriseOrganizationsMigratorRolePayload: gh_GrantEnterpriseOrganizationsMigratorRolePayload;
  gh_GrantMigratorRoleInput: gh_GrantMigratorRoleInput;
  gh_GrantMigratorRolePayload: gh_GrantMigratorRolePayload;
  gh_HTML: Scalars['gh_HTML']['output'];
  gh_HeadRefDeletedEvent: gh_HeadRefDeletedEvent;
  gh_HeadRefForcePushedEvent: gh_HeadRefForcePushedEvent;
  gh_HeadRefRestoredEvent: gh_HeadRefRestoredEvent;
  gh_Hovercard: gh_Hovercard;
  gh_HovercardContext: ResolversInterfaceTypes<ResolversParentTypes>['gh_HovercardContext'];
  gh_ImportProjectInput: gh_ImportProjectInput;
  gh_ImportProjectPayload: gh_ImportProjectPayload;
  gh_InviteEnterpriseAdminInput: gh_InviteEnterpriseAdminInput;
  gh_InviteEnterpriseAdminPayload: gh_InviteEnterpriseAdminPayload;
  gh_IpAllowListEntry: Omit<gh_IpAllowListEntry, 'owner'> & { owner: ResolversParentTypes['gh_IpAllowListOwner'] };
  gh_IpAllowListEntryConnection: gh_IpAllowListEntryConnection;
  gh_IpAllowListEntryEdge: gh_IpAllowListEntryEdge;
  gh_IpAllowListEntryOrder: gh_IpAllowListEntryOrder;
  gh_IpAllowListOwner: ResolversUnionTypes<ResolversParentTypes>['gh_IpAllowListOwner'];
  gh_Issue: gh_Issue;
  gh_IssueComment: gh_IssueComment;
  gh_IssueCommentConnection: gh_IssueCommentConnection;
  gh_IssueCommentEdge: gh_IssueCommentEdge;
  gh_IssueCommentOrder: gh_IssueCommentOrder;
  gh_IssueConnection: gh_IssueConnection;
  gh_IssueContributionsByRepository: gh_IssueContributionsByRepository;
  gh_IssueEdge: gh_IssueEdge;
  gh_IssueFilters: gh_IssueFilters;
  gh_IssueOrPullRequest: ResolversUnionTypes<ResolversParentTypes>['gh_IssueOrPullRequest'];
  gh_IssueOrder: gh_IssueOrder;
  gh_IssueTemplate: gh_IssueTemplate;
  gh_IssueTimelineConnection: Omit<gh_IssueTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_IssueTimelineItem']>>> };
  gh_IssueTimelineItem: ResolversUnionTypes<ResolversParentTypes>['gh_IssueTimelineItem'];
  gh_IssueTimelineItemEdge: Omit<gh_IssueTimelineItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_IssueTimelineItem']> };
  gh_IssueTimelineItems: ResolversUnionTypes<ResolversParentTypes>['gh_IssueTimelineItems'];
  gh_IssueTimelineItemsConnection: Omit<gh_IssueTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_IssueTimelineItems']>>> };
  gh_IssueTimelineItemsEdge: Omit<gh_IssueTimelineItemsEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_IssueTimelineItems']> };
  gh_JoinedGitHubContribution: gh_JoinedGitHubContribution;
  gh_Label: gh_Label;
  gh_LabelConnection: gh_LabelConnection;
  gh_LabelEdge: gh_LabelEdge;
  gh_LabelOrder: gh_LabelOrder;
  gh_Labelable: ResolversInterfaceTypes<ResolversParentTypes>['gh_Labelable'];
  gh_LabeledEvent: gh_LabeledEvent;
  gh_Language: gh_Language;
  gh_LanguageConnection: gh_LanguageConnection;
  gh_LanguageEdge: gh_LanguageEdge;
  gh_LanguageOrder: gh_LanguageOrder;
  gh_License: gh_License;
  gh_LicenseRule: gh_LicenseRule;
  gh_LinkProjectV2ToRepositoryInput: gh_LinkProjectV2ToRepositoryInput;
  gh_LinkProjectV2ToRepositoryPayload: gh_LinkProjectV2ToRepositoryPayload;
  gh_LinkProjectV2ToTeamInput: gh_LinkProjectV2ToTeamInput;
  gh_LinkProjectV2ToTeamPayload: gh_LinkProjectV2ToTeamPayload;
  gh_LinkRepositoryToProjectInput: gh_LinkRepositoryToProjectInput;
  gh_LinkRepositoryToProjectPayload: gh_LinkRepositoryToProjectPayload;
  gh_LinkedBranch: gh_LinkedBranch;
  gh_LinkedBranchConnection: gh_LinkedBranchConnection;
  gh_LinkedBranchEdge: gh_LinkedBranchEdge;
  gh_LockLockableInput: gh_LockLockableInput;
  gh_LockLockablePayload: gh_LockLockablePayload;
  gh_Lockable: ResolversInterfaceTypes<ResolversParentTypes>['gh_Lockable'];
  gh_LockedEvent: gh_LockedEvent;
  gh_Mannequin: gh_Mannequin;
  gh_MannequinConnection: gh_MannequinConnection;
  gh_MannequinEdge: gh_MannequinEdge;
  gh_MannequinOrder: gh_MannequinOrder;
  gh_MarkDiscussionCommentAsAnswerInput: gh_MarkDiscussionCommentAsAnswerInput;
  gh_MarkDiscussionCommentAsAnswerPayload: gh_MarkDiscussionCommentAsAnswerPayload;
  gh_MarkFileAsViewedInput: gh_MarkFileAsViewedInput;
  gh_MarkFileAsViewedPayload: gh_MarkFileAsViewedPayload;
  gh_MarkProjectV2AsTemplateInput: gh_MarkProjectV2AsTemplateInput;
  gh_MarkProjectV2AsTemplatePayload: gh_MarkProjectV2AsTemplatePayload;
  gh_MarkPullRequestReadyForReviewInput: gh_MarkPullRequestReadyForReviewInput;
  gh_MarkPullRequestReadyForReviewPayload: gh_MarkPullRequestReadyForReviewPayload;
  gh_MarkedAsDuplicateEvent: Omit<gh_MarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<ResolversParentTypes['gh_IssueOrPullRequest']>, duplicate?: Maybe<ResolversParentTypes['gh_IssueOrPullRequest']> };
  gh_MarketplaceCategory: gh_MarketplaceCategory;
  gh_MarketplaceListing: gh_MarketplaceListing;
  gh_MarketplaceListingConnection: gh_MarketplaceListingConnection;
  gh_MarketplaceListingEdge: gh_MarketplaceListingEdge;
  gh_MemberFeatureRequestNotification: gh_MemberFeatureRequestNotification;
  gh_MemberStatusable: ResolversInterfaceTypes<ResolversParentTypes>['gh_MemberStatusable'];
  gh_MembersCanDeleteReposClearAuditEntry: Omit<gh_MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_MembersCanDeleteReposDisableAuditEntry: Omit<gh_MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_MembersCanDeleteReposEnableAuditEntry: Omit<gh_MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_MentionedEvent: gh_MentionedEvent;
  gh_MergeBranchInput: gh_MergeBranchInput;
  gh_MergeBranchPayload: gh_MergeBranchPayload;
  gh_MergePullRequestInput: gh_MergePullRequestInput;
  gh_MergePullRequestPayload: gh_MergePullRequestPayload;
  gh_MergeQueue: gh_MergeQueue;
  gh_MergeQueueConfiguration: gh_MergeQueueConfiguration;
  gh_MergeQueueEntry: gh_MergeQueueEntry;
  gh_MergeQueueEntryConnection: gh_MergeQueueEntryConnection;
  gh_MergeQueueEntryEdge: gh_MergeQueueEntryEdge;
  gh_MergedEvent: gh_MergedEvent;
  gh_Migration: ResolversInterfaceTypes<ResolversParentTypes>['gh_Migration'];
  gh_MigrationSource: gh_MigrationSource;
  gh_Milestone: gh_Milestone;
  gh_MilestoneConnection: gh_MilestoneConnection;
  gh_MilestoneEdge: gh_MilestoneEdge;
  gh_MilestoneItem: ResolversUnionTypes<ResolversParentTypes>['gh_MilestoneItem'];
  gh_MilestoneOrder: gh_MilestoneOrder;
  gh_MilestonedEvent: Omit<gh_MilestonedEvent, 'subject'> & { subject: ResolversParentTypes['gh_MilestoneItem'] };
  gh_Minimizable: ResolversInterfaceTypes<ResolversParentTypes>['gh_Minimizable'];
  gh_MinimizeCommentInput: gh_MinimizeCommentInput;
  gh_MinimizeCommentPayload: gh_MinimizeCommentPayload;
  gh_MoveProjectCardInput: gh_MoveProjectCardInput;
  gh_MoveProjectCardPayload: gh_MoveProjectCardPayload;
  gh_MoveProjectColumnInput: gh_MoveProjectColumnInput;
  gh_MoveProjectColumnPayload: gh_MoveProjectColumnPayload;
  gh_MovedColumnsInProjectEvent: gh_MovedColumnsInProjectEvent;
  gh_Node: ResolversInterfaceTypes<ResolversParentTypes>['gh_Node'];
  gh_OIDCProvider: gh_OIDCProvider;
  gh_OauthApplicationAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>['gh_OauthApplicationAuditEntryData'];
  gh_OauthApplicationCreateAuditEntry: Omit<gh_OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgAddBillingManagerAuditEntry: Omit<gh_OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgAddMemberAuditEntry: Omit<gh_OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgBlockUserAuditEntry: Omit<gh_OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgConfigDisableCollaboratorsOnlyAuditEntry: Omit<gh_OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgConfigEnableCollaboratorsOnlyAuditEntry: Omit<gh_OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgCreateAuditEntry: Omit<gh_OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgDisableOauthAppRestrictionsAuditEntry: Omit<gh_OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgDisableSamlAuditEntry: Omit<gh_OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgDisableTwoFactorRequirementAuditEntry: Omit<gh_OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgEnableOauthAppRestrictionsAuditEntry: Omit<gh_OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgEnableSamlAuditEntry: Omit<gh_OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgEnableTwoFactorRequirementAuditEntry: Omit<gh_OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgEnterpriseOwnerOrder: gh_OrgEnterpriseOwnerOrder;
  gh_OrgInviteMemberAuditEntry: Omit<gh_OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgInviteToBusinessAuditEntry: Omit<gh_OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgOauthAppAccessApprovedAuditEntry: Omit<gh_OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgOauthAppAccessBlockedAuditEntry: Omit<gh_OrgOauthAppAccessBlockedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgOauthAppAccessDeniedAuditEntry: Omit<gh_OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgOauthAppAccessRequestedAuditEntry: Omit<gh_OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgOauthAppAccessUnblockedAuditEntry: Omit<gh_OrgOauthAppAccessUnblockedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgRemoveBillingManagerAuditEntry: Omit<gh_OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgRemoveMemberAuditEntry: Omit<gh_OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgRemoveOutsideCollaboratorAuditEntry: Omit<gh_OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgRestoreMemberAuditEntry: Omit<gh_OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']>, restoredMemberships?: Maybe<Array<ResolversParentTypes['gh_OrgRestoreMemberAuditEntryMembership']>> };
  gh_OrgRestoreMemberAuditEntryMembership: ResolversUnionTypes<ResolversParentTypes>['gh_OrgRestoreMemberAuditEntryMembership'];
  gh_OrgRestoreMemberMembershipOrganizationAuditEntryData: gh_OrgRestoreMemberMembershipOrganizationAuditEntryData;
  gh_OrgRestoreMemberMembershipRepositoryAuditEntryData: gh_OrgRestoreMemberMembershipRepositoryAuditEntryData;
  gh_OrgRestoreMemberMembershipTeamAuditEntryData: gh_OrgRestoreMemberMembershipTeamAuditEntryData;
  gh_OrgUnblockUserAuditEntry: Omit<gh_OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgUpdateDefaultRepositoryPermissionAuditEntry: Omit<gh_OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgUpdateMemberAuditEntry: Omit<gh_OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry: Omit<gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: Omit<gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_Organization: gh_Organization;
  gh_OrganizationAuditEntry: ResolversUnionTypes<ResolversParentTypes>['gh_OrganizationAuditEntry'];
  gh_OrganizationAuditEntryConnection: Omit<gh_OrganizationAuditEntryConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_OrganizationAuditEntry']>>> };
  gh_OrganizationAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>['gh_OrganizationAuditEntryData'];
  gh_OrganizationAuditEntryEdge: Omit<gh_OrganizationAuditEntryEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_OrganizationAuditEntry']> };
  gh_OrganizationConnection: gh_OrganizationConnection;
  gh_OrganizationEdge: gh_OrganizationEdge;
  gh_OrganizationEnterpriseOwnerConnection: gh_OrganizationEnterpriseOwnerConnection;
  gh_OrganizationEnterpriseOwnerEdge: gh_OrganizationEnterpriseOwnerEdge;
  gh_OrganizationIdentityProvider: gh_OrganizationIdentityProvider;
  gh_OrganizationInvitation: gh_OrganizationInvitation;
  gh_OrganizationInvitationConnection: gh_OrganizationInvitationConnection;
  gh_OrganizationInvitationEdge: gh_OrganizationInvitationEdge;
  gh_OrganizationMemberConnection: gh_OrganizationMemberConnection;
  gh_OrganizationMemberEdge: gh_OrganizationMemberEdge;
  gh_OrganizationMigration: gh_OrganizationMigration;
  gh_OrganizationOrUser: ResolversUnionTypes<ResolversParentTypes>['gh_OrganizationOrUser'];
  gh_OrganizationOrder: gh_OrganizationOrder;
  gh_OrganizationTeamsHovercardContext: gh_OrganizationTeamsHovercardContext;
  gh_OrganizationsHovercardContext: gh_OrganizationsHovercardContext;
  gh_Package: gh_Package;
  gh_PackageConnection: gh_PackageConnection;
  gh_PackageEdge: gh_PackageEdge;
  gh_PackageFile: gh_PackageFile;
  gh_PackageFileConnection: gh_PackageFileConnection;
  gh_PackageFileEdge: gh_PackageFileEdge;
  gh_PackageFileOrder: gh_PackageFileOrder;
  gh_PackageOrder: gh_PackageOrder;
  gh_PackageOwner: ResolversInterfaceTypes<ResolversParentTypes>['gh_PackageOwner'];
  gh_PackageStatistics: gh_PackageStatistics;
  gh_PackageTag: gh_PackageTag;
  gh_PackageVersion: gh_PackageVersion;
  gh_PackageVersionConnection: gh_PackageVersionConnection;
  gh_PackageVersionEdge: gh_PackageVersionEdge;
  gh_PackageVersionOrder: gh_PackageVersionOrder;
  gh_PackageVersionStatistics: gh_PackageVersionStatistics;
  gh_PageInfo: gh_PageInfo;
  gh_PermissionGranter: ResolversUnionTypes<ResolversParentTypes>['gh_PermissionGranter'];
  gh_PermissionSource: Omit<gh_PermissionSource, 'source'> & { source: ResolversParentTypes['gh_PermissionGranter'] };
  gh_PinIssueInput: gh_PinIssueInput;
  gh_PinIssuePayload: gh_PinIssuePayload;
  gh_PinnableItem: ResolversUnionTypes<ResolversParentTypes>['gh_PinnableItem'];
  gh_PinnableItemConnection: Omit<gh_PinnableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_PinnableItem']>>> };
  gh_PinnableItemEdge: Omit<gh_PinnableItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_PinnableItem']> };
  gh_PinnedDiscussion: gh_PinnedDiscussion;
  gh_PinnedDiscussionConnection: gh_PinnedDiscussionConnection;
  gh_PinnedDiscussionEdge: gh_PinnedDiscussionEdge;
  gh_PinnedEvent: gh_PinnedEvent;
  gh_PinnedIssue: gh_PinnedIssue;
  gh_PinnedIssueConnection: gh_PinnedIssueConnection;
  gh_PinnedIssueEdge: gh_PinnedIssueEdge;
  gh_PreciseDateTime: Scalars['gh_PreciseDateTime']['output'];
  gh_PrivateRepositoryForkingDisableAuditEntry: Omit<gh_PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_PrivateRepositoryForkingEnableAuditEntry: Omit<gh_PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_ProfileItemShowcase: gh_ProfileItemShowcase;
  gh_ProfileOwner: ResolversInterfaceTypes<ResolversParentTypes>['gh_ProfileOwner'];
  gh_Project: gh_Project;
  gh_ProjectCard: Omit<gh_ProjectCard, 'content'> & { content?: Maybe<ResolversParentTypes['gh_ProjectCardItem']> };
  gh_ProjectCardConnection: gh_ProjectCardConnection;
  gh_ProjectCardEdge: gh_ProjectCardEdge;
  gh_ProjectCardImport: gh_ProjectCardImport;
  gh_ProjectCardItem: ResolversUnionTypes<ResolversParentTypes>['gh_ProjectCardItem'];
  gh_ProjectColumn: gh_ProjectColumn;
  gh_ProjectColumnConnection: gh_ProjectColumnConnection;
  gh_ProjectColumnEdge: gh_ProjectColumnEdge;
  gh_ProjectColumnImport: gh_ProjectColumnImport;
  gh_ProjectConnection: gh_ProjectConnection;
  gh_ProjectEdge: gh_ProjectEdge;
  gh_ProjectOrder: gh_ProjectOrder;
  gh_ProjectOwner: ResolversInterfaceTypes<ResolversParentTypes>['gh_ProjectOwner'];
  gh_ProjectProgress: gh_ProjectProgress;
  gh_ProjectV2: Omit<gh_ProjectV2, 'field'> & { field?: Maybe<ResolversParentTypes['gh_ProjectV2FieldConfiguration']> };
  gh_ProjectV2Actor: ResolversUnionTypes<ResolversParentTypes>['gh_ProjectV2Actor'];
  gh_ProjectV2ActorConnection: Omit<gh_ProjectV2ActorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_ProjectV2Actor']>>> };
  gh_ProjectV2ActorEdge: Omit<gh_ProjectV2ActorEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_ProjectV2Actor']> };
  gh_ProjectV2Collaborator: gh_ProjectV2Collaborator;
  gh_ProjectV2Connection: gh_ProjectV2Connection;
  gh_ProjectV2Edge: gh_ProjectV2Edge;
  gh_ProjectV2Field: gh_ProjectV2Field;
  gh_ProjectV2FieldCommon: ResolversInterfaceTypes<ResolversParentTypes>['gh_ProjectV2FieldCommon'];
  gh_ProjectV2FieldConfiguration: ResolversUnionTypes<ResolversParentTypes>['gh_ProjectV2FieldConfiguration'];
  gh_ProjectV2FieldConfigurationConnection: Omit<gh_ProjectV2FieldConfigurationConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_ProjectV2FieldConfiguration']>>> };
  gh_ProjectV2FieldConfigurationEdge: Omit<gh_ProjectV2FieldConfigurationEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_ProjectV2FieldConfiguration']> };
  gh_ProjectV2FieldConnection: gh_ProjectV2FieldConnection;
  gh_ProjectV2FieldEdge: gh_ProjectV2FieldEdge;
  gh_ProjectV2FieldOrder: gh_ProjectV2FieldOrder;
  gh_ProjectV2FieldValue: gh_ProjectV2FieldValue;
  gh_ProjectV2Filters: gh_ProjectV2Filters;
  gh_ProjectV2Item: Omit<gh_ProjectV2Item, 'content' | 'fieldValueByName'> & { content?: Maybe<ResolversParentTypes['gh_ProjectV2ItemContent']>, fieldValueByName?: Maybe<ResolversParentTypes['gh_ProjectV2ItemFieldValue']> };
  gh_ProjectV2ItemConnection: gh_ProjectV2ItemConnection;
  gh_ProjectV2ItemContent: ResolversUnionTypes<ResolversParentTypes>['gh_ProjectV2ItemContent'];
  gh_ProjectV2ItemEdge: gh_ProjectV2ItemEdge;
  gh_ProjectV2ItemFieldDateValue: Omit<gh_ProjectV2ItemFieldDateValue, 'field'> & { field: ResolversParentTypes['gh_ProjectV2FieldConfiguration'] };
  gh_ProjectV2ItemFieldIterationValue: Omit<gh_ProjectV2ItemFieldIterationValue, 'field'> & { field: ResolversParentTypes['gh_ProjectV2FieldConfiguration'] };
  gh_ProjectV2ItemFieldLabelValue: Omit<gh_ProjectV2ItemFieldLabelValue, 'field'> & { field: ResolversParentTypes['gh_ProjectV2FieldConfiguration'] };
  gh_ProjectV2ItemFieldMilestoneValue: Omit<gh_ProjectV2ItemFieldMilestoneValue, 'field'> & { field: ResolversParentTypes['gh_ProjectV2FieldConfiguration'] };
  gh_ProjectV2ItemFieldNumberValue: Omit<gh_ProjectV2ItemFieldNumberValue, 'field'> & { field: ResolversParentTypes['gh_ProjectV2FieldConfiguration'] };
  gh_ProjectV2ItemFieldPullRequestValue: Omit<gh_ProjectV2ItemFieldPullRequestValue, 'field'> & { field: ResolversParentTypes['gh_ProjectV2FieldConfiguration'] };
  gh_ProjectV2ItemFieldRepositoryValue: Omit<gh_ProjectV2ItemFieldRepositoryValue, 'field'> & { field: ResolversParentTypes['gh_ProjectV2FieldConfiguration'] };
  gh_ProjectV2ItemFieldReviewerValue: Omit<gh_ProjectV2ItemFieldReviewerValue, 'field'> & { field: ResolversParentTypes['gh_ProjectV2FieldConfiguration'] };
  gh_ProjectV2ItemFieldSingleSelectValue: Omit<gh_ProjectV2ItemFieldSingleSelectValue, 'field'> & { field: ResolversParentTypes['gh_ProjectV2FieldConfiguration'] };
  gh_ProjectV2ItemFieldTextValue: Omit<gh_ProjectV2ItemFieldTextValue, 'field'> & { field: ResolversParentTypes['gh_ProjectV2FieldConfiguration'] };
  gh_ProjectV2ItemFieldUserValue: Omit<gh_ProjectV2ItemFieldUserValue, 'field'> & { field: ResolversParentTypes['gh_ProjectV2FieldConfiguration'] };
  gh_ProjectV2ItemFieldValue: ResolversUnionTypes<ResolversParentTypes>['gh_ProjectV2ItemFieldValue'];
  gh_ProjectV2ItemFieldValueCommon: ResolversInterfaceTypes<ResolversParentTypes>['gh_ProjectV2ItemFieldValueCommon'];
  gh_ProjectV2ItemFieldValueConnection: Omit<gh_ProjectV2ItemFieldValueConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_ProjectV2ItemFieldValue']>>> };
  gh_ProjectV2ItemFieldValueEdge: Omit<gh_ProjectV2ItemFieldValueEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_ProjectV2ItemFieldValue']> };
  gh_ProjectV2ItemFieldValueOrder: gh_ProjectV2ItemFieldValueOrder;
  gh_ProjectV2ItemOrder: gh_ProjectV2ItemOrder;
  gh_ProjectV2IterationField: gh_ProjectV2IterationField;
  gh_ProjectV2IterationFieldConfiguration: gh_ProjectV2IterationFieldConfiguration;
  gh_ProjectV2IterationFieldIteration: gh_ProjectV2IterationFieldIteration;
  gh_ProjectV2Order: gh_ProjectV2Order;
  gh_ProjectV2Owner: ResolversInterfaceTypes<ResolversParentTypes>['gh_ProjectV2Owner'];
  gh_ProjectV2Recent: ResolversInterfaceTypes<ResolversParentTypes>['gh_ProjectV2Recent'];
  gh_ProjectV2SingleSelectField: gh_ProjectV2SingleSelectField;
  gh_ProjectV2SingleSelectFieldOption: gh_ProjectV2SingleSelectFieldOption;
  gh_ProjectV2SingleSelectFieldOptionInput: gh_ProjectV2SingleSelectFieldOptionInput;
  gh_ProjectV2SortBy: gh_ProjectV2SortBy;
  gh_ProjectV2SortByConnection: gh_ProjectV2SortByConnection;
  gh_ProjectV2SortByEdge: gh_ProjectV2SortByEdge;
  gh_ProjectV2SortByField: Omit<gh_ProjectV2SortByField, 'field'> & { field: ResolversParentTypes['gh_ProjectV2FieldConfiguration'] };
  gh_ProjectV2SortByFieldConnection: gh_ProjectV2SortByFieldConnection;
  gh_ProjectV2SortByFieldEdge: gh_ProjectV2SortByFieldEdge;
  gh_ProjectV2View: gh_ProjectV2View;
  gh_ProjectV2ViewConnection: gh_ProjectV2ViewConnection;
  gh_ProjectV2ViewEdge: gh_ProjectV2ViewEdge;
  gh_ProjectV2ViewOrder: gh_ProjectV2ViewOrder;
  gh_ProjectV2Workflow: gh_ProjectV2Workflow;
  gh_ProjectV2WorkflowConnection: gh_ProjectV2WorkflowConnection;
  gh_ProjectV2WorkflowEdge: gh_ProjectV2WorkflowEdge;
  gh_ProjectV2WorkflowOrder: gh_ProjectV2WorkflowOrder;
  gh_PublicKey: gh_PublicKey;
  gh_PublicKeyConnection: gh_PublicKeyConnection;
  gh_PublicKeyEdge: gh_PublicKeyEdge;
  gh_PublishSponsorsTierInput: gh_PublishSponsorsTierInput;
  gh_PublishSponsorsTierPayload: gh_PublishSponsorsTierPayload;
  gh_PullRequest: gh_PullRequest;
  gh_PullRequestChangedFile: gh_PullRequestChangedFile;
  gh_PullRequestChangedFileConnection: gh_PullRequestChangedFileConnection;
  gh_PullRequestChangedFileEdge: gh_PullRequestChangedFileEdge;
  gh_PullRequestCommit: gh_PullRequestCommit;
  gh_PullRequestCommitCommentThread: gh_PullRequestCommitCommentThread;
  gh_PullRequestCommitConnection: gh_PullRequestCommitConnection;
  gh_PullRequestCommitEdge: gh_PullRequestCommitEdge;
  gh_PullRequestConnection: gh_PullRequestConnection;
  gh_PullRequestContributionsByRepository: gh_PullRequestContributionsByRepository;
  gh_PullRequestEdge: gh_PullRequestEdge;
  gh_PullRequestOrder: gh_PullRequestOrder;
  gh_PullRequestParameters: gh_PullRequestParameters;
  gh_PullRequestParametersInput: gh_PullRequestParametersInput;
  gh_PullRequestReview: gh_PullRequestReview;
  gh_PullRequestReviewComment: gh_PullRequestReviewComment;
  gh_PullRequestReviewCommentConnection: gh_PullRequestReviewCommentConnection;
  gh_PullRequestReviewCommentEdge: gh_PullRequestReviewCommentEdge;
  gh_PullRequestReviewConnection: gh_PullRequestReviewConnection;
  gh_PullRequestReviewContributionsByRepository: gh_PullRequestReviewContributionsByRepository;
  gh_PullRequestReviewEdge: gh_PullRequestReviewEdge;
  gh_PullRequestReviewThread: gh_PullRequestReviewThread;
  gh_PullRequestReviewThreadConnection: gh_PullRequestReviewThreadConnection;
  gh_PullRequestReviewThreadEdge: gh_PullRequestReviewThreadEdge;
  gh_PullRequestRevisionMarker: gh_PullRequestRevisionMarker;
  gh_PullRequestTemplate: gh_PullRequestTemplate;
  gh_PullRequestThread: gh_PullRequestThread;
  gh_PullRequestTimelineConnection: Omit<gh_PullRequestTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_PullRequestTimelineItem']>>> };
  gh_PullRequestTimelineItem: ResolversUnionTypes<ResolversParentTypes>['gh_PullRequestTimelineItem'];
  gh_PullRequestTimelineItemEdge: Omit<gh_PullRequestTimelineItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_PullRequestTimelineItem']> };
  gh_PullRequestTimelineItems: ResolversUnionTypes<ResolversParentTypes>['gh_PullRequestTimelineItems'];
  gh_PullRequestTimelineItemsConnection: Omit<gh_PullRequestTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_PullRequestTimelineItems']>>> };
  gh_PullRequestTimelineItemsEdge: Omit<gh_PullRequestTimelineItemsEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_PullRequestTimelineItems']> };
  gh_Push: gh_Push;
  gh_PushAllowance: Omit<gh_PushAllowance, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_PushAllowanceActor']> };
  gh_PushAllowanceActor: ResolversUnionTypes<ResolversParentTypes>['gh_PushAllowanceActor'];
  gh_PushAllowanceConnection: gh_PushAllowanceConnection;
  gh_PushAllowanceEdge: gh_PushAllowanceEdge;
  gh_RateLimit: gh_RateLimit;
  gh_Reactable: ResolversInterfaceTypes<ResolversParentTypes>['gh_Reactable'];
  gh_ReactingUserConnection: gh_ReactingUserConnection;
  gh_ReactingUserEdge: gh_ReactingUserEdge;
  gh_Reaction: gh_Reaction;
  gh_ReactionConnection: gh_ReactionConnection;
  gh_ReactionEdge: gh_ReactionEdge;
  gh_ReactionGroup: gh_ReactionGroup;
  gh_ReactionOrder: gh_ReactionOrder;
  gh_Reactor: ResolversUnionTypes<ResolversParentTypes>['gh_Reactor'];
  gh_ReactorConnection: Omit<gh_ReactorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_Reactor']>>> };
  gh_ReactorEdge: Omit<gh_ReactorEdge, 'node'> & { node: ResolversParentTypes['gh_Reactor'] };
  gh_ReadyForReviewEvent: gh_ReadyForReviewEvent;
  gh_Ref: gh_Ref;
  gh_RefConnection: gh_RefConnection;
  gh_RefEdge: gh_RefEdge;
  gh_RefNameConditionTarget: gh_RefNameConditionTarget;
  gh_RefNameConditionTargetInput: gh_RefNameConditionTargetInput;
  gh_RefOrder: gh_RefOrder;
  gh_RefUpdate: gh_RefUpdate;
  gh_RefUpdateRule: gh_RefUpdateRule;
  gh_ReferencedEvent: Omit<gh_ReferencedEvent, 'subject'> & { subject: ResolversParentTypes['gh_ReferencedSubject'] };
  gh_ReferencedSubject: ResolversUnionTypes<ResolversParentTypes>['gh_ReferencedSubject'];
  gh_RegenerateEnterpriseIdentityProviderRecoveryCodesInput: gh_RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
  gh_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: gh_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload;
  gh_RegenerateVerifiableDomainTokenInput: gh_RegenerateVerifiableDomainTokenInput;
  gh_RegenerateVerifiableDomainTokenPayload: gh_RegenerateVerifiableDomainTokenPayload;
  gh_RejectDeploymentsInput: gh_RejectDeploymentsInput;
  gh_RejectDeploymentsPayload: gh_RejectDeploymentsPayload;
  gh_Release: gh_Release;
  gh_ReleaseAsset: gh_ReleaseAsset;
  gh_ReleaseAssetConnection: gh_ReleaseAssetConnection;
  gh_ReleaseAssetEdge: gh_ReleaseAssetEdge;
  gh_ReleaseConnection: gh_ReleaseConnection;
  gh_ReleaseEdge: gh_ReleaseEdge;
  gh_ReleaseOrder: gh_ReleaseOrder;
  gh_RemoveAssigneesFromAssignableInput: gh_RemoveAssigneesFromAssignableInput;
  gh_RemoveAssigneesFromAssignablePayload: gh_RemoveAssigneesFromAssignablePayload;
  gh_RemoveEnterpriseAdminInput: gh_RemoveEnterpriseAdminInput;
  gh_RemoveEnterpriseAdminPayload: gh_RemoveEnterpriseAdminPayload;
  gh_RemoveEnterpriseIdentityProviderInput: gh_RemoveEnterpriseIdentityProviderInput;
  gh_RemoveEnterpriseIdentityProviderPayload: gh_RemoveEnterpriseIdentityProviderPayload;
  gh_RemoveEnterpriseMemberInput: gh_RemoveEnterpriseMemberInput;
  gh_RemoveEnterpriseMemberPayload: gh_RemoveEnterpriseMemberPayload;
  gh_RemoveEnterpriseOrganizationInput: gh_RemoveEnterpriseOrganizationInput;
  gh_RemoveEnterpriseOrganizationPayload: gh_RemoveEnterpriseOrganizationPayload;
  gh_RemoveEnterpriseSupportEntitlementInput: gh_RemoveEnterpriseSupportEntitlementInput;
  gh_RemoveEnterpriseSupportEntitlementPayload: gh_RemoveEnterpriseSupportEntitlementPayload;
  gh_RemoveLabelsFromLabelableInput: gh_RemoveLabelsFromLabelableInput;
  gh_RemoveLabelsFromLabelablePayload: gh_RemoveLabelsFromLabelablePayload;
  gh_RemoveOutsideCollaboratorInput: gh_RemoveOutsideCollaboratorInput;
  gh_RemoveOutsideCollaboratorPayload: gh_RemoveOutsideCollaboratorPayload;
  gh_RemoveReactionInput: gh_RemoveReactionInput;
  gh_RemoveReactionPayload: gh_RemoveReactionPayload;
  gh_RemoveStarInput: gh_RemoveStarInput;
  gh_RemoveStarPayload: gh_RemoveStarPayload;
  gh_RemoveUpvoteInput: gh_RemoveUpvoteInput;
  gh_RemoveUpvotePayload: gh_RemoveUpvotePayload;
  gh_RemovedFromMergeQueueEvent: gh_RemovedFromMergeQueueEvent;
  gh_RemovedFromProjectEvent: gh_RemovedFromProjectEvent;
  gh_RenamedTitleEvent: Omit<gh_RenamedTitleEvent, 'subject'> & { subject: ResolversParentTypes['gh_RenamedTitleSubject'] };
  gh_RenamedTitleSubject: ResolversUnionTypes<ResolversParentTypes>['gh_RenamedTitleSubject'];
  gh_ReopenDiscussionInput: gh_ReopenDiscussionInput;
  gh_ReopenDiscussionPayload: gh_ReopenDiscussionPayload;
  gh_ReopenIssueInput: gh_ReopenIssueInput;
  gh_ReopenIssuePayload: gh_ReopenIssuePayload;
  gh_ReopenPullRequestInput: gh_ReopenPullRequestInput;
  gh_ReopenPullRequestPayload: gh_ReopenPullRequestPayload;
  gh_ReopenedEvent: gh_ReopenedEvent;
  gh_RepoAccessAuditEntry: Omit<gh_RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoAddMemberAuditEntry: Omit<gh_RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoAddTopicAuditEntry: Omit<gh_RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoArchivedAuditEntry: Omit<gh_RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoChangeMergeSettingAuditEntry: Omit<gh_RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoConfigDisableAnonymousGitAccessAuditEntry: Omit<gh_RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoConfigDisableCollaboratorsOnlyAuditEntry: Omit<gh_RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoConfigDisableContributorsOnlyAuditEntry: Omit<gh_RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoConfigDisableSockpuppetDisallowedAuditEntry: Omit<gh_RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoConfigEnableAnonymousGitAccessAuditEntry: Omit<gh_RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoConfigEnableCollaboratorsOnlyAuditEntry: Omit<gh_RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoConfigEnableContributorsOnlyAuditEntry: Omit<gh_RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoConfigEnableSockpuppetDisallowedAuditEntry: Omit<gh_RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoConfigLockAnonymousGitAccessAuditEntry: Omit<gh_RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoConfigUnlockAnonymousGitAccessAuditEntry: Omit<gh_RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoCreateAuditEntry: Omit<gh_RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoDestroyAuditEntry: Omit<gh_RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoRemoveMemberAuditEntry: Omit<gh_RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepoRemoveTopicAuditEntry: Omit<gh_RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_Repository: Omit<gh_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<ResolversParentTypes['gh_IssueOrPullRequest']> };
  gh_RepositoryAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>['gh_RepositoryAuditEntryData'];
  gh_RepositoryCodeowners: gh_RepositoryCodeowners;
  gh_RepositoryCodeownersError: gh_RepositoryCodeownersError;
  gh_RepositoryCollaboratorConnection: gh_RepositoryCollaboratorConnection;
  gh_RepositoryCollaboratorEdge: gh_RepositoryCollaboratorEdge;
  gh_RepositoryConnection: gh_RepositoryConnection;
  gh_RepositoryContactLink: gh_RepositoryContactLink;
  gh_RepositoryDiscussionAuthor: ResolversInterfaceTypes<ResolversParentTypes>['gh_RepositoryDiscussionAuthor'];
  gh_RepositoryDiscussionCommentAuthor: ResolversInterfaceTypes<ResolversParentTypes>['gh_RepositoryDiscussionCommentAuthor'];
  gh_RepositoryEdge: gh_RepositoryEdge;
  gh_RepositoryIdConditionTarget: gh_RepositoryIdConditionTarget;
  gh_RepositoryIdConditionTargetInput: gh_RepositoryIdConditionTargetInput;
  gh_RepositoryInfo: ResolversInterfaceTypes<ResolversParentTypes>['gh_RepositoryInfo'];
  gh_RepositoryInteractionAbility: gh_RepositoryInteractionAbility;
  gh_RepositoryInvitation: gh_RepositoryInvitation;
  gh_RepositoryInvitationConnection: gh_RepositoryInvitationConnection;
  gh_RepositoryInvitationEdge: gh_RepositoryInvitationEdge;
  gh_RepositoryInvitationOrder: gh_RepositoryInvitationOrder;
  gh_RepositoryMigration: gh_RepositoryMigration;
  gh_RepositoryMigrationConnection: gh_RepositoryMigrationConnection;
  gh_RepositoryMigrationEdge: gh_RepositoryMigrationEdge;
  gh_RepositoryMigrationOrder: gh_RepositoryMigrationOrder;
  gh_RepositoryNameConditionTarget: gh_RepositoryNameConditionTarget;
  gh_RepositoryNameConditionTargetInput: gh_RepositoryNameConditionTargetInput;
  gh_RepositoryNode: ResolversInterfaceTypes<ResolversParentTypes>['gh_RepositoryNode'];
  gh_RepositoryOrder: gh_RepositoryOrder;
  gh_RepositoryOwner: ResolversInterfaceTypes<ResolversParentTypes>['gh_RepositoryOwner'];
  gh_RepositoryRule: Omit<gh_RepositoryRule, 'parameters'> & { parameters?: Maybe<ResolversParentTypes['gh_RuleParameters']> };
  gh_RepositoryRuleConditions: gh_RepositoryRuleConditions;
  gh_RepositoryRuleConditionsInput: gh_RepositoryRuleConditionsInput;
  gh_RepositoryRuleConnection: gh_RepositoryRuleConnection;
  gh_RepositoryRuleEdge: gh_RepositoryRuleEdge;
  gh_RepositoryRuleInput: gh_RepositoryRuleInput;
  gh_RepositoryRuleset: Omit<gh_RepositoryRuleset, 'source'> & { source: ResolversParentTypes['gh_RuleSource'] };
  gh_RepositoryRulesetBypassActor: Omit<gh_RepositoryRulesetBypassActor, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_BypassActor']> };
  gh_RepositoryRulesetBypassActorConnection: gh_RepositoryRulesetBypassActorConnection;
  gh_RepositoryRulesetBypassActorEdge: gh_RepositoryRulesetBypassActorEdge;
  gh_RepositoryRulesetBypassActorInput: gh_RepositoryRulesetBypassActorInput;
  gh_RepositoryRulesetConnection: gh_RepositoryRulesetConnection;
  gh_RepositoryRulesetEdge: gh_RepositoryRulesetEdge;
  gh_RepositoryTopic: gh_RepositoryTopic;
  gh_RepositoryTopicConnection: gh_RepositoryTopicConnection;
  gh_RepositoryTopicEdge: gh_RepositoryTopicEdge;
  gh_RepositoryVisibilityChangeDisableAuditEntry: Omit<gh_RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepositoryVisibilityChangeEnableAuditEntry: Omit<gh_RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_RepositoryVulnerabilityAlert: gh_RepositoryVulnerabilityAlert;
  gh_RepositoryVulnerabilityAlertConnection: gh_RepositoryVulnerabilityAlertConnection;
  gh_RepositoryVulnerabilityAlertEdge: gh_RepositoryVulnerabilityAlertEdge;
  gh_RequestReviewsInput: gh_RequestReviewsInput;
  gh_RequestReviewsPayload: gh_RequestReviewsPayload;
  gh_RequestedReviewer: ResolversUnionTypes<ResolversParentTypes>['gh_RequestedReviewer'];
  gh_RequestedReviewerConnection: Omit<gh_RequestedReviewerConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_RequestedReviewer']>>> };
  gh_RequestedReviewerEdge: Omit<gh_RequestedReviewerEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_RequestedReviewer']> };
  gh_RequirableByPullRequest: ResolversInterfaceTypes<ResolversParentTypes>['gh_RequirableByPullRequest'];
  gh_RequiredDeploymentsParameters: gh_RequiredDeploymentsParameters;
  gh_RequiredDeploymentsParametersInput: gh_RequiredDeploymentsParametersInput;
  gh_RequiredStatusCheckDescription: gh_RequiredStatusCheckDescription;
  gh_RequiredStatusCheckInput: gh_RequiredStatusCheckInput;
  gh_RequiredStatusChecksParameters: gh_RequiredStatusChecksParameters;
  gh_RequiredStatusChecksParametersInput: gh_RequiredStatusChecksParametersInput;
  gh_RerequestCheckSuiteInput: gh_RerequestCheckSuiteInput;
  gh_RerequestCheckSuitePayload: gh_RerequestCheckSuitePayload;
  gh_ResolveReviewThreadInput: gh_ResolveReviewThreadInput;
  gh_ResolveReviewThreadPayload: gh_ResolveReviewThreadPayload;
  gh_RestrictedContribution: gh_RestrictedContribution;
  gh_RetireSponsorsTierInput: gh_RetireSponsorsTierInput;
  gh_RetireSponsorsTierPayload: gh_RetireSponsorsTierPayload;
  gh_RevertPullRequestInput: gh_RevertPullRequestInput;
  gh_RevertPullRequestPayload: gh_RevertPullRequestPayload;
  gh_ReviewDismissalAllowance: Omit<gh_ReviewDismissalAllowance, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_ReviewDismissalAllowanceActor']> };
  gh_ReviewDismissalAllowanceActor: ResolversUnionTypes<ResolversParentTypes>['gh_ReviewDismissalAllowanceActor'];
  gh_ReviewDismissalAllowanceConnection: gh_ReviewDismissalAllowanceConnection;
  gh_ReviewDismissalAllowanceEdge: gh_ReviewDismissalAllowanceEdge;
  gh_ReviewDismissedEvent: gh_ReviewDismissedEvent;
  gh_ReviewRequest: Omit<gh_ReviewRequest, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversParentTypes['gh_RequestedReviewer']> };
  gh_ReviewRequestConnection: gh_ReviewRequestConnection;
  gh_ReviewRequestEdge: gh_ReviewRequestEdge;
  gh_ReviewRequestRemovedEvent: Omit<gh_ReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversParentTypes['gh_RequestedReviewer']> };
  gh_ReviewRequestedEvent: Omit<gh_ReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversParentTypes['gh_RequestedReviewer']> };
  gh_ReviewStatusHovercardContext: gh_ReviewStatusHovercardContext;
  gh_RevokeEnterpriseOrganizationsMigratorRoleInput: gh_RevokeEnterpriseOrganizationsMigratorRoleInput;
  gh_RevokeEnterpriseOrganizationsMigratorRolePayload: gh_RevokeEnterpriseOrganizationsMigratorRolePayload;
  gh_RevokeMigratorRoleInput: gh_RevokeMigratorRoleInput;
  gh_RevokeMigratorRolePayload: gh_RevokeMigratorRolePayload;
  gh_RuleParameters: ResolversUnionTypes<ResolversParentTypes>['gh_RuleParameters'];
  gh_RuleParametersInput: gh_RuleParametersInput;
  gh_RuleSource: ResolversUnionTypes<ResolversParentTypes>['gh_RuleSource'];
  gh_SavedReply: gh_SavedReply;
  gh_SavedReplyConnection: gh_SavedReplyConnection;
  gh_SavedReplyEdge: gh_SavedReplyEdge;
  gh_SavedReplyOrder: gh_SavedReplyOrder;
  gh_SearchResultItem: ResolversUnionTypes<ResolversParentTypes>['gh_SearchResultItem'];
  gh_SearchResultItemConnection: Omit<gh_SearchResultItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_SearchResultItem']>>> };
  gh_SearchResultItemEdge: Omit<gh_SearchResultItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_SearchResultItem']> };
  gh_SecurityAdvisory: gh_SecurityAdvisory;
  gh_SecurityAdvisoryConnection: gh_SecurityAdvisoryConnection;
  gh_SecurityAdvisoryEdge: gh_SecurityAdvisoryEdge;
  gh_SecurityAdvisoryIdentifier: gh_SecurityAdvisoryIdentifier;
  gh_SecurityAdvisoryIdentifierFilter: gh_SecurityAdvisoryIdentifierFilter;
  gh_SecurityAdvisoryOrder: gh_SecurityAdvisoryOrder;
  gh_SecurityAdvisoryPackage: gh_SecurityAdvisoryPackage;
  gh_SecurityAdvisoryPackageVersion: gh_SecurityAdvisoryPackageVersion;
  gh_SecurityAdvisoryReference: gh_SecurityAdvisoryReference;
  gh_SecurityVulnerability: gh_SecurityVulnerability;
  gh_SecurityVulnerabilityConnection: gh_SecurityVulnerabilityConnection;
  gh_SecurityVulnerabilityEdge: gh_SecurityVulnerabilityEdge;
  gh_SecurityVulnerabilityOrder: gh_SecurityVulnerabilityOrder;
  gh_SetEnterpriseIdentityProviderInput: gh_SetEnterpriseIdentityProviderInput;
  gh_SetEnterpriseIdentityProviderPayload: gh_SetEnterpriseIdentityProviderPayload;
  gh_SetOrganizationInteractionLimitInput: gh_SetOrganizationInteractionLimitInput;
  gh_SetOrganizationInteractionLimitPayload: gh_SetOrganizationInteractionLimitPayload;
  gh_SetRepositoryInteractionLimitInput: gh_SetRepositoryInteractionLimitInput;
  gh_SetRepositoryInteractionLimitPayload: gh_SetRepositoryInteractionLimitPayload;
  gh_SetUserInteractionLimitInput: gh_SetUserInteractionLimitInput;
  gh_SetUserInteractionLimitPayload: gh_SetUserInteractionLimitPayload;
  gh_SmimeSignature: gh_SmimeSignature;
  gh_SocialAccount: gh_SocialAccount;
  gh_SocialAccountConnection: gh_SocialAccountConnection;
  gh_SocialAccountEdge: gh_SocialAccountEdge;
  gh_Sponsor: ResolversUnionTypes<ResolversParentTypes>['gh_Sponsor'];
  gh_SponsorConnection: Omit<gh_SponsorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_Sponsor']>>> };
  gh_SponsorEdge: Omit<gh_SponsorEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_Sponsor']> };
  gh_SponsorOrder: gh_SponsorOrder;
  gh_Sponsorable: ResolversInterfaceTypes<ResolversParentTypes>['gh_Sponsorable'];
  gh_SponsorableItem: ResolversUnionTypes<ResolversParentTypes>['gh_SponsorableItem'];
  gh_SponsorableItemConnection: Omit<gh_SponsorableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_SponsorableItem']>>> };
  gh_SponsorableItemEdge: Omit<gh_SponsorableItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_SponsorableItem']> };
  gh_SponsorableOrder: gh_SponsorableOrder;
  gh_SponsorsActivity: Omit<gh_SponsorsActivity, 'sponsor'> & { sponsor?: Maybe<ResolversParentTypes['gh_Sponsor']> };
  gh_SponsorsActivityConnection: gh_SponsorsActivityConnection;
  gh_SponsorsActivityEdge: gh_SponsorsActivityEdge;
  gh_SponsorsActivityOrder: gh_SponsorsActivityOrder;
  gh_SponsorsGoal: gh_SponsorsGoal;
  gh_SponsorsListing: gh_SponsorsListing;
  gh_SponsorsListingFeatureableItem: ResolversUnionTypes<ResolversParentTypes>['gh_SponsorsListingFeatureableItem'];
  gh_SponsorsListingFeaturedItem: Omit<gh_SponsorsListingFeaturedItem, 'featureable'> & { featureable: ResolversParentTypes['gh_SponsorsListingFeatureableItem'] };
  gh_SponsorsTier: gh_SponsorsTier;
  gh_SponsorsTierAdminInfo: gh_SponsorsTierAdminInfo;
  gh_SponsorsTierConnection: gh_SponsorsTierConnection;
  gh_SponsorsTierEdge: gh_SponsorsTierEdge;
  gh_SponsorsTierOrder: gh_SponsorsTierOrder;
  gh_Sponsorship: Omit<gh_Sponsorship, 'sponsorEntity'> & { sponsorEntity?: Maybe<ResolversParentTypes['gh_Sponsor']> };
  gh_SponsorshipConnection: gh_SponsorshipConnection;
  gh_SponsorshipEdge: gh_SponsorshipEdge;
  gh_SponsorshipNewsletter: gh_SponsorshipNewsletter;
  gh_SponsorshipNewsletterConnection: gh_SponsorshipNewsletterConnection;
  gh_SponsorshipNewsletterEdge: gh_SponsorshipNewsletterEdge;
  gh_SponsorshipNewsletterOrder: gh_SponsorshipNewsletterOrder;
  gh_SponsorshipOrder: gh_SponsorshipOrder;
  gh_SshSignature: gh_SshSignature;
  gh_StarOrder: gh_StarOrder;
  gh_StargazerConnection: gh_StargazerConnection;
  gh_StargazerEdge: gh_StargazerEdge;
  gh_Starrable: ResolversInterfaceTypes<ResolversParentTypes>['gh_Starrable'];
  gh_StarredRepositoryConnection: gh_StarredRepositoryConnection;
  gh_StarredRepositoryEdge: gh_StarredRepositoryEdge;
  gh_StartOrganizationMigrationInput: gh_StartOrganizationMigrationInput;
  gh_StartOrganizationMigrationPayload: gh_StartOrganizationMigrationPayload;
  gh_StartRepositoryMigrationInput: gh_StartRepositoryMigrationInput;
  gh_StartRepositoryMigrationPayload: gh_StartRepositoryMigrationPayload;
  gh_Status: gh_Status;
  gh_StatusCheckConfiguration: gh_StatusCheckConfiguration;
  gh_StatusCheckConfigurationInput: gh_StatusCheckConfigurationInput;
  gh_StatusCheckRollup: gh_StatusCheckRollup;
  gh_StatusCheckRollupContext: ResolversUnionTypes<ResolversParentTypes>['gh_StatusCheckRollupContext'];
  gh_StatusCheckRollupContextConnection: Omit<gh_StatusCheckRollupContextConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_StatusCheckRollupContext']>>> };
  gh_StatusCheckRollupContextEdge: Omit<gh_StatusCheckRollupContextEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_StatusCheckRollupContext']> };
  gh_StatusContext: gh_StatusContext;
  gh_StatusContextStateCount: gh_StatusContextStateCount;
  gh_StripeConnectAccount: gh_StripeConnectAccount;
  gh_SubmitPullRequestReviewInput: gh_SubmitPullRequestReviewInput;
  gh_SubmitPullRequestReviewPayload: gh_SubmitPullRequestReviewPayload;
  gh_Submodule: gh_Submodule;
  gh_SubmoduleConnection: gh_SubmoduleConnection;
  gh_SubmoduleEdge: gh_SubmoduleEdge;
  gh_Subscribable: ResolversInterfaceTypes<ResolversParentTypes>['gh_Subscribable'];
  gh_SubscribableThread: ResolversInterfaceTypes<ResolversParentTypes>['gh_SubscribableThread'];
  gh_SubscribedEvent: gh_SubscribedEvent;
  gh_SuggestedReviewer: gh_SuggestedReviewer;
  gh_Tag: gh_Tag;
  gh_TagNamePatternParameters: gh_TagNamePatternParameters;
  gh_TagNamePatternParametersInput: gh_TagNamePatternParametersInput;
  gh_Team: gh_Team;
  gh_TeamAddMemberAuditEntry: Omit<gh_TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_TeamAddRepositoryAuditEntry: Omit<gh_TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_TeamAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>['gh_TeamAuditEntryData'];
  gh_TeamChangeParentTeamAuditEntry: Omit<gh_TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_TeamConnection: gh_TeamConnection;
  gh_TeamDiscussion: gh_TeamDiscussion;
  gh_TeamDiscussionComment: gh_TeamDiscussionComment;
  gh_TeamDiscussionCommentConnection: gh_TeamDiscussionCommentConnection;
  gh_TeamDiscussionCommentEdge: gh_TeamDiscussionCommentEdge;
  gh_TeamDiscussionCommentOrder: gh_TeamDiscussionCommentOrder;
  gh_TeamDiscussionConnection: gh_TeamDiscussionConnection;
  gh_TeamDiscussionEdge: gh_TeamDiscussionEdge;
  gh_TeamDiscussionOrder: gh_TeamDiscussionOrder;
  gh_TeamEdge: gh_TeamEdge;
  gh_TeamMemberConnection: gh_TeamMemberConnection;
  gh_TeamMemberEdge: gh_TeamMemberEdge;
  gh_TeamMemberOrder: gh_TeamMemberOrder;
  gh_TeamOrder: gh_TeamOrder;
  gh_TeamRemoveMemberAuditEntry: Omit<gh_TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_TeamRemoveRepositoryAuditEntry: Omit<gh_TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['gh_AuditEntryActor']> };
  gh_TeamRepositoryConnection: gh_TeamRepositoryConnection;
  gh_TeamRepositoryEdge: gh_TeamRepositoryEdge;
  gh_TeamRepositoryOrder: gh_TeamRepositoryOrder;
  gh_TextMatch: gh_TextMatch;
  gh_TextMatchHighlight: gh_TextMatchHighlight;
  gh_Topic: gh_Topic;
  gh_TopicAuditEntryData: ResolversInterfaceTypes<ResolversParentTypes>['gh_TopicAuditEntryData'];
  gh_TransferEnterpriseOrganizationInput: gh_TransferEnterpriseOrganizationInput;
  gh_TransferEnterpriseOrganizationPayload: gh_TransferEnterpriseOrganizationPayload;
  gh_TransferIssueInput: gh_TransferIssueInput;
  gh_TransferIssuePayload: gh_TransferIssuePayload;
  gh_TransferredEvent: gh_TransferredEvent;
  gh_Tree: gh_Tree;
  gh_TreeEntry: gh_TreeEntry;
  gh_URI: Scalars['gh_URI']['output'];
  gh_UnarchiveProjectV2ItemInput: gh_UnarchiveProjectV2ItemInput;
  gh_UnarchiveProjectV2ItemPayload: gh_UnarchiveProjectV2ItemPayload;
  gh_UnarchiveRepositoryInput: gh_UnarchiveRepositoryInput;
  gh_UnarchiveRepositoryPayload: gh_UnarchiveRepositoryPayload;
  gh_UnassignedEvent: Omit<gh_UnassignedEvent, 'assignee'> & { assignee?: Maybe<ResolversParentTypes['gh_Assignee']> };
  gh_UnfollowOrganizationInput: gh_UnfollowOrganizationInput;
  gh_UnfollowOrganizationPayload: gh_UnfollowOrganizationPayload;
  gh_UnfollowUserInput: gh_UnfollowUserInput;
  gh_UnfollowUserPayload: gh_UnfollowUserPayload;
  gh_UniformResourceLocatable: ResolversInterfaceTypes<ResolversParentTypes>['gh_UniformResourceLocatable'];
  gh_UnknownSignature: gh_UnknownSignature;
  gh_UnlabeledEvent: gh_UnlabeledEvent;
  gh_UnlinkProjectV2FromRepositoryInput: gh_UnlinkProjectV2FromRepositoryInput;
  gh_UnlinkProjectV2FromRepositoryPayload: gh_UnlinkProjectV2FromRepositoryPayload;
  gh_UnlinkProjectV2FromTeamInput: gh_UnlinkProjectV2FromTeamInput;
  gh_UnlinkProjectV2FromTeamPayload: gh_UnlinkProjectV2FromTeamPayload;
  gh_UnlinkRepositoryFromProjectInput: gh_UnlinkRepositoryFromProjectInput;
  gh_UnlinkRepositoryFromProjectPayload: gh_UnlinkRepositoryFromProjectPayload;
  gh_UnlockLockableInput: gh_UnlockLockableInput;
  gh_UnlockLockablePayload: gh_UnlockLockablePayload;
  gh_UnlockedEvent: gh_UnlockedEvent;
  gh_UnmarkDiscussionCommentAsAnswerInput: gh_UnmarkDiscussionCommentAsAnswerInput;
  gh_UnmarkDiscussionCommentAsAnswerPayload: gh_UnmarkDiscussionCommentAsAnswerPayload;
  gh_UnmarkFileAsViewedInput: gh_UnmarkFileAsViewedInput;
  gh_UnmarkFileAsViewedPayload: gh_UnmarkFileAsViewedPayload;
  gh_UnmarkIssueAsDuplicateInput: gh_UnmarkIssueAsDuplicateInput;
  gh_UnmarkIssueAsDuplicatePayload: Omit<gh_UnmarkIssueAsDuplicatePayload, 'duplicate'> & { duplicate?: Maybe<ResolversParentTypes['gh_IssueOrPullRequest']> };
  gh_UnmarkProjectV2AsTemplateInput: gh_UnmarkProjectV2AsTemplateInput;
  gh_UnmarkProjectV2AsTemplatePayload: gh_UnmarkProjectV2AsTemplatePayload;
  gh_UnmarkedAsDuplicateEvent: Omit<gh_UnmarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<ResolversParentTypes['gh_IssueOrPullRequest']>, duplicate?: Maybe<ResolversParentTypes['gh_IssueOrPullRequest']> };
  gh_UnminimizeCommentInput: gh_UnminimizeCommentInput;
  gh_UnminimizeCommentPayload: gh_UnminimizeCommentPayload;
  gh_UnpinIssueInput: gh_UnpinIssueInput;
  gh_UnpinIssuePayload: gh_UnpinIssuePayload;
  gh_UnpinnedEvent: gh_UnpinnedEvent;
  gh_UnresolveReviewThreadInput: gh_UnresolveReviewThreadInput;
  gh_UnresolveReviewThreadPayload: gh_UnresolveReviewThreadPayload;
  gh_UnsubscribeFromNotificationsInput: gh_UnsubscribeFromNotificationsInput;
  gh_UnsubscribeFromNotificationsPayload: gh_UnsubscribeFromNotificationsPayload;
  gh_UnsubscribedEvent: gh_UnsubscribedEvent;
  gh_Updatable: ResolversInterfaceTypes<ResolversParentTypes>['gh_Updatable'];
  gh_UpdatableComment: ResolversInterfaceTypes<ResolversParentTypes>['gh_UpdatableComment'];
  gh_UpdateBranchProtectionRuleInput: gh_UpdateBranchProtectionRuleInput;
  gh_UpdateBranchProtectionRulePayload: gh_UpdateBranchProtectionRulePayload;
  gh_UpdateCheckRunInput: gh_UpdateCheckRunInput;
  gh_UpdateCheckRunPayload: gh_UpdateCheckRunPayload;
  gh_UpdateCheckSuitePreferencesInput: gh_UpdateCheckSuitePreferencesInput;
  gh_UpdateCheckSuitePreferencesPayload: gh_UpdateCheckSuitePreferencesPayload;
  gh_UpdateDiscussionCommentInput: gh_UpdateDiscussionCommentInput;
  gh_UpdateDiscussionCommentPayload: gh_UpdateDiscussionCommentPayload;
  gh_UpdateDiscussionInput: gh_UpdateDiscussionInput;
  gh_UpdateDiscussionPayload: gh_UpdateDiscussionPayload;
  gh_UpdateEnterpriseAdministratorRoleInput: gh_UpdateEnterpriseAdministratorRoleInput;
  gh_UpdateEnterpriseAdministratorRolePayload: gh_UpdateEnterpriseAdministratorRolePayload;
  gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput: gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
  gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload;
  gh_UpdateEnterpriseDefaultRepositoryPermissionSettingInput: gh_UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
  gh_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: gh_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload;
  gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput: gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
  gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload;
  gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput: gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
  gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload;
  gh_UpdateEnterpriseMembersCanDeleteIssuesSettingInput: gh_UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
  gh_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: gh_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload;
  gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput: gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
  gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload;
  gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput: gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
  gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload;
  gh_UpdateEnterpriseMembersCanMakePurchasesSettingInput: gh_UpdateEnterpriseMembersCanMakePurchasesSettingInput;
  gh_UpdateEnterpriseMembersCanMakePurchasesSettingPayload: gh_UpdateEnterpriseMembersCanMakePurchasesSettingPayload;
  gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput: gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
  gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload;
  gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput: gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
  gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload;
  gh_UpdateEnterpriseOrganizationProjectsSettingInput: gh_UpdateEnterpriseOrganizationProjectsSettingInput;
  gh_UpdateEnterpriseOrganizationProjectsSettingPayload: gh_UpdateEnterpriseOrganizationProjectsSettingPayload;
  gh_UpdateEnterpriseOwnerOrganizationRoleInput: gh_UpdateEnterpriseOwnerOrganizationRoleInput;
  gh_UpdateEnterpriseOwnerOrganizationRolePayload: gh_UpdateEnterpriseOwnerOrganizationRolePayload;
  gh_UpdateEnterpriseProfileInput: gh_UpdateEnterpriseProfileInput;
  gh_UpdateEnterpriseProfilePayload: gh_UpdateEnterpriseProfilePayload;
  gh_UpdateEnterpriseRepositoryProjectsSettingInput: gh_UpdateEnterpriseRepositoryProjectsSettingInput;
  gh_UpdateEnterpriseRepositoryProjectsSettingPayload: gh_UpdateEnterpriseRepositoryProjectsSettingPayload;
  gh_UpdateEnterpriseTeamDiscussionsSettingInput: gh_UpdateEnterpriseTeamDiscussionsSettingInput;
  gh_UpdateEnterpriseTeamDiscussionsSettingPayload: gh_UpdateEnterpriseTeamDiscussionsSettingPayload;
  gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput: gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
  gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload;
  gh_UpdateEnvironmentInput: gh_UpdateEnvironmentInput;
  gh_UpdateEnvironmentPayload: gh_UpdateEnvironmentPayload;
  gh_UpdateIpAllowListEnabledSettingInput: gh_UpdateIpAllowListEnabledSettingInput;
  gh_UpdateIpAllowListEnabledSettingPayload: Omit<gh_UpdateIpAllowListEnabledSettingPayload, 'owner'> & { owner?: Maybe<ResolversParentTypes['gh_IpAllowListOwner']> };
  gh_UpdateIpAllowListEntryInput: gh_UpdateIpAllowListEntryInput;
  gh_UpdateIpAllowListEntryPayload: gh_UpdateIpAllowListEntryPayload;
  gh_UpdateIpAllowListForInstalledAppsEnabledSettingInput: gh_UpdateIpAllowListForInstalledAppsEnabledSettingInput;
  gh_UpdateIpAllowListForInstalledAppsEnabledSettingPayload: Omit<gh_UpdateIpAllowListForInstalledAppsEnabledSettingPayload, 'owner'> & { owner?: Maybe<ResolversParentTypes['gh_IpAllowListOwner']> };
  gh_UpdateIssueCommentInput: gh_UpdateIssueCommentInput;
  gh_UpdateIssueCommentPayload: gh_UpdateIssueCommentPayload;
  gh_UpdateIssueInput: gh_UpdateIssueInput;
  gh_UpdateIssuePayload: gh_UpdateIssuePayload;
  gh_UpdateLabelInput: gh_UpdateLabelInput;
  gh_UpdateLabelPayload: gh_UpdateLabelPayload;
  gh_UpdateNotificationRestrictionSettingInput: gh_UpdateNotificationRestrictionSettingInput;
  gh_UpdateNotificationRestrictionSettingPayload: Omit<gh_UpdateNotificationRestrictionSettingPayload, 'owner'> & { owner?: Maybe<ResolversParentTypes['gh_VerifiableDomainOwner']> };
  gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput: gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
  gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload: gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload;
  gh_UpdateOrganizationWebCommitSignoffSettingInput: gh_UpdateOrganizationWebCommitSignoffSettingInput;
  gh_UpdateOrganizationWebCommitSignoffSettingPayload: gh_UpdateOrganizationWebCommitSignoffSettingPayload;
  gh_UpdateParameters: gh_UpdateParameters;
  gh_UpdateParametersInput: gh_UpdateParametersInput;
  gh_UpdatePatreonSponsorabilityInput: gh_UpdatePatreonSponsorabilityInput;
  gh_UpdatePatreonSponsorabilityPayload: gh_UpdatePatreonSponsorabilityPayload;
  gh_UpdateProjectCardInput: gh_UpdateProjectCardInput;
  gh_UpdateProjectCardPayload: gh_UpdateProjectCardPayload;
  gh_UpdateProjectColumnInput: gh_UpdateProjectColumnInput;
  gh_UpdateProjectColumnPayload: gh_UpdateProjectColumnPayload;
  gh_UpdateProjectInput: gh_UpdateProjectInput;
  gh_UpdateProjectPayload: gh_UpdateProjectPayload;
  gh_UpdateProjectV2CollaboratorsInput: gh_UpdateProjectV2CollaboratorsInput;
  gh_UpdateProjectV2CollaboratorsPayload: gh_UpdateProjectV2CollaboratorsPayload;
  gh_UpdateProjectV2DraftIssueInput: gh_UpdateProjectV2DraftIssueInput;
  gh_UpdateProjectV2DraftIssuePayload: gh_UpdateProjectV2DraftIssuePayload;
  gh_UpdateProjectV2Input: gh_UpdateProjectV2Input;
  gh_UpdateProjectV2ItemFieldValueInput: gh_UpdateProjectV2ItemFieldValueInput;
  gh_UpdateProjectV2ItemFieldValuePayload: gh_UpdateProjectV2ItemFieldValuePayload;
  gh_UpdateProjectV2ItemPositionInput: gh_UpdateProjectV2ItemPositionInput;
  gh_UpdateProjectV2ItemPositionPayload: gh_UpdateProjectV2ItemPositionPayload;
  gh_UpdateProjectV2Payload: gh_UpdateProjectV2Payload;
  gh_UpdatePullRequestBranchInput: gh_UpdatePullRequestBranchInput;
  gh_UpdatePullRequestBranchPayload: gh_UpdatePullRequestBranchPayload;
  gh_UpdatePullRequestInput: gh_UpdatePullRequestInput;
  gh_UpdatePullRequestPayload: gh_UpdatePullRequestPayload;
  gh_UpdatePullRequestReviewCommentInput: gh_UpdatePullRequestReviewCommentInput;
  gh_UpdatePullRequestReviewCommentPayload: gh_UpdatePullRequestReviewCommentPayload;
  gh_UpdatePullRequestReviewInput: gh_UpdatePullRequestReviewInput;
  gh_UpdatePullRequestReviewPayload: gh_UpdatePullRequestReviewPayload;
  gh_UpdateRefInput: gh_UpdateRefInput;
  gh_UpdateRefPayload: gh_UpdateRefPayload;
  gh_UpdateRefsInput: gh_UpdateRefsInput;
  gh_UpdateRefsPayload: gh_UpdateRefsPayload;
  gh_UpdateRepositoryInput: gh_UpdateRepositoryInput;
  gh_UpdateRepositoryPayload: gh_UpdateRepositoryPayload;
  gh_UpdateRepositoryRulesetInput: gh_UpdateRepositoryRulesetInput;
  gh_UpdateRepositoryRulesetPayload: gh_UpdateRepositoryRulesetPayload;
  gh_UpdateRepositoryWebCommitSignoffSettingInput: gh_UpdateRepositoryWebCommitSignoffSettingInput;
  gh_UpdateRepositoryWebCommitSignoffSettingPayload: gh_UpdateRepositoryWebCommitSignoffSettingPayload;
  gh_UpdateSponsorshipPreferencesInput: gh_UpdateSponsorshipPreferencesInput;
  gh_UpdateSponsorshipPreferencesPayload: gh_UpdateSponsorshipPreferencesPayload;
  gh_UpdateSubscriptionInput: gh_UpdateSubscriptionInput;
  gh_UpdateSubscriptionPayload: gh_UpdateSubscriptionPayload;
  gh_UpdateTeamDiscussionCommentInput: gh_UpdateTeamDiscussionCommentInput;
  gh_UpdateTeamDiscussionCommentPayload: gh_UpdateTeamDiscussionCommentPayload;
  gh_UpdateTeamDiscussionInput: gh_UpdateTeamDiscussionInput;
  gh_UpdateTeamDiscussionPayload: gh_UpdateTeamDiscussionPayload;
  gh_UpdateTeamReviewAssignmentInput: gh_UpdateTeamReviewAssignmentInput;
  gh_UpdateTeamReviewAssignmentPayload: gh_UpdateTeamReviewAssignmentPayload;
  gh_UpdateTeamsRepositoryInput: gh_UpdateTeamsRepositoryInput;
  gh_UpdateTeamsRepositoryPayload: gh_UpdateTeamsRepositoryPayload;
  gh_UpdateTopicsInput: gh_UpdateTopicsInput;
  gh_UpdateTopicsPayload: gh_UpdateTopicsPayload;
  gh_UpdateUserListInput: gh_UpdateUserListInput;
  gh_UpdateUserListPayload: gh_UpdateUserListPayload;
  gh_UpdateUserListsForItemInput: gh_UpdateUserListsForItemInput;
  gh_UpdateUserListsForItemPayload: Omit<gh_UpdateUserListsForItemPayload, 'item'> & { item?: Maybe<ResolversParentTypes['gh_UserListItems']> };
  gh_User: gh_User;
  gh_UserBlockedEvent: gh_UserBlockedEvent;
  gh_UserConnection: gh_UserConnection;
  gh_UserContentEdit: gh_UserContentEdit;
  gh_UserContentEditConnection: gh_UserContentEditConnection;
  gh_UserContentEditEdge: gh_UserContentEditEdge;
  gh_UserEdge: gh_UserEdge;
  gh_UserEmailMetadata: gh_UserEmailMetadata;
  gh_UserList: gh_UserList;
  gh_UserListConnection: gh_UserListConnection;
  gh_UserListEdge: gh_UserListEdge;
  gh_UserListItems: ResolversUnionTypes<ResolversParentTypes>['gh_UserListItems'];
  gh_UserListItemsConnection: Omit<gh_UserListItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['gh_UserListItems']>>> };
  gh_UserListItemsEdge: Omit<gh_UserListItemsEdge, 'node'> & { node?: Maybe<ResolversParentTypes['gh_UserListItems']> };
  gh_UserListSuggestion: gh_UserListSuggestion;
  gh_UserStatus: gh_UserStatus;
  gh_UserStatusConnection: gh_UserStatusConnection;
  gh_UserStatusEdge: gh_UserStatusEdge;
  gh_UserStatusOrder: gh_UserStatusOrder;
  gh_VerifiableDomain: Omit<gh_VerifiableDomain, 'owner'> & { owner: ResolversParentTypes['gh_VerifiableDomainOwner'] };
  gh_VerifiableDomainConnection: gh_VerifiableDomainConnection;
  gh_VerifiableDomainEdge: gh_VerifiableDomainEdge;
  gh_VerifiableDomainOrder: gh_VerifiableDomainOrder;
  gh_VerifiableDomainOwner: ResolversUnionTypes<ResolversParentTypes>['gh_VerifiableDomainOwner'];
  gh_VerifyVerifiableDomainInput: gh_VerifyVerifiableDomainInput;
  gh_VerifyVerifiableDomainPayload: gh_VerifyVerifiableDomainPayload;
  gh_ViewerHovercardContext: gh_ViewerHovercardContext;
  gh_Votable: ResolversInterfaceTypes<ResolversParentTypes>['gh_Votable'];
  gh_Workflow: gh_Workflow;
  gh_WorkflowFileReference: gh_WorkflowFileReference;
  gh_WorkflowFileReferenceInput: gh_WorkflowFileReferenceInput;
  gh_WorkflowRun: gh_WorkflowRun;
  gh_WorkflowRunConnection: gh_WorkflowRunConnection;
  gh_WorkflowRunEdge: gh_WorkflowRunEdge;
  gh_WorkflowRunFile: gh_WorkflowRunFile;
  gh_WorkflowRunOrder: gh_WorkflowRunOrder;
  gh_WorkflowsParameters: gh_WorkflowsParameters;
  gh_WorkflowsParametersInput: gh_WorkflowsParametersInput;
  gh_X509Certificate: Scalars['gh_X509Certificate']['output'];
  GithubQuery: GithubQuery;
  GithubMutation: GithubMutation;
  hn_ObjectId: Scalars['hn_ObjectId']['output'];
  hn_Node: ResolversInterfaceTypes<ResolversParentTypes>['hn_Node'];
  hn_Connection: ResolversInterfaceTypes<ResolversParentTypes>['hn_Connection'];
  hn_Edge: ResolversInterfaceTypes<ResolversParentTypes>['hn_Edge'];
  hn_PageConnection: ResolversInterfaceTypes<ResolversParentTypes>['hn_PageConnection'];
  hn_Feature: ResolversInterfaceTypes<ResolversParentTypes>['hn_Feature'];
  hn_PageInfo: hn_PageInfo;
  hn_OffsetPageInfo: hn_OffsetPageInfo;
  hn_Content: hn_Content;
  hn_SEO: hn_SEO;
  hn_OpenGraphMetaData: hn_OpenGraphMetaData;
  hn_UserConnection: hn_UserConnection;
  hn_IUser: ResolversInterfaceTypes<ResolversParentTypes>['hn_IUser'];
  hn_User: hn_User;
  hn_MyUser: hn_MyUser;
  hn_UserPublicationsConnection: hn_UserPublicationsConnection;
  hn_UserPublicationsEdge: hn_UserPublicationsEdge;
  hn_SocialMediaLinks: hn_SocialMediaLinks;
  hn_Badge: hn_Badge;
  hn_UserPublicationsConnectionFilter: hn_UserPublicationsConnectionFilter;
  hn_ToggleFollowUserPayload: hn_ToggleFollowUserPayload;
  hn_CommenterUserConnection: hn_CommenterUserConnection;
  hn_UserEdge: hn_UserEdge;
  hn_UserPostConnectionFilter: hn_UserPostConnectionFilter;
  hn_ITag: ResolversInterfaceTypes<ResolversParentTypes>['hn_ITag'];
  hn_Tag: hn_Tag;
  hn_PopularTag: hn_PopularTag;
  hn_TagPostConnectionFilter: hn_TagPostConnectionFilter;
  hn_PopularTagEdge: hn_PopularTagEdge;
  hn_TagEdge: hn_TagEdge;
  hn_Publication: hn_Publication;
  hn_UserRecommendedPublicationEdge: hn_UserRecommendedPublicationEdge;
  hn_PublicationUserRecommendingPublicationConnection: hn_PublicationUserRecommendingPublicationConnection;
  hn_UserRecommendingPublicationEdge: hn_UserRecommendingPublicationEdge;
  hn_RSSImport: hn_RSSImport;
  hn_PublicationSponsorship: hn_PublicationSponsorship;
  hn_StripeConfiguration: hn_StripeConfiguration;
  hn_RedirectionRule: hn_RedirectionRule;
  hn_PublicationPostConnectionFilter: hn_PublicationPostConnectionFilter;
  hn_PublicationDraftConnectionFilter: hn_PublicationDraftConnectionFilter;
  hn_PublicationFeatures: hn_PublicationFeatures;
  hn_NewsletterFeature: hn_NewsletterFeature;
  hn_ViewCountFeature: hn_ViewCountFeature;
  hn_ReadTimeFeature: hn_ReadTimeFeature;
  hn_AudioBlogFeature: hn_AudioBlogFeature;
  hn_TextSelectionSharerFeature: hn_TextSelectionSharerFeature;
  hn_CustomCSSFeature: hn_CustomCSSFeature;
  hn_CustomCSS: hn_CustomCSS;
  hn_DomainInfo: hn_DomainInfo;
  hn_DomainStatus: hn_DomainStatus;
  hn_Preferences: hn_Preferences;
  hn_PublicationNavbarItem: hn_PublicationNavbarItem;
  hn_PagesPreferences: hn_PagesPreferences;
  hn_DarkModePreferences: hn_DarkModePreferences;
  hn_PublicationIntegrations: hn_PublicationIntegrations;
  hn_PublicationLinks: hn_PublicationLinks;
  hn_EmailImport: hn_EmailImport;
  hn_EmailCurrentImport: hn_EmailCurrentImport;
  hn_RecommendedPublicationEdge: hn_RecommendedPublicationEdge;
  hn_SubscribeToNewsletterInput: hn_SubscribeToNewsletterInput;
  hn_UnsubscribeFromNewsletterInput: hn_UnsubscribeFromNewsletterInput;
  hn_SubscribeToNewsletterPayload: hn_SubscribeToNewsletterPayload;
  hn_UnsubscribeFromNewsletterPayload: hn_UnsubscribeFromNewsletterPayload;
  hn_Post: hn_Post;
  hn_PostFeatures: hn_PostFeatures;
  hn_TableOfContentsFeature: hn_TableOfContentsFeature;
  hn_PostBadgesFeature: hn_PostBadgesFeature;
  hn_TableOfContentsItem: hn_TableOfContentsItem;
  hn_PostBadge: hn_PostBadge;
  hn_PostLikerFilter: hn_PostLikerFilter;
  hn_AudioUrls: hn_AudioUrls;
  hn_PostPreferences: hn_PostPreferences;
  hn_PostCommenterConnection: hn_PostCommenterConnection;
  hn_PostCommenterEdge: hn_PostCommenterEdge;
  hn_PostCommentConnection: hn_PostCommentConnection;
  hn_PostCommentEdge: hn_PostCommentEdge;
  hn_PostLikerEdge: hn_PostLikerEdge;
  hn_PostLikerConnection: hn_PostLikerConnection;
  hn_PostCoverImage: hn_PostCoverImage;
  hn_PostEdge: hn_PostEdge;
  hn_UserPostEdge: hn_UserPostEdge;
  hn_FeedPostConnection: hn_FeedPostConnection;
  hn_SearchPostConnection: hn_SearchPostConnection;
  hn_SeriesPostConnection: hn_SeriesPostConnection;
  hn_PublicationPostConnection: hn_PublicationPostConnection;
  hn_UserPostConnection: hn_UserPostConnection;
  hn_PublishPostPayload: hn_PublishPostPayload;
  hn_UpdatePostPayload: hn_UpdatePostPayload;
  hn_RemovePostPayload: hn_RemovePostPayload;
  hn_RemovePostInput: hn_RemovePostInput;
  hn_CoverImageOptionsInput: hn_CoverImageOptionsInput;
  hn_MetaTagsInput: hn_MetaTagsInput;
  hn_PublishPostTagInput: hn_PublishPostTagInput;
  hn_UpdatePostSettingsInput: hn_UpdatePostSettingsInput;
  hn_PublishPostSettingsInput: hn_PublishPostSettingsInput;
  hn_PublishPostInput: hn_PublishPostInput;
  hn_UpdatePostInput: hn_UpdatePostInput;
  hn_AddPostToSeriesInput: hn_AddPostToSeriesInput;
  hn_AddPostToSeriesPayload: hn_AddPostToSeriesPayload;
  hn_FeedFilter: hn_FeedFilter;
  hn_SearchPostsOfPublicationFilter: hn_SearchPostsOfPublicationFilter;
  hn_Comment: hn_Comment;
  hn_CommentReplyConnection: hn_CommentReplyConnection;
  hn_CommentReplyEdge: hn_CommentReplyEdge;
  hn_Reply: hn_Reply;
  hn_Series: hn_Series;
  hn_SeriesEdge: hn_SeriesEdge;
  hn_SeriesConnection: hn_SeriesConnection;
  hn_Draft: hn_Draft;
  hn_DraftSettings: hn_DraftSettings;
  hn_DraftFeatures: hn_DraftFeatures;
  hn_DraftBackup: hn_DraftBackup;
  hn_DraftConnection: hn_DraftConnection;
  hn_DraftCoverImage: hn_DraftCoverImage;
  hn_DraftEdge: hn_DraftEdge;
  hn_BetaFeature: hn_BetaFeature;
  hn_ScheduledPost: hn_ScheduledPost;
  hn_ReschedulePostInput: hn_ReschedulePostInput;
  hn_ScheduledPostPayload: hn_ScheduledPostPayload;
  hn_StaticPage: hn_StaticPage;
  hn_StaticPageConnection: hn_StaticPageConnection;
  hn_StaticPageEdge: hn_StaticPageEdge;
  hn_Webhook: hn_Webhook;
  hn_WebhookMessageConnection: hn_WebhookMessageConnection;
  hn_WebhookMessageEdge: hn_WebhookMessageEdge;
  hn_WebhookMessage: hn_WebhookMessage;
  hn_WebhookMessageRequest: hn_WebhookMessageRequest;
  hn_WebhookMessageRequestError: hn_WebhookMessageRequestError;
  hn_WebhookMessageResponse: hn_WebhookMessageResponse;
  HashnodeQuery: HashnodeQuery;
  HashnodeMutation: HashnodeMutation;
}>;

export type requiredCapabilitiesDirectiveArgs = {
  requiredCapabilities?: Maybe<Array<Scalars['String']['input']>>;
};

export type requiredCapabilitiesDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = requiredCapabilitiesDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type previewDirectiveArgs = {
  toggledBy: Scalars['String']['input'];
};

export type previewDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = previewDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type possibleTypesDirectiveArgs = {
  abstractType?: Maybe<Scalars['String']['input']>;
  concreteTypes: Array<Scalars['String']['input']>;
};

export type possibleTypesDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = possibleTypesDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type requireAuthDirectiveArgs = {
  scopes?: Maybe<Array<hn_Scope>>;
};

export type requireAuthDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = requireAuthDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type constraintDirectiveArgs = {
  minLength?: Maybe<Scalars['Int']['input']>;
  maxLength?: Maybe<Scalars['Int']['input']>;
  startsWith?: Maybe<Scalars['String']['input']>;
  endsWith?: Maybe<Scalars['String']['input']>;
  contains?: Maybe<Scalars['String']['input']>;
  notContains?: Maybe<Scalars['String']['input']>;
  pattern?: Maybe<Scalars['String']['input']>;
  format?: Maybe<Scalars['String']['input']>;
  min?: Maybe<Scalars['Float']['input']>;
  max?: Maybe<Scalars['Float']['input']>;
  exclusiveMin?: Maybe<Scalars['Float']['input']>;
  exclusiveMax?: Maybe<Scalars['Float']['input']>;
  multipleOf?: Maybe<Scalars['Float']['input']>;
  minItems?: Maybe<Scalars['Int']['input']>;
  maxItems?: Maybe<Scalars['Int']['input']>;
  uniqueTypeName?: Maybe<Scalars['String']['input']>;
};

export type constraintDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = constraintDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type hiddenDirectiveArgs = { };

export type hiddenDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = hiddenDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type privateDirectiveArgs = { };

export type privateDirectiveResolver<Result, Parent, ContextType = MeshContext, Args = privateDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type QueryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{
  Github?: Resolver<ResolversTypes['GithubQuery'], ParentType, ContextType>;
  Hashnode?: Resolver<ResolversTypes['HashnodeQuery'], ParentType, ContextType>;
}>;

export type MutationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = ResolversObject<{
  Github?: Resolver<ResolversTypes['GithubMutation'], ParentType, ContextType>;
  Hashnode?: Resolver<ResolversTypes['HashnodeMutation'], ParentType, ContextType>;
}>;

export type gh_AbortQueuedMigrationsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AbortQueuedMigrationsPayload'] = ResolversParentTypes['gh_AbortQueuedMigrationsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AbortRepositoryMigrationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AbortRepositoryMigrationPayload'] = ResolversParentTypes['gh_AbortRepositoryMigrationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AcceptEnterpriseAdministratorInvitationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AcceptEnterpriseAdministratorInvitationPayload'] = ResolversParentTypes['gh_AcceptEnterpriseAdministratorInvitationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<ResolversTypes['gh_EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AcceptTopicSuggestionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AcceptTopicSuggestionPayload'] = ResolversParentTypes['gh_AcceptTopicSuggestionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['gh_Topic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Actor'] = ResolversParentTypes['gh_Actor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Bot' | 'gh_EnterpriseUserAccount' | 'gh_Mannequin' | 'gh_Organization' | 'gh_User', ParentType, ContextType>;
  avatarUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType, Partial<gh_ActoravatarUrlArgs>>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
}>;

export type gh_ActorLocationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ActorLocation'] = ResolversParentTypes['gh_ActorLocation']> = ResolversObject<{
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  countryCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  region?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  regionCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddAssigneesToAssignablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddAssigneesToAssignablePayload'] = ResolversParentTypes['gh_AddAssigneesToAssignablePayload']> = ResolversObject<{
  assignable?: Resolver<Maybe<ResolversTypes['gh_Assignable']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddCommentPayload'] = ResolversParentTypes['gh_AddCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  commentEdge?: Resolver<Maybe<ResolversTypes['gh_IssueCommentEdge']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['gh_Node']>, ParentType, ContextType>;
  timelineEdge?: Resolver<Maybe<ResolversTypes['gh_IssueTimelineItemEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddDiscussionCommentPayload'] = ResolversParentTypes['gh_AddDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['gh_DiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddDiscussionPollVotePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddDiscussionPollVotePayload'] = ResolversParentTypes['gh_AddDiscussionPollVotePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pollOption?: Resolver<Maybe<ResolversTypes['gh_DiscussionPollOption']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddEnterpriseOrganizationMemberPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddEnterpriseOrganizationMemberPayload'] = ResolversParentTypes['gh_AddEnterpriseOrganizationMemberPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<Array<ResolversTypes['gh_User']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddEnterpriseSupportEntitlementPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddEnterpriseSupportEntitlementPayload'] = ResolversParentTypes['gh_AddEnterpriseSupportEntitlementPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddLabelsToLabelablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddLabelsToLabelablePayload'] = ResolversParentTypes['gh_AddLabelsToLabelablePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labelable?: Resolver<Maybe<ResolversTypes['gh_Labelable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddProjectCardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddProjectCardPayload'] = ResolversParentTypes['gh_AddProjectCardPayload']> = ResolversObject<{
  cardEdge?: Resolver<Maybe<ResolversTypes['gh_ProjectCardEdge']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectColumn?: Resolver<Maybe<ResolversTypes['gh_ProjectColumn']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddProjectColumnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddProjectColumnPayload'] = ResolversParentTypes['gh_AddProjectColumnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  columnEdge?: Resolver<Maybe<ResolversTypes['gh_ProjectColumnEdge']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddProjectV2DraftIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddProjectV2DraftIssuePayload'] = ResolversParentTypes['gh_AddProjectV2DraftIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectItem?: Resolver<Maybe<ResolversTypes['gh_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddProjectV2ItemByIdPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddProjectV2ItemByIdPayload'] = ResolversParentTypes['gh_AddProjectV2ItemByIdPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['gh_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddPullRequestReviewCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddPullRequestReviewCommentPayload'] = ResolversParentTypes['gh_AddPullRequestReviewCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewComment']>, ParentType, ContextType>;
  commentEdge?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewCommentEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddPullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddPullRequestReviewPayload'] = ResolversParentTypes['gh_AddPullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['gh_PullRequestReview']>, ParentType, ContextType>;
  reviewEdge?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddPullRequestReviewThreadPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddPullRequestReviewThreadPayload'] = ResolversParentTypes['gh_AddPullRequestReviewThreadPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  thread?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddPullRequestReviewThreadReplyPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddPullRequestReviewThreadReplyPayload'] = ResolversParentTypes['gh_AddPullRequestReviewThreadReplyPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddReactionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddReactionPayload'] = ResolversParentTypes['gh_AddReactionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reaction?: Resolver<Maybe<ResolversTypes['gh_Reaction']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['gh_Reactable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddStarPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddStarPayload'] = ResolversParentTypes['gh_AddStarPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  starrable?: Resolver<Maybe<ResolversTypes['gh_Starrable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddUpvotePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddUpvotePayload'] = ResolversParentTypes['gh_AddUpvotePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['gh_Votable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddVerifiableDomainPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddVerifiableDomainPayload'] = ResolversParentTypes['gh_AddVerifiableDomainPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domain?: Resolver<Maybe<ResolversTypes['gh_VerifiableDomain']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddedToMergeQueueEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddedToMergeQueueEvent'] = ResolversParentTypes['gh_AddedToMergeQueueEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enqueuer?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  mergeQueue?: Resolver<Maybe<ResolversTypes['gh_MergeQueue']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AddedToProjectEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AddedToProjectEvent'] = ResolversParentTypes['gh_AddedToProjectEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['gh_ProjectCard']>, ParentType, ContextType>;
  projectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AnnouncementBannerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AnnouncementBanner'] = ResolversParentTypes['gh_AnnouncementBanner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Enterprise' | 'gh_Organization', ParentType, ContextType>;
  announcement?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  announcementExpiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  announcementUserDismissible?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
}>;

export type gh_AppResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_App'] = ResolversParentTypes['gh_App']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ipAllowListEntries?: Resolver<ResolversTypes['gh_IpAllowListEntryConnection'], ParentType, ContextType, RequireFields<gh_AppipAllowListEntriesArgs, 'orderBy'>>;
  logoBackgroundColor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logoUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType, Partial<gh_ApplogoUrlArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ApproveDeploymentsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ApproveDeploymentsPayload'] = ResolversParentTypes['gh_ApproveDeploymentsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deployments?: Resolver<Maybe<Array<ResolversTypes['gh_Deployment']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ApproveVerifiableDomainPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ApproveVerifiableDomainPayload'] = ResolversParentTypes['gh_ApproveVerifiableDomainPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domain?: Resolver<Maybe<ResolversTypes['gh_VerifiableDomain']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ArchiveProjectV2ItemPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ArchiveProjectV2ItemPayload'] = ResolversParentTypes['gh_ArchiveProjectV2ItemPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['gh_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ArchiveRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ArchiveRepositoryPayload'] = ResolversParentTypes['gh_ArchiveRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AssignableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Assignable'] = ResolversParentTypes['gh_Assignable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Issue' | 'gh_PullRequest', ParentType, ContextType>;
  assignees?: Resolver<ResolversTypes['gh_UserConnection'], ParentType, ContextType, Partial<gh_AssignableassigneesArgs>>;
}>;

export type gh_AssignedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AssignedEvent'] = ResolversParentTypes['gh_AssignedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  assignable?: Resolver<ResolversTypes['gh_Assignable'], ParentType, ContextType>;
  assignee?: Resolver<Maybe<ResolversTypes['gh_Assignee']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AssigneeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Assignee'] = ResolversParentTypes['gh_Assignee']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Bot' | 'gh_Mannequin' | 'gh_Organization' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_AuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AuditEntry'] = ResolversParentTypes['gh_AuditEntry']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_MembersCanDeleteReposClearAuditEntry' | 'gh_MembersCanDeleteReposDisableAuditEntry' | 'gh_MembersCanDeleteReposEnableAuditEntry' | 'gh_OauthApplicationCreateAuditEntry' | 'gh_OrgAddBillingManagerAuditEntry' | 'gh_OrgAddMemberAuditEntry' | 'gh_OrgBlockUserAuditEntry' | 'gh_OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'gh_OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'gh_OrgCreateAuditEntry' | 'gh_OrgDisableOauthAppRestrictionsAuditEntry' | 'gh_OrgDisableSamlAuditEntry' | 'gh_OrgDisableTwoFactorRequirementAuditEntry' | 'gh_OrgEnableOauthAppRestrictionsAuditEntry' | 'gh_OrgEnableSamlAuditEntry' | 'gh_OrgEnableTwoFactorRequirementAuditEntry' | 'gh_OrgInviteMemberAuditEntry' | 'gh_OrgInviteToBusinessAuditEntry' | 'gh_OrgOauthAppAccessApprovedAuditEntry' | 'gh_OrgOauthAppAccessBlockedAuditEntry' | 'gh_OrgOauthAppAccessDeniedAuditEntry' | 'gh_OrgOauthAppAccessRequestedAuditEntry' | 'gh_OrgOauthAppAccessUnblockedAuditEntry' | 'gh_OrgRemoveBillingManagerAuditEntry' | 'gh_OrgRemoveMemberAuditEntry' | 'gh_OrgRemoveOutsideCollaboratorAuditEntry' | 'gh_OrgRestoreMemberAuditEntry' | 'gh_OrgUnblockUserAuditEntry' | 'gh_OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'gh_OrgUpdateMemberAuditEntry' | 'gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'gh_PrivateRepositoryForkingDisableAuditEntry' | 'gh_PrivateRepositoryForkingEnableAuditEntry' | 'gh_RepoAccessAuditEntry' | 'gh_RepoAddMemberAuditEntry' | 'gh_RepoAddTopicAuditEntry' | 'gh_RepoArchivedAuditEntry' | 'gh_RepoChangeMergeSettingAuditEntry' | 'gh_RepoConfigDisableAnonymousGitAccessAuditEntry' | 'gh_RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'gh_RepoConfigDisableContributorsOnlyAuditEntry' | 'gh_RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'gh_RepoConfigEnableAnonymousGitAccessAuditEntry' | 'gh_RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'gh_RepoConfigEnableContributorsOnlyAuditEntry' | 'gh_RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'gh_RepoConfigLockAnonymousGitAccessAuditEntry' | 'gh_RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'gh_RepoCreateAuditEntry' | 'gh_RepoDestroyAuditEntry' | 'gh_RepoRemoveMemberAuditEntry' | 'gh_RepoRemoveTopicAuditEntry' | 'gh_RepositoryVisibilityChangeDisableAuditEntry' | 'gh_RepositoryVisibilityChangeEnableAuditEntry' | 'gh_TeamAddMemberAuditEntry' | 'gh_TeamAddRepositoryAuditEntry' | 'gh_TeamChangeParentTeamAuditEntry' | 'gh_TeamRemoveMemberAuditEntry' | 'gh_TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
}>;

export type gh_AuditEntryActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AuditEntryActor'] = ResolversParentTypes['gh_AuditEntryActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Bot' | 'gh_Organization' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_AutoMergeDisabledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AutoMergeDisabledEvent'] = ResolversParentTypes['gh_AutoMergeDisabledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  disabler?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reasonCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AutoMergeEnabledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AutoMergeEnabledEvent'] = ResolversParentTypes['gh_AutoMergeEnabledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enabler?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AutoMergeRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AutoMergeRequest'] = ResolversParentTypes['gh_AutoMergeRequest']> = ResolversObject<{
  authorEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  commitBody?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  commitHeadline?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enabledAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  enabledBy?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  mergeMethod?: Resolver<ResolversTypes['gh_PullRequestMergeMethod'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AutoRebaseEnabledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AutoRebaseEnabledEvent'] = ResolversParentTypes['gh_AutoRebaseEnabledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enabler?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AutoSquashEnabledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AutoSquashEnabledEvent'] = ResolversParentTypes['gh_AutoSquashEnabledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enabler?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AutomaticBaseChangeFailedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AutomaticBaseChangeFailedEvent'] = ResolversParentTypes['gh_AutomaticBaseChangeFailedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  newBase?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  oldBase?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_AutomaticBaseChangeSucceededEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_AutomaticBaseChangeSucceededEvent'] = ResolversParentTypes['gh_AutomaticBaseChangeSucceededEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  newBase?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  oldBase?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface gh_Base64StringScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['gh_Base64String'], any> {
  name: 'gh_Base64String';
}

export type gh_BaseRefChangedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BaseRefChangedEvent'] = ResolversParentTypes['gh_BaseRefChangedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  currentRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  previousRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BaseRefDeletedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BaseRefDeletedEvent'] = ResolversParentTypes['gh_BaseRefDeletedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  baseRefName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BaseRefForcePushedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BaseRefForcePushedEvent'] = ResolversParentTypes['gh_BaseRefForcePushedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  afterCommit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  beforeCommit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
  name: 'BigInt';
}

export type gh_BlameResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Blame'] = ResolversParentTypes['gh_Blame']> = ResolversObject<{
  ranges?: Resolver<Array<ResolversTypes['gh_BlameRange']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BlameRangeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BlameRange'] = ResolversParentTypes['gh_BlameRange']> = ResolversObject<{
  age?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  commit?: Resolver<ResolversTypes['gh_Commit'], ParentType, ContextType>;
  endingLine?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  startingLine?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BlobResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Blob'] = ResolversParentTypes['gh_Blob']> = ResolversObject<{
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  byteSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isBinary?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isTruncated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['gh_GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BotResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Bot'] = ResolversParentTypes['gh_Bot']> = ResolversObject<{
  avatarUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType, Partial<gh_BotavatarUrlArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BranchActorAllowanceActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BranchActorAllowanceActor'] = ResolversParentTypes['gh_BranchActorAllowanceActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_App' | 'gh_Team' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_BranchNamePatternParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BranchNamePatternParameters'] = ResolversParentTypes['gh_BranchNamePatternParameters']> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BranchProtectionRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BranchProtectionRule'] = ResolversParentTypes['gh_BranchProtectionRule']> = ResolversObject<{
  allowsDeletions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  allowsForcePushes?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  blocksCreations?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  branchProtectionRuleConflicts?: Resolver<ResolversTypes['gh_BranchProtectionRuleConflictConnection'], ParentType, ContextType, Partial<gh_BranchProtectionRulebranchProtectionRuleConflictsArgs>>;
  bypassForcePushAllowances?: Resolver<ResolversTypes['gh_BypassForcePushAllowanceConnection'], ParentType, ContextType, Partial<gh_BranchProtectionRulebypassForcePushAllowancesArgs>>;
  bypassPullRequestAllowances?: Resolver<ResolversTypes['gh_BypassPullRequestAllowanceConnection'], ParentType, ContextType, Partial<gh_BranchProtectionRulebypassPullRequestAllowancesArgs>>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  dismissesStaleReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isAdminEnforced?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lockAllowsFetchAndMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lockBranch?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  matchingRefs?: Resolver<ResolversTypes['gh_RefConnection'], ParentType, ContextType, Partial<gh_BranchProtectionRulematchingRefsArgs>>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pushAllowances?: Resolver<ResolversTypes['gh_PushAllowanceConnection'], ParentType, ContextType, Partial<gh_BranchProtectionRulepushAllowancesArgs>>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  requireLastPushApproval?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiredApprovingReviewCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  requiredDeploymentEnvironments?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  requiredStatusCheckContexts?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  requiredStatusChecks?: Resolver<Maybe<Array<ResolversTypes['gh_RequiredStatusCheckDescription']>>, ParentType, ContextType>;
  requiresApprovingReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresCodeOwnerReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresCommitSignatures?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresConversationResolution?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresDeployments?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresLinearHistory?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresStatusChecks?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresStrictStatusChecks?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  restrictsPushes?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  restrictsReviewDismissals?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  reviewDismissalAllowances?: Resolver<ResolversTypes['gh_ReviewDismissalAllowanceConnection'], ParentType, ContextType, Partial<gh_BranchProtectionRulereviewDismissalAllowancesArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BranchProtectionRuleConflictResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BranchProtectionRuleConflict'] = ResolversParentTypes['gh_BranchProtectionRuleConflict']> = ResolversObject<{
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['gh_BranchProtectionRule']>, ParentType, ContextType>;
  conflictingBranchProtectionRule?: Resolver<Maybe<ResolversTypes['gh_BranchProtectionRule']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BranchProtectionRuleConflictConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BranchProtectionRuleConflictConnection'] = ResolversParentTypes['gh_BranchProtectionRuleConflictConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_BranchProtectionRuleConflictEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_BranchProtectionRuleConflict']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BranchProtectionRuleConflictEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BranchProtectionRuleConflictEdge'] = ResolversParentTypes['gh_BranchProtectionRuleConflictEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_BranchProtectionRuleConflict']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BranchProtectionRuleConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BranchProtectionRuleConnection'] = ResolversParentTypes['gh_BranchProtectionRuleConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_BranchProtectionRuleEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_BranchProtectionRule']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BranchProtectionRuleEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BranchProtectionRuleEdge'] = ResolversParentTypes['gh_BranchProtectionRuleEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_BranchProtectionRule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BypassActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BypassActor'] = ResolversParentTypes['gh_BypassActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_App' | 'gh_Team', ParentType, ContextType>;
}>;

export type gh_BypassForcePushAllowanceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BypassForcePushAllowance'] = ResolversParentTypes['gh_BypassForcePushAllowance']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_BranchActorAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['gh_BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BypassForcePushAllowanceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BypassForcePushAllowanceConnection'] = ResolversParentTypes['gh_BypassForcePushAllowanceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_BypassForcePushAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_BypassForcePushAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BypassForcePushAllowanceEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BypassForcePushAllowanceEdge'] = ResolversParentTypes['gh_BypassForcePushAllowanceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_BypassForcePushAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BypassPullRequestAllowanceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BypassPullRequestAllowance'] = ResolversParentTypes['gh_BypassPullRequestAllowance']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_BranchActorAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['gh_BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BypassPullRequestAllowanceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BypassPullRequestAllowanceConnection'] = ResolversParentTypes['gh_BypassPullRequestAllowanceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_BypassPullRequestAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_BypassPullRequestAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_BypassPullRequestAllowanceEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_BypassPullRequestAllowanceEdge'] = ResolversParentTypes['gh_BypassPullRequestAllowanceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_BypassPullRequestAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CVSSResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CVSS'] = ResolversParentTypes['gh_CVSS']> = ResolversObject<{
  score?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  vectorString?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CWEResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CWE'] = ResolversParentTypes['gh_CWE']> = ResolversObject<{
  cweId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CWEConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CWEConnection'] = ResolversParentTypes['gh_CWEConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CWEEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CWE']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CWEEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CWEEdge'] = ResolversParentTypes['gh_CWEEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_CWE']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CancelEnterpriseAdminInvitationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CancelEnterpriseAdminInvitationPayload'] = ResolversParentTypes['gh_CancelEnterpriseAdminInvitationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<ResolversTypes['gh_EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CancelSponsorshipPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CancelSponsorshipPayload'] = ResolversParentTypes['gh_CancelSponsorshipPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['gh_SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ChangeUserStatusPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ChangeUserStatusPayload'] = ResolversParentTypes['gh_ChangeUserStatusPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['gh_UserStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckAnnotationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckAnnotation'] = ResolversParentTypes['gh_CheckAnnotation']> = ResolversObject<{
  annotationLevel?: Resolver<Maybe<ResolversTypes['gh_CheckAnnotationLevel']>, ParentType, ContextType>;
  blobUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  location?: Resolver<ResolversTypes['gh_CheckAnnotationSpan'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  rawDetails?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckAnnotationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckAnnotationConnection'] = ResolversParentTypes['gh_CheckAnnotationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CheckAnnotationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CheckAnnotation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckAnnotationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckAnnotationEdge'] = ResolversParentTypes['gh_CheckAnnotationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_CheckAnnotation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckAnnotationPositionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckAnnotationPosition'] = ResolversParentTypes['gh_CheckAnnotationPosition']> = ResolversObject<{
  column?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  line?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckAnnotationSpanResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckAnnotationSpan'] = ResolversParentTypes['gh_CheckAnnotationSpan']> = ResolversObject<{
  end?: Resolver<ResolversTypes['gh_CheckAnnotationPosition'], ParentType, ContextType>;
  start?: Resolver<ResolversTypes['gh_CheckAnnotationPosition'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckRunResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckRun'] = ResolversParentTypes['gh_CheckRun']> = ResolversObject<{
  annotations?: Resolver<Maybe<ResolversTypes['gh_CheckAnnotationConnection']>, ParentType, ContextType, Partial<gh_CheckRunannotationsArgs>>;
  checkSuite?: Resolver<ResolversTypes['gh_CheckSuite'], ParentType, ContextType>;
  completedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  conclusion?: Resolver<Maybe<ResolversTypes['gh_CheckConclusionState']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deployment?: Resolver<Maybe<ResolversTypes['gh_Deployment']>, ParentType, ContextType>;
  detailsUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<gh_CheckRunisRequiredArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingDeploymentRequest?: Resolver<Maybe<ResolversTypes['gh_DeploymentRequest']>, ParentType, ContextType>;
  permalink?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  startedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['gh_CheckStatusState'], ParentType, ContextType>;
  steps?: Resolver<Maybe<ResolversTypes['gh_CheckStepConnection']>, ParentType, ContextType, Partial<gh_CheckRunstepsArgs>>;
  summary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckRunConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckRunConnection'] = ResolversParentTypes['gh_CheckRunConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CheckRunEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CheckRun']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckRunEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckRunEdge'] = ResolversParentTypes['gh_CheckRunEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_CheckRun']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckRunStateCountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckRunStateCount'] = ResolversParentTypes['gh_CheckRunStateCount']> = ResolversObject<{
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_CheckRunState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckStepResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckStep'] = ResolversParentTypes['gh_CheckStep']> = ResolversObject<{
  completedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  conclusion?: Resolver<Maybe<ResolversTypes['gh_CheckConclusionState']>, ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  secondsToCompletion?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  startedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['gh_CheckStatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckStepConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckStepConnection'] = ResolversParentTypes['gh_CheckStepConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CheckStepEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CheckStep']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckStepEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckStepEdge'] = ResolversParentTypes['gh_CheckStepEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_CheckStep']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckSuiteResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckSuite'] = ResolversParentTypes['gh_CheckSuite']> = ResolversObject<{
  app?: Resolver<Maybe<ResolversTypes['gh_App']>, ParentType, ContextType>;
  branch?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  checkRuns?: Resolver<Maybe<ResolversTypes['gh_CheckRunConnection']>, ParentType, ContextType, Partial<gh_CheckSuitecheckRunsArgs>>;
  commit?: Resolver<ResolversTypes['gh_Commit'], ParentType, ContextType>;
  conclusion?: Resolver<Maybe<ResolversTypes['gh_CheckConclusionState']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  matchingPullRequests?: Resolver<Maybe<ResolversTypes['gh_PullRequestConnection']>, ParentType, ContextType, Partial<gh_CheckSuitematchingPullRequestsArgs>>;
  push?: Resolver<Maybe<ResolversTypes['gh_Push']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['gh_CheckStatusState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  workflowRun?: Resolver<Maybe<ResolversTypes['gh_WorkflowRun']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckSuiteConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckSuiteConnection'] = ResolversParentTypes['gh_CheckSuiteConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CheckSuiteEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CheckSuite']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CheckSuiteEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CheckSuiteEdge'] = ResolversParentTypes['gh_CheckSuiteEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_CheckSuite']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ClaimableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Claimable'] = ResolversParentTypes['gh_Claimable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Mannequin' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_ClearLabelsFromLabelablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ClearLabelsFromLabelablePayload'] = ResolversParentTypes['gh_ClearLabelsFromLabelablePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labelable?: Resolver<Maybe<ResolversTypes['gh_Labelable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ClearProjectV2ItemFieldValuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ClearProjectV2ItemFieldValuePayload'] = ResolversParentTypes['gh_ClearProjectV2ItemFieldValuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2Item?: Resolver<Maybe<ResolversTypes['gh_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CloneProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CloneProjectPayload'] = ResolversParentTypes['gh_CloneProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  jobStatusId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CloneTemplateRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CloneTemplateRepositoryPayload'] = ResolversParentTypes['gh_CloneTemplateRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ClosableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Closable'] = ResolversParentTypes['gh_Closable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Discussion' | 'gh_Issue' | 'gh_Milestone' | 'gh_Project' | 'gh_ProjectV2' | 'gh_PullRequest', ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type gh_CloseDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CloseDiscussionPayload'] = ResolversParentTypes['gh_CloseDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['gh_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CloseIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CloseIssuePayload'] = ResolversParentTypes['gh_CloseIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['gh_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ClosePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ClosePullRequestPayload'] = ResolversParentTypes['gh_ClosePullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ClosedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ClosedEvent'] = ResolversParentTypes['gh_ClosedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  closable?: Resolver<ResolversTypes['gh_Closable'], ParentType, ContextType>;
  closer?: Resolver<Maybe<ResolversTypes['gh_Closer']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  stateReason?: Resolver<Maybe<ResolversTypes['gh_IssueStateReason']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CloserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Closer'] = ResolversParentTypes['gh_Closer']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Commit' | 'gh_PullRequest', ParentType, ContextType>;
}>;

export type gh_CodeOfConductResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CodeOfConduct'] = ResolversParentTypes['gh_CodeOfConduct']> = ResolversObject<{
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Comment'] = ResolversParentTypes['gh_Comment']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_CommitComment' | 'gh_Discussion' | 'gh_DiscussionComment' | 'gh_GistComment' | 'gh_Issue' | 'gh_IssueComment' | 'gh_PullRequest' | 'gh_PullRequestReview' | 'gh_PullRequestReviewComment' | 'gh_TeamDiscussion' | 'gh_TeamDiscussionComment', ParentType, ContextType>;
  author?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['gh_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['gh_UserContentEditConnection']>, ParentType, ContextType, Partial<gh_CommentuserContentEditsArgs>>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type gh_CommentDeletedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CommentDeletedEvent'] = ResolversParentTypes['gh_CommentDeletedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deletedCommentAuthor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CommitResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Commit'] = ResolversParentTypes['gh_Commit']> = ResolversObject<{
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  additions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  associatedPullRequests?: Resolver<Maybe<ResolversTypes['gh_PullRequestConnection']>, ParentType, ContextType, RequireFields<gh_CommitassociatedPullRequestsArgs, 'orderBy'>>;
  author?: Resolver<Maybe<ResolversTypes['gh_GitActor']>, ParentType, ContextType>;
  authoredByCommitter?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  authoredDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  authors?: Resolver<ResolversTypes['gh_GitActorConnection'], ParentType, ContextType, Partial<gh_CommitauthorsArgs>>;
  blame?: Resolver<ResolversTypes['gh_Blame'], ParentType, ContextType, RequireFields<gh_CommitblameArgs, 'path'>>;
  changedFiles?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  changedFilesIfAvailable?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  checkSuites?: Resolver<Maybe<ResolversTypes['gh_CheckSuiteConnection']>, ParentType, ContextType, Partial<gh_CommitcheckSuitesArgs>>;
  comments?: Resolver<ResolversTypes['gh_CommitCommentConnection'], ParentType, ContextType, Partial<gh_CommitcommentsArgs>>;
  commitResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  committedDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  committedViaWeb?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  committer?: Resolver<Maybe<ResolversTypes['gh_GitActor']>, ParentType, ContextType>;
  deletions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  deployments?: Resolver<Maybe<ResolversTypes['gh_DeploymentConnection']>, ParentType, ContextType, RequireFields<gh_CommitdeploymentsArgs, 'orderBy'>>;
  file?: Resolver<Maybe<ResolversTypes['gh_TreeEntry']>, ParentType, ContextType, RequireFields<gh_CommitfileArgs, 'path'>>;
  history?: Resolver<ResolversTypes['gh_CommitHistoryConnection'], ParentType, ContextType, Partial<gh_CommithistoryArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  messageBody?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  messageBodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  messageHeadline?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  messageHeadlineHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['gh_GitObjectID'], ParentType, ContextType>;
  onBehalfOf?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  parents?: Resolver<ResolversTypes['gh_CommitConnection'], ParentType, ContextType, Partial<gh_CommitparentsArgs>>;
  pushedDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  signature?: Resolver<Maybe<ResolversTypes['gh_GitSignature']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['gh_Status']>, ParentType, ContextType>;
  statusCheckRollup?: Resolver<Maybe<ResolversTypes['gh_StatusCheckRollup']>, ParentType, ContextType>;
  submodules?: Resolver<ResolversTypes['gh_SubmoduleConnection'], ParentType, ContextType, Partial<gh_CommitsubmodulesArgs>>;
  tarballUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  tree?: Resolver<ResolversTypes['gh_Tree'], ParentType, ContextType>;
  treeResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  treeUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['gh_SubscriptionState']>, ParentType, ContextType>;
  zipballUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CommitAuthorEmailPatternParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CommitAuthorEmailPatternParameters'] = ResolversParentTypes['gh_CommitAuthorEmailPatternParameters']> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CommitCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CommitComment'] = ResolversParentTypes['gh_CommitComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['gh_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['gh_ReactionConnection'], ParentType, ContextType, Partial<gh_CommitCommentreactionsArgs>>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['gh_UserContentEditConnection']>, ParentType, ContextType, Partial<gh_CommitCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['gh_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CommitCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CommitCommentConnection'] = ResolversParentTypes['gh_CommitCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CommitCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CommitComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CommitCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CommitCommentEdge'] = ResolversParentTypes['gh_CommitCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_CommitComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CommitCommentThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CommitCommentThread'] = ResolversParentTypes['gh_CommitCommentThread']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['gh_CommitCommentConnection'], ParentType, ContextType, Partial<gh_CommitCommentThreadcommentsArgs>>;
  commit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CommitConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CommitConnection'] = ResolversParentTypes['gh_CommitConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Commit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CommitContributionsByRepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CommitContributionsByRepository'] = ResolversParentTypes['gh_CommitContributionsByRepository']> = ResolversObject<{
  contributions?: Resolver<ResolversTypes['gh_CreatedCommitContributionConnection'], ParentType, ContextType, RequireFields<gh_CommitContributionsByRepositorycontributionsArgs, 'orderBy'>>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CommitEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CommitEdge'] = ResolversParentTypes['gh_CommitEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CommitHistoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CommitHistoryConnection'] = ResolversParentTypes['gh_CommitHistoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Commit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CommitMessagePatternParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CommitMessagePatternParameters'] = ResolversParentTypes['gh_CommitMessagePatternParameters']> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CommitterEmailPatternParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CommitterEmailPatternParameters'] = ResolversParentTypes['gh_CommitterEmailPatternParameters']> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ComparisonResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Comparison'] = ResolversParentTypes['gh_Comparison']> = ResolversObject<{
  aheadBy?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  baseTarget?: Resolver<ResolversTypes['gh_GitObject'], ParentType, ContextType>;
  behindBy?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  commits?: Resolver<ResolversTypes['gh_ComparisonCommitConnection'], ParentType, ContextType, Partial<gh_ComparisoncommitsArgs>>;
  headTarget?: Resolver<ResolversTypes['gh_GitObject'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['gh_ComparisonStatus'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ComparisonCommitConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ComparisonCommitConnection'] = ResolversParentTypes['gh_ComparisonCommitConnection']> = ResolversObject<{
  authorCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Commit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ConnectedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ConnectedEvent'] = ResolversParentTypes['gh_ConnectedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['gh_ReferencedSubject'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['gh_ReferencedSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ContributingGuidelinesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ContributingGuidelines'] = ResolversParentTypes['gh_ContributingGuidelines']> = ResolversObject<{
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  resourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Contribution'] = ResolversParentTypes['gh_Contribution']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_CreatedCommitContribution' | 'gh_CreatedIssueContribution' | 'gh_CreatedPullRequestContribution' | 'gh_CreatedPullRequestReviewContribution' | 'gh_CreatedRepositoryContribution' | 'gh_JoinedGitHubContribution' | 'gh_RestrictedContribution', ParentType, ContextType>;
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
}>;

export type gh_ContributionCalendarResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ContributionCalendar'] = ResolversParentTypes['gh_ContributionCalendar']> = ResolversObject<{
  colors?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  isHalloween?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  months?: Resolver<Array<ResolversTypes['gh_ContributionCalendarMonth']>, ParentType, ContextType>;
  totalContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  weeks?: Resolver<Array<ResolversTypes['gh_ContributionCalendarWeek']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ContributionCalendarDayResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ContributionCalendarDay'] = ResolversParentTypes['gh_ContributionCalendarDay']> = ResolversObject<{
  color?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  contributionCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  contributionLevel?: Resolver<ResolversTypes['gh_ContributionLevel'], ParentType, ContextType>;
  date?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  weekday?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ContributionCalendarMonthResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ContributionCalendarMonth'] = ResolversParentTypes['gh_ContributionCalendarMonth']> = ResolversObject<{
  firstDay?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalWeeks?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  year?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ContributionCalendarWeekResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ContributionCalendarWeek'] = ResolversParentTypes['gh_ContributionCalendarWeek']> = ResolversObject<{
  contributionDays?: Resolver<Array<ResolversTypes['gh_ContributionCalendarDay']>, ParentType, ContextType>;
  firstDay?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ContributionsCollectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ContributionsCollection'] = ResolversParentTypes['gh_ContributionsCollection']> = ResolversObject<{
  commitContributionsByRepository?: Resolver<Array<ResolversTypes['gh_CommitContributionsByRepository']>, ParentType, ContextType, RequireFields<gh_ContributionsCollectioncommitContributionsByRepositoryArgs, 'maxRepositories'>>;
  contributionCalendar?: Resolver<ResolversTypes['gh_ContributionCalendar'], ParentType, ContextType>;
  contributionYears?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
  doesEndInCurrentMonth?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  earliestRestrictedContributionDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  endedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  firstIssueContribution?: Resolver<Maybe<ResolversTypes['gh_CreatedIssueOrRestrictedContribution']>, ParentType, ContextType>;
  firstPullRequestContribution?: Resolver<Maybe<ResolversTypes['gh_CreatedPullRequestOrRestrictedContribution']>, ParentType, ContextType>;
  firstRepositoryContribution?: Resolver<Maybe<ResolversTypes['gh_CreatedRepositoryOrRestrictedContribution']>, ParentType, ContextType>;
  hasActivityInThePast?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasAnyContributions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasAnyRestrictedContributions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSingleDay?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issueContributions?: Resolver<ResolversTypes['gh_CreatedIssueContributionConnection'], ParentType, ContextType, RequireFields<gh_ContributionsCollectionissueContributionsArgs, 'excludeFirst' | 'excludePopular' | 'orderBy'>>;
  issueContributionsByRepository?: Resolver<Array<ResolversTypes['gh_IssueContributionsByRepository']>, ParentType, ContextType, RequireFields<gh_ContributionsCollectionissueContributionsByRepositoryArgs, 'excludeFirst' | 'excludePopular' | 'maxRepositories'>>;
  joinedGitHubContribution?: Resolver<Maybe<ResolversTypes['gh_JoinedGitHubContribution']>, ParentType, ContextType>;
  latestRestrictedContributionDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  mostRecentCollectionWithActivity?: Resolver<Maybe<ResolversTypes['gh_ContributionsCollection']>, ParentType, ContextType>;
  mostRecentCollectionWithoutActivity?: Resolver<Maybe<ResolversTypes['gh_ContributionsCollection']>, ParentType, ContextType>;
  popularIssueContribution?: Resolver<Maybe<ResolversTypes['gh_CreatedIssueContribution']>, ParentType, ContextType>;
  popularPullRequestContribution?: Resolver<Maybe<ResolversTypes['gh_CreatedPullRequestContribution']>, ParentType, ContextType>;
  pullRequestContributions?: Resolver<ResolversTypes['gh_CreatedPullRequestContributionConnection'], ParentType, ContextType, RequireFields<gh_ContributionsCollectionpullRequestContributionsArgs, 'excludeFirst' | 'excludePopular' | 'orderBy'>>;
  pullRequestContributionsByRepository?: Resolver<Array<ResolversTypes['gh_PullRequestContributionsByRepository']>, ParentType, ContextType, RequireFields<gh_ContributionsCollectionpullRequestContributionsByRepositoryArgs, 'excludeFirst' | 'excludePopular' | 'maxRepositories'>>;
  pullRequestReviewContributions?: Resolver<ResolversTypes['gh_CreatedPullRequestReviewContributionConnection'], ParentType, ContextType, RequireFields<gh_ContributionsCollectionpullRequestReviewContributionsArgs, 'orderBy'>>;
  pullRequestReviewContributionsByRepository?: Resolver<Array<ResolversTypes['gh_PullRequestReviewContributionsByRepository']>, ParentType, ContextType, RequireFields<gh_ContributionsCollectionpullRequestReviewContributionsByRepositoryArgs, 'maxRepositories'>>;
  repositoryContributions?: Resolver<ResolversTypes['gh_CreatedRepositoryContributionConnection'], ParentType, ContextType, RequireFields<gh_ContributionsCollectionrepositoryContributionsArgs, 'excludeFirst' | 'orderBy'>>;
  restrictedContributionsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  startedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  totalCommitContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalIssueContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<gh_ContributionsCollectiontotalIssueContributionsArgs, 'excludeFirst' | 'excludePopular'>>;
  totalPullRequestContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<gh_ContributionsCollectiontotalPullRequestContributionsArgs, 'excludeFirst' | 'excludePopular'>>;
  totalPullRequestReviewContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRepositoriesWithContributedCommits?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRepositoriesWithContributedIssues?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<gh_ContributionsCollectiontotalRepositoriesWithContributedIssuesArgs, 'excludeFirst' | 'excludePopular'>>;
  totalRepositoriesWithContributedPullRequestReviews?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRepositoriesWithContributedPullRequests?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<gh_ContributionsCollectiontotalRepositoriesWithContributedPullRequestsArgs, 'excludeFirst' | 'excludePopular'>>;
  totalRepositoryContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<gh_ContributionsCollectiontotalRepositoryContributionsArgs, 'excludeFirst'>>;
  user?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ConvertProjectCardNoteToIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ConvertProjectCardNoteToIssuePayload'] = ResolversParentTypes['gh_ConvertProjectCardNoteToIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['gh_ProjectCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ConvertPullRequestToDraftPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ConvertPullRequestToDraftPayload'] = ResolversParentTypes['gh_ConvertPullRequestToDraftPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ConvertToDraftEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ConvertToDraftEvent'] = ResolversParentTypes['gh_ConvertToDraftEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ConvertedNoteToIssueEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ConvertedNoteToIssueEvent'] = ResolversParentTypes['gh_ConvertedNoteToIssueEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['gh_ProjectCard']>, ParentType, ContextType>;
  projectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ConvertedToDiscussionEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ConvertedToDiscussionEvent'] = ResolversParentTypes['gh_ConvertedToDiscussionEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['gh_Discussion']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CopyProjectV2PayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CopyProjectV2Payload'] = ResolversParentTypes['gh_CopyProjectV2Payload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateAttributionInvitationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateAttributionInvitationPayload'] = ResolversParentTypes['gh_CreateAttributionInvitationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  source?: Resolver<Maybe<ResolversTypes['gh_Claimable']>, ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['gh_Claimable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateBranchProtectionRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateBranchProtectionRulePayload'] = ResolversParentTypes['gh_CreateBranchProtectionRulePayload']> = ResolversObject<{
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['gh_BranchProtectionRule']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateCheckRunPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateCheckRunPayload'] = ResolversParentTypes['gh_CreateCheckRunPayload']> = ResolversObject<{
  checkRun?: Resolver<Maybe<ResolversTypes['gh_CheckRun']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateCheckSuitePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateCheckSuitePayload'] = ResolversParentTypes['gh_CreateCheckSuitePayload']> = ResolversObject<{
  checkSuite?: Resolver<Maybe<ResolversTypes['gh_CheckSuite']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateCommitOnBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateCommitOnBranchPayload'] = ResolversParentTypes['gh_CreateCommitOnBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateDeploymentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateDeploymentPayload'] = ResolversParentTypes['gh_CreateDeploymentPayload']> = ResolversObject<{
  autoMerged?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deployment?: Resolver<Maybe<ResolversTypes['gh_Deployment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateDeploymentStatusPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateDeploymentStatusPayload'] = ResolversParentTypes['gh_CreateDeploymentStatusPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deploymentStatus?: Resolver<Maybe<ResolversTypes['gh_DeploymentStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateDiscussionPayload'] = ResolversParentTypes['gh_CreateDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['gh_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateEnterpriseOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateEnterpriseOrganizationPayload'] = ResolversParentTypes['gh_CreateEnterpriseOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateEnvironmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateEnvironmentPayload'] = ResolversParentTypes['gh_CreateEnvironmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['gh_Environment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateIpAllowListEntryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateIpAllowListEntryPayload'] = ResolversParentTypes['gh_CreateIpAllowListEntryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ipAllowListEntry?: Resolver<Maybe<ResolversTypes['gh_IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateIssuePayload'] = ResolversParentTypes['gh_CreateIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['gh_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateLabelPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateLabelPayload'] = ResolversParentTypes['gh_CreateLabelPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['gh_Label']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateLinkedBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateLinkedBranchPayload'] = ResolversParentTypes['gh_CreateLinkedBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['gh_Issue']>, ParentType, ContextType>;
  linkedBranch?: Resolver<Maybe<ResolversTypes['gh_LinkedBranch']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateMigrationSourcePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateMigrationSourcePayload'] = ResolversParentTypes['gh_CreateMigrationSourcePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  migrationSource?: Resolver<Maybe<ResolversTypes['gh_MigrationSource']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateProjectPayload'] = ResolversParentTypes['gh_CreateProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateProjectV2FieldPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateProjectV2FieldPayload'] = ResolversParentTypes['gh_CreateProjectV2FieldPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2Field?: Resolver<Maybe<ResolversTypes['gh_ProjectV2FieldConfiguration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateProjectV2PayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateProjectV2Payload'] = ResolversParentTypes['gh_CreateProjectV2Payload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatePullRequestPayload'] = ResolversParentTypes['gh_CreatePullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateRefPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateRefPayload'] = ResolversParentTypes['gh_CreateRefPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateRepositoryPayload'] = ResolversParentTypes['gh_CreateRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateRepositoryRulesetPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateRepositoryRulesetPayload'] = ResolversParentTypes['gh_CreateRepositoryRulesetPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ruleset?: Resolver<Maybe<ResolversTypes['gh_RepositoryRuleset']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateSponsorsListingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateSponsorsListingPayload'] = ResolversParentTypes['gh_CreateSponsorsListingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['gh_SponsorsListing']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateSponsorsTierPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateSponsorsTierPayload'] = ResolversParentTypes['gh_CreateSponsorsTierPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['gh_SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateSponsorshipPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateSponsorshipPayload'] = ResolversParentTypes['gh_CreateSponsorshipPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorship?: Resolver<Maybe<ResolversTypes['gh_Sponsorship']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateSponsorshipsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateSponsorshipsPayload'] = ResolversParentTypes['gh_CreateSponsorshipsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorables?: Resolver<Maybe<Array<ResolversTypes['gh_Sponsorable']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateTeamDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateTeamDiscussionCommentPayload'] = ResolversParentTypes['gh_CreateTeamDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussionComment?: Resolver<Maybe<ResolversTypes['gh_TeamDiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateTeamDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateTeamDiscussionPayload'] = ResolversParentTypes['gh_CreateTeamDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussion?: Resolver<Maybe<ResolversTypes['gh_TeamDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreateUserListPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreateUserListPayload'] = ResolversParentTypes['gh_CreateUserListPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  list?: Resolver<Maybe<ResolversTypes['gh_UserList']>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedCommitContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedCommitContribution'] = ResolversParentTypes['gh_CreatedCommitContribution']> = ResolversObject<{
  commitCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedCommitContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedCommitContributionConnection'] = ResolversParentTypes['gh_CreatedCommitContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CreatedCommitContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CreatedCommitContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedCommitContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedCommitContributionEdge'] = ResolversParentTypes['gh_CreatedCommitContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_CreatedCommitContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedIssueContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedIssueContribution'] = ResolversParentTypes['gh_CreatedIssueContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['gh_Issue'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedIssueContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedIssueContributionConnection'] = ResolversParentTypes['gh_CreatedIssueContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CreatedIssueContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CreatedIssueContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedIssueContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedIssueContributionEdge'] = ResolversParentTypes['gh_CreatedIssueContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_CreatedIssueContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedIssueOrRestrictedContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedIssueOrRestrictedContribution'] = ResolversParentTypes['gh_CreatedIssueOrRestrictedContribution']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_CreatedIssueContribution' | 'gh_RestrictedContribution', ParentType, ContextType>;
}>;

export type gh_CreatedPullRequestContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedPullRequestContribution'] = ResolversParentTypes['gh_CreatedPullRequestContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedPullRequestContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedPullRequestContributionConnection'] = ResolversParentTypes['gh_CreatedPullRequestContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CreatedPullRequestContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CreatedPullRequestContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedPullRequestContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedPullRequestContributionEdge'] = ResolversParentTypes['gh_CreatedPullRequestContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_CreatedPullRequestContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedPullRequestOrRestrictedContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedPullRequestOrRestrictedContribution'] = ResolversParentTypes['gh_CreatedPullRequestOrRestrictedContribution']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_CreatedPullRequestContribution' | 'gh_RestrictedContribution', ParentType, ContextType>;
}>;

export type gh_CreatedPullRequestReviewContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedPullRequestReviewContribution'] = ResolversParentTypes['gh_CreatedPullRequestReviewContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  pullRequestReview?: Resolver<ResolversTypes['gh_PullRequestReview'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedPullRequestReviewContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedPullRequestReviewContributionConnection'] = ResolversParentTypes['gh_CreatedPullRequestReviewContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CreatedPullRequestReviewContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CreatedPullRequestReviewContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedPullRequestReviewContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedPullRequestReviewContributionEdge'] = ResolversParentTypes['gh_CreatedPullRequestReviewContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_CreatedPullRequestReviewContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedRepositoryContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedRepositoryContribution'] = ResolversParentTypes['gh_CreatedRepositoryContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedRepositoryContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedRepositoryContributionConnection'] = ResolversParentTypes['gh_CreatedRepositoryContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CreatedRepositoryContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CreatedRepositoryContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedRepositoryContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedRepositoryContributionEdge'] = ResolversParentTypes['gh_CreatedRepositoryContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_CreatedRepositoryContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_CreatedRepositoryOrRestrictedContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CreatedRepositoryOrRestrictedContribution'] = ResolversParentTypes['gh_CreatedRepositoryOrRestrictedContribution']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_CreatedRepositoryContribution' | 'gh_RestrictedContribution', ParentType, ContextType>;
}>;

export type gh_CrossReferencedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_CrossReferencedEvent'] = ResolversParentTypes['gh_CrossReferencedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  referencedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['gh_ReferencedSubject'], ParentType, ContextType>;
  target?: Resolver<ResolversTypes['gh_ReferencedSubject'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  willCloseTarget?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
  name: 'Date';
}

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
  name: 'DateTime';
}

export type gh_DeclineTopicSuggestionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeclineTopicSuggestionPayload'] = ResolversParentTypes['gh_DeclineTopicSuggestionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['gh_Topic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeletableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Deletable'] = ResolversParentTypes['gh_Deletable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_CommitComment' | 'gh_Discussion' | 'gh_DiscussionComment' | 'gh_GistComment' | 'gh_Issue' | 'gh_IssueComment' | 'gh_PullRequestReview' | 'gh_PullRequestReviewComment' | 'gh_TeamDiscussion' | 'gh_TeamDiscussionComment', ParentType, ContextType>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type gh_DeleteBranchProtectionRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteBranchProtectionRulePayload'] = ResolversParentTypes['gh_DeleteBranchProtectionRulePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteDeploymentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteDeploymentPayload'] = ResolversParentTypes['gh_DeleteDeploymentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteDiscussionCommentPayload'] = ResolversParentTypes['gh_DeleteDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['gh_DiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteDiscussionPayload'] = ResolversParentTypes['gh_DeleteDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['gh_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteEnvironmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteEnvironmentPayload'] = ResolversParentTypes['gh_DeleteEnvironmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteIpAllowListEntryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteIpAllowListEntryPayload'] = ResolversParentTypes['gh_DeleteIpAllowListEntryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ipAllowListEntry?: Resolver<Maybe<ResolversTypes['gh_IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteIssueCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteIssueCommentPayload'] = ResolversParentTypes['gh_DeleteIssueCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteIssuePayload'] = ResolversParentTypes['gh_DeleteIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteLabelPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteLabelPayload'] = ResolversParentTypes['gh_DeleteLabelPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteLinkedBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteLinkedBranchPayload'] = ResolversParentTypes['gh_DeleteLinkedBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['gh_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeletePackageVersionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeletePackageVersionPayload'] = ResolversParentTypes['gh_DeletePackageVersionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteProjectCardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteProjectCardPayload'] = ResolversParentTypes['gh_DeleteProjectCardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  column?: Resolver<Maybe<ResolversTypes['gh_ProjectColumn']>, ParentType, ContextType>;
  deletedCardId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteProjectColumnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteProjectColumnPayload'] = ResolversParentTypes['gh_DeleteProjectColumnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedColumnId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteProjectPayload'] = ResolversParentTypes['gh_DeleteProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['gh_ProjectOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteProjectV2FieldPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteProjectV2FieldPayload'] = ResolversParentTypes['gh_DeleteProjectV2FieldPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2Field?: Resolver<Maybe<ResolversTypes['gh_ProjectV2FieldConfiguration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteProjectV2ItemPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteProjectV2ItemPayload'] = ResolversParentTypes['gh_DeleteProjectV2ItemPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedItemId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteProjectV2PayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteProjectV2Payload'] = ResolversParentTypes['gh_DeleteProjectV2Payload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteProjectV2WorkflowPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteProjectV2WorkflowPayload'] = ResolversParentTypes['gh_DeleteProjectV2WorkflowPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedWorkflowId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeletePullRequestReviewCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeletePullRequestReviewCommentPayload'] = ResolversParentTypes['gh_DeletePullRequestReviewCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['gh_PullRequestReview']>, ParentType, ContextType>;
  pullRequestReviewComment?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeletePullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeletePullRequestReviewPayload'] = ResolversParentTypes['gh_DeletePullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['gh_PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteRefPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteRefPayload'] = ResolversParentTypes['gh_DeleteRefPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteRepositoryRulesetPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteRepositoryRulesetPayload'] = ResolversParentTypes['gh_DeleteRepositoryRulesetPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteTeamDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteTeamDiscussionCommentPayload'] = ResolversParentTypes['gh_DeleteTeamDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteTeamDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteTeamDiscussionPayload'] = ResolversParentTypes['gh_DeleteTeamDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteUserListPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteUserListPayload'] = ResolversParentTypes['gh_DeleteUserListPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeleteVerifiableDomainPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeleteVerifiableDomainPayload'] = ResolversParentTypes['gh_DeleteVerifiableDomainPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['gh_VerifiableDomainOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DemilestonedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DemilestonedEvent'] = ResolversParentTypes['gh_DemilestonedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  milestoneTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['gh_MilestoneItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DependabotUpdateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DependabotUpdate'] = ResolversParentTypes['gh_DependabotUpdate']> = ResolversObject<{
  error?: Resolver<Maybe<ResolversTypes['gh_DependabotUpdateError']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DependabotUpdateErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DependabotUpdateError'] = ResolversParentTypes['gh_DependabotUpdateError']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  errorType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DependencyGraphDependencyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DependencyGraphDependency'] = ResolversParentTypes['gh_DependencyGraphDependency']> = ResolversObject<{
  hasDependencies?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  packageLabel?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  packageManager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  packageName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  requirements?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DependencyGraphDependencyConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DependencyGraphDependencyConnection'] = ResolversParentTypes['gh_DependencyGraphDependencyConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DependencyGraphDependencyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DependencyGraphDependency']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DependencyGraphDependencyEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DependencyGraphDependencyEdge'] = ResolversParentTypes['gh_DependencyGraphDependencyEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_DependencyGraphDependency']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DependencyGraphManifestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DependencyGraphManifest'] = ResolversParentTypes['gh_DependencyGraphManifest']> = ResolversObject<{
  blobPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  dependencies?: Resolver<Maybe<ResolversTypes['gh_DependencyGraphDependencyConnection']>, ParentType, ContextType, Partial<gh_DependencyGraphManifestdependenciesArgs>>;
  dependenciesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  exceedsMaxSize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  filename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parseable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DependencyGraphManifestConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DependencyGraphManifestConnection'] = ResolversParentTypes['gh_DependencyGraphManifestConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DependencyGraphManifestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DependencyGraphManifest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DependencyGraphManifestEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DependencyGraphManifestEdge'] = ResolversParentTypes['gh_DependencyGraphManifestEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_DependencyGraphManifest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeployKeyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeployKey'] = ResolversParentTypes['gh_DeployKey']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  readOnly?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeployKeyConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeployKeyConnection'] = ResolversParentTypes['gh_DeployKeyConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DeployKeyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DeployKey']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeployKeyEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeployKeyEdge'] = ResolversParentTypes['gh_DeployKeyEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_DeployKey']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeployedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeployedEvent'] = ResolversParentTypes['gh_DeployedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deployment?: Resolver<ResolversTypes['gh_Deployment'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Deployment'] = ResolversParentTypes['gh_Deployment']> = ResolversObject<{
  commit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  commitOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<ResolversTypes['gh_Actor'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  latestEnvironment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latestStatus?: Resolver<Maybe<ResolversTypes['gh_DeploymentStatus']>, ParentType, ContextType>;
  originalEnvironment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  payload?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['gh_DeploymentState']>, ParentType, ContextType>;
  statuses?: Resolver<Maybe<ResolversTypes['gh_DeploymentStatusConnection']>, ParentType, ContextType, Partial<gh_DeploymentstatusesArgs>>;
  task?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentConnection'] = ResolversParentTypes['gh_DeploymentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DeploymentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Deployment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentEdge'] = ResolversParentTypes['gh_DeploymentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Deployment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentEnvironmentChangedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentEnvironmentChangedEvent'] = ResolversParentTypes['gh_DeploymentEnvironmentChangedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  deploymentStatus?: Resolver<ResolversTypes['gh_DeploymentStatus'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentProtectionRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentProtectionRule'] = ResolversParentTypes['gh_DeploymentProtectionRule']> = ResolversObject<{
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  preventSelfReview?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  reviewers?: Resolver<ResolversTypes['gh_DeploymentReviewerConnection'], ParentType, ContextType, Partial<gh_DeploymentProtectionRulereviewersArgs>>;
  timeout?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['gh_DeploymentProtectionRuleType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentProtectionRuleConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentProtectionRuleConnection'] = ResolversParentTypes['gh_DeploymentProtectionRuleConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DeploymentProtectionRuleEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DeploymentProtectionRule']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentProtectionRuleEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentProtectionRuleEdge'] = ResolversParentTypes['gh_DeploymentProtectionRuleEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_DeploymentProtectionRule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentRequest'] = ResolversParentTypes['gh_DeploymentRequest']> = ResolversObject<{
  currentUserCanApprove?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  environment?: Resolver<ResolversTypes['gh_Environment'], ParentType, ContextType>;
  reviewers?: Resolver<ResolversTypes['gh_DeploymentReviewerConnection'], ParentType, ContextType, Partial<gh_DeploymentRequestreviewersArgs>>;
  waitTimer?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  waitTimerStartedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentRequestConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentRequestConnection'] = ResolversParentTypes['gh_DeploymentRequestConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DeploymentRequestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DeploymentRequest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentRequestEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentRequestEdge'] = ResolversParentTypes['gh_DeploymentRequestEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_DeploymentRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentReviewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentReview'] = ResolversParentTypes['gh_DeploymentReview']> = ResolversObject<{
  comment?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  environments?: Resolver<ResolversTypes['gh_EnvironmentConnection'], ParentType, ContextType, Partial<gh_DeploymentReviewenvironmentsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_DeploymentReviewState'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentReviewConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentReviewConnection'] = ResolversParentTypes['gh_DeploymentReviewConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DeploymentReviewEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DeploymentReview']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentReviewEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentReviewEdge'] = ResolversParentTypes['gh_DeploymentReviewEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_DeploymentReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentReviewerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentReviewer'] = ResolversParentTypes['gh_DeploymentReviewer']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Team' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_DeploymentReviewerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentReviewerConnection'] = ResolversParentTypes['gh_DeploymentReviewerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DeploymentReviewerEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DeploymentReviewer']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentReviewerEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentReviewerEdge'] = ResolversParentTypes['gh_DeploymentReviewerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_DeploymentReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentStatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentStatus'] = ResolversParentTypes['gh_DeploymentStatus']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<ResolversTypes['gh_Actor'], ParentType, ContextType>;
  deployment?: Resolver<ResolversTypes['gh_Deployment'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environmentUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  logUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_DeploymentStatusState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentStatusConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentStatusConnection'] = ResolversParentTypes['gh_DeploymentStatusConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DeploymentStatusEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DeploymentStatus']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DeploymentStatusEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DeploymentStatusEdge'] = ResolversParentTypes['gh_DeploymentStatusEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_DeploymentStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DequeuePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DequeuePullRequestPayload'] = ResolversParentTypes['gh_DequeuePullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mergeQueueEntry?: Resolver<Maybe<ResolversTypes['gh_MergeQueueEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DisablePullRequestAutoMergePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DisablePullRequestAutoMergePayload'] = ResolversParentTypes['gh_DisablePullRequestAutoMergePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DisconnectedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DisconnectedEvent'] = ResolversParentTypes['gh_DisconnectedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['gh_ReferencedSubject'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['gh_ReferencedSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DiscussionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Discussion'] = ResolversParentTypes['gh_Discussion']> = ResolversObject<{
  activeLockReason?: Resolver<Maybe<ResolversTypes['gh_LockReason']>, ParentType, ContextType>;
  answer?: Resolver<Maybe<ResolversTypes['gh_DiscussionComment']>, ParentType, ContextType>;
  answerChosenAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  answerChosenBy?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  author?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['gh_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  category?: Resolver<ResolversTypes['gh_DiscussionCategory'], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['gh_DiscussionCommentConnection'], ParentType, ContextType, Partial<gh_DiscussioncommentsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isAnswered?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['gh_LabelConnection']>, ParentType, ContextType, RequireFields<gh_DiscussionlabelsArgs, 'orderBy'>>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  locked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  poll?: Resolver<Maybe<ResolversTypes['gh_DiscussionPoll']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['gh_ReactionConnection'], ParentType, ContextType, Partial<gh_DiscussionreactionsArgs>>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  stateReason?: Resolver<Maybe<ResolversTypes['gh_DiscussionStateReason']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  upvoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['gh_UserContentEditConnection']>, ParentType, ContextType, Partial<gh_DiscussionuserContentEditsArgs>>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpvote?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasUpvoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['gh_SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DiscussionCategoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DiscussionCategory'] = ResolversParentTypes['gh_DiscussionCategory']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emoji?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  emojiHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isAnswerable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DiscussionCategoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DiscussionCategoryConnection'] = ResolversParentTypes['gh_DiscussionCategoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DiscussionCategoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DiscussionCategory']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DiscussionCategoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DiscussionCategoryEdge'] = ResolversParentTypes['gh_DiscussionCategoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_DiscussionCategory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DiscussionCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DiscussionComment'] = ResolversParentTypes['gh_DiscussionComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['gh_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deletedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['gh_Discussion']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isAnswer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['gh_ReactionConnection'], ParentType, ContextType, Partial<gh_DiscussionCommentreactionsArgs>>;
  replies?: Resolver<ResolversTypes['gh_DiscussionCommentConnection'], ParentType, ContextType, Partial<gh_DiscussionCommentrepliesArgs>>;
  replyTo?: Resolver<Maybe<ResolversTypes['gh_DiscussionComment']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  upvoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['gh_UserContentEditConnection']>, ParentType, ContextType, Partial<gh_DiscussionCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMarkAsAnswer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUnmarkAsAnswer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpvote?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['gh_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasUpvoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DiscussionCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DiscussionCommentConnection'] = ResolversParentTypes['gh_DiscussionCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DiscussionCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DiscussionComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DiscussionCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DiscussionCommentEdge'] = ResolversParentTypes['gh_DiscussionCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_DiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DiscussionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DiscussionConnection'] = ResolversParentTypes['gh_DiscussionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DiscussionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Discussion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DiscussionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DiscussionEdge'] = ResolversParentTypes['gh_DiscussionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DiscussionPollResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DiscussionPoll'] = ResolversParentTypes['gh_DiscussionPoll']> = ResolversObject<{
  discussion?: Resolver<Maybe<ResolversTypes['gh_Discussion']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  options?: Resolver<Maybe<ResolversTypes['gh_DiscussionPollOptionConnection']>, ParentType, ContextType, RequireFields<gh_DiscussionPolloptionsArgs, 'orderBy'>>;
  question?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalVoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerCanVote?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasVoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DiscussionPollOptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DiscussionPollOption'] = ResolversParentTypes['gh_DiscussionPollOption']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  option?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  poll?: Resolver<Maybe<ResolversTypes['gh_DiscussionPoll']>, ParentType, ContextType>;
  totalVoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerHasVoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DiscussionPollOptionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DiscussionPollOptionConnection'] = ResolversParentTypes['gh_DiscussionPollOptionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DiscussionPollOptionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_DiscussionPollOption']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DiscussionPollOptionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DiscussionPollOptionEdge'] = ResolversParentTypes['gh_DiscussionPollOptionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_DiscussionPollOption']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DismissPullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DismissPullRequestReviewPayload'] = ResolversParentTypes['gh_DismissPullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['gh_PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DismissRepositoryVulnerabilityAlertPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DismissRepositoryVulnerabilityAlertPayload'] = ResolversParentTypes['gh_DismissRepositoryVulnerabilityAlertPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryVulnerabilityAlert?: Resolver<Maybe<ResolversTypes['gh_RepositoryVulnerabilityAlert']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_DraftIssueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_DraftIssue'] = ResolversParentTypes['gh_DraftIssue']> = ResolversObject<{
  assignees?: Resolver<ResolversTypes['gh_UserConnection'], ParentType, ContextType, Partial<gh_DraftIssueassigneesArgs>>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  projectV2Items?: Resolver<ResolversTypes['gh_ProjectV2ItemConnection'], ParentType, ContextType, Partial<gh_DraftIssueprojectV2ItemsArgs>>;
  projectsV2?: Resolver<ResolversTypes['gh_ProjectV2Connection'], ParentType, ContextType, Partial<gh_DraftIssueprojectsV2Args>>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnablePullRequestAutoMergePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnablePullRequestAutoMergePayload'] = ResolversParentTypes['gh_EnablePullRequestAutoMergePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnqueuePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnqueuePullRequestPayload'] = ResolversParentTypes['gh_EnqueuePullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mergeQueueEntry?: Resolver<Maybe<ResolversTypes['gh_MergeQueueEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Enterprise'] = ResolversParentTypes['gh_Enterprise']> = ResolversObject<{
  announcement?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  announcementExpiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  announcementUserDismissible?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  avatarUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType, Partial<gh_EnterpriseavatarUrlArgs>>;
  billingInfo?: Resolver<Maybe<ResolversTypes['gh_EnterpriseBillingInfo']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  members?: Resolver<ResolversTypes['gh_EnterpriseMemberConnection'], ParentType, ContextType, RequireFields<gh_EnterprisemembersArgs, 'hasTwoFactorEnabled' | 'orderBy'>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  organizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseorganizationsArgs, 'orderBy'>>;
  ownerInfo?: Resolver<Maybe<ResolversTypes['gh_EnterpriseOwnerInfo']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  viewerIsAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  websiteUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseAdministratorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseAdministratorConnection'] = ResolversParentTypes['gh_EnterpriseAdministratorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseAdministratorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseAdministratorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseAdministratorEdge'] = ResolversParentTypes['gh_EnterpriseAdministratorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  role?: Resolver<ResolversTypes['gh_EnterpriseAdministratorRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseAdministratorInvitationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseAdministratorInvitation'] = ResolversParentTypes['gh_EnterpriseAdministratorInvitation']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<ResolversTypes['gh_Enterprise'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitee?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  inviter?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  role?: Resolver<ResolversTypes['gh_EnterpriseAdministratorRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseAdministratorInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseAdministratorInvitationConnection'] = ResolversParentTypes['gh_EnterpriseAdministratorInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseAdministratorInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseAdministratorInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseAdministratorInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseAdministratorInvitationEdge'] = ResolversParentTypes['gh_EnterpriseAdministratorInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseAuditEntryData'] = ResolversParentTypes['gh_EnterpriseAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_MembersCanDeleteReposClearAuditEntry' | 'gh_MembersCanDeleteReposDisableAuditEntry' | 'gh_MembersCanDeleteReposEnableAuditEntry' | 'gh_OrgInviteToBusinessAuditEntry' | 'gh_PrivateRepositoryForkingDisableAuditEntry' | 'gh_PrivateRepositoryForkingEnableAuditEntry' | 'gh_RepositoryVisibilityChangeDisableAuditEntry' | 'gh_RepositoryVisibilityChangeEnableAuditEntry', ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
}>;

export type gh_EnterpriseBillingInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseBillingInfo'] = ResolversParentTypes['gh_EnterpriseBillingInfo']> = ResolversObject<{
  allLicensableUsersCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  assetPacks?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  bandwidthQuota?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  bandwidthUsage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  bandwidthUsagePercentage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  storageQuota?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  storageUsage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  storageUsagePercentage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalAvailableLicenses?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalLicenses?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseConnection'] = ResolversParentTypes['gh_EnterpriseConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Enterprise']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseEdge'] = ResolversParentTypes['gh_EnterpriseEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseFailedInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseFailedInvitationConnection'] = ResolversParentTypes['gh_EnterpriseFailedInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseFailedInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_OrganizationInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalUniqueUserCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseFailedInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseFailedInvitationEdge'] = ResolversParentTypes['gh_EnterpriseFailedInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_OrganizationInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseIdentityProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseIdentityProvider'] = ResolversParentTypes['gh_EnterpriseIdentityProvider']> = ResolversObject<{
  digestMethod?: Resolver<Maybe<ResolversTypes['gh_SamlDigestAlgorithm']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  externalIdentities?: Resolver<ResolversTypes['gh_ExternalIdentityConnection'], ParentType, ContextType, Partial<gh_EnterpriseIdentityProviderexternalIdentitiesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  idpCertificate?: Resolver<Maybe<ResolversTypes['gh_X509Certificate']>, ParentType, ContextType>;
  issuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  recoveryCodes?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  signatureMethod?: Resolver<Maybe<ResolversTypes['gh_SamlSignatureAlgorithm']>, ParentType, ContextType>;
  ssoUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseMemberResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseMember'] = ResolversParentTypes['gh_EnterpriseMember']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_EnterpriseUserAccount' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_EnterpriseMemberConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseMemberConnection'] = ResolversParentTypes['gh_EnterpriseMemberConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseMemberEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseMember']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseMemberEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseMemberEdge'] = ResolversParentTypes['gh_EnterpriseMemberEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_EnterpriseMember']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseOrganizationMembershipConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseOrganizationMembershipConnection'] = ResolversParentTypes['gh_EnterpriseOrganizationMembershipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseOrganizationMembershipEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Organization']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseOrganizationMembershipEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseOrganizationMembershipEdge'] = ResolversParentTypes['gh_EnterpriseOrganizationMembershipEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  role?: Resolver<ResolversTypes['gh_EnterpriseUserAccountMembershipRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseOutsideCollaboratorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseOutsideCollaboratorConnection'] = ResolversParentTypes['gh_EnterpriseOutsideCollaboratorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseOutsideCollaboratorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseOutsideCollaboratorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseOutsideCollaboratorEdge'] = ResolversParentTypes['gh_EnterpriseOutsideCollaboratorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  repositories?: Resolver<ResolversTypes['gh_EnterpriseRepositoryInfoConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOutsideCollaboratorEdgerepositoriesArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseOwnerInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseOwnerInfo'] = ResolversParentTypes['gh_EnterpriseOwnerInfo']> = ResolversObject<{
  admins?: Resolver<ResolversTypes['gh_EnterpriseAdministratorConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfoadminsArgs, 'hasTwoFactorEnabled' | 'orderBy'>>;
  affiliatedUsersWithTwoFactorDisabled?: Resolver<ResolversTypes['gh_UserConnection'], ParentType, ContextType, Partial<gh_EnterpriseOwnerInfoaffiliatedUsersWithTwoFactorDisabledArgs>>;
  affiliatedUsersWithTwoFactorDisabledExist?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  allowPrivateRepositoryForkingSetting?: Resolver<ResolversTypes['gh_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  allowPrivateRepositoryForkingSettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfoallowPrivateRepositoryForkingSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  allowPrivateRepositoryForkingSettingPolicyValue?: Resolver<Maybe<ResolversTypes['gh_EnterpriseAllowPrivateRepositoryForkingPolicyValue']>, ParentType, ContextType>;
  defaultRepositoryPermissionSetting?: Resolver<ResolversTypes['gh_EnterpriseDefaultRepositoryPermissionSettingValue'], ParentType, ContextType>;
  defaultRepositoryPermissionSettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfodefaultRepositoryPermissionSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  domains?: Resolver<ResolversTypes['gh_VerifiableDomainConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfodomainsArgs, 'isApproved' | 'isVerified' | 'orderBy'>>;
  enterpriseServerInstallations?: Resolver<ResolversTypes['gh_EnterpriseServerInstallationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfoenterpriseServerInstallationsArgs, 'connectedOnly' | 'orderBy'>>;
  failedInvitations?: Resolver<ResolversTypes['gh_EnterpriseFailedInvitationConnection'], ParentType, ContextType, Partial<gh_EnterpriseOwnerInfofailedInvitationsArgs>>;
  ipAllowListEnabledSetting?: Resolver<ResolversTypes['gh_IpAllowListEnabledSettingValue'], ParentType, ContextType>;
  ipAllowListEntries?: Resolver<ResolversTypes['gh_IpAllowListEntryConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfoipAllowListEntriesArgs, 'orderBy'>>;
  ipAllowListForInstalledAppsEnabledSetting?: Resolver<ResolversTypes['gh_IpAllowListForInstalledAppsEnabledSettingValue'], ParentType, ContextType>;
  isUpdatingDefaultRepositoryPermission?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isUpdatingTwoFactorRequirement?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  membersCanChangeRepositoryVisibilitySetting?: Resolver<ResolversTypes['gh_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanChangeRepositoryVisibilitySettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfomembersCanChangeRepositoryVisibilitySettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanCreateInternalRepositoriesSetting?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  membersCanCreatePrivateRepositoriesSetting?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  membersCanCreatePublicRepositoriesSetting?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  membersCanCreateRepositoriesSetting?: Resolver<Maybe<ResolversTypes['gh_EnterpriseMembersCanCreateRepositoriesSettingValue']>, ParentType, ContextType>;
  membersCanCreateRepositoriesSettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfomembersCanCreateRepositoriesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanDeleteIssuesSetting?: Resolver<ResolversTypes['gh_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanDeleteIssuesSettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfomembersCanDeleteIssuesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanDeleteRepositoriesSetting?: Resolver<ResolversTypes['gh_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanDeleteRepositoriesSettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfomembersCanDeleteRepositoriesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanInviteCollaboratorsSetting?: Resolver<ResolversTypes['gh_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanInviteCollaboratorsSettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfomembersCanInviteCollaboratorsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanMakePurchasesSetting?: Resolver<ResolversTypes['gh_EnterpriseMembersCanMakePurchasesSettingValue'], ParentType, ContextType>;
  membersCanUpdateProtectedBranchesSetting?: Resolver<ResolversTypes['gh_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanUpdateProtectedBranchesSettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfomembersCanUpdateProtectedBranchesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanViewDependencyInsightsSetting?: Resolver<ResolversTypes['gh_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanViewDependencyInsightsSettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfomembersCanViewDependencyInsightsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  notificationDeliveryRestrictionEnabledSetting?: Resolver<ResolversTypes['gh_NotificationRestrictionSettingValue'], ParentType, ContextType>;
  oidcProvider?: Resolver<Maybe<ResolversTypes['gh_OIDCProvider']>, ParentType, ContextType>;
  organizationProjectsSetting?: Resolver<ResolversTypes['gh_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  organizationProjectsSettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfoorganizationProjectsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  outsideCollaborators?: Resolver<ResolversTypes['gh_EnterpriseOutsideCollaboratorConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfooutsideCollaboratorsArgs, 'hasTwoFactorEnabled' | 'orderBy'>>;
  pendingAdminInvitations?: Resolver<ResolversTypes['gh_EnterpriseAdministratorInvitationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfopendingAdminInvitationsArgs, 'orderBy'>>;
  pendingCollaboratorInvitations?: Resolver<ResolversTypes['gh_RepositoryInvitationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfopendingCollaboratorInvitationsArgs, 'orderBy'>>;
  pendingMemberInvitations?: Resolver<ResolversTypes['gh_EnterprisePendingMemberInvitationConnection'], ParentType, ContextType, Partial<gh_EnterpriseOwnerInfopendingMemberInvitationsArgs>>;
  repositoryProjectsSetting?: Resolver<ResolversTypes['gh_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  repositoryProjectsSettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInforepositoryProjectsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  samlIdentityProvider?: Resolver<Maybe<ResolversTypes['gh_EnterpriseIdentityProvider']>, ParentType, ContextType>;
  samlIdentityProviderSettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfosamlIdentityProviderSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  supportEntitlements?: Resolver<ResolversTypes['gh_EnterpriseMemberConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfosupportEntitlementsArgs, 'orderBy'>>;
  teamDiscussionsSetting?: Resolver<ResolversTypes['gh_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  teamDiscussionsSettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfoteamDiscussionsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  twoFactorRequiredSetting?: Resolver<ResolversTypes['gh_EnterpriseEnabledSettingValue'], ParentType, ContextType>;
  twoFactorRequiredSettingOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseOwnerInfotwoFactorRequiredSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterprisePendingMemberInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterprisePendingMemberInvitationConnection'] = ResolversParentTypes['gh_EnterprisePendingMemberInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterprisePendingMemberInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_OrganizationInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalUniqueUserCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterprisePendingMemberInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterprisePendingMemberInvitationEdge'] = ResolversParentTypes['gh_EnterprisePendingMemberInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_OrganizationInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseRepositoryInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseRepositoryInfo'] = ResolversParentTypes['gh_EnterpriseRepositoryInfo']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameWithOwner?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseRepositoryInfoConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseRepositoryInfoConnection'] = ResolversParentTypes['gh_EnterpriseRepositoryInfoConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseRepositoryInfoEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseRepositoryInfo']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseRepositoryInfoEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseRepositoryInfoEdge'] = ResolversParentTypes['gh_EnterpriseRepositoryInfoEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_EnterpriseRepositoryInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerInstallationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerInstallation'] = ResolversParentTypes['gh_EnterpriseServerInstallation']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  customerName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  hostName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isConnected?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userAccounts?: Resolver<ResolversTypes['gh_EnterpriseServerUserAccountConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseServerInstallationuserAccountsArgs, 'orderBy'>>;
  userAccountsUploads?: Resolver<ResolversTypes['gh_EnterpriseServerUserAccountsUploadConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseServerInstallationuserAccountsUploadsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerInstallationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerInstallationConnection'] = ResolversParentTypes['gh_EnterpriseServerInstallationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseServerInstallationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseServerInstallation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerInstallationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerInstallationEdge'] = ResolversParentTypes['gh_EnterpriseServerInstallationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_EnterpriseServerInstallation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerInstallationMembershipConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerInstallationMembershipConnection'] = ResolversParentTypes['gh_EnterpriseServerInstallationMembershipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseServerInstallationMembershipEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseServerInstallation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerInstallationMembershipEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerInstallationMembershipEdge'] = ResolversParentTypes['gh_EnterpriseServerInstallationMembershipEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_EnterpriseServerInstallation']>, ParentType, ContextType>;
  role?: Resolver<ResolversTypes['gh_EnterpriseUserAccountMembershipRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerUserAccountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerUserAccount'] = ResolversParentTypes['gh_EnterpriseServerUserAccount']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  emails?: Resolver<ResolversTypes['gh_EnterpriseServerUserAccountEmailConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseServerUserAccountemailsArgs, 'orderBy'>>;
  enterpriseServerInstallation?: Resolver<ResolversTypes['gh_EnterpriseServerInstallation'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isSiteAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  profileName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  remoteCreatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  remoteUserId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerUserAccountConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerUserAccountConnection'] = ResolversParentTypes['gh_EnterpriseServerUserAccountConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseServerUserAccountEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseServerUserAccount']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerUserAccountEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerUserAccountEdge'] = ResolversParentTypes['gh_EnterpriseServerUserAccountEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_EnterpriseServerUserAccount']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerUserAccountEmailResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerUserAccountEmail'] = ResolversParentTypes['gh_EnterpriseServerUserAccountEmail']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPrimary?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userAccount?: Resolver<ResolversTypes['gh_EnterpriseServerUserAccount'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerUserAccountEmailConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerUserAccountEmailConnection'] = ResolversParentTypes['gh_EnterpriseServerUserAccountEmailConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseServerUserAccountEmailEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseServerUserAccountEmail']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerUserAccountEmailEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerUserAccountEmailEdge'] = ResolversParentTypes['gh_EnterpriseServerUserAccountEmailEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_EnterpriseServerUserAccountEmail']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerUserAccountsUploadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerUserAccountsUpload'] = ResolversParentTypes['gh_EnterpriseServerUserAccountsUpload']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enterprise?: Resolver<ResolversTypes['gh_Enterprise'], ParentType, ContextType>;
  enterpriseServerInstallation?: Resolver<ResolversTypes['gh_EnterpriseServerInstallation'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  syncState?: Resolver<ResolversTypes['gh_EnterpriseServerUserAccountsUploadSyncState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerUserAccountsUploadConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerUserAccountsUploadConnection'] = ResolversParentTypes['gh_EnterpriseServerUserAccountsUploadConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseServerUserAccountsUploadEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnterpriseServerUserAccountsUpload']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseServerUserAccountsUploadEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseServerUserAccountsUploadEdge'] = ResolversParentTypes['gh_EnterpriseServerUserAccountsUploadEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_EnterpriseServerUserAccountsUpload']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnterpriseUserAccountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnterpriseUserAccount'] = ResolversParentTypes['gh_EnterpriseUserAccount']> = ResolversObject<{
  avatarUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType, Partial<gh_EnterpriseUserAccountavatarUrlArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enterprise?: Resolver<ResolversTypes['gh_Enterprise'], ParentType, ContextType>;
  enterpriseInstallations?: Resolver<ResolversTypes['gh_EnterpriseServerInstallationMembershipConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseUserAccountenterpriseInstallationsArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizations?: Resolver<ResolversTypes['gh_EnterpriseOrganizationMembershipConnection'], ParentType, ContextType, RequireFields<gh_EnterpriseUserAccountorganizationsArgs, 'orderBy'>>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnvironmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Environment'] = ResolversParentTypes['gh_Environment']> = ResolversObject<{
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  protectionRules?: Resolver<ResolversTypes['gh_DeploymentProtectionRuleConnection'], ParentType, ContextType, Partial<gh_EnvironmentprotectionRulesArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnvironmentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnvironmentConnection'] = ResolversParentTypes['gh_EnvironmentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_EnvironmentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Environment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_EnvironmentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_EnvironmentEdge'] = ResolversParentTypes['gh_EnvironmentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Environment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ExternalIdentityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ExternalIdentity'] = ResolversParentTypes['gh_ExternalIdentity']> = ResolversObject<{
  guid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organizationInvitation?: Resolver<Maybe<ResolversTypes['gh_OrganizationInvitation']>, ParentType, ContextType>;
  samlIdentity?: Resolver<Maybe<ResolversTypes['gh_ExternalIdentitySamlAttributes']>, ParentType, ContextType>;
  scimIdentity?: Resolver<Maybe<ResolversTypes['gh_ExternalIdentityScimAttributes']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ExternalIdentityAttributeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ExternalIdentityAttribute'] = ResolversParentTypes['gh_ExternalIdentityAttribute']> = ResolversObject<{
  metadata?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ExternalIdentityConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ExternalIdentityConnection'] = ResolversParentTypes['gh_ExternalIdentityConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ExternalIdentityEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ExternalIdentity']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ExternalIdentityEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ExternalIdentityEdge'] = ResolversParentTypes['gh_ExternalIdentityEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ExternalIdentity']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ExternalIdentitySamlAttributesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ExternalIdentitySamlAttributes'] = ResolversParentTypes['gh_ExternalIdentitySamlAttributes']> = ResolversObject<{
  attributes?: Resolver<Array<ResolversTypes['gh_ExternalIdentityAttribute']>, ParentType, ContextType>;
  emails?: Resolver<Maybe<Array<ResolversTypes['gh_UserEmailMetadata']>>, ParentType, ContextType>;
  familyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  givenName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groups?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  nameId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ExternalIdentityScimAttributesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ExternalIdentityScimAttributes'] = ResolversParentTypes['gh_ExternalIdentityScimAttributes']> = ResolversObject<{
  emails?: Resolver<Maybe<Array<ResolversTypes['gh_UserEmailMetadata']>>, ParentType, ContextType>;
  familyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  givenName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groups?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_FollowOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_FollowOrganizationPayload'] = ResolversParentTypes['gh_FollowOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_FollowUserPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_FollowUserPayload'] = ResolversParentTypes['gh_FollowUserPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_FollowerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_FollowerConnection'] = ResolversParentTypes['gh_FollowerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_UserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_FollowingConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_FollowingConnection'] = ResolversParentTypes['gh_FollowingConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_UserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_FundingLinkResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_FundingLink'] = ResolversParentTypes['gh_FundingLink']> = ResolversObject<{
  platform?: Resolver<ResolversTypes['gh_FundingPlatform'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GenericHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GenericHovercardContext'] = ResolversParentTypes['gh_GenericHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GistResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Gist'] = ResolversParentTypes['gh_Gist']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['gh_GistCommentConnection'], ParentType, ContextType, Partial<gh_GistcommentsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  files?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_GistFile']>>>, ParentType, ContextType, RequireFields<gh_GistfilesArgs, 'limit'>>;
  forks?: Resolver<ResolversTypes['gh_GistConnection'], ParentType, ContextType, Partial<gh_GistforksArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isFork?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPublic?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['gh_RepositoryOwner']>, ParentType, ContextType>;
  pushedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  stargazerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stargazers?: Resolver<ResolversTypes['gh_StargazerConnection'], ParentType, ContextType, Partial<gh_GiststargazersArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  viewerHasStarred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GistCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GistComment'] = ResolversParentTypes['gh_GistComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['gh_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  gist?: Resolver<ResolversTypes['gh_Gist'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['gh_UserContentEditConnection']>, ParentType, ContextType, Partial<gh_GistCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['gh_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GistCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GistCommentConnection'] = ResolversParentTypes['gh_GistCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_GistCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_GistComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GistCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GistCommentEdge'] = ResolversParentTypes['gh_GistCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_GistComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GistConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GistConnection'] = ResolversParentTypes['gh_GistConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_GistEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Gist']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GistEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GistEdge'] = ResolversParentTypes['gh_GistEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Gist']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GistFileResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GistFile'] = ResolversParentTypes['gh_GistFile']> = ResolversObject<{
  encodedName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  encoding?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  extension?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isImage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isTruncated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  language?: Resolver<Maybe<ResolversTypes['gh_Language']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<gh_GistFiletextArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GitActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GitActor'] = ResolversParentTypes['gh_GitActor']> = ResolversObject<{
  avatarUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType, Partial<gh_GitActoravatarUrlArgs>>;
  date?: Resolver<Maybe<ResolversTypes['gh_GitTimestamp']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GitActorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GitActorConnection'] = ResolversParentTypes['gh_GitActorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_GitActorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_GitActor']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GitActorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GitActorEdge'] = ResolversParentTypes['gh_GitActorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_GitActor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GitHubMetadataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GitHubMetadata'] = ResolversParentTypes['gh_GitHubMetadata']> = ResolversObject<{
  gitHubServicesSha?: Resolver<ResolversTypes['gh_GitObjectID'], ParentType, ContextType>;
  gitIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  githubEnterpriseImporterIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  hookIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  importerIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  isPasswordAuthenticationVerifiable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  pagesIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GitObjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GitObject'] = ResolversParentTypes['gh_GitObject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Blob' | 'gh_Commit' | 'gh_Tag' | 'gh_Tree', ParentType, ContextType>;
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['gh_GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
}>;

export interface gh_GitObjectIDScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['gh_GitObjectID'], any> {
  name: 'gh_GitObjectID';
}

export interface gh_GitRefnameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['gh_GitRefname'], any> {
  name: 'gh_GitRefname';
}

export interface gh_GitSSHRemoteScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['gh_GitSSHRemote'], any> {
  name: 'gh_GitSSHRemote';
}

export type gh_GitSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GitSignature'] = ResolversParentTypes['gh_GitSignature']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_GpgSignature' | 'gh_SmimeSignature' | 'gh_SshSignature' | 'gh_UnknownSignature', ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export interface gh_GitTimestampScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['gh_GitTimestamp'], any> {
  name: 'gh_GitTimestamp';
}

export type gh_GpgSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GpgSignature'] = ResolversParentTypes['gh_GpgSignature']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  keyId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GrantEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GrantEnterpriseOrganizationsMigratorRolePayload'] = ResolversParentTypes['gh_GrantEnterpriseOrganizationsMigratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizations?: Resolver<Maybe<ResolversTypes['gh_OrganizationConnection']>, ParentType, ContextType, Partial<gh_GrantEnterpriseOrganizationsMigratorRolePayloadorganizationsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_GrantMigratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_GrantMigratorRolePayload'] = ResolversParentTypes['gh_GrantMigratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface gh_HTMLScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['gh_HTML'], any> {
  name: 'gh_HTML';
}

export type gh_HeadRefDeletedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_HeadRefDeletedEvent'] = ResolversParentTypes['gh_HeadRefDeletedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  headRef?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  headRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_HeadRefForcePushedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_HeadRefForcePushedEvent'] = ResolversParentTypes['gh_HeadRefForcePushedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  afterCommit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  beforeCommit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_HeadRefRestoredEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_HeadRefRestoredEvent'] = ResolversParentTypes['gh_HeadRefRestoredEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_HovercardResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Hovercard'] = ResolversParentTypes['gh_Hovercard']> = ResolversObject<{
  contexts?: Resolver<Array<ResolversTypes['gh_HovercardContext']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_HovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_HovercardContext'] = ResolversParentTypes['gh_HovercardContext']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_GenericHovercardContext' | 'gh_OrganizationTeamsHovercardContext' | 'gh_OrganizationsHovercardContext' | 'gh_ReviewStatusHovercardContext' | 'gh_ViewerHovercardContext', ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
}>;

export type gh_ImportProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ImportProjectPayload'] = ResolversParentTypes['gh_ImportProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_InviteEnterpriseAdminPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_InviteEnterpriseAdminPayload'] = ResolversParentTypes['gh_InviteEnterpriseAdminPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<ResolversTypes['gh_EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IpAllowListEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IpAllowListEntry'] = ResolversParentTypes['gh_IpAllowListEntry']> = ResolversObject<{
  allowListValue?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['gh_IpAllowListOwner'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IpAllowListEntryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IpAllowListEntryConnection'] = ResolversParentTypes['gh_IpAllowListEntryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_IpAllowListEntryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_IpAllowListEntry']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IpAllowListEntryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IpAllowListEntryEdge'] = ResolversParentTypes['gh_IpAllowListEntryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IpAllowListOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IpAllowListOwner'] = ResolversParentTypes['gh_IpAllowListOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_App' | 'gh_Enterprise' | 'gh_Organization', ParentType, ContextType>;
}>;

export type gh_IssueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Issue'] = ResolversParentTypes['gh_Issue']> = ResolversObject<{
  activeLockReason?: Resolver<Maybe<ResolversTypes['gh_LockReason']>, ParentType, ContextType>;
  assignees?: Resolver<ResolversTypes['gh_UserConnection'], ParentType, ContextType, Partial<gh_IssueassigneesArgs>>;
  author?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['gh_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  bodyResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['gh_IssueCommentConnection'], ParentType, ContextType, Partial<gh_IssuecommentsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  fullDatabaseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  hovercard?: Resolver<ResolversTypes['gh_Hovercard'], ParentType, ContextType, RequireFields<gh_IssuehovercardArgs, 'includeNotificationContexts'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPinned?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isReadByViewer?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['gh_LabelConnection']>, ParentType, ContextType, RequireFields<gh_IssuelabelsArgs, 'orderBy'>>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  linkedBranches?: Resolver<ResolversTypes['gh_LinkedBranchConnection'], ParentType, ContextType, Partial<gh_IssuelinkedBranchesArgs>>;
  locked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  milestone?: Resolver<Maybe<ResolversTypes['gh_Milestone']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  participants?: Resolver<ResolversTypes['gh_UserConnection'], ParentType, ContextType, Partial<gh_IssueparticipantsArgs>>;
  projectCards?: Resolver<ResolversTypes['gh_ProjectCardConnection'], ParentType, ContextType, RequireFields<gh_IssueprojectCardsArgs, 'archivedStates'>>;
  projectItems?: Resolver<ResolversTypes['gh_ProjectV2ItemConnection'], ParentType, ContextType, RequireFields<gh_IssueprojectItemsArgs, 'includeArchived'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType, RequireFields<gh_IssueprojectV2Args, 'number'>>;
  projectsV2?: Resolver<ResolversTypes['gh_ProjectV2Connection'], ParentType, ContextType, RequireFields<gh_IssueprojectsV2Args, 'orderBy'>>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['gh_ReactionConnection'], ParentType, ContextType, Partial<gh_IssuereactionsArgs>>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_IssueState'], ParentType, ContextType>;
  stateReason?: Resolver<Maybe<ResolversTypes['gh_IssueStateReason']>, ParentType, ContextType>;
  timeline?: Resolver<ResolversTypes['gh_IssueTimelineConnection'], ParentType, ContextType, Partial<gh_IssuetimelineArgs>>;
  timelineItems?: Resolver<ResolversTypes['gh_IssueTimelineItemsConnection'], ParentType, ContextType, Partial<gh_IssuetimelineItemsArgs>>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  trackedInIssues?: Resolver<ResolversTypes['gh_IssueConnection'], ParentType, ContextType, Partial<gh_IssuetrackedInIssuesArgs>>;
  trackedIssues?: Resolver<ResolversTypes['gh_IssueConnection'], ParentType, ContextType, Partial<gh_IssuetrackedIssuesArgs>>;
  trackedIssuesCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType, Partial<gh_IssuetrackedIssuesCountArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['gh_UserContentEditConnection']>, ParentType, ContextType, Partial<gh_IssueuserContentEditsArgs>>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['gh_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['gh_SubscriptionState']>, ParentType, ContextType>;
  viewerThreadSubscriptionFormAction?: Resolver<Maybe<ResolversTypes['gh_ThreadSubscriptionFormAction']>, ParentType, ContextType>;
  viewerThreadSubscriptionStatus?: Resolver<Maybe<ResolversTypes['gh_ThreadSubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IssueCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueComment'] = ResolversParentTypes['gh_IssueComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['gh_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  fullDatabaseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['gh_Issue'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['gh_ReactionConnection'], ParentType, ContextType, Partial<gh_IssueCommentreactionsArgs>>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['gh_UserContentEditConnection']>, ParentType, ContextType, Partial<gh_IssueCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['gh_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IssueCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueCommentConnection'] = ResolversParentTypes['gh_IssueCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_IssueCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_IssueComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IssueCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueCommentEdge'] = ResolversParentTypes['gh_IssueCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_IssueComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IssueConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueConnection'] = ResolversParentTypes['gh_IssueConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_IssueEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Issue']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IssueContributionsByRepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueContributionsByRepository'] = ResolversParentTypes['gh_IssueContributionsByRepository']> = ResolversObject<{
  contributions?: Resolver<ResolversTypes['gh_CreatedIssueContributionConnection'], ParentType, ContextType, RequireFields<gh_IssueContributionsByRepositorycontributionsArgs, 'orderBy'>>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IssueEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueEdge'] = ResolversParentTypes['gh_IssueEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IssueOrPullRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueOrPullRequest'] = ResolversParentTypes['gh_IssueOrPullRequest']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Issue' | 'gh_PullRequest', ParentType, ContextType>;
}>;

export type gh_IssueTemplateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueTemplate'] = ResolversParentTypes['gh_IssueTemplate']> = ResolversObject<{
  about?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assignees?: Resolver<ResolversTypes['gh_UserConnection'], ParentType, ContextType, Partial<gh_IssueTemplateassigneesArgs>>;
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['gh_LabelConnection']>, ParentType, ContextType, RequireFields<gh_IssueTemplatelabelsArgs, 'orderBy'>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IssueTimelineConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueTimelineConnection'] = ResolversParentTypes['gh_IssueTimelineConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_IssueTimelineItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_IssueTimelineItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IssueTimelineItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueTimelineItem'] = ResolversParentTypes['gh_IssueTimelineItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_AssignedEvent' | 'gh_ClosedEvent' | 'gh_Commit' | 'gh_CrossReferencedEvent' | 'gh_DemilestonedEvent' | 'gh_IssueComment' | 'gh_LabeledEvent' | 'gh_LockedEvent' | 'gh_MilestonedEvent' | 'gh_ReferencedEvent' | 'gh_RenamedTitleEvent' | 'gh_ReopenedEvent' | 'gh_SubscribedEvent' | 'gh_TransferredEvent' | 'gh_UnassignedEvent' | 'gh_UnlabeledEvent' | 'gh_UnlockedEvent' | 'gh_UnsubscribedEvent' | 'gh_UserBlockedEvent', ParentType, ContextType>;
}>;

export type gh_IssueTimelineItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueTimelineItemEdge'] = ResolversParentTypes['gh_IssueTimelineItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_IssueTimelineItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IssueTimelineItemsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueTimelineItems'] = ResolversParentTypes['gh_IssueTimelineItems']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_AddedToProjectEvent' | 'gh_AssignedEvent' | 'gh_ClosedEvent' | 'gh_CommentDeletedEvent' | 'gh_ConnectedEvent' | 'gh_ConvertedNoteToIssueEvent' | 'gh_ConvertedToDiscussionEvent' | 'gh_CrossReferencedEvent' | 'gh_DemilestonedEvent' | 'gh_DisconnectedEvent' | 'gh_IssueComment' | 'gh_LabeledEvent' | 'gh_LockedEvent' | 'gh_MarkedAsDuplicateEvent' | 'gh_MentionedEvent' | 'gh_MilestonedEvent' | 'gh_MovedColumnsInProjectEvent' | 'gh_PinnedEvent' | 'gh_ReferencedEvent' | 'gh_RemovedFromProjectEvent' | 'gh_RenamedTitleEvent' | 'gh_ReopenedEvent' | 'gh_SubscribedEvent' | 'gh_TransferredEvent' | 'gh_UnassignedEvent' | 'gh_UnlabeledEvent' | 'gh_UnlockedEvent' | 'gh_UnmarkedAsDuplicateEvent' | 'gh_UnpinnedEvent' | 'gh_UnsubscribedEvent' | 'gh_UserBlockedEvent', ParentType, ContextType>;
}>;

export type gh_IssueTimelineItemsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueTimelineItemsConnection'] = ResolversParentTypes['gh_IssueTimelineItemsConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_IssueTimelineItemsEdge']>>>, ParentType, ContextType>;
  filteredCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_IssueTimelineItems']>>>, ParentType, ContextType>;
  pageCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_IssueTimelineItemsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_IssueTimelineItemsEdge'] = ResolversParentTypes['gh_IssueTimelineItemsEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_IssueTimelineItems']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_JoinedGitHubContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_JoinedGitHubContribution'] = ResolversParentTypes['gh_JoinedGitHubContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LabelResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Label'] = ResolversParentTypes['gh_Label']> = ResolversObject<{
  color?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isDefault?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issues?: Resolver<ResolversTypes['gh_IssueConnection'], ParentType, ContextType, Partial<gh_LabelissuesArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequests?: Resolver<ResolversTypes['gh_PullRequestConnection'], ParentType, ContextType, Partial<gh_LabelpullRequestsArgs>>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LabelConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LabelConnection'] = ResolversParentTypes['gh_LabelConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_LabelEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Label']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LabelEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LabelEdge'] = ResolversParentTypes['gh_LabelEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Label']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LabelableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Labelable'] = ResolversParentTypes['gh_Labelable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Discussion' | 'gh_Issue' | 'gh_PullRequest', ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['gh_LabelConnection']>, ParentType, ContextType, RequireFields<gh_LabelablelabelsArgs, 'orderBy'>>;
}>;

export type gh_LabeledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LabeledEvent'] = ResolversParentTypes['gh_LabeledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['gh_Label'], ParentType, ContextType>;
  labelable?: Resolver<ResolversTypes['gh_Labelable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LanguageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Language'] = ResolversParentTypes['gh_Language']> = ResolversObject<{
  color?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LanguageConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LanguageConnection'] = ResolversParentTypes['gh_LanguageConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_LanguageEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Language']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LanguageEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LanguageEdge'] = ResolversParentTypes['gh_LanguageEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['gh_Language'], ParentType, ContextType>;
  size?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LicenseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_License'] = ResolversParentTypes['gh_License']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  conditions?: Resolver<Array<Maybe<ResolversTypes['gh_LicenseRule']>>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  featured?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hidden?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  implementation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  limitations?: Resolver<Array<Maybe<ResolversTypes['gh_LicenseRule']>>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nickname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Array<Maybe<ResolversTypes['gh_LicenseRule']>>, ParentType, ContextType>;
  pseudoLicense?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spdxId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LicenseRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LicenseRule'] = ResolversParentTypes['gh_LicenseRule']> = ResolversObject<{
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LinkProjectV2ToRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LinkProjectV2ToRepositoryPayload'] = ResolversParentTypes['gh_LinkProjectV2ToRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LinkProjectV2ToTeamPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LinkProjectV2ToTeamPayload'] = ResolversParentTypes['gh_LinkProjectV2ToTeamPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LinkRepositoryToProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LinkRepositoryToProjectPayload'] = ResolversParentTypes['gh_LinkRepositoryToProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LinkedBranchResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LinkedBranch'] = ResolversParentTypes['gh_LinkedBranch']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LinkedBranchConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LinkedBranchConnection'] = ResolversParentTypes['gh_LinkedBranchConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_LinkedBranchEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_LinkedBranch']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LinkedBranchEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LinkedBranchEdge'] = ResolversParentTypes['gh_LinkedBranchEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_LinkedBranch']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LockLockablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LockLockablePayload'] = ResolversParentTypes['gh_LockLockablePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lockedRecord?: Resolver<Maybe<ResolversTypes['gh_Lockable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_LockableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Lockable'] = ResolversParentTypes['gh_Lockable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Discussion' | 'gh_Issue' | 'gh_PullRequest', ParentType, ContextType>;
  activeLockReason?: Resolver<Maybe<ResolversTypes['gh_LockReason']>, ParentType, ContextType>;
  locked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type gh_LockedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_LockedEvent'] = ResolversParentTypes['gh_LockedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lockReason?: Resolver<Maybe<ResolversTypes['gh_LockReason']>, ParentType, ContextType>;
  lockable?: Resolver<ResolversTypes['gh_Lockable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MannequinResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Mannequin'] = ResolversParentTypes['gh_Mannequin']> = ResolversObject<{
  avatarUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType, Partial<gh_MannequinavatarUrlArgs>>;
  claimant?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MannequinConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MannequinConnection'] = ResolversParentTypes['gh_MannequinConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_MannequinEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Mannequin']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MannequinEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MannequinEdge'] = ResolversParentTypes['gh_MannequinEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Mannequin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MarkDiscussionCommentAsAnswerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MarkDiscussionCommentAsAnswerPayload'] = ResolversParentTypes['gh_MarkDiscussionCommentAsAnswerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['gh_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MarkFileAsViewedPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MarkFileAsViewedPayload'] = ResolversParentTypes['gh_MarkFileAsViewedPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MarkProjectV2AsTemplatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MarkProjectV2AsTemplatePayload'] = ResolversParentTypes['gh_MarkProjectV2AsTemplatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MarkPullRequestReadyForReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MarkPullRequestReadyForReviewPayload'] = ResolversParentTypes['gh_MarkPullRequestReadyForReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MarkedAsDuplicateEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MarkedAsDuplicateEvent'] = ResolversParentTypes['gh_MarkedAsDuplicateEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  canonical?: Resolver<Maybe<ResolversTypes['gh_IssueOrPullRequest']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  duplicate?: Resolver<Maybe<ResolversTypes['gh_IssueOrPullRequest']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MarketplaceCategoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MarketplaceCategory'] = ResolversParentTypes['gh_MarketplaceCategory']> = ResolversObject<{
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  howItWorks?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  primaryListingCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  secondaryListingCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MarketplaceListingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MarketplaceListing'] = ResolversParentTypes['gh_MarketplaceListing']> = ResolversObject<{
  app?: Resolver<Maybe<ResolversTypes['gh_App']>, ParentType, ContextType>;
  companyUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  configurationResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  configurationUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  documentationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  extendedDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  extendedDescriptionHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  fullDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fullDescriptionHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  hasPublishedFreeTrialPlans?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasTermsOfService?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasVerifiedOwner?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  howItWorks?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  howItWorksHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  installationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  installedForViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPaid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPublic?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRejected?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isUnverified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isUnverifiedPending?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerificationPendingFromDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerificationPendingFromUnverified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  logoBackgroundColor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logoUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType, RequireFields<gh_MarketplaceListinglogoUrlArgs, 'size'>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  normalizedShortDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pricingUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  primaryCategory?: Resolver<ResolversTypes['gh_MarketplaceCategory'], ParentType, ContextType>;
  privacyPolicyUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  screenshotUrls?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  secondaryCategory?: Resolver<Maybe<ResolversTypes['gh_MarketplaceCategory']>, ParentType, ContextType>;
  shortDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  statusUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  supportEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  supportUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  termsOfServiceUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  viewerCanAddPlans?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanApprove?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDelist?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEditCategories?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEditPlans?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanRedraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReject?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanRequestApproval?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasPurchased?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasPurchasedForAllOrganizations?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsListingAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MarketplaceListingConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MarketplaceListingConnection'] = ResolversParentTypes['gh_MarketplaceListingConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_MarketplaceListingEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_MarketplaceListing']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MarketplaceListingEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MarketplaceListingEdge'] = ResolversParentTypes['gh_MarketplaceListingEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_MarketplaceListing']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MemberFeatureRequestNotificationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MemberFeatureRequestNotification'] = ResolversParentTypes['gh_MemberFeatureRequestNotification']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MemberStatusableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MemberStatusable'] = ResolversParentTypes['gh_MemberStatusable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_Team', ParentType, ContextType>;
  memberStatuses?: Resolver<ResolversTypes['gh_UserStatusConnection'], ParentType, ContextType, RequireFields<gh_MemberStatusablememberStatusesArgs, 'orderBy'>>;
}>;

export type gh_MembersCanDeleteReposClearAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MembersCanDeleteReposClearAuditEntry'] = ResolversParentTypes['gh_MembersCanDeleteReposClearAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MembersCanDeleteReposDisableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MembersCanDeleteReposDisableAuditEntry'] = ResolversParentTypes['gh_MembersCanDeleteReposDisableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MembersCanDeleteReposEnableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MembersCanDeleteReposEnableAuditEntry'] = ResolversParentTypes['gh_MembersCanDeleteReposEnableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MentionedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MentionedEvent'] = ResolversParentTypes['gh_MentionedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MergeBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MergeBranchPayload'] = ResolversParentTypes['gh_MergeBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mergeCommit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MergePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MergePullRequestPayload'] = ResolversParentTypes['gh_MergePullRequestPayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MergeQueueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MergeQueue'] = ResolversParentTypes['gh_MergeQueue']> = ResolversObject<{
  configuration?: Resolver<Maybe<ResolversTypes['gh_MergeQueueConfiguration']>, ParentType, ContextType>;
  entries?: Resolver<Maybe<ResolversTypes['gh_MergeQueueEntryConnection']>, ParentType, ContextType, Partial<gh_MergeQueueentriesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  nextEntryEstimatedTimeToMerge?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MergeQueueConfigurationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MergeQueueConfiguration'] = ResolversParentTypes['gh_MergeQueueConfiguration']> = ResolversObject<{
  checkResponseTimeout?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximumEntriesToBuild?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximumEntriesToMerge?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  mergeMethod?: Resolver<Maybe<ResolversTypes['gh_PullRequestMergeMethod']>, ParentType, ContextType>;
  mergingStrategy?: Resolver<Maybe<ResolversTypes['gh_MergeQueueMergingStrategy']>, ParentType, ContextType>;
  minimumEntriesToMerge?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  minimumEntriesToMergeWaitTime?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MergeQueueEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MergeQueueEntry'] = ResolversParentTypes['gh_MergeQueueEntry']> = ResolversObject<{
  baseCommit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  enqueuedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enqueuer?: Resolver<ResolversTypes['gh_Actor'], ParentType, ContextType>;
  estimatedTimeToMerge?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  headCommit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  jump?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mergeQueue?: Resolver<Maybe<ResolversTypes['gh_MergeQueue']>, ParentType, ContextType>;
  position?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  solo?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_MergeQueueEntryState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MergeQueueEntryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MergeQueueEntryConnection'] = ResolversParentTypes['gh_MergeQueueEntryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_MergeQueueEntryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_MergeQueueEntry']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MergeQueueEntryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MergeQueueEntryEdge'] = ResolversParentTypes['gh_MergeQueueEntryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_MergeQueueEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MergedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MergedEvent'] = ResolversParentTypes['gh_MergedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  mergeRef?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  mergeRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MigrationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Migration'] = ResolversParentTypes['gh_Migration']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_RepositoryMigration', ParentType, ContextType>;
  continueOnError?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  failureReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  migrationLogUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  migrationSource?: Resolver<ResolversTypes['gh_MigrationSource'], ParentType, ContextType>;
  repositoryName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sourceUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_MigrationState'], ParentType, ContextType>;
  warningsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
}>;

export type gh_MigrationSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MigrationSource'] = ResolversParentTypes['gh_MigrationSource']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['gh_MigrationSourceType'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MilestoneResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Milestone'] = ResolversParentTypes['gh_Milestone']> = ResolversObject<{
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dueOn?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issues?: Resolver<ResolversTypes['gh_IssueConnection'], ParentType, ContextType, Partial<gh_MilestoneissuesArgs>>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  progressPercentage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  pullRequests?: Resolver<ResolversTypes['gh_PullRequestConnection'], ParentType, ContextType, Partial<gh_MilestonepullRequestsArgs>>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_MilestoneState'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MilestoneConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MilestoneConnection'] = ResolversParentTypes['gh_MilestoneConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_MilestoneEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Milestone']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MilestoneEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MilestoneEdge'] = ResolversParentTypes['gh_MilestoneEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Milestone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MilestoneItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MilestoneItem'] = ResolversParentTypes['gh_MilestoneItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Issue' | 'gh_PullRequest', ParentType, ContextType>;
}>;

export type gh_MilestonedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MilestonedEvent'] = ResolversParentTypes['gh_MilestonedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  milestoneTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['gh_MilestoneItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MinimizableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Minimizable'] = ResolversParentTypes['gh_Minimizable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_CommitComment' | 'gh_DiscussionComment' | 'gh_GistComment' | 'gh_IssueComment' | 'gh_PullRequestReview' | 'gh_PullRequestReviewComment', ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type gh_MinimizeCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MinimizeCommentPayload'] = ResolversParentTypes['gh_MinimizeCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimizedComment?: Resolver<Maybe<ResolversTypes['gh_Minimizable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MoveProjectCardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MoveProjectCardPayload'] = ResolversParentTypes['gh_MoveProjectCardPayload']> = ResolversObject<{
  cardEdge?: Resolver<Maybe<ResolversTypes['gh_ProjectCardEdge']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MoveProjectColumnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MoveProjectColumnPayload'] = ResolversParentTypes['gh_MoveProjectColumnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  columnEdge?: Resolver<Maybe<ResolversTypes['gh_ProjectColumnEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_MovedColumnsInProjectEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_MovedColumnsInProjectEvent'] = ResolversParentTypes['gh_MovedColumnsInProjectEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  previousProjectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['gh_ProjectCard']>, ParentType, ContextType>;
  projectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_NodeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Node'] = ResolversParentTypes['gh_Node']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_AddedToMergeQueueEvent' | 'gh_AddedToProjectEvent' | 'gh_App' | 'gh_AssignedEvent' | 'gh_AutoMergeDisabledEvent' | 'gh_AutoMergeEnabledEvent' | 'gh_AutoRebaseEnabledEvent' | 'gh_AutoSquashEnabledEvent' | 'gh_AutomaticBaseChangeFailedEvent' | 'gh_AutomaticBaseChangeSucceededEvent' | 'gh_BaseRefChangedEvent' | 'gh_BaseRefDeletedEvent' | 'gh_BaseRefForcePushedEvent' | 'gh_Blob' | 'gh_Bot' | 'gh_BranchProtectionRule' | 'gh_BypassForcePushAllowance' | 'gh_BypassPullRequestAllowance' | 'gh_CWE' | 'gh_CheckRun' | 'gh_CheckSuite' | 'gh_ClosedEvent' | 'gh_CodeOfConduct' | 'gh_CommentDeletedEvent' | 'gh_Commit' | 'gh_CommitComment' | 'gh_CommitCommentThread' | 'gh_Comparison' | 'gh_ConnectedEvent' | 'gh_ConvertToDraftEvent' | 'gh_ConvertedNoteToIssueEvent' | 'gh_ConvertedToDiscussionEvent' | 'gh_CrossReferencedEvent' | 'gh_DemilestonedEvent' | 'gh_DependencyGraphManifest' | 'gh_DeployKey' | 'gh_DeployedEvent' | 'gh_Deployment' | 'gh_DeploymentEnvironmentChangedEvent' | 'gh_DeploymentReview' | 'gh_DeploymentStatus' | 'gh_DisconnectedEvent' | 'gh_Discussion' | 'gh_DiscussionCategory' | 'gh_DiscussionComment' | 'gh_DiscussionPoll' | 'gh_DiscussionPollOption' | 'gh_DraftIssue' | 'gh_Enterprise' | 'gh_EnterpriseAdministratorInvitation' | 'gh_EnterpriseIdentityProvider' | 'gh_EnterpriseRepositoryInfo' | 'gh_EnterpriseServerInstallation' | 'gh_EnterpriseServerUserAccount' | 'gh_EnterpriseServerUserAccountEmail' | 'gh_EnterpriseServerUserAccountsUpload' | 'gh_EnterpriseUserAccount' | 'gh_Environment' | 'gh_ExternalIdentity' | 'gh_Gist' | 'gh_GistComment' | 'gh_HeadRefDeletedEvent' | 'gh_HeadRefForcePushedEvent' | 'gh_HeadRefRestoredEvent' | 'gh_IpAllowListEntry' | 'gh_Issue' | 'gh_IssueComment' | 'gh_Label' | 'gh_LabeledEvent' | 'gh_Language' | 'gh_License' | 'gh_LinkedBranch' | 'gh_LockedEvent' | 'gh_Mannequin' | 'gh_MarkedAsDuplicateEvent' | 'gh_MarketplaceCategory' | 'gh_MarketplaceListing' | 'gh_MemberFeatureRequestNotification' | 'gh_MembersCanDeleteReposClearAuditEntry' | 'gh_MembersCanDeleteReposDisableAuditEntry' | 'gh_MembersCanDeleteReposEnableAuditEntry' | 'gh_MentionedEvent' | 'gh_MergeQueue' | 'gh_MergeQueueEntry' | 'gh_MergedEvent' | 'gh_MigrationSource' | 'gh_Milestone' | 'gh_MilestonedEvent' | 'gh_MovedColumnsInProjectEvent' | 'gh_OIDCProvider' | 'gh_OauthApplicationCreateAuditEntry' | 'gh_OrgAddBillingManagerAuditEntry' | 'gh_OrgAddMemberAuditEntry' | 'gh_OrgBlockUserAuditEntry' | 'gh_OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'gh_OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'gh_OrgCreateAuditEntry' | 'gh_OrgDisableOauthAppRestrictionsAuditEntry' | 'gh_OrgDisableSamlAuditEntry' | 'gh_OrgDisableTwoFactorRequirementAuditEntry' | 'gh_OrgEnableOauthAppRestrictionsAuditEntry' | 'gh_OrgEnableSamlAuditEntry' | 'gh_OrgEnableTwoFactorRequirementAuditEntry' | 'gh_OrgInviteMemberAuditEntry' | 'gh_OrgInviteToBusinessAuditEntry' | 'gh_OrgOauthAppAccessApprovedAuditEntry' | 'gh_OrgOauthAppAccessBlockedAuditEntry' | 'gh_OrgOauthAppAccessDeniedAuditEntry' | 'gh_OrgOauthAppAccessRequestedAuditEntry' | 'gh_OrgOauthAppAccessUnblockedAuditEntry' | 'gh_OrgRemoveBillingManagerAuditEntry' | 'gh_OrgRemoveMemberAuditEntry' | 'gh_OrgRemoveOutsideCollaboratorAuditEntry' | 'gh_OrgRestoreMemberAuditEntry' | 'gh_OrgUnblockUserAuditEntry' | 'gh_OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'gh_OrgUpdateMemberAuditEntry' | 'gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'gh_Organization' | 'gh_OrganizationIdentityProvider' | 'gh_OrganizationInvitation' | 'gh_OrganizationMigration' | 'gh_Package' | 'gh_PackageFile' | 'gh_PackageTag' | 'gh_PackageVersion' | 'gh_PinnedDiscussion' | 'gh_PinnedEvent' | 'gh_PinnedIssue' | 'gh_PrivateRepositoryForkingDisableAuditEntry' | 'gh_PrivateRepositoryForkingEnableAuditEntry' | 'gh_Project' | 'gh_ProjectCard' | 'gh_ProjectColumn' | 'gh_ProjectV2' | 'gh_ProjectV2Field' | 'gh_ProjectV2Item' | 'gh_ProjectV2ItemFieldDateValue' | 'gh_ProjectV2ItemFieldIterationValue' | 'gh_ProjectV2ItemFieldNumberValue' | 'gh_ProjectV2ItemFieldSingleSelectValue' | 'gh_ProjectV2ItemFieldTextValue' | 'gh_ProjectV2IterationField' | 'gh_ProjectV2SingleSelectField' | 'gh_ProjectV2View' | 'gh_ProjectV2Workflow' | 'gh_PublicKey' | 'gh_PullRequest' | 'gh_PullRequestCommit' | 'gh_PullRequestCommitCommentThread' | 'gh_PullRequestReview' | 'gh_PullRequestReviewComment' | 'gh_PullRequestReviewThread' | 'gh_PullRequestThread' | 'gh_Push' | 'gh_PushAllowance' | 'gh_Reaction' | 'gh_ReadyForReviewEvent' | 'gh_Ref' | 'gh_ReferencedEvent' | 'gh_Release' | 'gh_ReleaseAsset' | 'gh_RemovedFromMergeQueueEvent' | 'gh_RemovedFromProjectEvent' | 'gh_RenamedTitleEvent' | 'gh_ReopenedEvent' | 'gh_RepoAccessAuditEntry' | 'gh_RepoAddMemberAuditEntry' | 'gh_RepoAddTopicAuditEntry' | 'gh_RepoArchivedAuditEntry' | 'gh_RepoChangeMergeSettingAuditEntry' | 'gh_RepoConfigDisableAnonymousGitAccessAuditEntry' | 'gh_RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'gh_RepoConfigDisableContributorsOnlyAuditEntry' | 'gh_RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'gh_RepoConfigEnableAnonymousGitAccessAuditEntry' | 'gh_RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'gh_RepoConfigEnableContributorsOnlyAuditEntry' | 'gh_RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'gh_RepoConfigLockAnonymousGitAccessAuditEntry' | 'gh_RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'gh_RepoCreateAuditEntry' | 'gh_RepoDestroyAuditEntry' | 'gh_RepoRemoveMemberAuditEntry' | 'gh_RepoRemoveTopicAuditEntry' | 'gh_Repository' | 'gh_RepositoryInvitation' | 'gh_RepositoryMigration' | 'gh_RepositoryRule' | 'gh_RepositoryRuleset' | 'gh_RepositoryRulesetBypassActor' | 'gh_RepositoryTopic' | 'gh_RepositoryVisibilityChangeDisableAuditEntry' | 'gh_RepositoryVisibilityChangeEnableAuditEntry' | 'gh_RepositoryVulnerabilityAlert' | 'gh_ReviewDismissalAllowance' | 'gh_ReviewDismissedEvent' | 'gh_ReviewRequest' | 'gh_ReviewRequestRemovedEvent' | 'gh_ReviewRequestedEvent' | 'gh_SavedReply' | 'gh_SecurityAdvisory' | 'gh_SponsorsActivity' | 'gh_SponsorsListing' | 'gh_SponsorsListingFeaturedItem' | 'gh_SponsorsTier' | 'gh_Sponsorship' | 'gh_SponsorshipNewsletter' | 'gh_Status' | 'gh_StatusCheckRollup' | 'gh_StatusContext' | 'gh_SubscribedEvent' | 'gh_Tag' | 'gh_Team' | 'gh_TeamAddMemberAuditEntry' | 'gh_TeamAddRepositoryAuditEntry' | 'gh_TeamChangeParentTeamAuditEntry' | 'gh_TeamDiscussion' | 'gh_TeamDiscussionComment' | 'gh_TeamRemoveMemberAuditEntry' | 'gh_TeamRemoveRepositoryAuditEntry' | 'gh_Topic' | 'gh_TransferredEvent' | 'gh_Tree' | 'gh_UnassignedEvent' | 'gh_UnlabeledEvent' | 'gh_UnlockedEvent' | 'gh_UnmarkedAsDuplicateEvent' | 'gh_UnpinnedEvent' | 'gh_UnsubscribedEvent' | 'gh_User' | 'gh_UserBlockedEvent' | 'gh_UserContentEdit' | 'gh_UserList' | 'gh_UserStatus' | 'gh_VerifiableDomain' | 'gh_Workflow' | 'gh_WorkflowRun' | 'gh_WorkflowRunFile', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
}>;

export type gh_OIDCProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OIDCProvider'] = ResolversParentTypes['gh_OIDCProvider']> = ResolversObject<{
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  externalIdentities?: Resolver<ResolversTypes['gh_ExternalIdentityConnection'], ParentType, ContextType, Partial<gh_OIDCProviderexternalIdentitiesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  providerType?: Resolver<ResolversTypes['gh_OIDCProviderType'], ParentType, ContextType>;
  tenantId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OauthApplicationAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OauthApplicationAuditEntryData'] = ResolversParentTypes['gh_OauthApplicationAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_OauthApplicationCreateAuditEntry' | 'gh_OrgOauthAppAccessApprovedAuditEntry' | 'gh_OrgOauthAppAccessBlockedAuditEntry' | 'gh_OrgOauthAppAccessDeniedAuditEntry' | 'gh_OrgOauthAppAccessRequestedAuditEntry' | 'gh_OrgOauthAppAccessUnblockedAuditEntry', ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
}>;

export type gh_OauthApplicationCreateAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OauthApplicationCreateAuditEntry'] = ResolversParentTypes['gh_OauthApplicationCreateAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  applicationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  callbackUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  rateLimit?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['gh_OauthApplicationCreateAuditEntryState']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgAddBillingManagerAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgAddBillingManagerAuditEntry'] = ResolversParentTypes['gh_OrgAddBillingManagerAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitationEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgAddMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgAddMemberAuditEntry'] = ResolversParentTypes['gh_OrgAddMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<ResolversTypes['gh_OrgAddMemberAuditEntryPermission']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgBlockUserAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgBlockUserAuditEntry'] = ResolversParentTypes['gh_OrgBlockUserAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  blockedUser?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  blockedUserName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  blockedUserResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  blockedUserUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgConfigDisableCollaboratorsOnlyAuditEntry'] = ResolversParentTypes['gh_OrgConfigDisableCollaboratorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgConfigEnableCollaboratorsOnlyAuditEntry'] = ResolversParentTypes['gh_OrgConfigEnableCollaboratorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgCreateAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgCreateAuditEntry'] = ResolversParentTypes['gh_OrgCreateAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  billingPlan?: Resolver<Maybe<ResolversTypes['gh_OrgCreateAuditEntryBillingPlan']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgDisableOauthAppRestrictionsAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgDisableOauthAppRestrictionsAuditEntry'] = ResolversParentTypes['gh_OrgDisableOauthAppRestrictionsAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgDisableSamlAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgDisableSamlAuditEntry'] = ResolversParentTypes['gh_OrgDisableSamlAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  digestMethodUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issuerUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  signatureMethodUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  singleSignOnUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgDisableTwoFactorRequirementAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgDisableTwoFactorRequirementAuditEntry'] = ResolversParentTypes['gh_OrgDisableTwoFactorRequirementAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgEnableOauthAppRestrictionsAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgEnableOauthAppRestrictionsAuditEntry'] = ResolversParentTypes['gh_OrgEnableOauthAppRestrictionsAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgEnableSamlAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgEnableSamlAuditEntry'] = ResolversParentTypes['gh_OrgEnableSamlAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  digestMethodUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issuerUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  signatureMethodUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  singleSignOnUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgEnableTwoFactorRequirementAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgEnableTwoFactorRequirementAuditEntry'] = ResolversParentTypes['gh_OrgEnableTwoFactorRequirementAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgInviteMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgInviteMemberAuditEntry'] = ResolversParentTypes['gh_OrgInviteMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationInvitation?: Resolver<Maybe<ResolversTypes['gh_OrganizationInvitation']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgInviteToBusinessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgInviteToBusinessAuditEntry'] = ResolversParentTypes['gh_OrgInviteToBusinessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgOauthAppAccessApprovedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgOauthAppAccessApprovedAuditEntry'] = ResolversParentTypes['gh_OrgOauthAppAccessApprovedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgOauthAppAccessBlockedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgOauthAppAccessBlockedAuditEntry'] = ResolversParentTypes['gh_OrgOauthAppAccessBlockedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgOauthAppAccessDeniedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgOauthAppAccessDeniedAuditEntry'] = ResolversParentTypes['gh_OrgOauthAppAccessDeniedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgOauthAppAccessRequestedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgOauthAppAccessRequestedAuditEntry'] = ResolversParentTypes['gh_OrgOauthAppAccessRequestedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgOauthAppAccessUnblockedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgOauthAppAccessUnblockedAuditEntry'] = ResolversParentTypes['gh_OrgOauthAppAccessUnblockedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgRemoveBillingManagerAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgRemoveBillingManagerAuditEntry'] = ResolversParentTypes['gh_OrgRemoveBillingManagerAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['gh_OrgRemoveBillingManagerAuditEntryReason']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgRemoveMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgRemoveMemberAuditEntry'] = ResolversParentTypes['gh_OrgRemoveMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  membershipTypes?: Resolver<Maybe<Array<ResolversTypes['gh_OrgRemoveMemberAuditEntryMembershipType']>>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['gh_OrgRemoveMemberAuditEntryReason']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgRemoveOutsideCollaboratorAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgRemoveOutsideCollaboratorAuditEntry'] = ResolversParentTypes['gh_OrgRemoveOutsideCollaboratorAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  membershipTypes?: Resolver<Maybe<Array<ResolversTypes['gh_OrgRemoveOutsideCollaboratorAuditEntryMembershipType']>>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['gh_OrgRemoveOutsideCollaboratorAuditEntryReason']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgRestoreMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgRestoreMemberAuditEntry'] = ResolversParentTypes['gh_OrgRestoreMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  restoredCustomEmailRoutingsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredIssueAssignmentsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredMemberships?: Resolver<Maybe<Array<ResolversTypes['gh_OrgRestoreMemberAuditEntryMembership']>>, ParentType, ContextType>;
  restoredMembershipsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredRepositoriesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredRepositoryStarsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredRepositoryWatchesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgRestoreMemberAuditEntryMembershipResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgRestoreMemberAuditEntryMembership'] = ResolversParentTypes['gh_OrgRestoreMemberAuditEntryMembership']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_OrgRestoreMemberMembershipOrganizationAuditEntryData' | 'gh_OrgRestoreMemberMembershipRepositoryAuditEntryData' | 'gh_OrgRestoreMemberMembershipTeamAuditEntryData', ParentType, ContextType>;
}>;

export type gh_OrgRestoreMemberMembershipOrganizationAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgRestoreMemberMembershipOrganizationAuditEntryData'] = ResolversParentTypes['gh_OrgRestoreMemberMembershipOrganizationAuditEntryData']> = ResolversObject<{
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgRestoreMemberMembershipRepositoryAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgRestoreMemberMembershipRepositoryAuditEntryData'] = ResolversParentTypes['gh_OrgRestoreMemberMembershipRepositoryAuditEntryData']> = ResolversObject<{
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgRestoreMemberMembershipTeamAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgRestoreMemberMembershipTeamAuditEntryData'] = ResolversParentTypes['gh_OrgRestoreMemberMembershipTeamAuditEntryData']> = ResolversObject<{
  team?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgUnblockUserAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgUnblockUserAuditEntry'] = ResolversParentTypes['gh_OrgUnblockUserAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  blockedUser?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  blockedUserName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  blockedUserResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  blockedUserUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgUpdateDefaultRepositoryPermissionAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgUpdateDefaultRepositoryPermissionAuditEntry'] = ResolversParentTypes['gh_OrgUpdateDefaultRepositoryPermissionAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<ResolversTypes['gh_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission']>, ParentType, ContextType>;
  permissionWas?: Resolver<Maybe<ResolversTypes['gh_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgUpdateMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgUpdateMemberAuditEntry'] = ResolversParentTypes['gh_OrgUpdateMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<ResolversTypes['gh_OrgUpdateMemberAuditEntryPermission']>, ParentType, ContextType>;
  permissionWas?: Resolver<Maybe<ResolversTypes['gh_OrgUpdateMemberAuditEntryPermission']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] = ResolversParentTypes['gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  canCreateRepositories?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] = ResolversParentTypes['gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  canInviteOutsideCollaboratorsToRepositories?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Organization'] = ResolversParentTypes['gh_Organization']> = ResolversObject<{
  announcement?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  announcementExpiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  announcementUserDismissible?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  anyPinnableItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<gh_OrganizationanyPinnableItemsArgs>>;
  archivedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  auditLog?: Resolver<ResolversTypes['gh_OrganizationAuditEntryConnection'], ParentType, ContextType, RequireFields<gh_OrganizationauditLogArgs, 'orderBy'>>;
  avatarUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType, Partial<gh_OrganizationavatarUrlArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domains?: Resolver<Maybe<ResolversTypes['gh_VerifiableDomainConnection']>, ParentType, ContextType, RequireFields<gh_OrganizationdomainsArgs, 'isApproved' | 'isVerified' | 'orderBy'>>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseOwners?: Resolver<ResolversTypes['gh_OrganizationEnterpriseOwnerConnection'], ParentType, ContextType, RequireFields<gh_OrganizationenterpriseOwnersArgs, 'orderBy'>>;
  estimatedNextSponsorsPayoutInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hasSponsorsListing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  interactionAbility?: Resolver<Maybe<ResolversTypes['gh_RepositoryInteractionAbility']>, ParentType, ContextType>;
  ipAllowListEnabledSetting?: Resolver<ResolversTypes['gh_IpAllowListEnabledSettingValue'], ParentType, ContextType>;
  ipAllowListEntries?: Resolver<ResolversTypes['gh_IpAllowListEntryConnection'], ParentType, ContextType, RequireFields<gh_OrganizationipAllowListEntriesArgs, 'orderBy'>>;
  ipAllowListForInstalledAppsEnabledSetting?: Resolver<ResolversTypes['gh_IpAllowListForInstalledAppsEnabledSettingValue'], ParentType, ContextType>;
  isSponsoredBy?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<gh_OrganizationisSponsoredByArgs, 'accountLogin'>>;
  isSponsoringViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  itemShowcase?: Resolver<ResolversTypes['gh_ProfileItemShowcase'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  mannequins?: Resolver<ResolversTypes['gh_MannequinConnection'], ParentType, ContextType, RequireFields<gh_OrganizationmannequinsArgs, 'orderBy'>>;
  memberStatuses?: Resolver<ResolversTypes['gh_UserStatusConnection'], ParentType, ContextType, RequireFields<gh_OrganizationmemberStatusesArgs, 'orderBy'>>;
  membersCanForkPrivateRepositories?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  membersWithRole?: Resolver<ResolversTypes['gh_OrganizationMemberConnection'], ParentType, ContextType, Partial<gh_OrganizationmembersWithRoleArgs>>;
  monthlyEstimatedSponsorsIncomeInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  newTeamResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  newTeamUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  notificationDeliveryRestrictionEnabledSetting?: Resolver<ResolversTypes['gh_NotificationRestrictionSettingValue'], ParentType, ContextType>;
  organizationBillingEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  packages?: Resolver<ResolversTypes['gh_PackageConnection'], ParentType, ContextType, RequireFields<gh_OrganizationpackagesArgs, 'orderBy'>>;
  pendingMembers?: Resolver<ResolversTypes['gh_UserConnection'], ParentType, ContextType, Partial<gh_OrganizationpendingMembersArgs>>;
  pinnableItems?: Resolver<ResolversTypes['gh_PinnableItemConnection'], ParentType, ContextType, Partial<gh_OrganizationpinnableItemsArgs>>;
  pinnedItems?: Resolver<ResolversTypes['gh_PinnableItemConnection'], ParentType, ContextType, Partial<gh_OrganizationpinnedItemsArgs>>;
  pinnedItemsRemaining?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType, RequireFields<gh_OrganizationprojectArgs, 'number'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType, RequireFields<gh_OrganizationprojectV2Args, 'number'>>;
  projects?: Resolver<ResolversTypes['gh_ProjectConnection'], ParentType, ContextType, Partial<gh_OrganizationprojectsArgs>>;
  projectsResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  projectsV2?: Resolver<ResolversTypes['gh_ProjectV2Connection'], ParentType, ContextType, RequireFields<gh_OrganizationprojectsV2Args, 'orderBy'>>;
  recentProjects?: Resolver<ResolversTypes['gh_ProjectV2Connection'], ParentType, ContextType, Partial<gh_OrganizationrecentProjectsArgs>>;
  repositories?: Resolver<ResolversTypes['gh_RepositoryConnection'], ParentType, ContextType, RequireFields<gh_OrganizationrepositoriesArgs, 'ownerAffiliations'>>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType, RequireFields<gh_OrganizationrepositoryArgs, 'followRenames' | 'name'>>;
  repositoryDiscussionComments?: Resolver<ResolversTypes['gh_DiscussionCommentConnection'], ParentType, ContextType, RequireFields<gh_OrganizationrepositoryDiscussionCommentsArgs, 'onlyAnswers'>>;
  repositoryDiscussions?: Resolver<ResolversTypes['gh_DiscussionConnection'], ParentType, ContextType, RequireFields<gh_OrganizationrepositoryDiscussionsArgs, 'answered' | 'orderBy' | 'states'>>;
  repositoryMigrations?: Resolver<ResolversTypes['gh_RepositoryMigrationConnection'], ParentType, ContextType, RequireFields<gh_OrganizationrepositoryMigrationsArgs, 'orderBy'>>;
  requiresTwoFactorAuthentication?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  ruleset?: Resolver<Maybe<ResolversTypes['gh_RepositoryRuleset']>, ParentType, ContextType, RequireFields<gh_OrganizationrulesetArgs, 'databaseId'>>;
  rulesets?: Resolver<Maybe<ResolversTypes['gh_RepositoryRulesetConnection']>, ParentType, ContextType, RequireFields<gh_OrganizationrulesetsArgs, 'includeParents'>>;
  samlIdentityProvider?: Resolver<Maybe<ResolversTypes['gh_OrganizationIdentityProvider']>, ParentType, ContextType>;
  sponsoring?: Resolver<ResolversTypes['gh_SponsorConnection'], ParentType, ContextType, RequireFields<gh_OrganizationsponsoringArgs, 'orderBy'>>;
  sponsors?: Resolver<ResolversTypes['gh_SponsorConnection'], ParentType, ContextType, RequireFields<gh_OrganizationsponsorsArgs, 'orderBy'>>;
  sponsorsActivities?: Resolver<ResolversTypes['gh_SponsorsActivityConnection'], ParentType, ContextType, RequireFields<gh_OrganizationsponsorsActivitiesArgs, 'actions' | 'includeAsSponsor' | 'includePrivate' | 'orderBy' | 'period'>>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['gh_SponsorsListing']>, ParentType, ContextType>;
  sponsorshipForViewerAsSponsor?: Resolver<Maybe<ResolversTypes['gh_Sponsorship']>, ParentType, ContextType, RequireFields<gh_OrganizationsponsorshipForViewerAsSponsorArgs, 'activeOnly'>>;
  sponsorshipForViewerAsSponsorable?: Resolver<Maybe<ResolversTypes['gh_Sponsorship']>, ParentType, ContextType, RequireFields<gh_OrganizationsponsorshipForViewerAsSponsorableArgs, 'activeOnly'>>;
  sponsorshipNewsletters?: Resolver<ResolversTypes['gh_SponsorshipNewsletterConnection'], ParentType, ContextType, RequireFields<gh_OrganizationsponsorshipNewslettersArgs, 'orderBy'>>;
  sponsorshipsAsMaintainer?: Resolver<ResolversTypes['gh_SponsorshipConnection'], ParentType, ContextType, RequireFields<gh_OrganizationsponsorshipsAsMaintainerArgs, 'activeOnly' | 'includePrivate'>>;
  sponsorshipsAsSponsor?: Resolver<ResolversTypes['gh_SponsorshipConnection'], ParentType, ContextType, RequireFields<gh_OrganizationsponsorshipsAsSponsorArgs, 'activeOnly'>>;
  team?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType, RequireFields<gh_OrganizationteamArgs, 'slug'>>;
  teams?: Resolver<ResolversTypes['gh_TeamConnection'], ParentType, ContextType, RequireFields<gh_OrganizationteamsArgs, 'rootTeamsOnly'>>;
  teamsResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  teamsUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  totalSponsorshipAmountAsSponsorInCents?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<gh_OrganizationtotalSponsorshipAmountAsSponsorInCentsArgs, 'sponsorableLogins'>>;
  twitterUsername?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanChangePinnedItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateRepositories?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateTeams?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSponsor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsAMember?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsFollowing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsSponsoring?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  webCommitSignoffRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  websiteUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationAuditEntry'] = ResolversParentTypes['gh_OrganizationAuditEntry']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_MembersCanDeleteReposClearAuditEntry' | 'gh_MembersCanDeleteReposDisableAuditEntry' | 'gh_MembersCanDeleteReposEnableAuditEntry' | 'gh_OauthApplicationCreateAuditEntry' | 'gh_OrgAddBillingManagerAuditEntry' | 'gh_OrgAddMemberAuditEntry' | 'gh_OrgBlockUserAuditEntry' | 'gh_OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'gh_OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'gh_OrgCreateAuditEntry' | 'gh_OrgDisableOauthAppRestrictionsAuditEntry' | 'gh_OrgDisableSamlAuditEntry' | 'gh_OrgDisableTwoFactorRequirementAuditEntry' | 'gh_OrgEnableOauthAppRestrictionsAuditEntry' | 'gh_OrgEnableSamlAuditEntry' | 'gh_OrgEnableTwoFactorRequirementAuditEntry' | 'gh_OrgInviteMemberAuditEntry' | 'gh_OrgInviteToBusinessAuditEntry' | 'gh_OrgOauthAppAccessApprovedAuditEntry' | 'gh_OrgOauthAppAccessBlockedAuditEntry' | 'gh_OrgOauthAppAccessDeniedAuditEntry' | 'gh_OrgOauthAppAccessRequestedAuditEntry' | 'gh_OrgOauthAppAccessUnblockedAuditEntry' | 'gh_OrgRemoveBillingManagerAuditEntry' | 'gh_OrgRemoveMemberAuditEntry' | 'gh_OrgRemoveOutsideCollaboratorAuditEntry' | 'gh_OrgRestoreMemberAuditEntry' | 'gh_OrgUnblockUserAuditEntry' | 'gh_OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'gh_OrgUpdateMemberAuditEntry' | 'gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'gh_PrivateRepositoryForkingDisableAuditEntry' | 'gh_PrivateRepositoryForkingEnableAuditEntry' | 'gh_RepoAccessAuditEntry' | 'gh_RepoAddMemberAuditEntry' | 'gh_RepoAddTopicAuditEntry' | 'gh_RepoArchivedAuditEntry' | 'gh_RepoChangeMergeSettingAuditEntry' | 'gh_RepoConfigDisableAnonymousGitAccessAuditEntry' | 'gh_RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'gh_RepoConfigDisableContributorsOnlyAuditEntry' | 'gh_RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'gh_RepoConfigEnableAnonymousGitAccessAuditEntry' | 'gh_RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'gh_RepoConfigEnableContributorsOnlyAuditEntry' | 'gh_RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'gh_RepoConfigLockAnonymousGitAccessAuditEntry' | 'gh_RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'gh_RepoCreateAuditEntry' | 'gh_RepoDestroyAuditEntry' | 'gh_RepoRemoveMemberAuditEntry' | 'gh_RepoRemoveTopicAuditEntry' | 'gh_RepositoryVisibilityChangeDisableAuditEntry' | 'gh_RepositoryVisibilityChangeEnableAuditEntry' | 'gh_TeamAddMemberAuditEntry' | 'gh_TeamAddRepositoryAuditEntry' | 'gh_TeamChangeParentTeamAuditEntry' | 'gh_TeamRemoveMemberAuditEntry' | 'gh_TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
}>;

export type gh_OrganizationAuditEntryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationAuditEntryConnection'] = ResolversParentTypes['gh_OrganizationAuditEntryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_OrganizationAuditEntryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_OrganizationAuditEntry']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationAuditEntryData'] = ResolversParentTypes['gh_OrganizationAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_MembersCanDeleteReposClearAuditEntry' | 'gh_MembersCanDeleteReposDisableAuditEntry' | 'gh_MembersCanDeleteReposEnableAuditEntry' | 'gh_OauthApplicationCreateAuditEntry' | 'gh_OrgAddBillingManagerAuditEntry' | 'gh_OrgAddMemberAuditEntry' | 'gh_OrgBlockUserAuditEntry' | 'gh_OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'gh_OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'gh_OrgCreateAuditEntry' | 'gh_OrgDisableOauthAppRestrictionsAuditEntry' | 'gh_OrgDisableSamlAuditEntry' | 'gh_OrgDisableTwoFactorRequirementAuditEntry' | 'gh_OrgEnableOauthAppRestrictionsAuditEntry' | 'gh_OrgEnableSamlAuditEntry' | 'gh_OrgEnableTwoFactorRequirementAuditEntry' | 'gh_OrgInviteMemberAuditEntry' | 'gh_OrgInviteToBusinessAuditEntry' | 'gh_OrgOauthAppAccessApprovedAuditEntry' | 'gh_OrgOauthAppAccessBlockedAuditEntry' | 'gh_OrgOauthAppAccessDeniedAuditEntry' | 'gh_OrgOauthAppAccessRequestedAuditEntry' | 'gh_OrgOauthAppAccessUnblockedAuditEntry' | 'gh_OrgRemoveBillingManagerAuditEntry' | 'gh_OrgRemoveMemberAuditEntry' | 'gh_OrgRemoveOutsideCollaboratorAuditEntry' | 'gh_OrgRestoreMemberAuditEntry' | 'gh_OrgRestoreMemberMembershipOrganizationAuditEntryData' | 'gh_OrgUnblockUserAuditEntry' | 'gh_OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'gh_OrgUpdateMemberAuditEntry' | 'gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'gh_PrivateRepositoryForkingDisableAuditEntry' | 'gh_PrivateRepositoryForkingEnableAuditEntry' | 'gh_RepoAccessAuditEntry' | 'gh_RepoAddMemberAuditEntry' | 'gh_RepoAddTopicAuditEntry' | 'gh_RepoArchivedAuditEntry' | 'gh_RepoChangeMergeSettingAuditEntry' | 'gh_RepoConfigDisableAnonymousGitAccessAuditEntry' | 'gh_RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'gh_RepoConfigDisableContributorsOnlyAuditEntry' | 'gh_RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'gh_RepoConfigEnableAnonymousGitAccessAuditEntry' | 'gh_RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'gh_RepoConfigEnableContributorsOnlyAuditEntry' | 'gh_RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'gh_RepoConfigLockAnonymousGitAccessAuditEntry' | 'gh_RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'gh_RepoCreateAuditEntry' | 'gh_RepoDestroyAuditEntry' | 'gh_RepoRemoveMemberAuditEntry' | 'gh_RepoRemoveTopicAuditEntry' | 'gh_RepositoryVisibilityChangeDisableAuditEntry' | 'gh_RepositoryVisibilityChangeEnableAuditEntry' | 'gh_TeamAddMemberAuditEntry' | 'gh_TeamAddRepositoryAuditEntry' | 'gh_TeamChangeParentTeamAuditEntry' | 'gh_TeamRemoveMemberAuditEntry' | 'gh_TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
}>;

export type gh_OrganizationAuditEntryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationAuditEntryEdge'] = ResolversParentTypes['gh_OrganizationAuditEntryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_OrganizationAuditEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationConnection'] = ResolversParentTypes['gh_OrganizationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_OrganizationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Organization']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationEdge'] = ResolversParentTypes['gh_OrganizationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationEnterpriseOwnerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationEnterpriseOwnerConnection'] = ResolversParentTypes['gh_OrganizationEnterpriseOwnerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_OrganizationEnterpriseOwnerEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationEnterpriseOwnerEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationEnterpriseOwnerEdge'] = ResolversParentTypes['gh_OrganizationEnterpriseOwnerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  organizationRole?: Resolver<ResolversTypes['gh_RoleInOrganization'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationIdentityProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationIdentityProvider'] = ResolversParentTypes['gh_OrganizationIdentityProvider']> = ResolversObject<{
  digestMethod?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  externalIdentities?: Resolver<ResolversTypes['gh_ExternalIdentityConnection'], ParentType, ContextType, Partial<gh_OrganizationIdentityProviderexternalIdentitiesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  idpCertificate?: Resolver<Maybe<ResolversTypes['gh_X509Certificate']>, ParentType, ContextType>;
  issuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  signatureMethod?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  ssoUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationInvitationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationInvitation'] = ResolversParentTypes['gh_OrganizationInvitation']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitationSource?: Resolver<ResolversTypes['gh_OrganizationInvitationSource'], ParentType, ContextType>;
  invitationType?: Resolver<ResolversTypes['gh_OrganizationInvitationType'], ParentType, ContextType>;
  invitee?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  inviter?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  organization?: Resolver<ResolversTypes['gh_Organization'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['gh_OrganizationInvitationRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationInvitationConnection'] = ResolversParentTypes['gh_OrganizationInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_OrganizationInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_OrganizationInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationInvitationEdge'] = ResolversParentTypes['gh_OrganizationInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_OrganizationInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationMemberConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationMemberConnection'] = ResolversParentTypes['gh_OrganizationMemberConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_OrganizationMemberEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationMemberEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationMemberEdge'] = ResolversParentTypes['gh_OrganizationMemberEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  hasTwoFactorEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['gh_OrganizationMemberRole']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationMigrationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationMigration'] = ResolversParentTypes['gh_OrganizationMigration']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  failureReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  remainingRepositoriesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sourceOrgName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sourceOrgUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_OrganizationMigrationState'], ParentType, ContextType>;
  targetOrgName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalRepositoriesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationOrUserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationOrUser'] = ResolversParentTypes['gh_OrganizationOrUser']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_OrganizationTeamsHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationTeamsHovercardContext'] = ResolversParentTypes['gh_OrganizationTeamsHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  relevantTeams?: Resolver<ResolversTypes['gh_TeamConnection'], ParentType, ContextType, Partial<gh_OrganizationTeamsHovercardContextrelevantTeamsArgs>>;
  teamsResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  teamsUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  totalTeamCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_OrganizationsHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_OrganizationsHovercardContext'] = ResolversParentTypes['gh_OrganizationsHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  relevantOrganizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_OrganizationsHovercardContextrelevantOrganizationsArgs, 'orderBy'>>;
  totalOrganizationCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PackageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Package'] = ResolversParentTypes['gh_Package']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  latestVersion?: Resolver<Maybe<ResolversTypes['gh_PackageVersion']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  packageType?: Resolver<ResolversTypes['gh_PackageType'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  statistics?: Resolver<Maybe<ResolversTypes['gh_PackageStatistics']>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['gh_PackageVersion']>, ParentType, ContextType, RequireFields<gh_PackageversionArgs, 'version'>>;
  versions?: Resolver<ResolversTypes['gh_PackageVersionConnection'], ParentType, ContextType, RequireFields<gh_PackageversionsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PackageConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PackageConnection'] = ResolversParentTypes['gh_PackageConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PackageEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Package']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PackageEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PackageEdge'] = ResolversParentTypes['gh_PackageEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Package']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PackageFileResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PackageFile'] = ResolversParentTypes['gh_PackageFile']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  md5?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  packageVersion?: Resolver<Maybe<ResolversTypes['gh_PackageVersion']>, ParentType, ContextType>;
  sha1?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sha256?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PackageFileConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PackageFileConnection'] = ResolversParentTypes['gh_PackageFileConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PackageFileEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PackageFile']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PackageFileEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PackageFileEdge'] = ResolversParentTypes['gh_PackageFileEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PackageFile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PackageOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PackageOwner'] = ResolversParentTypes['gh_PackageOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_Repository' | 'gh_User', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  packages?: Resolver<ResolversTypes['gh_PackageConnection'], ParentType, ContextType, RequireFields<gh_PackageOwnerpackagesArgs, 'orderBy'>>;
}>;

export type gh_PackageStatisticsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PackageStatistics'] = ResolversParentTypes['gh_PackageStatistics']> = ResolversObject<{
  downloadsTotalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PackageTagResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PackageTag'] = ResolversParentTypes['gh_PackageTag']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['gh_PackageVersion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PackageVersionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PackageVersion'] = ResolversParentTypes['gh_PackageVersion']> = ResolversObject<{
  files?: Resolver<ResolversTypes['gh_PackageFileConnection'], ParentType, ContextType, RequireFields<gh_PackageVersionfilesArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  package?: Resolver<Maybe<ResolversTypes['gh_Package']>, ParentType, ContextType>;
  platform?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  preRelease?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  readme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  release?: Resolver<Maybe<ResolversTypes['gh_Release']>, ParentType, ContextType>;
  statistics?: Resolver<Maybe<ResolversTypes['gh_PackageVersionStatistics']>, ParentType, ContextType>;
  summary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PackageVersionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PackageVersionConnection'] = ResolversParentTypes['gh_PackageVersionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PackageVersionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PackageVersion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PackageVersionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PackageVersionEdge'] = ResolversParentTypes['gh_PackageVersionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PackageVersion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PackageVersionStatisticsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PackageVersionStatistics'] = ResolversParentTypes['gh_PackageVersionStatistics']> = ResolversObject<{
  downloadsTotalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PageInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PageInfo'] = ResolversParentTypes['gh_PageInfo']> = ResolversObject<{
  endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PermissionGranterResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PermissionGranter'] = ResolversParentTypes['gh_PermissionGranter']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_Repository' | 'gh_Team', ParentType, ContextType>;
}>;

export type gh_PermissionSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PermissionSource'] = ResolversParentTypes['gh_PermissionSource']> = ResolversObject<{
  organization?: Resolver<ResolversTypes['gh_Organization'], ParentType, ContextType>;
  permission?: Resolver<ResolversTypes['gh_DefaultRepositoryPermissionField'], ParentType, ContextType>;
  roleName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  source?: Resolver<ResolversTypes['gh_PermissionGranter'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PinIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PinIssuePayload'] = ResolversParentTypes['gh_PinIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['gh_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PinnableItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PinnableItem'] = ResolversParentTypes['gh_PinnableItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Gist' | 'gh_Repository', ParentType, ContextType>;
}>;

export type gh_PinnableItemConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PinnableItemConnection'] = ResolversParentTypes['gh_PinnableItemConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PinnableItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PinnableItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PinnableItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PinnableItemEdge'] = ResolversParentTypes['gh_PinnableItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PinnableItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PinnedDiscussionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PinnedDiscussion'] = ResolversParentTypes['gh_PinnedDiscussion']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  discussion?: Resolver<ResolversTypes['gh_Discussion'], ParentType, ContextType>;
  gradientStopColors?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['gh_PinnedDiscussionPattern'], ParentType, ContextType>;
  pinnedBy?: Resolver<ResolversTypes['gh_Actor'], ParentType, ContextType>;
  preconfiguredGradient?: Resolver<Maybe<ResolversTypes['gh_PinnedDiscussionGradient']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PinnedDiscussionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PinnedDiscussionConnection'] = ResolversParentTypes['gh_PinnedDiscussionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PinnedDiscussionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PinnedDiscussion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PinnedDiscussionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PinnedDiscussionEdge'] = ResolversParentTypes['gh_PinnedDiscussionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PinnedDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PinnedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PinnedEvent'] = ResolversParentTypes['gh_PinnedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['gh_Issue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PinnedIssueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PinnedIssue'] = ResolversParentTypes['gh_PinnedIssue']> = ResolversObject<{
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fullDatabaseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['gh_Issue'], ParentType, ContextType>;
  pinnedBy?: Resolver<ResolversTypes['gh_Actor'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PinnedIssueConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PinnedIssueConnection'] = ResolversParentTypes['gh_PinnedIssueConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PinnedIssueEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PinnedIssue']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PinnedIssueEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PinnedIssueEdge'] = ResolversParentTypes['gh_PinnedIssueEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PinnedIssue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface gh_PreciseDateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['gh_PreciseDateTime'], any> {
  name: 'gh_PreciseDateTime';
}

export type gh_PrivateRepositoryForkingDisableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PrivateRepositoryForkingDisableAuditEntry'] = ResolversParentTypes['gh_PrivateRepositoryForkingDisableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PrivateRepositoryForkingEnableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PrivateRepositoryForkingEnableAuditEntry'] = ResolversParentTypes['gh_PrivateRepositoryForkingEnableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProfileItemShowcaseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProfileItemShowcase'] = ResolversParentTypes['gh_ProfileItemShowcase']> = ResolversObject<{
  hasPinnedItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  items?: Resolver<ResolversTypes['gh_PinnableItemConnection'], ParentType, ContextType, Partial<gh_ProfileItemShowcaseitemsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProfileOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProfileOwner'] = ResolversParentTypes['gh_ProfileOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_User', ParentType, ContextType>;
  anyPinnableItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<gh_ProfileOwneranyPinnableItemsArgs>>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  itemShowcase?: Resolver<ResolversTypes['gh_ProfileItemShowcase'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pinnableItems?: Resolver<ResolversTypes['gh_PinnableItemConnection'], ParentType, ContextType, Partial<gh_ProfileOwnerpinnableItemsArgs>>;
  pinnedItems?: Resolver<ResolversTypes['gh_PinnableItemConnection'], ParentType, ContextType, Partial<gh_ProfileOwnerpinnedItemsArgs>>;
  pinnedItemsRemaining?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerCanChangePinnedItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  websiteUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
}>;

export type gh_ProjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Project'] = ResolversParentTypes['gh_Project']> = ResolversObject<{
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  columns?: Resolver<ResolversTypes['gh_ProjectColumnConnection'], ParentType, ContextType, Partial<gh_ProjectcolumnsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['gh_ProjectOwner'], ParentType, ContextType>;
  pendingCards?: Resolver<ResolversTypes['gh_ProjectCardConnection'], ParentType, ContextType, RequireFields<gh_ProjectpendingCardsArgs, 'archivedStates'>>;
  progress?: Resolver<ResolversTypes['gh_ProjectProgress'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_ProjectState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectCardResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectCard'] = ResolversParentTypes['gh_ProjectCard']> = ResolversObject<{
  column?: Resolver<Maybe<ResolversTypes['gh_ProjectColumn']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['gh_ProjectCardItem']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  note?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<ResolversTypes['gh_Project'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['gh_ProjectCardState']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectCardConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectCardConnection'] = ResolversParentTypes['gh_ProjectCardConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectCardEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectCard']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectCardEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectCardEdge'] = ResolversParentTypes['gh_ProjectCardEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ProjectCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectCardItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectCardItem'] = ResolversParentTypes['gh_ProjectCardItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Issue' | 'gh_PullRequest', ParentType, ContextType>;
}>;

export type gh_ProjectColumnResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectColumn'] = ResolversParentTypes['gh_ProjectColumn']> = ResolversObject<{
  cards?: Resolver<ResolversTypes['gh_ProjectCardConnection'], ParentType, ContextType, RequireFields<gh_ProjectColumncardsArgs, 'archivedStates'>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['gh_Project'], ParentType, ContextType>;
  purpose?: Resolver<Maybe<ResolversTypes['gh_ProjectColumnPurpose']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectColumnConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectColumnConnection'] = ResolversParentTypes['gh_ProjectColumnConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectColumnEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectColumn']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectColumnEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectColumnEdge'] = ResolversParentTypes['gh_ProjectColumnEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ProjectColumn']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectConnection'] = ResolversParentTypes['gh_ProjectConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Project']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectEdge'] = ResolversParentTypes['gh_ProjectEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectOwner'] = ResolversParentTypes['gh_ProjectOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_Repository' | 'gh_User', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType, RequireFields<gh_ProjectOwnerprojectArgs, 'number'>>;
  projects?: Resolver<ResolversTypes['gh_ProjectConnection'], ParentType, ContextType, Partial<gh_ProjectOwnerprojectsArgs>>;
  projectsResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type gh_ProjectProgressResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectProgress'] = ResolversParentTypes['gh_ProjectProgress']> = ResolversObject<{
  doneCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  donePercentage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  inProgressCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  inProgressPercentage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  todoCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  todoPercentage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2Resolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2'] = ResolversParentTypes['gh_ProjectV2']> = ResolversObject<{
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['gh_ProjectV2FieldConfiguration']>, ParentType, ContextType, RequireFields<gh_ProjectV2fieldArgs, 'name'>>;
  fields?: Resolver<ResolversTypes['gh_ProjectV2FieldConfigurationConnection'], ParentType, ContextType, RequireFields<gh_ProjectV2fieldsArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  items?: Resolver<ResolversTypes['gh_ProjectV2ItemConnection'], ParentType, ContextType, RequireFields<gh_ProjectV2itemsArgs, 'orderBy'>>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['gh_ProjectV2Owner'], ParentType, ContextType>;
  public?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  readme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositories?: Resolver<ResolversTypes['gh_RepositoryConnection'], ParentType, ContextType, RequireFields<gh_ProjectV2repositoriesArgs, 'orderBy'>>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  shortDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teams?: Resolver<ResolversTypes['gh_TeamConnection'], ParentType, ContextType, RequireFields<gh_ProjectV2teamsArgs, 'orderBy'>>;
  template?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  view?: Resolver<Maybe<ResolversTypes['gh_ProjectV2View']>, ParentType, ContextType, RequireFields<gh_ProjectV2viewArgs, 'number'>>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  views?: Resolver<ResolversTypes['gh_ProjectV2ViewConnection'], ParentType, ContextType, RequireFields<gh_ProjectV2viewsArgs, 'orderBy'>>;
  workflow?: Resolver<Maybe<ResolversTypes['gh_ProjectV2Workflow']>, ParentType, ContextType, RequireFields<gh_ProjectV2workflowArgs, 'number'>>;
  workflows?: Resolver<ResolversTypes['gh_ProjectV2WorkflowConnection'], ParentType, ContextType, RequireFields<gh_ProjectV2workflowsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2Actor'] = ResolversParentTypes['gh_ProjectV2Actor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Team' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_ProjectV2ActorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ActorConnection'] = ResolversParentTypes['gh_ProjectV2ActorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2ActorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2Actor']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ActorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ActorEdge'] = ResolversParentTypes['gh_ProjectV2ActorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ProjectV2Actor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2Connection'] = ResolversParentTypes['gh_ProjectV2Connection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2Edge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2EdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2Edge'] = ResolversParentTypes['gh_ProjectV2Edge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2FieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2Field'] = ResolversParentTypes['gh_ProjectV2Field']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['gh_ProjectV2FieldType'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['gh_ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2FieldCommonResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2FieldCommon'] = ResolversParentTypes['gh_ProjectV2FieldCommon']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_ProjectV2Field' | 'gh_ProjectV2IterationField' | 'gh_ProjectV2SingleSelectField', ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['gh_ProjectV2FieldType'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['gh_ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
}>;

export type gh_ProjectV2FieldConfigurationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2FieldConfiguration'] = ResolversParentTypes['gh_ProjectV2FieldConfiguration']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_ProjectV2Field' | 'gh_ProjectV2IterationField' | 'gh_ProjectV2SingleSelectField', ParentType, ContextType>;
}>;

export type gh_ProjectV2FieldConfigurationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2FieldConfigurationConnection'] = ResolversParentTypes['gh_ProjectV2FieldConfigurationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2FieldConfigurationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2FieldConfiguration']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2FieldConfigurationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2FieldConfigurationEdge'] = ResolversParentTypes['gh_ProjectV2FieldConfigurationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ProjectV2FieldConfiguration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2FieldConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2FieldConnection'] = ResolversParentTypes['gh_ProjectV2FieldConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2FieldEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2Field']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2FieldEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2FieldEdge'] = ResolversParentTypes['gh_ProjectV2FieldEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ProjectV2Field']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2Item'] = ResolversParentTypes['gh_ProjectV2Item']> = ResolversObject<{
  content?: Resolver<Maybe<ResolversTypes['gh_ProjectV2ItemContent']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fieldValueByName?: Resolver<Maybe<ResolversTypes['gh_ProjectV2ItemFieldValue']>, ParentType, ContextType, RequireFields<gh_ProjectV2ItemfieldValueByNameArgs, 'name'>>;
  fieldValues?: Resolver<ResolversTypes['gh_ProjectV2ItemFieldValueConnection'], ParentType, ContextType, RequireFields<gh_ProjectV2ItemfieldValuesArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['gh_ProjectV2'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['gh_ProjectV2ItemType'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemConnection'] = ResolversParentTypes['gh_ProjectV2ItemConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2ItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2Item']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemContentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemContent'] = ResolversParentTypes['gh_ProjectV2ItemContent']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_DraftIssue' | 'gh_Issue' | 'gh_PullRequest', ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemEdge'] = ResolversParentTypes['gh_ProjectV2ItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldDateValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldDateValue'] = ResolversParentTypes['gh_ProjectV2ItemFieldDateValue']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['gh_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['gh_ProjectV2Item'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldIterationValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldIterationValue'] = ResolversParentTypes['gh_ProjectV2ItemFieldIterationValue']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  duration?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  field?: Resolver<ResolversTypes['gh_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['gh_ProjectV2Item'], ParentType, ContextType>;
  iterationId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  startDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldLabelValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldLabelValue'] = ResolversParentTypes['gh_ProjectV2ItemFieldLabelValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['gh_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['gh_LabelConnection']>, ParentType, ContextType, Partial<gh_ProjectV2ItemFieldLabelValuelabelsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldMilestoneValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldMilestoneValue'] = ResolversParentTypes['gh_ProjectV2ItemFieldMilestoneValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['gh_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  milestone?: Resolver<Maybe<ResolversTypes['gh_Milestone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldNumberValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldNumberValue'] = ResolversParentTypes['gh_ProjectV2ItemFieldNumberValue']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['gh_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['gh_ProjectV2Item'], ParentType, ContextType>;
  number?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldPullRequestValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldPullRequestValue'] = ResolversParentTypes['gh_ProjectV2ItemFieldPullRequestValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['gh_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  pullRequests?: Resolver<Maybe<ResolversTypes['gh_PullRequestConnection']>, ParentType, ContextType, RequireFields<gh_ProjectV2ItemFieldPullRequestValuepullRequestsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldRepositoryValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldRepositoryValue'] = ResolversParentTypes['gh_ProjectV2ItemFieldRepositoryValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['gh_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldReviewerValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldReviewerValue'] = ResolversParentTypes['gh_ProjectV2ItemFieldReviewerValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['gh_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  reviewers?: Resolver<Maybe<ResolversTypes['gh_RequestedReviewerConnection']>, ParentType, ContextType, Partial<gh_ProjectV2ItemFieldReviewerValuereviewersArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldSingleSelectValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldSingleSelectValue'] = ResolversParentTypes['gh_ProjectV2ItemFieldSingleSelectValue']> = ResolversObject<{
  color?: Resolver<ResolversTypes['gh_ProjectV2SingleSelectFieldOptionColor'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['gh_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['gh_ProjectV2Item'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nameHTML?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  optionId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldTextValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldTextValue'] = ResolversParentTypes['gh_ProjectV2ItemFieldTextValue']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['gh_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['gh_ProjectV2Item'], ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldUserValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldUserValue'] = ResolversParentTypes['gh_ProjectV2ItemFieldUserValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['gh_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['gh_UserConnection']>, ParentType, ContextType, Partial<gh_ProjectV2ItemFieldUserValueusersArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldValue'] = ResolversParentTypes['gh_ProjectV2ItemFieldValue']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_ProjectV2ItemFieldDateValue' | 'gh_ProjectV2ItemFieldIterationValue' | 'gh_ProjectV2ItemFieldLabelValue' | 'gh_ProjectV2ItemFieldMilestoneValue' | 'gh_ProjectV2ItemFieldNumberValue' | 'gh_ProjectV2ItemFieldPullRequestValue' | 'gh_ProjectV2ItemFieldRepositoryValue' | 'gh_ProjectV2ItemFieldReviewerValue' | 'gh_ProjectV2ItemFieldSingleSelectValue' | 'gh_ProjectV2ItemFieldTextValue' | 'gh_ProjectV2ItemFieldUserValue', ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldValueCommonResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldValueCommon'] = ResolversParentTypes['gh_ProjectV2ItemFieldValueCommon']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_ProjectV2ItemFieldDateValue' | 'gh_ProjectV2ItemFieldIterationValue' | 'gh_ProjectV2ItemFieldNumberValue' | 'gh_ProjectV2ItemFieldSingleSelectValue' | 'gh_ProjectV2ItemFieldTextValue', ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['gh_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['gh_ProjectV2Item'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldValueConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldValueConnection'] = ResolversParentTypes['gh_ProjectV2ItemFieldValueConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2ItemFieldValueEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2ItemFieldValue']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ItemFieldValueEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ItemFieldValueEdge'] = ResolversParentTypes['gh_ProjectV2ItemFieldValueEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ProjectV2ItemFieldValue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2IterationFieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2IterationField'] = ResolversParentTypes['gh_ProjectV2IterationField']> = ResolversObject<{
  configuration?: Resolver<ResolversTypes['gh_ProjectV2IterationFieldConfiguration'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['gh_ProjectV2FieldType'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['gh_ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2IterationFieldConfigurationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2IterationFieldConfiguration'] = ResolversParentTypes['gh_ProjectV2IterationFieldConfiguration']> = ResolversObject<{
  completedIterations?: Resolver<Array<ResolversTypes['gh_ProjectV2IterationFieldIteration']>, ParentType, ContextType>;
  duration?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  iterations?: Resolver<Array<ResolversTypes['gh_ProjectV2IterationFieldIteration']>, ParentType, ContextType>;
  startDay?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2IterationFieldIterationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2IterationFieldIteration'] = ResolversParentTypes['gh_ProjectV2IterationFieldIteration']> = ResolversObject<{
  duration?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  startDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2OwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2Owner'] = ResolversParentTypes['gh_ProjectV2Owner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Issue' | 'gh_Organization' | 'gh_PullRequest' | 'gh_User', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType, RequireFields<gh_ProjectV2OwnerprojectV2Args, 'number'>>;
  projectsV2?: Resolver<ResolversTypes['gh_ProjectV2Connection'], ParentType, ContextType, RequireFields<gh_ProjectV2OwnerprojectsV2Args, 'orderBy'>>;
}>;

export type gh_ProjectV2RecentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2Recent'] = ResolversParentTypes['gh_ProjectV2Recent']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_Repository' | 'gh_User', ParentType, ContextType>;
  recentProjects?: Resolver<ResolversTypes['gh_ProjectV2Connection'], ParentType, ContextType, Partial<gh_ProjectV2RecentrecentProjectsArgs>>;
}>;

export type gh_ProjectV2SingleSelectFieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2SingleSelectField'] = ResolversParentTypes['gh_ProjectV2SingleSelectField']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['gh_ProjectV2FieldType'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['gh_ProjectV2SingleSelectFieldOption']>, ParentType, ContextType, Partial<gh_ProjectV2SingleSelectFieldoptionsArgs>>;
  project?: Resolver<ResolversTypes['gh_ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2SingleSelectFieldOptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2SingleSelectFieldOption'] = ResolversParentTypes['gh_ProjectV2SingleSelectFieldOption']> = ResolversObject<{
  color?: Resolver<ResolversTypes['gh_ProjectV2SingleSelectFieldOptionColor'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2SortByResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2SortBy'] = ResolversParentTypes['gh_ProjectV2SortBy']> = ResolversObject<{
  direction?: Resolver<ResolversTypes['gh_OrderDirection'], ParentType, ContextType>;
  field?: Resolver<ResolversTypes['gh_ProjectV2Field'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2SortByConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2SortByConnection'] = ResolversParentTypes['gh_ProjectV2SortByConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2SortByEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2SortBy']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2SortByEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2SortByEdge'] = ResolversParentTypes['gh_ProjectV2SortByEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ProjectV2SortBy']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2SortByFieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2SortByField'] = ResolversParentTypes['gh_ProjectV2SortByField']> = ResolversObject<{
  direction?: Resolver<ResolversTypes['gh_OrderDirection'], ParentType, ContextType>;
  field?: Resolver<ResolversTypes['gh_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2SortByFieldConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2SortByFieldConnection'] = ResolversParentTypes['gh_ProjectV2SortByFieldConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2SortByFieldEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2SortByField']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2SortByFieldEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2SortByFieldEdge'] = ResolversParentTypes['gh_ProjectV2SortByFieldEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ProjectV2SortByField']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ViewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2View'] = ResolversParentTypes['gh_ProjectV2View']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fields?: Resolver<Maybe<ResolversTypes['gh_ProjectV2FieldConfigurationConnection']>, ParentType, ContextType, RequireFields<gh_ProjectV2ViewfieldsArgs, 'orderBy'>>;
  filter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groupBy?: Resolver<Maybe<ResolversTypes['gh_ProjectV2FieldConnection']>, ParentType, ContextType, RequireFields<gh_ProjectV2ViewgroupByArgs, 'orderBy'>>;
  groupByFields?: Resolver<Maybe<ResolversTypes['gh_ProjectV2FieldConfigurationConnection']>, ParentType, ContextType, RequireFields<gh_ProjectV2ViewgroupByFieldsArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  layout?: Resolver<ResolversTypes['gh_ProjectV2ViewLayout'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['gh_ProjectV2'], ParentType, ContextType>;
  sortBy?: Resolver<Maybe<ResolversTypes['gh_ProjectV2SortByConnection']>, ParentType, ContextType, Partial<gh_ProjectV2ViewsortByArgs>>;
  sortByFields?: Resolver<Maybe<ResolversTypes['gh_ProjectV2SortByFieldConnection']>, ParentType, ContextType, Partial<gh_ProjectV2ViewsortByFieldsArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  verticalGroupBy?: Resolver<Maybe<ResolversTypes['gh_ProjectV2FieldConnection']>, ParentType, ContextType, RequireFields<gh_ProjectV2ViewverticalGroupByArgs, 'orderBy'>>;
  verticalGroupByFields?: Resolver<Maybe<ResolversTypes['gh_ProjectV2FieldConfigurationConnection']>, ParentType, ContextType, RequireFields<gh_ProjectV2ViewverticalGroupByFieldsArgs, 'orderBy'>>;
  visibleFields?: Resolver<Maybe<ResolversTypes['gh_ProjectV2FieldConnection']>, ParentType, ContextType, RequireFields<gh_ProjectV2ViewvisibleFieldsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ViewConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ViewConnection'] = ResolversParentTypes['gh_ProjectV2ViewConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2ViewEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2View']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2ViewEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2ViewEdge'] = ResolversParentTypes['gh_ProjectV2ViewEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ProjectV2View']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2WorkflowResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2Workflow'] = ResolversParentTypes['gh_ProjectV2Workflow']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['gh_ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2WorkflowConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2WorkflowConnection'] = ResolversParentTypes['gh_ProjectV2WorkflowConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2WorkflowEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ProjectV2Workflow']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ProjectV2WorkflowEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ProjectV2WorkflowEdge'] = ResolversParentTypes['gh_ProjectV2WorkflowEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ProjectV2Workflow']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PublicKeyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PublicKey'] = ResolversParentTypes['gh_PublicKey']> = ResolversObject<{
  accessedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  fingerprint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isReadOnly?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PublicKeyConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PublicKeyConnection'] = ResolversParentTypes['gh_PublicKeyConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PublicKeyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PublicKey']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PublicKeyEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PublicKeyEdge'] = ResolversParentTypes['gh_PublicKeyEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PublicKey']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PublishSponsorsTierPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PublishSponsorsTierPayload'] = ResolversParentTypes['gh_PublishSponsorsTierPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['gh_SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequest'] = ResolversParentTypes['gh_PullRequest']> = ResolversObject<{
  activeLockReason?: Resolver<Maybe<ResolversTypes['gh_LockReason']>, ParentType, ContextType>;
  additions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  assignees?: Resolver<ResolversTypes['gh_UserConnection'], ParentType, ContextType, Partial<gh_PullRequestassigneesArgs>>;
  author?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['gh_CommentAuthorAssociation'], ParentType, ContextType>;
  autoMergeRequest?: Resolver<Maybe<ResolversTypes['gh_AutoMergeRequest']>, ParentType, ContextType>;
  baseRef?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  baseRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  baseRefOid?: Resolver<ResolversTypes['gh_GitObjectID'], ParentType, ContextType>;
  baseRepository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  canBeRebased?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  changedFiles?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  checksResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  checksUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  closingIssuesReferences?: Resolver<Maybe<ResolversTypes['gh_IssueConnection']>, ParentType, ContextType, RequireFields<gh_PullRequestclosingIssuesReferencesArgs, 'userLinkedOnly'>>;
  comments?: Resolver<ResolversTypes['gh_IssueCommentConnection'], ParentType, ContextType, Partial<gh_PullRequestcommentsArgs>>;
  commits?: Resolver<ResolversTypes['gh_PullRequestCommitConnection'], ParentType, ContextType, Partial<gh_PullRequestcommitsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deletions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  files?: Resolver<Maybe<ResolversTypes['gh_PullRequestChangedFileConnection']>, ParentType, ContextType, Partial<gh_PullRequestfilesArgs>>;
  headRef?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  headRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  headRefOid?: Resolver<ResolversTypes['gh_GitObjectID'], ParentType, ContextType>;
  headRepository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  headRepositoryOwner?: Resolver<Maybe<ResolversTypes['gh_RepositoryOwner']>, ParentType, ContextType>;
  hovercard?: Resolver<ResolversTypes['gh_Hovercard'], ParentType, ContextType, RequireFields<gh_PullRequesthovercardArgs, 'includeNotificationContexts'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isReadByViewer?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['gh_LabelConnection']>, ParentType, ContextType, RequireFields<gh_PullRequestlabelsArgs, 'orderBy'>>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  latestOpinionatedReviews?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewConnection']>, ParentType, ContextType, RequireFields<gh_PullRequestlatestOpinionatedReviewsArgs, 'writersOnly'>>;
  latestReviews?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewConnection']>, ParentType, ContextType, Partial<gh_PullRequestlatestReviewsArgs>>;
  locked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  maintainerCanModify?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mergeCommit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  mergeQueueEntry?: Resolver<Maybe<ResolversTypes['gh_MergeQueueEntry']>, ParentType, ContextType>;
  mergeStateStatus?: Resolver<ResolversTypes['gh_MergeStateStatus'], ParentType, ContextType>;
  mergeable?: Resolver<ResolversTypes['gh_MergeableState'], ParentType, ContextType>;
  merged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mergedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  mergedBy?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  milestone?: Resolver<Maybe<ResolversTypes['gh_Milestone']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  participants?: Resolver<ResolversTypes['gh_UserConnection'], ParentType, ContextType, Partial<gh_PullRequestparticipantsArgs>>;
  permalink?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  potentialMergeCommit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  projectCards?: Resolver<ResolversTypes['gh_ProjectCardConnection'], ParentType, ContextType, RequireFields<gh_PullRequestprojectCardsArgs, 'archivedStates'>>;
  projectItems?: Resolver<ResolversTypes['gh_ProjectV2ItemConnection'], ParentType, ContextType, RequireFields<gh_PullRequestprojectItemsArgs, 'includeArchived'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType, RequireFields<gh_PullRequestprojectV2Args, 'number'>>;
  projectsV2?: Resolver<ResolversTypes['gh_ProjectV2Connection'], ParentType, ContextType, RequireFields<gh_PullRequestprojectsV2Args, 'orderBy'>>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['gh_ReactionConnection'], ParentType, ContextType, Partial<gh_PullRequestreactionsArgs>>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  revertResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  revertUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewDecision']>, ParentType, ContextType>;
  reviewRequests?: Resolver<Maybe<ResolversTypes['gh_ReviewRequestConnection']>, ParentType, ContextType, Partial<gh_PullRequestreviewRequestsArgs>>;
  reviewThreads?: Resolver<ResolversTypes['gh_PullRequestReviewThreadConnection'], ParentType, ContextType, Partial<gh_PullRequestreviewThreadsArgs>>;
  reviews?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewConnection']>, ParentType, ContextType, Partial<gh_PullRequestreviewsArgs>>;
  state?: Resolver<ResolversTypes['gh_PullRequestState'], ParentType, ContextType>;
  suggestedReviewers?: Resolver<Array<Maybe<ResolversTypes['gh_SuggestedReviewer']>>, ParentType, ContextType>;
  timeline?: Resolver<ResolversTypes['gh_PullRequestTimelineConnection'], ParentType, ContextType, Partial<gh_PullRequesttimelineArgs>>;
  timelineItems?: Resolver<ResolversTypes['gh_PullRequestTimelineItemsConnection'], ParentType, ContextType, Partial<gh_PullRequesttimelineItemsArgs>>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  totalCommentsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['gh_UserContentEditConnection']>, ParentType, ContextType, Partial<gh_PullRequestuserContentEditsArgs>>;
  viewerCanApplySuggestion?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanClose?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDeleteHeadRef?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDisableAutoMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEditFiles?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEnableAutoMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMergeAsAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReopen?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdateBranch?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['gh_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerLatestReview?: Resolver<Maybe<ResolversTypes['gh_PullRequestReview']>, ParentType, ContextType>;
  viewerLatestReviewRequest?: Resolver<Maybe<ResolversTypes['gh_ReviewRequest']>, ParentType, ContextType>;
  viewerMergeBodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType, Partial<gh_PullRequestviewerMergeBodyTextArgs>>;
  viewerMergeHeadlineText?: Resolver<ResolversTypes['String'], ParentType, ContextType, Partial<gh_PullRequestviewerMergeHeadlineTextArgs>>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['gh_SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestChangedFileResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestChangedFile'] = ResolversParentTypes['gh_PullRequestChangedFile']> = ResolversObject<{
  additions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  changeType?: Resolver<ResolversTypes['gh_PatchStatus'], ParentType, ContextType>;
  deletions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  viewerViewedState?: Resolver<ResolversTypes['gh_FileViewedState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestChangedFileConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestChangedFileConnection'] = ResolversParentTypes['gh_PullRequestChangedFileConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestChangedFileEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestChangedFile']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestChangedFileEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestChangedFileEdge'] = ResolversParentTypes['gh_PullRequestChangedFileEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PullRequestChangedFile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestCommitResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestCommit'] = ResolversParentTypes['gh_PullRequestCommit']> = ResolversObject<{
  commit?: Resolver<ResolversTypes['gh_Commit'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestCommitCommentThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestCommitCommentThread'] = ResolversParentTypes['gh_PullRequestCommitCommentThread']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['gh_CommitCommentConnection'], ParentType, ContextType, Partial<gh_PullRequestCommitCommentThreadcommentsArgs>>;
  commit?: Resolver<ResolversTypes['gh_Commit'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestCommitConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestCommitConnection'] = ResolversParentTypes['gh_PullRequestCommitConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestCommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestCommit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestCommitEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestCommitEdge'] = ResolversParentTypes['gh_PullRequestCommitEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PullRequestCommit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestConnection'] = ResolversParentTypes['gh_PullRequestConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestContributionsByRepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestContributionsByRepository'] = ResolversParentTypes['gh_PullRequestContributionsByRepository']> = ResolversObject<{
  contributions?: Resolver<ResolversTypes['gh_CreatedPullRequestContributionConnection'], ParentType, ContextType, RequireFields<gh_PullRequestContributionsByRepositorycontributionsArgs, 'orderBy'>>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestEdge'] = ResolversParentTypes['gh_PullRequestEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestParameters'] = ResolversParentTypes['gh_PullRequestParameters']> = ResolversObject<{
  dismissStaleReviewsOnPush?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requireCodeOwnerReview?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requireLastPushApproval?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiredApprovingReviewCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  requiredReviewThreadResolution?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestReviewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestReview'] = ResolversParentTypes['gh_PullRequestReview']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['gh_CommentAuthorAssociation'], ParentType, ContextType>;
  authorCanPushToRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['gh_PullRequestReviewCommentConnection'], ParentType, ContextType, Partial<gh_PullRequestReviewcommentsArgs>>;
  commit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  onBehalfOf?: Resolver<ResolversTypes['gh_TeamConnection'], ParentType, ContextType, Partial<gh_PullRequestReviewonBehalfOfArgs>>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['gh_ReactionConnection'], ParentType, ContextType, Partial<gh_PullRequestReviewreactionsArgs>>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_PullRequestReviewState'], ParentType, ContextType>;
  submittedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['gh_UserContentEditConnection']>, ParentType, ContextType, Partial<gh_PullRequestReviewuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['gh_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestReviewCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestReviewComment'] = ResolversParentTypes['gh_PullRequestReviewComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['gh_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  diffHunk?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  draftedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  line?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  originalCommit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  originalLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  originalPosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  originalStartLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  outdated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['gh_PullRequestReview']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['gh_ReactionConnection'], ParentType, ContextType, Partial<gh_PullRequestReviewCommentreactionsArgs>>;
  replyTo?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewComment']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  startLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_PullRequestReviewCommentState'], ParentType, ContextType>;
  subjectType?: Resolver<ResolversTypes['gh_PullRequestReviewThreadSubjectType'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['gh_UserContentEditConnection']>, ParentType, ContextType, Partial<gh_PullRequestReviewCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['gh_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestReviewCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestReviewCommentConnection'] = ResolversParentTypes['gh_PullRequestReviewCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestReviewCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestReviewComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestReviewCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestReviewCommentEdge'] = ResolversParentTypes['gh_PullRequestReviewCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestReviewConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestReviewConnection'] = ResolversParentTypes['gh_PullRequestReviewConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestReviewEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestReview']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestReviewContributionsByRepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestReviewContributionsByRepository'] = ResolversParentTypes['gh_PullRequestReviewContributionsByRepository']> = ResolversObject<{
  contributions?: Resolver<ResolversTypes['gh_CreatedPullRequestReviewContributionConnection'], ParentType, ContextType, RequireFields<gh_PullRequestReviewContributionsByRepositorycontributionsArgs, 'orderBy'>>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestReviewEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestReviewEdge'] = ResolversParentTypes['gh_PullRequestReviewEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestReviewThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestReviewThread'] = ResolversParentTypes['gh_PullRequestReviewThread']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['gh_PullRequestReviewCommentConnection'], ParentType, ContextType, Partial<gh_PullRequestReviewThreadcommentsArgs>>;
  diffSide?: Resolver<ResolversTypes['gh_DiffSide'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCollapsed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOutdated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isResolved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  line?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  originalLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  originalStartLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resolvedBy?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  startDiffSide?: Resolver<Maybe<ResolversTypes['gh_DiffSide']>, ParentType, ContextType>;
  startLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  subjectType?: Resolver<ResolversTypes['gh_PullRequestReviewThreadSubjectType'], ParentType, ContextType>;
  viewerCanReply?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanResolve?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUnresolve?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestReviewThreadConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestReviewThreadConnection'] = ResolversParentTypes['gh_PullRequestReviewThreadConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestReviewThreadEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestReviewThread']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestReviewThreadEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestReviewThreadEdge'] = ResolversParentTypes['gh_PullRequestReviewThreadEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestRevisionMarkerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestRevisionMarker'] = ResolversParentTypes['gh_PullRequestRevisionMarker']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastSeenCommit?: Resolver<ResolversTypes['gh_Commit'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestTemplateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestTemplate'] = ResolversParentTypes['gh_PullRequestTemplate']> = ResolversObject<{
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filename?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestThread'] = ResolversParentTypes['gh_PullRequestThread']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['gh_PullRequestReviewCommentConnection'], ParentType, ContextType, Partial<gh_PullRequestThreadcommentsArgs>>;
  diffSide?: Resolver<ResolversTypes['gh_DiffSide'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCollapsed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOutdated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isResolved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  line?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resolvedBy?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  startDiffSide?: Resolver<Maybe<ResolversTypes['gh_DiffSide']>, ParentType, ContextType>;
  startLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  subjectType?: Resolver<ResolversTypes['gh_PullRequestReviewThreadSubjectType'], ParentType, ContextType>;
  viewerCanReply?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanResolve?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUnresolve?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestTimelineConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestTimelineConnection'] = ResolversParentTypes['gh_PullRequestTimelineConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestTimelineItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestTimelineItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestTimelineItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestTimelineItem'] = ResolversParentTypes['gh_PullRequestTimelineItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_AssignedEvent' | 'gh_BaseRefDeletedEvent' | 'gh_BaseRefForcePushedEvent' | 'gh_ClosedEvent' | 'gh_Commit' | 'gh_CommitCommentThread' | 'gh_CrossReferencedEvent' | 'gh_DemilestonedEvent' | 'gh_DeployedEvent' | 'gh_DeploymentEnvironmentChangedEvent' | 'gh_HeadRefDeletedEvent' | 'gh_HeadRefForcePushedEvent' | 'gh_HeadRefRestoredEvent' | 'gh_IssueComment' | 'gh_LabeledEvent' | 'gh_LockedEvent' | 'gh_MergedEvent' | 'gh_MilestonedEvent' | 'gh_PullRequestReview' | 'gh_PullRequestReviewComment' | 'gh_PullRequestReviewThread' | 'gh_ReferencedEvent' | 'gh_RenamedTitleEvent' | 'gh_ReopenedEvent' | 'gh_ReviewDismissedEvent' | 'gh_ReviewRequestRemovedEvent' | 'gh_ReviewRequestedEvent' | 'gh_SubscribedEvent' | 'gh_UnassignedEvent' | 'gh_UnlabeledEvent' | 'gh_UnlockedEvent' | 'gh_UnsubscribedEvent' | 'gh_UserBlockedEvent', ParentType, ContextType>;
}>;

export type gh_PullRequestTimelineItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestTimelineItemEdge'] = ResolversParentTypes['gh_PullRequestTimelineItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PullRequestTimelineItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestTimelineItemsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestTimelineItems'] = ResolversParentTypes['gh_PullRequestTimelineItems']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_AddedToMergeQueueEvent' | 'gh_AddedToProjectEvent' | 'gh_AssignedEvent' | 'gh_AutoMergeDisabledEvent' | 'gh_AutoMergeEnabledEvent' | 'gh_AutoRebaseEnabledEvent' | 'gh_AutoSquashEnabledEvent' | 'gh_AutomaticBaseChangeFailedEvent' | 'gh_AutomaticBaseChangeSucceededEvent' | 'gh_BaseRefChangedEvent' | 'gh_BaseRefDeletedEvent' | 'gh_BaseRefForcePushedEvent' | 'gh_ClosedEvent' | 'gh_CommentDeletedEvent' | 'gh_ConnectedEvent' | 'gh_ConvertToDraftEvent' | 'gh_ConvertedNoteToIssueEvent' | 'gh_ConvertedToDiscussionEvent' | 'gh_CrossReferencedEvent' | 'gh_DemilestonedEvent' | 'gh_DeployedEvent' | 'gh_DeploymentEnvironmentChangedEvent' | 'gh_DisconnectedEvent' | 'gh_HeadRefDeletedEvent' | 'gh_HeadRefForcePushedEvent' | 'gh_HeadRefRestoredEvent' | 'gh_IssueComment' | 'gh_LabeledEvent' | 'gh_LockedEvent' | 'gh_MarkedAsDuplicateEvent' | 'gh_MentionedEvent' | 'gh_MergedEvent' | 'gh_MilestonedEvent' | 'gh_MovedColumnsInProjectEvent' | 'gh_PinnedEvent' | 'gh_PullRequestCommit' | 'gh_PullRequestCommitCommentThread' | 'gh_PullRequestReview' | 'gh_PullRequestReviewThread' | 'gh_PullRequestRevisionMarker' | 'gh_ReadyForReviewEvent' | 'gh_ReferencedEvent' | 'gh_RemovedFromMergeQueueEvent' | 'gh_RemovedFromProjectEvent' | 'gh_RenamedTitleEvent' | 'gh_ReopenedEvent' | 'gh_ReviewDismissedEvent' | 'gh_ReviewRequestRemovedEvent' | 'gh_ReviewRequestedEvent' | 'gh_SubscribedEvent' | 'gh_TransferredEvent' | 'gh_UnassignedEvent' | 'gh_UnlabeledEvent' | 'gh_UnlockedEvent' | 'gh_UnmarkedAsDuplicateEvent' | 'gh_UnpinnedEvent' | 'gh_UnsubscribedEvent' | 'gh_UserBlockedEvent', ParentType, ContextType>;
}>;

export type gh_PullRequestTimelineItemsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestTimelineItemsConnection'] = ResolversParentTypes['gh_PullRequestTimelineItemsConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestTimelineItemsEdge']>>>, ParentType, ContextType>;
  filteredCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PullRequestTimelineItems']>>>, ParentType, ContextType>;
  pageCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PullRequestTimelineItemsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PullRequestTimelineItemsEdge'] = ResolversParentTypes['gh_PullRequestTimelineItemsEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PullRequestTimelineItems']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PushResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Push'] = ResolversParentTypes['gh_Push']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  nextSha?: Resolver<Maybe<ResolversTypes['gh_GitObjectID']>, ParentType, ContextType>;
  permalink?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  previousSha?: Resolver<Maybe<ResolversTypes['gh_GitObjectID']>, ParentType, ContextType>;
  pusher?: Resolver<ResolversTypes['gh_Actor'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PushAllowanceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PushAllowance'] = ResolversParentTypes['gh_PushAllowance']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_PushAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['gh_BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PushAllowanceActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PushAllowanceActor'] = ResolversParentTypes['gh_PushAllowanceActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_App' | 'gh_Team' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_PushAllowanceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PushAllowanceConnection'] = ResolversParentTypes['gh_PushAllowanceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PushAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_PushAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_PushAllowanceEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_PushAllowanceEdge'] = ResolversParentTypes['gh_PushAllowanceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_PushAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RateLimitResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RateLimit'] = ResolversParentTypes['gh_RateLimit']> = ResolversObject<{
  cost?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  limit?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  remaining?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  resetAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  used?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReactableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Reactable'] = ResolversParentTypes['gh_Reactable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_CommitComment' | 'gh_Discussion' | 'gh_DiscussionComment' | 'gh_Issue' | 'gh_IssueComment' | 'gh_PullRequest' | 'gh_PullRequestReview' | 'gh_PullRequestReviewComment' | 'gh_Release' | 'gh_TeamDiscussion' | 'gh_TeamDiscussionComment', ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['gh_ReactionConnection'], ParentType, ContextType, Partial<gh_ReactablereactionsArgs>>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type gh_ReactingUserConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReactingUserConnection'] = ResolversParentTypes['gh_ReactingUserConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ReactingUserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReactingUserEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReactingUserEdge'] = ResolversParentTypes['gh_ReactingUserEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  reactedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReactionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Reaction'] = ResolversParentTypes['gh_Reaction']> = ResolversObject<{
  content?: Resolver<ResolversTypes['gh_ReactionContent'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  reactable?: Resolver<ResolversTypes['gh_Reactable'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReactionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReactionConnection'] = ResolversParentTypes['gh_ReactionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ReactionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Reaction']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerHasReacted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReactionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReactionEdge'] = ResolversParentTypes['gh_ReactionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Reaction']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReactionGroupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReactionGroup'] = ResolversParentTypes['gh_ReactionGroup']> = ResolversObject<{
  content?: Resolver<ResolversTypes['gh_ReactionContent'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactors?: Resolver<ResolversTypes['gh_ReactorConnection'], ParentType, ContextType, Partial<gh_ReactionGroupreactorsArgs>>;
  subject?: Resolver<ResolversTypes['gh_Reactable'], ParentType, ContextType>;
  users?: Resolver<ResolversTypes['gh_ReactingUserConnection'], ParentType, ContextType, Partial<gh_ReactionGroupusersArgs>>;
  viewerHasReacted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReactorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Reactor'] = ResolversParentTypes['gh_Reactor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Bot' | 'gh_Mannequin' | 'gh_Organization' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_ReactorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReactorConnection'] = ResolversParentTypes['gh_ReactorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ReactorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Reactor']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReactorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReactorEdge'] = ResolversParentTypes['gh_ReactorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['gh_Reactor'], ParentType, ContextType>;
  reactedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReadyForReviewEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReadyForReviewEvent'] = ResolversParentTypes['gh_ReadyForReviewEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RefResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Ref'] = ResolversParentTypes['gh_Ref']> = ResolversObject<{
  associatedPullRequests?: Resolver<ResolversTypes['gh_PullRequestConnection'], ParentType, ContextType, Partial<gh_RefassociatedPullRequestsArgs>>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['gh_BranchProtectionRule']>, ParentType, ContextType>;
  compare?: Resolver<Maybe<ResolversTypes['gh_Comparison']>, ParentType, ContextType, RequireFields<gh_RefcompareArgs, 'headRef'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  prefix?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  refUpdateRule?: Resolver<Maybe<ResolversTypes['gh_RefUpdateRule']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['gh_GitObject']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RefConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RefConnection'] = ResolversParentTypes['gh_RefConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RefEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Ref']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RefEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RefEdge'] = ResolversParentTypes['gh_RefEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RefNameConditionTargetResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RefNameConditionTarget'] = ResolversParentTypes['gh_RefNameConditionTarget']> = ResolversObject<{
  exclude?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  include?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RefUpdateRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RefUpdateRule'] = ResolversParentTypes['gh_RefUpdateRule']> = ResolversObject<{
  allowsDeletions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  allowsForcePushes?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  blocksCreations?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  requiredApprovingReviewCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  requiredStatusCheckContexts?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  requiresCodeOwnerReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresConversationResolution?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresLinearHistory?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresSignatures?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerAllowedToDismissReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanPush?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReferencedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReferencedEvent'] = ResolversParentTypes['gh_ReferencedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  commitRepository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDirectReference?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['gh_ReferencedSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReferencedSubjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReferencedSubject'] = ResolversParentTypes['gh_ReferencedSubject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Issue' | 'gh_PullRequest', ParentType, ContextType>;
}>;

export type gh_RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload'] = ResolversParentTypes['gh_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identityProvider?: Resolver<Maybe<ResolversTypes['gh_EnterpriseIdentityProvider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RegenerateVerifiableDomainTokenPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RegenerateVerifiableDomainTokenPayload'] = ResolversParentTypes['gh_RegenerateVerifiableDomainTokenPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  verificationToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RejectDeploymentsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RejectDeploymentsPayload'] = ResolversParentTypes['gh_RejectDeploymentsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deployments?: Resolver<Maybe<Array<ResolversTypes['gh_Deployment']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReleaseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Release'] = ResolversParentTypes['gh_Release']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<Maybe<ResolversTypes['gh_HTML']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isLatest?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPrerelease?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mentions?: Resolver<Maybe<ResolversTypes['gh_UserConnection']>, ParentType, ContextType, Partial<gh_ReleasementionsArgs>>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['gh_ReactionConnection'], ParentType, ContextType, Partial<gh_ReleasereactionsArgs>>;
  releaseAssets?: Resolver<ResolversTypes['gh_ReleaseAssetConnection'], ParentType, ContextType, Partial<gh_ReleasereleaseAssetsArgs>>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<Maybe<ResolversTypes['gh_HTML']>, ParentType, ContextType, RequireFields<gh_ReleaseshortDescriptionHTMLArgs, 'limit'>>;
  tag?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  tagCommit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  tagName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReleaseAssetResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReleaseAsset'] = ResolversParentTypes['gh_ReleaseAsset']> = ResolversObject<{
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  downloadCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  downloadUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  release?: Resolver<Maybe<ResolversTypes['gh_Release']>, ParentType, ContextType>;
  size?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  uploadedBy?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReleaseAssetConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReleaseAssetConnection'] = ResolversParentTypes['gh_ReleaseAssetConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ReleaseAssetEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ReleaseAsset']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReleaseAssetEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReleaseAssetEdge'] = ResolversParentTypes['gh_ReleaseAssetEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ReleaseAsset']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReleaseConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReleaseConnection'] = ResolversParentTypes['gh_ReleaseConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ReleaseEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Release']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReleaseEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReleaseEdge'] = ResolversParentTypes['gh_ReleaseEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Release']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RemoveAssigneesFromAssignablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RemoveAssigneesFromAssignablePayload'] = ResolversParentTypes['gh_RemoveAssigneesFromAssignablePayload']> = ResolversObject<{
  assignable?: Resolver<Maybe<ResolversTypes['gh_Assignable']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RemoveEnterpriseAdminPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RemoveEnterpriseAdminPayload'] = ResolversParentTypes['gh_RemoveEnterpriseAdminPayload']> = ResolversObject<{
  admin?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RemoveEnterpriseIdentityProviderPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RemoveEnterpriseIdentityProviderPayload'] = ResolversParentTypes['gh_RemoveEnterpriseIdentityProviderPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identityProvider?: Resolver<Maybe<ResolversTypes['gh_EnterpriseIdentityProvider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RemoveEnterpriseMemberPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RemoveEnterpriseMemberPayload'] = ResolversParentTypes['gh_RemoveEnterpriseMemberPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RemoveEnterpriseOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RemoveEnterpriseOrganizationPayload'] = ResolversParentTypes['gh_RemoveEnterpriseOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RemoveEnterpriseSupportEntitlementPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RemoveEnterpriseSupportEntitlementPayload'] = ResolversParentTypes['gh_RemoveEnterpriseSupportEntitlementPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RemoveLabelsFromLabelablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RemoveLabelsFromLabelablePayload'] = ResolversParentTypes['gh_RemoveLabelsFromLabelablePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labelable?: Resolver<Maybe<ResolversTypes['gh_Labelable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RemoveOutsideCollaboratorPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RemoveOutsideCollaboratorPayload'] = ResolversParentTypes['gh_RemoveOutsideCollaboratorPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  removedUser?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RemoveReactionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RemoveReactionPayload'] = ResolversParentTypes['gh_RemoveReactionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reaction?: Resolver<Maybe<ResolversTypes['gh_Reaction']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['gh_Reactable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RemoveStarPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RemoveStarPayload'] = ResolversParentTypes['gh_RemoveStarPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  starrable?: Resolver<Maybe<ResolversTypes['gh_Starrable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RemoveUpvotePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RemoveUpvotePayload'] = ResolversParentTypes['gh_RemoveUpvotePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['gh_Votable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RemovedFromMergeQueueEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RemovedFromMergeQueueEvent'] = ResolversParentTypes['gh_RemovedFromMergeQueueEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  beforeCommit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enqueuer?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  mergeQueue?: Resolver<Maybe<ResolversTypes['gh_MergeQueue']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RemovedFromProjectEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RemovedFromProjectEvent'] = ResolversParentTypes['gh_RemovedFromProjectEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType>;
  projectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RenamedTitleEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RenamedTitleEvent'] = ResolversParentTypes['gh_RenamedTitleEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  currentTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  previousTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['gh_RenamedTitleSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RenamedTitleSubjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RenamedTitleSubject'] = ResolversParentTypes['gh_RenamedTitleSubject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Issue' | 'gh_PullRequest', ParentType, ContextType>;
}>;

export type gh_ReopenDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReopenDiscussionPayload'] = ResolversParentTypes['gh_ReopenDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['gh_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReopenIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReopenIssuePayload'] = ResolversParentTypes['gh_ReopenIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['gh_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReopenPullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReopenPullRequestPayload'] = ResolversParentTypes['gh_ReopenPullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReopenedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReopenedEvent'] = ResolversParentTypes['gh_ReopenedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  closable?: Resolver<ResolversTypes['gh_Closable'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  stateReason?: Resolver<Maybe<ResolversTypes['gh_IssueStateReason']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoAccessAuditEntry'] = ResolversParentTypes['gh_RepoAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['gh_RepoAccessAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoAddMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoAddMemberAuditEntry'] = ResolversParentTypes['gh_RepoAddMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['gh_RepoAddMemberAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoAddTopicAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoAddTopicAuditEntry'] = ResolversParentTypes['gh_RepoAddTopicAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['gh_Topic']>, ParentType, ContextType>;
  topicName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoArchivedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoArchivedAuditEntry'] = ResolversParentTypes['gh_RepoArchivedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['gh_RepoArchivedAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoChangeMergeSettingAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoChangeMergeSettingAuditEntry'] = ResolversParentTypes['gh_RepoChangeMergeSettingAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  mergeType?: Resolver<Maybe<ResolversTypes['gh_RepoChangeMergeSettingAuditEntryMergeType']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoConfigDisableAnonymousGitAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoConfigDisableAnonymousGitAccessAuditEntry'] = ResolversParentTypes['gh_RepoConfigDisableAnonymousGitAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoConfigDisableCollaboratorsOnlyAuditEntry'] = ResolversParentTypes['gh_RepoConfigDisableCollaboratorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoConfigDisableContributorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoConfigDisableContributorsOnlyAuditEntry'] = ResolversParentTypes['gh_RepoConfigDisableContributorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoConfigDisableSockpuppetDisallowedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoConfigDisableSockpuppetDisallowedAuditEntry'] = ResolversParentTypes['gh_RepoConfigDisableSockpuppetDisallowedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoConfigEnableAnonymousGitAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoConfigEnableAnonymousGitAccessAuditEntry'] = ResolversParentTypes['gh_RepoConfigEnableAnonymousGitAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoConfigEnableCollaboratorsOnlyAuditEntry'] = ResolversParentTypes['gh_RepoConfigEnableCollaboratorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoConfigEnableContributorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoConfigEnableContributorsOnlyAuditEntry'] = ResolversParentTypes['gh_RepoConfigEnableContributorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoConfigEnableSockpuppetDisallowedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoConfigEnableSockpuppetDisallowedAuditEntry'] = ResolversParentTypes['gh_RepoConfigEnableSockpuppetDisallowedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoConfigLockAnonymousGitAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoConfigLockAnonymousGitAccessAuditEntry'] = ResolversParentTypes['gh_RepoConfigLockAnonymousGitAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoConfigUnlockAnonymousGitAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoConfigUnlockAnonymousGitAccessAuditEntry'] = ResolversParentTypes['gh_RepoConfigUnlockAnonymousGitAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoCreateAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoCreateAuditEntry'] = ResolversParentTypes['gh_RepoCreateAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  forkParentName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  forkSourceName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['gh_RepoCreateAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoDestroyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoDestroyAuditEntry'] = ResolversParentTypes['gh_RepoDestroyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['gh_RepoDestroyAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoRemoveMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoRemoveMemberAuditEntry'] = ResolversParentTypes['gh_RepoRemoveMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['gh_RepoRemoveMemberAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepoRemoveTopicAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepoRemoveTopicAuditEntry'] = ResolversParentTypes['gh_RepoRemoveTopicAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['gh_Topic']>, ParentType, ContextType>;
  topicName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Repository'] = ResolversParentTypes['gh_Repository']> = ResolversObject<{
  allowUpdateBranch?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  archivedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  assignableUsers?: Resolver<ResolversTypes['gh_UserConnection'], ParentType, ContextType, Partial<gh_RepositoryassignableUsersArgs>>;
  autoMergeAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  branchProtectionRules?: Resolver<ResolversTypes['gh_BranchProtectionRuleConnection'], ParentType, ContextType, Partial<gh_RepositorybranchProtectionRulesArgs>>;
  codeOfConduct?: Resolver<Maybe<ResolversTypes['gh_CodeOfConduct']>, ParentType, ContextType>;
  codeowners?: Resolver<Maybe<ResolversTypes['gh_RepositoryCodeowners']>, ParentType, ContextType, Partial<gh_RepositorycodeownersArgs>>;
  collaborators?: Resolver<Maybe<ResolversTypes['gh_RepositoryCollaboratorConnection']>, ParentType, ContextType, Partial<gh_RepositorycollaboratorsArgs>>;
  commitComments?: Resolver<ResolversTypes['gh_CommitCommentConnection'], ParentType, ContextType, Partial<gh_RepositorycommitCommentsArgs>>;
  contactLinks?: Resolver<Maybe<Array<ResolversTypes['gh_RepositoryContactLink']>>, ParentType, ContextType>;
  contributingGuidelines?: Resolver<Maybe<ResolversTypes['gh_ContributingGuidelines']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  defaultBranchRef?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  deleteBranchOnMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  dependencyGraphManifests?: Resolver<Maybe<ResolversTypes['gh_DependencyGraphManifestConnection']>, ParentType, ContextType, Partial<gh_RepositorydependencyGraphManifestsArgs>>;
  deployKeys?: Resolver<ResolversTypes['gh_DeployKeyConnection'], ParentType, ContextType, Partial<gh_RepositorydeployKeysArgs>>;
  deployments?: Resolver<ResolversTypes['gh_DeploymentConnection'], ParentType, ContextType, RequireFields<gh_RepositorydeploymentsArgs, 'orderBy'>>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['gh_Discussion']>, ParentType, ContextType, RequireFields<gh_RepositorydiscussionArgs, 'number'>>;
  discussionCategories?: Resolver<ResolversTypes['gh_DiscussionCategoryConnection'], ParentType, ContextType, RequireFields<gh_RepositorydiscussionCategoriesArgs, 'filterByAssignable'>>;
  discussionCategory?: Resolver<Maybe<ResolversTypes['gh_DiscussionCategory']>, ParentType, ContextType, RequireFields<gh_RepositorydiscussionCategoryArgs, 'slug'>>;
  discussions?: Resolver<ResolversTypes['gh_DiscussionConnection'], ParentType, ContextType, RequireFields<gh_RepositorydiscussionsArgs, 'answered' | 'categoryId' | 'orderBy' | 'states'>>;
  diskUsage?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['gh_Environment']>, ParentType, ContextType, RequireFields<gh_RepositoryenvironmentArgs, 'name'>>;
  environments?: Resolver<ResolversTypes['gh_EnvironmentConnection'], ParentType, ContextType, RequireFields<gh_RepositoryenvironmentsArgs, 'orderBy'>>;
  forkCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  forkingAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  forks?: Resolver<ResolversTypes['gh_RepositoryConnection'], ParentType, ContextType, RequireFields<gh_RepositoryforksArgs, 'ownerAffiliations'>>;
  fundingLinks?: Resolver<Array<ResolversTypes['gh_FundingLink']>, ParentType, ContextType>;
  hasDiscussionsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasIssuesEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasProjectsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasVulnerabilityAlertsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasWikiEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  homepageUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  interactionAbility?: Resolver<Maybe<ResolversTypes['gh_RepositoryInteractionAbility']>, ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isBlankIssuesEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDisabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isEmpty?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isFork?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isInOrganization?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isLocked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMirror?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSecurityPolicyEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isTemplate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isUserConfigurationRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['gh_Issue']>, ParentType, ContextType, RequireFields<gh_RepositoryissueArgs, 'number'>>;
  issueOrPullRequest?: Resolver<Maybe<ResolversTypes['gh_IssueOrPullRequest']>, ParentType, ContextType, RequireFields<gh_RepositoryissueOrPullRequestArgs, 'number'>>;
  issueTemplates?: Resolver<Maybe<Array<ResolversTypes['gh_IssueTemplate']>>, ParentType, ContextType>;
  issues?: Resolver<ResolversTypes['gh_IssueConnection'], ParentType, ContextType, Partial<gh_RepositoryissuesArgs>>;
  label?: Resolver<Maybe<ResolversTypes['gh_Label']>, ParentType, ContextType, RequireFields<gh_RepositorylabelArgs, 'name'>>;
  labels?: Resolver<Maybe<ResolversTypes['gh_LabelConnection']>, ParentType, ContextType, RequireFields<gh_RepositorylabelsArgs, 'orderBy'>>;
  languages?: Resolver<Maybe<ResolversTypes['gh_LanguageConnection']>, ParentType, ContextType, Partial<gh_RepositorylanguagesArgs>>;
  latestRelease?: Resolver<Maybe<ResolversTypes['gh_Release']>, ParentType, ContextType>;
  licenseInfo?: Resolver<Maybe<ResolversTypes['gh_License']>, ParentType, ContextType>;
  lockReason?: Resolver<Maybe<ResolversTypes['gh_RepositoryLockReason']>, ParentType, ContextType>;
  mentionableUsers?: Resolver<ResolversTypes['gh_UserConnection'], ParentType, ContextType, Partial<gh_RepositorymentionableUsersArgs>>;
  mergeCommitAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mergeCommitMessage?: Resolver<ResolversTypes['gh_MergeCommitMessage'], ParentType, ContextType>;
  mergeCommitTitle?: Resolver<ResolversTypes['gh_MergeCommitTitle'], ParentType, ContextType>;
  mergeQueue?: Resolver<Maybe<ResolversTypes['gh_MergeQueue']>, ParentType, ContextType, Partial<gh_RepositorymergeQueueArgs>>;
  milestone?: Resolver<Maybe<ResolversTypes['gh_Milestone']>, ParentType, ContextType, RequireFields<gh_RepositorymilestoneArgs, 'number'>>;
  milestones?: Resolver<Maybe<ResolversTypes['gh_MilestoneConnection']>, ParentType, ContextType, Partial<gh_RepositorymilestonesArgs>>;
  mirrorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameWithOwner?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  object?: Resolver<Maybe<ResolversTypes['gh_GitObject']>, ParentType, ContextType, Partial<gh_RepositoryobjectArgs>>;
  openGraphImageUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['gh_RepositoryOwner'], ParentType, ContextType>;
  packages?: Resolver<ResolversTypes['gh_PackageConnection'], ParentType, ContextType, RequireFields<gh_RepositorypackagesArgs, 'orderBy'>>;
  parent?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  pinnedDiscussions?: Resolver<ResolversTypes['gh_PinnedDiscussionConnection'], ParentType, ContextType, Partial<gh_RepositorypinnedDiscussionsArgs>>;
  pinnedIssues?: Resolver<Maybe<ResolversTypes['gh_PinnedIssueConnection']>, ParentType, ContextType, Partial<gh_RepositorypinnedIssuesArgs>>;
  primaryLanguage?: Resolver<Maybe<ResolversTypes['gh_Language']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType, RequireFields<gh_RepositoryprojectArgs, 'number'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType, RequireFields<gh_RepositoryprojectV2Args, 'number'>>;
  projects?: Resolver<ResolversTypes['gh_ProjectConnection'], ParentType, ContextType, Partial<gh_RepositoryprojectsArgs>>;
  projectsResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  projectsV2?: Resolver<ResolversTypes['gh_ProjectV2Connection'], ParentType, ContextType, RequireFields<gh_RepositoryprojectsV2Args, 'orderBy'>>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType, RequireFields<gh_RepositorypullRequestArgs, 'number'>>;
  pullRequestTemplates?: Resolver<Maybe<Array<ResolversTypes['gh_PullRequestTemplate']>>, ParentType, ContextType>;
  pullRequests?: Resolver<ResolversTypes['gh_PullRequestConnection'], ParentType, ContextType, Partial<gh_RepositorypullRequestsArgs>>;
  pushedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  rebaseMergeAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  recentProjects?: Resolver<ResolversTypes['gh_ProjectV2Connection'], ParentType, ContextType, Partial<gh_RepositoryrecentProjectsArgs>>;
  ref?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType, RequireFields<gh_RepositoryrefArgs, 'qualifiedName'>>;
  refs?: Resolver<Maybe<ResolversTypes['gh_RefConnection']>, ParentType, ContextType, RequireFields<gh_RepositoryrefsArgs, 'refPrefix'>>;
  release?: Resolver<Maybe<ResolversTypes['gh_Release']>, ParentType, ContextType, RequireFields<gh_RepositoryreleaseArgs, 'tagName'>>;
  releases?: Resolver<ResolversTypes['gh_ReleaseConnection'], ParentType, ContextType, Partial<gh_RepositoryreleasesArgs>>;
  repositoryTopics?: Resolver<ResolversTypes['gh_RepositoryTopicConnection'], ParentType, ContextType, Partial<gh_RepositoryrepositoryTopicsArgs>>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  ruleset?: Resolver<Maybe<ResolversTypes['gh_RepositoryRuleset']>, ParentType, ContextType, RequireFields<gh_RepositoryrulesetArgs, 'databaseId' | 'includeParents'>>;
  rulesets?: Resolver<Maybe<ResolversTypes['gh_RepositoryRulesetConnection']>, ParentType, ContextType, RequireFields<gh_RepositoryrulesetsArgs, 'includeParents'>>;
  securityPolicyUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType, RequireFields<gh_RepositoryshortDescriptionHTMLArgs, 'limit'>>;
  squashMergeAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  squashMergeCommitMessage?: Resolver<ResolversTypes['gh_SquashMergeCommitMessage'], ParentType, ContextType>;
  squashMergeCommitTitle?: Resolver<ResolversTypes['gh_SquashMergeCommitTitle'], ParentType, ContextType>;
  squashPrTitleUsedAsDefault?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sshUrl?: Resolver<ResolversTypes['gh_GitSSHRemote'], ParentType, ContextType>;
  stargazerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stargazers?: Resolver<ResolversTypes['gh_StargazerConnection'], ParentType, ContextType, Partial<gh_RepositorystargazersArgs>>;
  submodules?: Resolver<ResolversTypes['gh_SubmoduleConnection'], ParentType, ContextType, Partial<gh_RepositorysubmodulesArgs>>;
  tempCloneToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateRepository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  usesCustomOpenGraphImage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdateTopics?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerDefaultCommitEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  viewerDefaultMergeMethod?: Resolver<ResolversTypes['gh_PullRequestMergeMethod'], ParentType, ContextType>;
  viewerHasStarred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerPermission?: Resolver<Maybe<ResolversTypes['gh_RepositoryPermission']>, ParentType, ContextType>;
  viewerPossibleCommitEmails?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['gh_SubscriptionState']>, ParentType, ContextType>;
  visibility?: Resolver<ResolversTypes['gh_RepositoryVisibility'], ParentType, ContextType>;
  vulnerabilityAlert?: Resolver<Maybe<ResolversTypes['gh_RepositoryVulnerabilityAlert']>, ParentType, ContextType, RequireFields<gh_RepositoryvulnerabilityAlertArgs, 'number'>>;
  vulnerabilityAlerts?: Resolver<Maybe<ResolversTypes['gh_RepositoryVulnerabilityAlertConnection']>, ParentType, ContextType, Partial<gh_RepositoryvulnerabilityAlertsArgs>>;
  watchers?: Resolver<ResolversTypes['gh_UserConnection'], ParentType, ContextType, Partial<gh_RepositorywatchersArgs>>;
  webCommitSignoffRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryAuditEntryData'] = ResolversParentTypes['gh_RepositoryAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_OrgRestoreMemberMembershipRepositoryAuditEntryData' | 'gh_PrivateRepositoryForkingDisableAuditEntry' | 'gh_PrivateRepositoryForkingEnableAuditEntry' | 'gh_RepoAccessAuditEntry' | 'gh_RepoAddMemberAuditEntry' | 'gh_RepoAddTopicAuditEntry' | 'gh_RepoArchivedAuditEntry' | 'gh_RepoChangeMergeSettingAuditEntry' | 'gh_RepoConfigDisableAnonymousGitAccessAuditEntry' | 'gh_RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'gh_RepoConfigDisableContributorsOnlyAuditEntry' | 'gh_RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'gh_RepoConfigEnableAnonymousGitAccessAuditEntry' | 'gh_RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'gh_RepoConfigEnableContributorsOnlyAuditEntry' | 'gh_RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'gh_RepoConfigLockAnonymousGitAccessAuditEntry' | 'gh_RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'gh_RepoCreateAuditEntry' | 'gh_RepoDestroyAuditEntry' | 'gh_RepoRemoveMemberAuditEntry' | 'gh_RepoRemoveTopicAuditEntry' | 'gh_TeamAddRepositoryAuditEntry' | 'gh_TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
}>;

export type gh_RepositoryCodeownersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryCodeowners'] = ResolversParentTypes['gh_RepositoryCodeowners']> = ResolversObject<{
  errors?: Resolver<Array<ResolversTypes['gh_RepositoryCodeownersError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryCodeownersErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryCodeownersError'] = ResolversParentTypes['gh_RepositoryCodeownersError']> = ResolversObject<{
  column?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  line?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  suggestion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryCollaboratorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryCollaboratorConnection'] = ResolversParentTypes['gh_RepositoryCollaboratorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryCollaboratorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryCollaboratorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryCollaboratorEdge'] = ResolversParentTypes['gh_RepositoryCollaboratorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  permission?: Resolver<ResolversTypes['gh_RepositoryPermission'], ParentType, ContextType>;
  permissionSources?: Resolver<Maybe<Array<ResolversTypes['gh_PermissionSource']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryConnection'] = ResolversParentTypes['gh_RepositoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Repository']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalDiskUsage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryContactLinkResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryContactLink'] = ResolversParentTypes['gh_RepositoryContactLink']> = ResolversObject<{
  about?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryDiscussionAuthorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryDiscussionAuthor'] = ResolversParentTypes['gh_RepositoryDiscussionAuthor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_User', ParentType, ContextType>;
  repositoryDiscussions?: Resolver<ResolversTypes['gh_DiscussionConnection'], ParentType, ContextType, RequireFields<gh_RepositoryDiscussionAuthorrepositoryDiscussionsArgs, 'answered' | 'orderBy' | 'states'>>;
}>;

export type gh_RepositoryDiscussionCommentAuthorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryDiscussionCommentAuthor'] = ResolversParentTypes['gh_RepositoryDiscussionCommentAuthor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_User', ParentType, ContextType>;
  repositoryDiscussionComments?: Resolver<ResolversTypes['gh_DiscussionCommentConnection'], ParentType, ContextType, RequireFields<gh_RepositoryDiscussionCommentAuthorrepositoryDiscussionCommentsArgs, 'onlyAnswers'>>;
}>;

export type gh_RepositoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryEdge'] = ResolversParentTypes['gh_RepositoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryIdConditionTargetResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryIdConditionTarget'] = ResolversParentTypes['gh_RepositoryIdConditionTarget']> = ResolversObject<{
  repositoryIds?: Resolver<Array<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryInfo'] = ResolversParentTypes['gh_RepositoryInfo']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Repository', ParentType, ContextType>;
  archivedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  forkCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hasDiscussionsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasIssuesEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasProjectsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasWikiEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  homepageUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isFork?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isInOrganization?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isLocked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMirror?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isTemplate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  licenseInfo?: Resolver<Maybe<ResolversTypes['gh_License']>, ParentType, ContextType>;
  lockReason?: Resolver<Maybe<ResolversTypes['gh_RepositoryLockReason']>, ParentType, ContextType>;
  mirrorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameWithOwner?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  openGraphImageUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['gh_RepositoryOwner'], ParentType, ContextType>;
  pushedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType, RequireFields<gh_RepositoryInfoshortDescriptionHTMLArgs, 'limit'>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  usesCustomOpenGraphImage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  visibility?: Resolver<ResolversTypes['gh_RepositoryVisibility'], ParentType, ContextType>;
}>;

export type gh_RepositoryInteractionAbilityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryInteractionAbility'] = ResolversParentTypes['gh_RepositoryInteractionAbility']> = ResolversObject<{
  expiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  limit?: Resolver<ResolversTypes['gh_RepositoryInteractionLimit'], ParentType, ContextType>;
  origin?: Resolver<ResolversTypes['gh_RepositoryInteractionLimitOrigin'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryInvitationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryInvitation'] = ResolversParentTypes['gh_RepositoryInvitation']> = ResolversObject<{
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitee?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  inviter?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  permalink?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  permission?: Resolver<ResolversTypes['gh_RepositoryPermission'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_RepositoryInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryInvitationConnection'] = ResolversParentTypes['gh_RepositoryInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryInvitationEdge'] = ResolversParentTypes['gh_RepositoryInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_RepositoryInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryMigrationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryMigration'] = ResolversParentTypes['gh_RepositoryMigration']> = ResolversObject<{
  continueOnError?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  failureReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  migrationLogUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  migrationSource?: Resolver<ResolversTypes['gh_MigrationSource'], ParentType, ContextType>;
  repositoryName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sourceUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_MigrationState'], ParentType, ContextType>;
  warningsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryMigrationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryMigrationConnection'] = ResolversParentTypes['gh_RepositoryMigrationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryMigrationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryMigration']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryMigrationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryMigrationEdge'] = ResolversParentTypes['gh_RepositoryMigrationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_RepositoryMigration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryNameConditionTargetResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryNameConditionTarget'] = ResolversParentTypes['gh_RepositoryNameConditionTarget']> = ResolversObject<{
  exclude?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  include?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  protected?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryNodeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryNode'] = ResolversParentTypes['gh_RepositoryNode']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_CommitComment' | 'gh_CommitCommentThread' | 'gh_DependabotUpdate' | 'gh_Discussion' | 'gh_DiscussionCategory' | 'gh_Issue' | 'gh_IssueComment' | 'gh_PinnedDiscussion' | 'gh_PullRequest' | 'gh_PullRequestCommitCommentThread' | 'gh_PullRequestReview' | 'gh_PullRequestReviewComment' | 'gh_RepositoryVulnerabilityAlert', ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
}>;

export type gh_RepositoryOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryOwner'] = ResolversParentTypes['gh_RepositoryOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_User', ParentType, ContextType>;
  avatarUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType, Partial<gh_RepositoryOwneravatarUrlArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  repositories?: Resolver<ResolversTypes['gh_RepositoryConnection'], ParentType, ContextType, RequireFields<gh_RepositoryOwnerrepositoriesArgs, 'ownerAffiliations'>>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType, RequireFields<gh_RepositoryOwnerrepositoryArgs, 'followRenames' | 'name'>>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
}>;

export type gh_RepositoryRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryRule'] = ResolversParentTypes['gh_RepositoryRule']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parameters?: Resolver<Maybe<ResolversTypes['gh_RuleParameters']>, ParentType, ContextType>;
  repositoryRuleset?: Resolver<Maybe<ResolversTypes['gh_RepositoryRuleset']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['gh_RepositoryRuleType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryRuleConditionsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryRuleConditions'] = ResolversParentTypes['gh_RepositoryRuleConditions']> = ResolversObject<{
  refName?: Resolver<Maybe<ResolversTypes['gh_RefNameConditionTarget']>, ParentType, ContextType>;
  repositoryId?: Resolver<Maybe<ResolversTypes['gh_RepositoryIdConditionTarget']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['gh_RepositoryNameConditionTarget']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryRuleConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryRuleConnection'] = ResolversParentTypes['gh_RepositoryRuleConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryRuleEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryRule']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryRuleEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryRuleEdge'] = ResolversParentTypes['gh_RepositoryRuleEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_RepositoryRule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryRulesetResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryRuleset'] = ResolversParentTypes['gh_RepositoryRuleset']> = ResolversObject<{
  bypassActors?: Resolver<Maybe<ResolversTypes['gh_RepositoryRulesetBypassActorConnection']>, ParentType, ContextType, Partial<gh_RepositoryRulesetbypassActorsArgs>>;
  conditions?: Resolver<ResolversTypes['gh_RepositoryRuleConditions'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  enforcement?: Resolver<ResolversTypes['gh_RuleEnforcement'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  rules?: Resolver<Maybe<ResolversTypes['gh_RepositoryRuleConnection']>, ParentType, ContextType, Partial<gh_RepositoryRulesetrulesArgs>>;
  source?: Resolver<ResolversTypes['gh_RuleSource'], ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['gh_RepositoryRulesetTarget']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryRulesetBypassActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryRulesetBypassActor'] = ResolversParentTypes['gh_RepositoryRulesetBypassActor']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_BypassActor']>, ParentType, ContextType>;
  bypassMode?: Resolver<Maybe<ResolversTypes['gh_RepositoryRulesetBypassActorBypassMode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organizationAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  repositoryRoleDatabaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  repositoryRoleName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryRuleset?: Resolver<Maybe<ResolversTypes['gh_RepositoryRuleset']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryRulesetBypassActorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryRulesetBypassActorConnection'] = ResolversParentTypes['gh_RepositoryRulesetBypassActorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryRulesetBypassActorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryRulesetBypassActor']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryRulesetBypassActorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryRulesetBypassActorEdge'] = ResolversParentTypes['gh_RepositoryRulesetBypassActorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_RepositoryRulesetBypassActor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryRulesetConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryRulesetConnection'] = ResolversParentTypes['gh_RepositoryRulesetConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryRulesetEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryRuleset']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryRulesetEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryRulesetEdge'] = ResolversParentTypes['gh_RepositoryRulesetEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_RepositoryRuleset']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryTopicResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryTopic'] = ResolversParentTypes['gh_RepositoryTopic']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  topic?: Resolver<ResolversTypes['gh_Topic'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryTopicConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryTopicConnection'] = ResolversParentTypes['gh_RepositoryTopicConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryTopicEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryTopic']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryTopicEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryTopicEdge'] = ResolversParentTypes['gh_RepositoryTopicEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_RepositoryTopic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryVisibilityChangeDisableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryVisibilityChangeDisableAuditEntry'] = ResolversParentTypes['gh_RepositoryVisibilityChangeDisableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryVisibilityChangeEnableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryVisibilityChangeEnableAuditEntry'] = ResolversParentTypes['gh_RepositoryVisibilityChangeEnableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryVulnerabilityAlertResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryVulnerabilityAlert'] = ResolversParentTypes['gh_RepositoryVulnerabilityAlert']> = ResolversObject<{
  autoDismissedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dependabotUpdate?: Resolver<Maybe<ResolversTypes['gh_DependabotUpdate']>, ParentType, ContextType>;
  dependencyScope?: Resolver<Maybe<ResolversTypes['gh_RepositoryVulnerabilityAlertDependencyScope']>, ParentType, ContextType>;
  dismissComment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dismissReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dismissedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  dismisser?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  fixedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  securityAdvisory?: Resolver<Maybe<ResolversTypes['gh_SecurityAdvisory']>, ParentType, ContextType>;
  securityVulnerability?: Resolver<Maybe<ResolversTypes['gh_SecurityVulnerability']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_RepositoryVulnerabilityAlertState'], ParentType, ContextType>;
  vulnerableManifestFilename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  vulnerableManifestPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  vulnerableRequirements?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryVulnerabilityAlertConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryVulnerabilityAlertConnection'] = ResolversParentTypes['gh_RepositoryVulnerabilityAlertConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryVulnerabilityAlertEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RepositoryVulnerabilityAlert']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RepositoryVulnerabilityAlertEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RepositoryVulnerabilityAlertEdge'] = ResolversParentTypes['gh_RepositoryVulnerabilityAlertEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_RepositoryVulnerabilityAlert']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RequestReviewsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RequestReviewsPayload'] = ResolversParentTypes['gh_RequestReviewsPayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  requestedReviewersEdge?: Resolver<Maybe<ResolversTypes['gh_UserEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RequestedReviewerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RequestedReviewer'] = ResolversParentTypes['gh_RequestedReviewer']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Bot' | 'gh_Mannequin' | 'gh_Team' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_RequestedReviewerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RequestedReviewerConnection'] = ResolversParentTypes['gh_RequestedReviewerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RequestedReviewerEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_RequestedReviewer']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RequestedReviewerEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RequestedReviewerEdge'] = ResolversParentTypes['gh_RequestedReviewerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RequirableByPullRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RequirableByPullRequest'] = ResolversParentTypes['gh_RequirableByPullRequest']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_CheckRun' | 'gh_StatusContext', ParentType, ContextType>;
  isRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<gh_RequirableByPullRequestisRequiredArgs>>;
}>;

export type gh_RequiredDeploymentsParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RequiredDeploymentsParameters'] = ResolversParentTypes['gh_RequiredDeploymentsParameters']> = ResolversObject<{
  requiredDeploymentEnvironments?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RequiredStatusCheckDescriptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RequiredStatusCheckDescription'] = ResolversParentTypes['gh_RequiredStatusCheckDescription']> = ResolversObject<{
  app?: Resolver<Maybe<ResolversTypes['gh_App']>, ParentType, ContextType>;
  context?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RequiredStatusChecksParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RequiredStatusChecksParameters'] = ResolversParentTypes['gh_RequiredStatusChecksParameters']> = ResolversObject<{
  requiredStatusChecks?: Resolver<Array<ResolversTypes['gh_StatusCheckConfiguration']>, ParentType, ContextType>;
  strictRequiredStatusChecksPolicy?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RerequestCheckSuitePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RerequestCheckSuitePayload'] = ResolversParentTypes['gh_RerequestCheckSuitePayload']> = ResolversObject<{
  checkSuite?: Resolver<Maybe<ResolversTypes['gh_CheckSuite']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ResolveReviewThreadPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ResolveReviewThreadPayload'] = ResolversParentTypes['gh_ResolveReviewThreadPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  thread?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RestrictedContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RestrictedContribution'] = ResolversParentTypes['gh_RestrictedContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RetireSponsorsTierPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RetireSponsorsTierPayload'] = ResolversParentTypes['gh_RetireSponsorsTierPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['gh_SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RevertPullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RevertPullRequestPayload'] = ResolversParentTypes['gh_RevertPullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  revertPullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReviewDismissalAllowanceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReviewDismissalAllowance'] = ResolversParentTypes['gh_ReviewDismissalAllowance']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_ReviewDismissalAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['gh_BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReviewDismissalAllowanceActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReviewDismissalAllowanceActor'] = ResolversParentTypes['gh_ReviewDismissalAllowanceActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_App' | 'gh_Team' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_ReviewDismissalAllowanceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReviewDismissalAllowanceConnection'] = ResolversParentTypes['gh_ReviewDismissalAllowanceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ReviewDismissalAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ReviewDismissalAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReviewDismissalAllowanceEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReviewDismissalAllowanceEdge'] = ResolversParentTypes['gh_ReviewDismissalAllowanceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ReviewDismissalAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReviewDismissedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReviewDismissedEvent'] = ResolversParentTypes['gh_ReviewDismissedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  dismissalMessage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dismissalMessageHTML?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  previousReviewState?: Resolver<ResolversTypes['gh_PullRequestReviewState'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  pullRequestCommit?: Resolver<Maybe<ResolversTypes['gh_PullRequestCommit']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['gh_PullRequestReview']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReviewRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReviewRequest'] = ResolversParentTypes['gh_ReviewRequest']> = ResolversObject<{
  asCodeOwner?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  requestedReviewer?: Resolver<Maybe<ResolversTypes['gh_RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReviewRequestConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReviewRequestConnection'] = ResolversParentTypes['gh_ReviewRequestConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ReviewRequestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_ReviewRequest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReviewRequestEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReviewRequestEdge'] = ResolversParentTypes['gh_ReviewRequestEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_ReviewRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReviewRequestRemovedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReviewRequestRemovedEvent'] = ResolversParentTypes['gh_ReviewRequestRemovedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  requestedReviewer?: Resolver<Maybe<ResolversTypes['gh_RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReviewRequestedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReviewRequestedEvent'] = ResolversParentTypes['gh_ReviewRequestedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['gh_PullRequest'], ParentType, ContextType>;
  requestedReviewer?: Resolver<Maybe<ResolversTypes['gh_RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ReviewStatusHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ReviewStatusHovercardContext'] = ResolversParentTypes['gh_ReviewStatusHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewDecision']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RevokeEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RevokeEnterpriseOrganizationsMigratorRolePayload'] = ResolversParentTypes['gh_RevokeEnterpriseOrganizationsMigratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizations?: Resolver<Maybe<ResolversTypes['gh_OrganizationConnection']>, ParentType, ContextType, Partial<gh_RevokeEnterpriseOrganizationsMigratorRolePayloadorganizationsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RevokeMigratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RevokeMigratorRolePayload'] = ResolversParentTypes['gh_RevokeMigratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_RuleParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RuleParameters'] = ResolversParentTypes['gh_RuleParameters']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_BranchNamePatternParameters' | 'gh_CommitAuthorEmailPatternParameters' | 'gh_CommitMessagePatternParameters' | 'gh_CommitterEmailPatternParameters' | 'gh_PullRequestParameters' | 'gh_RequiredDeploymentsParameters' | 'gh_RequiredStatusChecksParameters' | 'gh_TagNamePatternParameters' | 'gh_UpdateParameters' | 'gh_WorkflowsParameters', ParentType, ContextType>;
}>;

export type gh_RuleSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_RuleSource'] = ResolversParentTypes['gh_RuleSource']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_Repository', ParentType, ContextType>;
}>;

export type gh_SavedReplyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SavedReply'] = ResolversParentTypes['gh_SavedReply']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SavedReplyConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SavedReplyConnection'] = ResolversParentTypes['gh_SavedReplyConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SavedReplyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SavedReply']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SavedReplyEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SavedReplyEdge'] = ResolversParentTypes['gh_SavedReplyEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_SavedReply']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SearchResultItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SearchResultItem'] = ResolversParentTypes['gh_SearchResultItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_App' | 'gh_Discussion' | 'gh_Issue' | 'gh_MarketplaceListing' | 'gh_Organization' | 'gh_PullRequest' | 'gh_Repository' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_SearchResultItemConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SearchResultItemConnection'] = ResolversParentTypes['gh_SearchResultItemConnection']> = ResolversObject<{
  codeCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  discussionCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SearchResultItemEdge']>>>, ParentType, ContextType>;
  issueCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SearchResultItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  repositoryCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  userCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  wikiCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SearchResultItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SearchResultItemEdge'] = ResolversParentTypes['gh_SearchResultItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_SearchResultItem']>, ParentType, ContextType>;
  textMatches?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_TextMatch']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SecurityAdvisoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SecurityAdvisory'] = ResolversParentTypes['gh_SecurityAdvisory']> = ResolversObject<{
  classification?: Resolver<ResolversTypes['gh_SecurityAdvisoryClassification'], ParentType, ContextType>;
  cvss?: Resolver<ResolversTypes['gh_CVSS'], ParentType, ContextType>;
  cwes?: Resolver<ResolversTypes['gh_CWEConnection'], ParentType, ContextType, Partial<gh_SecurityAdvisorycwesArgs>>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ghsaId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifiers?: Resolver<Array<ResolversTypes['gh_SecurityAdvisoryIdentifier']>, ParentType, ContextType>;
  notificationsPermalink?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  origin?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  permalink?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  publishedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  references?: Resolver<Array<ResolversTypes['gh_SecurityAdvisoryReference']>, ParentType, ContextType>;
  severity?: Resolver<ResolversTypes['gh_SecurityAdvisorySeverity'], ParentType, ContextType>;
  summary?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  vulnerabilities?: Resolver<ResolversTypes['gh_SecurityVulnerabilityConnection'], ParentType, ContextType, RequireFields<gh_SecurityAdvisoryvulnerabilitiesArgs, 'orderBy'>>;
  withdrawnAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SecurityAdvisoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SecurityAdvisoryConnection'] = ResolversParentTypes['gh_SecurityAdvisoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SecurityAdvisoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SecurityAdvisory']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SecurityAdvisoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SecurityAdvisoryEdge'] = ResolversParentTypes['gh_SecurityAdvisoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_SecurityAdvisory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SecurityAdvisoryIdentifierResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SecurityAdvisoryIdentifier'] = ResolversParentTypes['gh_SecurityAdvisoryIdentifier']> = ResolversObject<{
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SecurityAdvisoryPackageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SecurityAdvisoryPackage'] = ResolversParentTypes['gh_SecurityAdvisoryPackage']> = ResolversObject<{
  ecosystem?: Resolver<ResolversTypes['gh_SecurityAdvisoryEcosystem'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SecurityAdvisoryPackageVersionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SecurityAdvisoryPackageVersion'] = ResolversParentTypes['gh_SecurityAdvisoryPackageVersion']> = ResolversObject<{
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SecurityAdvisoryReferenceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SecurityAdvisoryReference'] = ResolversParentTypes['gh_SecurityAdvisoryReference']> = ResolversObject<{
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SecurityVulnerabilityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SecurityVulnerability'] = ResolversParentTypes['gh_SecurityVulnerability']> = ResolversObject<{
  advisory?: Resolver<ResolversTypes['gh_SecurityAdvisory'], ParentType, ContextType>;
  firstPatchedVersion?: Resolver<Maybe<ResolversTypes['gh_SecurityAdvisoryPackageVersion']>, ParentType, ContextType>;
  package?: Resolver<ResolversTypes['gh_SecurityAdvisoryPackage'], ParentType, ContextType>;
  severity?: Resolver<ResolversTypes['gh_SecurityAdvisorySeverity'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  vulnerableVersionRange?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SecurityVulnerabilityConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SecurityVulnerabilityConnection'] = ResolversParentTypes['gh_SecurityVulnerabilityConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SecurityVulnerabilityEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SecurityVulnerability']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SecurityVulnerabilityEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SecurityVulnerabilityEdge'] = ResolversParentTypes['gh_SecurityVulnerabilityEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_SecurityVulnerability']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SetEnterpriseIdentityProviderPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SetEnterpriseIdentityProviderPayload'] = ResolversParentTypes['gh_SetEnterpriseIdentityProviderPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identityProvider?: Resolver<Maybe<ResolversTypes['gh_EnterpriseIdentityProvider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SetOrganizationInteractionLimitPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SetOrganizationInteractionLimitPayload'] = ResolversParentTypes['gh_SetOrganizationInteractionLimitPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SetRepositoryInteractionLimitPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SetRepositoryInteractionLimitPayload'] = ResolversParentTypes['gh_SetRepositoryInteractionLimitPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SetUserInteractionLimitPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SetUserInteractionLimitPayload'] = ResolversParentTypes['gh_SetUserInteractionLimitPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SmimeSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SmimeSignature'] = ResolversParentTypes['gh_SmimeSignature']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SocialAccountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SocialAccount'] = ResolversParentTypes['gh_SocialAccount']> = ResolversObject<{
  displayName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  provider?: Resolver<ResolversTypes['gh_SocialAccountProvider'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SocialAccountConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SocialAccountConnection'] = ResolversParentTypes['gh_SocialAccountConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SocialAccountEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SocialAccount']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SocialAccountEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SocialAccountEdge'] = ResolversParentTypes['gh_SocialAccountEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_SocialAccount']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Sponsor'] = ResolversParentTypes['gh_Sponsor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_SponsorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorConnection'] = ResolversParentTypes['gh_SponsorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SponsorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Sponsor']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorEdge'] = ResolversParentTypes['gh_SponsorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Sponsor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Sponsorable'] = ResolversParentTypes['gh_Sponsorable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_User', ParentType, ContextType>;
  estimatedNextSponsorsPayoutInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hasSponsorsListing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSponsoredBy?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<gh_SponsorableisSponsoredByArgs, 'accountLogin'>>;
  isSponsoringViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  monthlyEstimatedSponsorsIncomeInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  sponsoring?: Resolver<ResolversTypes['gh_SponsorConnection'], ParentType, ContextType, RequireFields<gh_SponsorablesponsoringArgs, 'orderBy'>>;
  sponsors?: Resolver<ResolversTypes['gh_SponsorConnection'], ParentType, ContextType, RequireFields<gh_SponsorablesponsorsArgs, 'orderBy'>>;
  sponsorsActivities?: Resolver<ResolversTypes['gh_SponsorsActivityConnection'], ParentType, ContextType, RequireFields<gh_SponsorablesponsorsActivitiesArgs, 'actions' | 'includeAsSponsor' | 'includePrivate' | 'orderBy' | 'period'>>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['gh_SponsorsListing']>, ParentType, ContextType>;
  sponsorshipForViewerAsSponsor?: Resolver<Maybe<ResolversTypes['gh_Sponsorship']>, ParentType, ContextType, RequireFields<gh_SponsorablesponsorshipForViewerAsSponsorArgs, 'activeOnly'>>;
  sponsorshipForViewerAsSponsorable?: Resolver<Maybe<ResolversTypes['gh_Sponsorship']>, ParentType, ContextType, RequireFields<gh_SponsorablesponsorshipForViewerAsSponsorableArgs, 'activeOnly'>>;
  sponsorshipNewsletters?: Resolver<ResolversTypes['gh_SponsorshipNewsletterConnection'], ParentType, ContextType, RequireFields<gh_SponsorablesponsorshipNewslettersArgs, 'orderBy'>>;
  sponsorshipsAsMaintainer?: Resolver<ResolversTypes['gh_SponsorshipConnection'], ParentType, ContextType, RequireFields<gh_SponsorablesponsorshipsAsMaintainerArgs, 'activeOnly' | 'includePrivate'>>;
  sponsorshipsAsSponsor?: Resolver<ResolversTypes['gh_SponsorshipConnection'], ParentType, ContextType, RequireFields<gh_SponsorablesponsorshipsAsSponsorArgs, 'activeOnly'>>;
  totalSponsorshipAmountAsSponsorInCents?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<gh_SponsorabletotalSponsorshipAmountAsSponsorInCentsArgs, 'sponsorableLogins'>>;
  viewerCanSponsor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsSponsoring?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type gh_SponsorableItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorableItem'] = ResolversParentTypes['gh_SponsorableItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Organization' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_SponsorableItemConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorableItemConnection'] = ResolversParentTypes['gh_SponsorableItemConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SponsorableItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SponsorableItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorableItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorableItemEdge'] = ResolversParentTypes['gh_SponsorableItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_SponsorableItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorsActivityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorsActivity'] = ResolversParentTypes['gh_SponsorsActivity']> = ResolversObject<{
  action?: Resolver<ResolversTypes['gh_SponsorsActivityAction'], ParentType, ContextType>;
  currentPrivacyLevel?: Resolver<Maybe<ResolversTypes['gh_SponsorshipPrivacy']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  paymentSource?: Resolver<Maybe<ResolversTypes['gh_SponsorshipPaymentSource']>, ParentType, ContextType>;
  previousSponsorsTier?: Resolver<Maybe<ResolversTypes['gh_SponsorsTier']>, ParentType, ContextType>;
  sponsor?: Resolver<Maybe<ResolversTypes['gh_Sponsor']>, ParentType, ContextType>;
  sponsorable?: Resolver<ResolversTypes['gh_Sponsorable'], ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['gh_SponsorsTier']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  viaBulkSponsorship?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorsActivityConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorsActivityConnection'] = ResolversParentTypes['gh_SponsorsActivityConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SponsorsActivityEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SponsorsActivity']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorsActivityEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorsActivityEdge'] = ResolversParentTypes['gh_SponsorsActivityEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_SponsorsActivity']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorsGoalResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorsGoal'] = ResolversParentTypes['gh_SponsorsGoal']> = ResolversObject<{
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['gh_SponsorsGoalKind'], ParentType, ContextType>;
  percentComplete?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  targetValue?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorsListingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorsListing'] = ResolversParentTypes['gh_SponsorsListing']> = ResolversObject<{
  activeGoal?: Resolver<Maybe<ResolversTypes['gh_SponsorsGoal']>, ParentType, ContextType>;
  activeStripeConnectAccount?: Resolver<Maybe<ResolversTypes['gh_StripeConnectAccount']>, ParentType, ContextType>;
  billingCountryOrRegion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contactEmailAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dashboardResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  dashboardUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  featuredItems?: Resolver<Array<ResolversTypes['gh_SponsorsListingFeaturedItem']>, ParentType, ContextType, RequireFields<gh_SponsorsListingfeaturedItemsArgs, 'featureableTypes'>>;
  fiscalHost?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  fullDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fullDescriptionHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPublic?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nextPayoutDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  residenceCountryOrRegion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  shortDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sponsorable?: Resolver<ResolversTypes['gh_Sponsorable'], ParentType, ContextType>;
  tiers?: Resolver<Maybe<ResolversTypes['gh_SponsorsTierConnection']>, ParentType, ContextType, RequireFields<gh_SponsorsListingtiersArgs, 'includeUnpublished' | 'orderBy'>>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorsListingFeatureableItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorsListingFeatureableItem'] = ResolversParentTypes['gh_SponsorsListingFeatureableItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Repository' | 'gh_User', ParentType, ContextType>;
}>;

export type gh_SponsorsListingFeaturedItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorsListingFeaturedItem'] = ResolversParentTypes['gh_SponsorsListingFeaturedItem']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  featureable?: Resolver<ResolversTypes['gh_SponsorsListingFeatureableItem'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  position?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  sponsorsListing?: Resolver<ResolversTypes['gh_SponsorsListing'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorsTierResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorsTier'] = ResolversParentTypes['gh_SponsorsTier']> = ResolversObject<{
  adminInfo?: Resolver<Maybe<ResolversTypes['gh_SponsorsTierAdminInfo']>, ParentType, ContextType>;
  closestLesserValueTier?: Resolver<Maybe<ResolversTypes['gh_SponsorsTier']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCustomAmount?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOneTime?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  monthlyPriceInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  monthlyPriceInDollars?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sponsorsListing?: Resolver<ResolversTypes['gh_SponsorsListing'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorsTierAdminInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorsTierAdminInfo'] = ResolversParentTypes['gh_SponsorsTierAdminInfo']> = ResolversObject<{
  isDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPublished?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRetired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sponsorships?: Resolver<ResolversTypes['gh_SponsorshipConnection'], ParentType, ContextType, RequireFields<gh_SponsorsTierAdminInfosponsorshipsArgs, 'includePrivate'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorsTierConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorsTierConnection'] = ResolversParentTypes['gh_SponsorsTierConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SponsorsTierEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SponsorsTier']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorsTierEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorsTierEdge'] = ResolversParentTypes['gh_SponsorsTierEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorshipResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Sponsorship'] = ResolversParentTypes['gh_Sponsorship']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOneTimePayment?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSponsorOptedIntoEmail?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  maintainer?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  paymentSource?: Resolver<Maybe<ResolversTypes['gh_SponsorshipPaymentSource']>, ParentType, ContextType>;
  privacyLevel?: Resolver<ResolversTypes['gh_SponsorshipPrivacy'], ParentType, ContextType>;
  sponsor?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  sponsorEntity?: Resolver<Maybe<ResolversTypes['gh_Sponsor']>, ParentType, ContextType>;
  sponsorable?: Resolver<ResolversTypes['gh_Sponsorable'], ParentType, ContextType>;
  tier?: Resolver<Maybe<ResolversTypes['gh_SponsorsTier']>, ParentType, ContextType>;
  tierSelectedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorshipConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorshipConnection'] = ResolversParentTypes['gh_SponsorshipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SponsorshipEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Sponsorship']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRecurringMonthlyPriceInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRecurringMonthlyPriceInDollars?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorshipEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorshipEdge'] = ResolversParentTypes['gh_SponsorshipEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Sponsorship']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorshipNewsletterResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorshipNewsletter'] = ResolversParentTypes['gh_SponsorshipNewsletter']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPublished?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sponsorable?: Resolver<ResolversTypes['gh_Sponsorable'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorshipNewsletterConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorshipNewsletterConnection'] = ResolversParentTypes['gh_SponsorshipNewsletterConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SponsorshipNewsletterEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SponsorshipNewsletter']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SponsorshipNewsletterEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SponsorshipNewsletterEdge'] = ResolversParentTypes['gh_SponsorshipNewsletterEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_SponsorshipNewsletter']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SshSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SshSignature'] = ResolversParentTypes['gh_SshSignature']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  keyFingerprint?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StargazerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StargazerConnection'] = ResolversParentTypes['gh_StargazerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_StargazerEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StargazerEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StargazerEdge'] = ResolversParentTypes['gh_StargazerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  starredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StarrableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Starrable'] = ResolversParentTypes['gh_Starrable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Gist' | 'gh_Repository' | 'gh_Topic', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  stargazerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stargazers?: Resolver<ResolversTypes['gh_StargazerConnection'], ParentType, ContextType, Partial<gh_StarrablestargazersArgs>>;
  viewerHasStarred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type gh_StarredRepositoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StarredRepositoryConnection'] = ResolversParentTypes['gh_StarredRepositoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_StarredRepositoryEdge']>>>, ParentType, ContextType>;
  isOverLimit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Repository']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StarredRepositoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StarredRepositoryEdge'] = ResolversParentTypes['gh_StarredRepositoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  starredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StartOrganizationMigrationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StartOrganizationMigrationPayload'] = ResolversParentTypes['gh_StartOrganizationMigrationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orgMigration?: Resolver<Maybe<ResolversTypes['gh_OrganizationMigration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StartRepositoryMigrationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StartRepositoryMigrationPayload'] = ResolversParentTypes['gh_StartRepositoryMigrationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryMigration?: Resolver<Maybe<ResolversTypes['gh_RepositoryMigration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Status'] = ResolversParentTypes['gh_Status']> = ResolversObject<{
  combinedContexts?: Resolver<ResolversTypes['gh_StatusCheckRollupContextConnection'], ParentType, ContextType, Partial<gh_StatuscombinedContextsArgs>>;
  commit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  context?: Resolver<Maybe<ResolversTypes['gh_StatusContext']>, ParentType, ContextType, RequireFields<gh_StatuscontextArgs, 'name'>>;
  contexts?: Resolver<Array<ResolversTypes['gh_StatusContext']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_StatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StatusCheckConfigurationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StatusCheckConfiguration'] = ResolversParentTypes['gh_StatusCheckConfiguration']> = ResolversObject<{
  context?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  integrationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StatusCheckRollupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StatusCheckRollup'] = ResolversParentTypes['gh_StatusCheckRollup']> = ResolversObject<{
  commit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  contexts?: Resolver<ResolversTypes['gh_StatusCheckRollupContextConnection'], ParentType, ContextType, Partial<gh_StatusCheckRollupcontextsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_StatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StatusCheckRollupContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StatusCheckRollupContext'] = ResolversParentTypes['gh_StatusCheckRollupContext']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_CheckRun' | 'gh_StatusContext', ParentType, ContextType>;
}>;

export type gh_StatusCheckRollupContextConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StatusCheckRollupContextConnection'] = ResolversParentTypes['gh_StatusCheckRollupContextConnection']> = ResolversObject<{
  checkRunCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  checkRunCountsByState?: Resolver<Maybe<Array<ResolversTypes['gh_CheckRunStateCount']>>, ParentType, ContextType>;
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_StatusCheckRollupContextEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_StatusCheckRollupContext']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  statusContextCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  statusContextCountsByState?: Resolver<Maybe<Array<ResolversTypes['gh_StatusContextStateCount']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StatusCheckRollupContextEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StatusCheckRollupContextEdge'] = ResolversParentTypes['gh_StatusCheckRollupContextEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_StatusCheckRollupContext']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StatusContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StatusContext'] = ResolversParentTypes['gh_StatusContext']> = ResolversObject<{
  avatarUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType, RequireFields<gh_StatusContextavatarUrlArgs, 'size'>>;
  commit?: Resolver<Maybe<ResolversTypes['gh_Commit']>, ParentType, ContextType>;
  context?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<gh_StatusContextisRequiredArgs>>;
  state?: Resolver<ResolversTypes['gh_StatusState'], ParentType, ContextType>;
  targetUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StatusContextStateCountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StatusContextStateCount'] = ResolversParentTypes['gh_StatusContextStateCount']> = ResolversObject<{
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_StatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_StripeConnectAccountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_StripeConnectAccount'] = ResolversParentTypes['gh_StripeConnectAccount']> = ResolversObject<{
  accountId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  billingCountryOrRegion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  countryOrRegion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sponsorsListing?: Resolver<ResolversTypes['gh_SponsorsListing'], ParentType, ContextType>;
  stripeDashboardUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SubmitPullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SubmitPullRequestReviewPayload'] = ResolversParentTypes['gh_SubmitPullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['gh_PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SubmoduleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Submodule'] = ResolversParentTypes['gh_Submodule']> = ResolversObject<{
  branch?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gitUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameRaw?: Resolver<ResolversTypes['gh_Base64String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pathRaw?: Resolver<ResolversTypes['gh_Base64String'], ParentType, ContextType>;
  subprojectCommitOid?: Resolver<Maybe<ResolversTypes['gh_GitObjectID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SubmoduleConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SubmoduleConnection'] = ResolversParentTypes['gh_SubmoduleConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_SubmoduleEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Submodule']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SubmoduleEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SubmoduleEdge'] = ResolversParentTypes['gh_SubmoduleEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Submodule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SubscribableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Subscribable'] = ResolversParentTypes['gh_Subscribable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Commit' | 'gh_Discussion' | 'gh_Issue' | 'gh_PullRequest' | 'gh_Repository' | 'gh_Team' | 'gh_TeamDiscussion', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['gh_SubscriptionState']>, ParentType, ContextType>;
}>;

export type gh_SubscribableThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SubscribableThread'] = ResolversParentTypes['gh_SubscribableThread']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Issue', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  viewerThreadSubscriptionFormAction?: Resolver<Maybe<ResolversTypes['gh_ThreadSubscriptionFormAction']>, ParentType, ContextType>;
  viewerThreadSubscriptionStatus?: Resolver<Maybe<ResolversTypes['gh_ThreadSubscriptionState']>, ParentType, ContextType>;
}>;

export type gh_SubscribedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SubscribedEvent'] = ResolversParentTypes['gh_SubscribedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  subscribable?: Resolver<ResolversTypes['gh_Subscribable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_SuggestedReviewerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_SuggestedReviewer'] = ResolversParentTypes['gh_SuggestedReviewer']> = ResolversObject<{
  isAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isCommenter?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  reviewer?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TagResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Tag'] = ResolversParentTypes['gh_Tag']> = ResolversObject<{
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['gh_GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  tagger?: Resolver<Maybe<ResolversTypes['gh_GitActor']>, ParentType, ContextType>;
  target?: Resolver<ResolversTypes['gh_GitObject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TagNamePatternParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TagNamePatternParameters'] = ResolversParentTypes['gh_TagNamePatternParameters']> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  negate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Team'] = ResolversParentTypes['gh_Team']> = ResolversObject<{
  ancestors?: Resolver<ResolversTypes['gh_TeamConnection'], ParentType, ContextType, Partial<gh_TeamancestorsArgs>>;
  avatarUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType, RequireFields<gh_TeamavatarUrlArgs, 'size'>>;
  childTeams?: Resolver<ResolversTypes['gh_TeamConnection'], ParentType, ContextType, RequireFields<gh_TeamchildTeamsArgs, 'immediateOnly'>>;
  combinedSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['gh_TeamDiscussion']>, ParentType, ContextType, RequireFields<gh_TeamdiscussionArgs, 'number'>>;
  discussions?: Resolver<ResolversTypes['gh_TeamDiscussionConnection'], ParentType, ContextType, Partial<gh_TeamdiscussionsArgs>>;
  discussionsResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  discussionsUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  editTeamResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  editTeamUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitations?: Resolver<Maybe<ResolversTypes['gh_OrganizationInvitationConnection']>, ParentType, ContextType, Partial<gh_TeaminvitationsArgs>>;
  memberStatuses?: Resolver<ResolversTypes['gh_UserStatusConnection'], ParentType, ContextType, RequireFields<gh_TeammemberStatusesArgs, 'orderBy'>>;
  members?: Resolver<ResolversTypes['gh_TeamMemberConnection'], ParentType, ContextType, RequireFields<gh_TeammembersArgs, 'membership'>>;
  membersResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  membersUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  newTeamResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  newTeamUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  notificationSetting?: Resolver<ResolversTypes['gh_TeamNotificationSetting'], ParentType, ContextType>;
  organization?: Resolver<ResolversTypes['gh_Organization'], ParentType, ContextType>;
  parentTeam?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  privacy?: Resolver<ResolversTypes['gh_TeamPrivacy'], ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType, RequireFields<gh_TeamprojectV2Args, 'number'>>;
  projectsV2?: Resolver<ResolversTypes['gh_ProjectV2Connection'], ParentType, ContextType, RequireFields<gh_TeamprojectsV2Args, 'filterBy' | 'orderBy' | 'query'>>;
  repositories?: Resolver<ResolversTypes['gh_TeamRepositoryConnection'], ParentType, ContextType, Partial<gh_TeamrepositoriesArgs>>;
  repositoriesResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  repositoriesUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  reviewRequestDelegationAlgorithm?: Resolver<Maybe<ResolversTypes['gh_TeamReviewAssignmentAlgorithm']>, ParentType, ContextType>;
  reviewRequestDelegationEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  reviewRequestDelegationMemberCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewRequestDelegationNotifyTeam?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  teamsResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  teamsUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['gh_SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamAddMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamAddMemberAuditEntry'] = ResolversParentTypes['gh_TeamAddMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamAddRepositoryAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamAddRepositoryAuditEntry'] = ResolversParentTypes['gh_TeamAddRepositoryAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamAuditEntryData'] = ResolversParentTypes['gh_TeamAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_OrgRestoreMemberMembershipTeamAuditEntryData' | 'gh_TeamAddMemberAuditEntry' | 'gh_TeamAddRepositoryAuditEntry' | 'gh_TeamChangeParentTeamAuditEntry' | 'gh_TeamRemoveMemberAuditEntry' | 'gh_TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
}>;

export type gh_TeamChangeParentTeamAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamChangeParentTeamAuditEntry'] = ResolversParentTypes['gh_TeamChangeParentTeamAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  parentTeam?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  parentTeamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parentTeamNameWas?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parentTeamResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  parentTeamUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  parentTeamWas?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  parentTeamWasResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  parentTeamWasUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamConnection'] = ResolversParentTypes['gh_TeamConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_TeamEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Team']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamDiscussionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamDiscussion'] = ResolversParentTypes['gh_TeamDiscussion']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['gh_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyVersion?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['gh_TeamDiscussionCommentConnection'], ParentType, ContextType, Partial<gh_TeamDiscussioncommentsArgs>>;
  commentsResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  commentsUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPinned?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['gh_ReactionConnection'], ParentType, ContextType, Partial<gh_TeamDiscussionreactionsArgs>>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  team?: Resolver<ResolversTypes['gh_Team'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['gh_UserContentEditConnection']>, ParentType, ContextType, Partial<gh_TeamDiscussionuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanPin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['gh_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['gh_SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamDiscussionCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamDiscussionComment'] = ResolversParentTypes['gh_TeamDiscussionComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['gh_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyVersion?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  discussion?: Resolver<ResolversTypes['gh_TeamDiscussion'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['gh_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['gh_ReactionConnection'], ParentType, ContextType, Partial<gh_TeamDiscussionCommentreactionsArgs>>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['gh_UserContentEditConnection']>, ParentType, ContextType, Partial<gh_TeamDiscussionCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['gh_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamDiscussionCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamDiscussionCommentConnection'] = ResolversParentTypes['gh_TeamDiscussionCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_TeamDiscussionCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_TeamDiscussionComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamDiscussionCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamDiscussionCommentEdge'] = ResolversParentTypes['gh_TeamDiscussionCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_TeamDiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamDiscussionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamDiscussionConnection'] = ResolversParentTypes['gh_TeamDiscussionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_TeamDiscussionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_TeamDiscussion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamDiscussionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamDiscussionEdge'] = ResolversParentTypes['gh_TeamDiscussionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_TeamDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamEdge'] = ResolversParentTypes['gh_TeamEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamMemberConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamMemberConnection'] = ResolversParentTypes['gh_TeamMemberConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_TeamMemberEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamMemberEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamMemberEdge'] = ResolversParentTypes['gh_TeamMemberEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  memberAccessResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  memberAccessUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['gh_TeamMemberRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamRemoveMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamRemoveMemberAuditEntry'] = ResolversParentTypes['gh_TeamRemoveMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamRemoveRepositoryAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamRemoveRepositoryAuditEntry'] = ResolversParentTypes['gh_TeamRemoveRepositoryAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['gh_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['gh_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['gh_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['gh_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamRepositoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamRepositoryConnection'] = ResolversParentTypes['gh_TeamRepositoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_TeamRepositoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_Repository']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TeamRepositoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TeamRepositoryEdge'] = ResolversParentTypes['gh_TeamRepositoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  permission?: Resolver<ResolversTypes['gh_RepositoryPermission'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TextMatchResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TextMatch'] = ResolversParentTypes['gh_TextMatch']> = ResolversObject<{
  fragment?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  highlights?: Resolver<Array<ResolversTypes['gh_TextMatchHighlight']>, ParentType, ContextType>;
  property?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TextMatchHighlightResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TextMatchHighlight'] = ResolversParentTypes['gh_TextMatchHighlight']> = ResolversObject<{
  beginIndice?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  endIndice?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  text?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TopicResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Topic'] = ResolversParentTypes['gh_Topic']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  relatedTopics?: Resolver<Array<ResolversTypes['gh_Topic']>, ParentType, ContextType, RequireFields<gh_TopicrelatedTopicsArgs, 'first'>>;
  repositories?: Resolver<ResolversTypes['gh_RepositoryConnection'], ParentType, ContextType, RequireFields<gh_TopicrepositoriesArgs, 'ownerAffiliations' | 'sponsorableOnly'>>;
  stargazerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stargazers?: Resolver<ResolversTypes['gh_StargazerConnection'], ParentType, ContextType, Partial<gh_TopicstargazersArgs>>;
  viewerHasStarred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TopicAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TopicAuditEntryData'] = ResolversParentTypes['gh_TopicAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_RepoAddTopicAuditEntry' | 'gh_RepoRemoveTopicAuditEntry', ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['gh_Topic']>, ParentType, ContextType>;
  topicName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
}>;

export type gh_TransferEnterpriseOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TransferEnterpriseOrganizationPayload'] = ResolversParentTypes['gh_TransferEnterpriseOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TransferIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TransferIssuePayload'] = ResolversParentTypes['gh_TransferIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['gh_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TransferredEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TransferredEvent'] = ResolversParentTypes['gh_TransferredEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  fromRepository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['gh_Issue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TreeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Tree'] = ResolversParentTypes['gh_Tree']> = ResolversObject<{
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  entries?: Resolver<Maybe<Array<ResolversTypes['gh_TreeEntry']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['gh_GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_TreeEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_TreeEntry'] = ResolversParentTypes['gh_TreeEntry']> = ResolversObject<{
  extension?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isGenerated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  language?: Resolver<Maybe<ResolversTypes['gh_Language']>, ParentType, ContextType>;
  lineCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  mode?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameRaw?: Resolver<ResolversTypes['gh_Base64String'], ParentType, ContextType>;
  object?: Resolver<Maybe<ResolversTypes['gh_GitObject']>, ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['gh_GitObjectID'], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pathRaw?: Resolver<Maybe<ResolversTypes['gh_Base64String']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['gh_Repository'], ParentType, ContextType>;
  size?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  submodule?: Resolver<Maybe<ResolversTypes['gh_Submodule']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface gh_URIScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['gh_URI'], any> {
  name: 'gh_URI';
}

export type gh_UnarchiveProjectV2ItemPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnarchiveProjectV2ItemPayload'] = ResolversParentTypes['gh_UnarchiveProjectV2ItemPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['gh_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnarchiveRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnarchiveRepositoryPayload'] = ResolversParentTypes['gh_UnarchiveRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnassignedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnassignedEvent'] = ResolversParentTypes['gh_UnassignedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  assignable?: Resolver<ResolversTypes['gh_Assignable'], ParentType, ContextType>;
  assignee?: Resolver<Maybe<ResolversTypes['gh_Assignee']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnfollowOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnfollowOrganizationPayload'] = ResolversParentTypes['gh_UnfollowOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnfollowUserPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnfollowUserPayload'] = ResolversParentTypes['gh_UnfollowUserPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UniformResourceLocatableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UniformResourceLocatable'] = ResolversParentTypes['gh_UniformResourceLocatable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Bot' | 'gh_CheckRun' | 'gh_ClosedEvent' | 'gh_Commit' | 'gh_ConvertToDraftEvent' | 'gh_CrossReferencedEvent' | 'gh_Gist' | 'gh_Issue' | 'gh_Mannequin' | 'gh_MergedEvent' | 'gh_Milestone' | 'gh_Organization' | 'gh_PullRequest' | 'gh_PullRequestCommit' | 'gh_ReadyForReviewEvent' | 'gh_Release' | 'gh_Repository' | 'gh_RepositoryTopic' | 'gh_ReviewDismissedEvent' | 'gh_TeamDiscussion' | 'gh_TeamDiscussionComment' | 'gh_User' | 'gh_Workflow' | 'gh_WorkflowRun' | 'gh_WorkflowRunFile', ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
}>;

export type gh_UnknownSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnknownSignature'] = ResolversParentTypes['gh_UnknownSignature']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['gh_GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnlabeledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnlabeledEvent'] = ResolversParentTypes['gh_UnlabeledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['gh_Label'], ParentType, ContextType>;
  labelable?: Resolver<ResolversTypes['gh_Labelable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnlinkProjectV2FromRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnlinkProjectV2FromRepositoryPayload'] = ResolversParentTypes['gh_UnlinkProjectV2FromRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnlinkProjectV2FromTeamPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnlinkProjectV2FromTeamPayload'] = ResolversParentTypes['gh_UnlinkProjectV2FromTeamPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnlinkRepositoryFromProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnlinkRepositoryFromProjectPayload'] = ResolversParentTypes['gh_UnlinkRepositoryFromProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnlockLockablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnlockLockablePayload'] = ResolversParentTypes['gh_UnlockLockablePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unlockedRecord?: Resolver<Maybe<ResolversTypes['gh_Lockable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnlockedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnlockedEvent'] = ResolversParentTypes['gh_UnlockedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lockable?: Resolver<ResolversTypes['gh_Lockable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnmarkDiscussionCommentAsAnswerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnmarkDiscussionCommentAsAnswerPayload'] = ResolversParentTypes['gh_UnmarkDiscussionCommentAsAnswerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['gh_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnmarkFileAsViewedPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnmarkFileAsViewedPayload'] = ResolversParentTypes['gh_UnmarkFileAsViewedPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnmarkIssueAsDuplicatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnmarkIssueAsDuplicatePayload'] = ResolversParentTypes['gh_UnmarkIssueAsDuplicatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  duplicate?: Resolver<Maybe<ResolversTypes['gh_IssueOrPullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnmarkProjectV2AsTemplatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnmarkProjectV2AsTemplatePayload'] = ResolversParentTypes['gh_UnmarkProjectV2AsTemplatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnmarkedAsDuplicateEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnmarkedAsDuplicateEvent'] = ResolversParentTypes['gh_UnmarkedAsDuplicateEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  canonical?: Resolver<Maybe<ResolversTypes['gh_IssueOrPullRequest']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  duplicate?: Resolver<Maybe<ResolversTypes['gh_IssueOrPullRequest']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnminimizeCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnminimizeCommentPayload'] = ResolversParentTypes['gh_UnminimizeCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unminimizedComment?: Resolver<Maybe<ResolversTypes['gh_Minimizable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnpinIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnpinIssuePayload'] = ResolversParentTypes['gh_UnpinIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['gh_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnpinnedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnpinnedEvent'] = ResolversParentTypes['gh_UnpinnedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['gh_Issue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnresolveReviewThreadPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnresolveReviewThreadPayload'] = ResolversParentTypes['gh_UnresolveReviewThreadPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  thread?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnsubscribeFromNotificationsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnsubscribeFromNotificationsPayload'] = ResolversParentTypes['gh_UnsubscribeFromNotificationsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UnsubscribedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UnsubscribedEvent'] = ResolversParentTypes['gh_UnsubscribedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  subscribable?: Resolver<ResolversTypes['gh_Subscribable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdatableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Updatable'] = ResolversParentTypes['gh_Updatable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_CommitComment' | 'gh_Discussion' | 'gh_DiscussionComment' | 'gh_GistComment' | 'gh_Issue' | 'gh_IssueComment' | 'gh_Project' | 'gh_ProjectV2' | 'gh_PullRequest' | 'gh_PullRequestReview' | 'gh_PullRequestReviewComment' | 'gh_TeamDiscussion' | 'gh_TeamDiscussionComment', ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type gh_UpdatableCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdatableComment'] = ResolversParentTypes['gh_UpdatableComment']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_CommitComment' | 'gh_DiscussionComment' | 'gh_GistComment' | 'gh_Issue' | 'gh_IssueComment' | 'gh_PullRequest' | 'gh_PullRequestReview' | 'gh_PullRequestReviewComment' | 'gh_TeamDiscussion' | 'gh_TeamDiscussionComment', ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['gh_CommentCannotUpdateReason']>, ParentType, ContextType>;
}>;

export type gh_UpdateBranchProtectionRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateBranchProtectionRulePayload'] = ResolversParentTypes['gh_UpdateBranchProtectionRulePayload']> = ResolversObject<{
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['gh_BranchProtectionRule']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateCheckRunPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateCheckRunPayload'] = ResolversParentTypes['gh_UpdateCheckRunPayload']> = ResolversObject<{
  checkRun?: Resolver<Maybe<ResolversTypes['gh_CheckRun']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateCheckSuitePreferencesPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateCheckSuitePreferencesPayload'] = ResolversParentTypes['gh_UpdateCheckSuitePreferencesPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateDiscussionCommentPayload'] = ResolversParentTypes['gh_UpdateDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['gh_DiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateDiscussionPayload'] = ResolversParentTypes['gh_UpdateDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['gh_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseAdministratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseAdministratorRolePayload'] = ResolversParentTypes['gh_UpdateEnterpriseAdministratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseMembersCanMakePurchasesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseMembersCanMakePurchasesSettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseMembersCanMakePurchasesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseOrganizationProjectsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseOrganizationProjectsSettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseOrganizationProjectsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseOwnerOrganizationRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseOwnerOrganizationRolePayload'] = ResolversParentTypes['gh_UpdateEnterpriseOwnerOrganizationRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseProfilePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseProfilePayload'] = ResolversParentTypes['gh_UpdateEnterpriseProfilePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseRepositoryProjectsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseRepositoryProjectsSettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseRepositoryProjectsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseTeamDiscussionsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseTeamDiscussionsSettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseTeamDiscussionsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload'] = ResolversParentTypes['gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateEnvironmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateEnvironmentPayload'] = ResolversParentTypes['gh_UpdateEnvironmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['gh_Environment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateIpAllowListEnabledSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateIpAllowListEnabledSettingPayload'] = ResolversParentTypes['gh_UpdateIpAllowListEnabledSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['gh_IpAllowListOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateIpAllowListEntryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateIpAllowListEntryPayload'] = ResolversParentTypes['gh_UpdateIpAllowListEntryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ipAllowListEntry?: Resolver<Maybe<ResolversTypes['gh_IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateIpAllowListForInstalledAppsEnabledSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateIpAllowListForInstalledAppsEnabledSettingPayload'] = ResolversParentTypes['gh_UpdateIpAllowListForInstalledAppsEnabledSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['gh_IpAllowListOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateIssueCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateIssueCommentPayload'] = ResolversParentTypes['gh_UpdateIssueCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issueComment?: Resolver<Maybe<ResolversTypes['gh_IssueComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateIssuePayload'] = ResolversParentTypes['gh_UpdateIssuePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['gh_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateLabelPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateLabelPayload'] = ResolversParentTypes['gh_UpdateLabelPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['gh_Label']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateNotificationRestrictionSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateNotificationRestrictionSettingPayload'] = ResolversParentTypes['gh_UpdateNotificationRestrictionSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['gh_VerifiableDomainOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload'] = ResolversParentTypes['gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateOrganizationWebCommitSignoffSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateOrganizationWebCommitSignoffSettingPayload'] = ResolversParentTypes['gh_UpdateOrganizationWebCommitSignoffSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateParameters'] = ResolversParentTypes['gh_UpdateParameters']> = ResolversObject<{
  updateAllowsFetchAndMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdatePatreonSponsorabilityPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdatePatreonSponsorabilityPayload'] = ResolversParentTypes['gh_UpdatePatreonSponsorabilityPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['gh_SponsorsListing']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateProjectCardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateProjectCardPayload'] = ResolversParentTypes['gh_UpdateProjectCardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['gh_ProjectCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateProjectColumnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateProjectColumnPayload'] = ResolversParentTypes['gh_UpdateProjectColumnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectColumn?: Resolver<Maybe<ResolversTypes['gh_ProjectColumn']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateProjectPayload'] = ResolversParentTypes['gh_UpdateProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateProjectV2CollaboratorsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateProjectV2CollaboratorsPayload'] = ResolversParentTypes['gh_UpdateProjectV2CollaboratorsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collaborators?: Resolver<Maybe<ResolversTypes['gh_ProjectV2ActorConnection']>, ParentType, ContextType, Partial<gh_UpdateProjectV2CollaboratorsPayloadcollaboratorsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateProjectV2DraftIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateProjectV2DraftIssuePayload'] = ResolversParentTypes['gh_UpdateProjectV2DraftIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  draftIssue?: Resolver<Maybe<ResolversTypes['gh_DraftIssue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateProjectV2ItemFieldValuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateProjectV2ItemFieldValuePayload'] = ResolversParentTypes['gh_UpdateProjectV2ItemFieldValuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2Item?: Resolver<Maybe<ResolversTypes['gh_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateProjectV2ItemPositionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateProjectV2ItemPositionPayload'] = ResolversParentTypes['gh_UpdateProjectV2ItemPositionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  items?: Resolver<Maybe<ResolversTypes['gh_ProjectV2ItemConnection']>, ParentType, ContextType, Partial<gh_UpdateProjectV2ItemPositionPayloaditemsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateProjectV2PayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateProjectV2Payload'] = ResolversParentTypes['gh_UpdateProjectV2Payload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdatePullRequestBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdatePullRequestBranchPayload'] = ResolversParentTypes['gh_UpdatePullRequestBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdatePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdatePullRequestPayload'] = ResolversParentTypes['gh_UpdatePullRequestPayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['gh_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdatePullRequestReviewCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdatePullRequestReviewCommentPayload'] = ResolversParentTypes['gh_UpdatePullRequestReviewCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReviewComment?: Resolver<Maybe<ResolversTypes['gh_PullRequestReviewComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdatePullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdatePullRequestReviewPayload'] = ResolversParentTypes['gh_UpdatePullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['gh_PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateRefPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateRefPayload'] = ResolversParentTypes['gh_UpdateRefPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['gh_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateRefsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateRefsPayload'] = ResolversParentTypes['gh_UpdateRefsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateRepositoryPayload'] = ResolversParentTypes['gh_UpdateRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateRepositoryRulesetPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateRepositoryRulesetPayload'] = ResolversParentTypes['gh_UpdateRepositoryRulesetPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ruleset?: Resolver<Maybe<ResolversTypes['gh_RepositoryRuleset']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateRepositoryWebCommitSignoffSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateRepositoryWebCommitSignoffSettingPayload'] = ResolversParentTypes['gh_UpdateRepositoryWebCommitSignoffSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateSponsorshipPreferencesPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateSponsorshipPreferencesPayload'] = ResolversParentTypes['gh_UpdateSponsorshipPreferencesPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorship?: Resolver<Maybe<ResolversTypes['gh_Sponsorship']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateSubscriptionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateSubscriptionPayload'] = ResolversParentTypes['gh_UpdateSubscriptionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subscribable?: Resolver<Maybe<ResolversTypes['gh_Subscribable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateTeamDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateTeamDiscussionCommentPayload'] = ResolversParentTypes['gh_UpdateTeamDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussionComment?: Resolver<Maybe<ResolversTypes['gh_TeamDiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateTeamDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateTeamDiscussionPayload'] = ResolversParentTypes['gh_UpdateTeamDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussion?: Resolver<Maybe<ResolversTypes['gh_TeamDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateTeamReviewAssignmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateTeamReviewAssignmentPayload'] = ResolversParentTypes['gh_UpdateTeamReviewAssignmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['gh_Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateTeamsRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateTeamsRepositoryPayload'] = ResolversParentTypes['gh_UpdateTeamsRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  teams?: Resolver<Maybe<Array<ResolversTypes['gh_Team']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateTopicsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateTopicsPayload'] = ResolversParentTypes['gh_UpdateTopicsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invalidTopicNames?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateUserListPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateUserListPayload'] = ResolversParentTypes['gh_UpdateUserListPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  list?: Resolver<Maybe<ResolversTypes['gh_UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UpdateUserListsForItemPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UpdateUserListsForItemPayload'] = ResolversParentTypes['gh_UpdateUserListsForItemPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['gh_UserListItems']>, ParentType, ContextType>;
  lists?: Resolver<Maybe<Array<ResolversTypes['gh_UserList']>>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_User'] = ResolversParentTypes['gh_User']> = ResolversObject<{
  anyPinnableItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<gh_UseranyPinnableItemsArgs>>;
  avatarUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType, Partial<gh_UseravatarUrlArgs>>;
  bio?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  bioHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  canReceiveOrganizationEmailsWhenNotificationsRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<gh_UsercanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs, 'login'>>;
  commitComments?: Resolver<ResolversTypes['gh_CommitCommentConnection'], ParentType, ContextType, Partial<gh_UsercommitCommentsArgs>>;
  company?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  companyHTML?: Resolver<ResolversTypes['gh_HTML'], ParentType, ContextType>;
  contributionsCollection?: Resolver<ResolversTypes['gh_ContributionsCollection'], ParentType, ContextType, Partial<gh_UsercontributionsCollectionArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  enterprises?: Resolver<Maybe<ResolversTypes['gh_EnterpriseConnection']>, ParentType, ContextType, RequireFields<gh_UserenterprisesArgs, 'membershipType' | 'orderBy'>>;
  estimatedNextSponsorsPayoutInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  followers?: Resolver<ResolversTypes['gh_FollowerConnection'], ParentType, ContextType, Partial<gh_UserfollowersArgs>>;
  following?: Resolver<ResolversTypes['gh_FollowingConnection'], ParentType, ContextType, Partial<gh_UserfollowingArgs>>;
  gist?: Resolver<Maybe<ResolversTypes['gh_Gist']>, ParentType, ContextType, RequireFields<gh_UsergistArgs, 'name'>>;
  gistComments?: Resolver<ResolversTypes['gh_GistCommentConnection'], ParentType, ContextType, Partial<gh_UsergistCommentsArgs>>;
  gists?: Resolver<ResolversTypes['gh_GistConnection'], ParentType, ContextType, Partial<gh_UsergistsArgs>>;
  hasSponsorsListing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hovercard?: Resolver<ResolversTypes['gh_Hovercard'], ParentType, ContextType, Partial<gh_UserhovercardArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  interactionAbility?: Resolver<Maybe<ResolversTypes['gh_RepositoryInteractionAbility']>, ParentType, ContextType>;
  isBountyHunter?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isCampusExpert?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDeveloperProgramMember?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isEmployee?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isFollowingViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isGitHubStar?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isHireable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSiteAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSponsoredBy?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<gh_UserisSponsoredByArgs, 'accountLogin'>>;
  isSponsoringViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issueComments?: Resolver<ResolversTypes['gh_IssueCommentConnection'], ParentType, ContextType, Partial<gh_UserissueCommentsArgs>>;
  issues?: Resolver<ResolversTypes['gh_IssueConnection'], ParentType, ContextType, Partial<gh_UserissuesArgs>>;
  itemShowcase?: Resolver<ResolversTypes['gh_ProfileItemShowcase'], ParentType, ContextType>;
  lists?: Resolver<ResolversTypes['gh_UserListConnection'], ParentType, ContextType, Partial<gh_UserlistsArgs>>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  monthlyEstimatedSponsorsIncomeInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType, RequireFields<gh_UserorganizationArgs, 'login'>>;
  organizationVerifiedDomainEmails?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType, RequireFields<gh_UserorganizationVerifiedDomainEmailsArgs, 'login'>>;
  organizations?: Resolver<ResolversTypes['gh_OrganizationConnection'], ParentType, ContextType, RequireFields<gh_UserorganizationsArgs, 'orderBy'>>;
  packages?: Resolver<ResolversTypes['gh_PackageConnection'], ParentType, ContextType, RequireFields<gh_UserpackagesArgs, 'orderBy'>>;
  pinnableItems?: Resolver<ResolversTypes['gh_PinnableItemConnection'], ParentType, ContextType, Partial<gh_UserpinnableItemsArgs>>;
  pinnedItems?: Resolver<ResolversTypes['gh_PinnableItemConnection'], ParentType, ContextType, Partial<gh_UserpinnedItemsArgs>>;
  pinnedItemsRemaining?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['gh_Project']>, ParentType, ContextType, RequireFields<gh_UserprojectArgs, 'number'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['gh_ProjectV2']>, ParentType, ContextType, RequireFields<gh_UserprojectV2Args, 'number'>>;
  projects?: Resolver<ResolversTypes['gh_ProjectConnection'], ParentType, ContextType, Partial<gh_UserprojectsArgs>>;
  projectsResourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  projectsV2?: Resolver<ResolversTypes['gh_ProjectV2Connection'], ParentType, ContextType, RequireFields<gh_UserprojectsV2Args, 'orderBy'>>;
  pronouns?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publicKeys?: Resolver<ResolversTypes['gh_PublicKeyConnection'], ParentType, ContextType, Partial<gh_UserpublicKeysArgs>>;
  pullRequests?: Resolver<ResolversTypes['gh_PullRequestConnection'], ParentType, ContextType, Partial<gh_UserpullRequestsArgs>>;
  recentProjects?: Resolver<ResolversTypes['gh_ProjectV2Connection'], ParentType, ContextType, Partial<gh_UserrecentProjectsArgs>>;
  repositories?: Resolver<ResolversTypes['gh_RepositoryConnection'], ParentType, ContextType, RequireFields<gh_UserrepositoriesArgs, 'ownerAffiliations'>>;
  repositoriesContributedTo?: Resolver<ResolversTypes['gh_RepositoryConnection'], ParentType, ContextType, Partial<gh_UserrepositoriesContributedToArgs>>;
  repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType, RequireFields<gh_UserrepositoryArgs, 'followRenames' | 'name'>>;
  repositoryDiscussionComments?: Resolver<ResolversTypes['gh_DiscussionCommentConnection'], ParentType, ContextType, RequireFields<gh_UserrepositoryDiscussionCommentsArgs, 'onlyAnswers'>>;
  repositoryDiscussions?: Resolver<ResolversTypes['gh_DiscussionConnection'], ParentType, ContextType, RequireFields<gh_UserrepositoryDiscussionsArgs, 'answered' | 'orderBy' | 'states'>>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  savedReplies?: Resolver<Maybe<ResolversTypes['gh_SavedReplyConnection']>, ParentType, ContextType, RequireFields<gh_UsersavedRepliesArgs, 'orderBy'>>;
  socialAccounts?: Resolver<ResolversTypes['gh_SocialAccountConnection'], ParentType, ContextType, Partial<gh_UsersocialAccountsArgs>>;
  sponsoring?: Resolver<ResolversTypes['gh_SponsorConnection'], ParentType, ContextType, RequireFields<gh_UsersponsoringArgs, 'orderBy'>>;
  sponsors?: Resolver<ResolversTypes['gh_SponsorConnection'], ParentType, ContextType, RequireFields<gh_UsersponsorsArgs, 'orderBy'>>;
  sponsorsActivities?: Resolver<ResolversTypes['gh_SponsorsActivityConnection'], ParentType, ContextType, RequireFields<gh_UsersponsorsActivitiesArgs, 'actions' | 'includeAsSponsor' | 'includePrivate' | 'orderBy' | 'period'>>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['gh_SponsorsListing']>, ParentType, ContextType>;
  sponsorshipForViewerAsSponsor?: Resolver<Maybe<ResolversTypes['gh_Sponsorship']>, ParentType, ContextType, RequireFields<gh_UsersponsorshipForViewerAsSponsorArgs, 'activeOnly'>>;
  sponsorshipForViewerAsSponsorable?: Resolver<Maybe<ResolversTypes['gh_Sponsorship']>, ParentType, ContextType, RequireFields<gh_UsersponsorshipForViewerAsSponsorableArgs, 'activeOnly'>>;
  sponsorshipNewsletters?: Resolver<ResolversTypes['gh_SponsorshipNewsletterConnection'], ParentType, ContextType, RequireFields<gh_UsersponsorshipNewslettersArgs, 'orderBy'>>;
  sponsorshipsAsMaintainer?: Resolver<ResolversTypes['gh_SponsorshipConnection'], ParentType, ContextType, RequireFields<gh_UsersponsorshipsAsMaintainerArgs, 'activeOnly' | 'includePrivate'>>;
  sponsorshipsAsSponsor?: Resolver<ResolversTypes['gh_SponsorshipConnection'], ParentType, ContextType, RequireFields<gh_UsersponsorshipsAsSponsorArgs, 'activeOnly'>>;
  starredRepositories?: Resolver<ResolversTypes['gh_StarredRepositoryConnection'], ParentType, ContextType, Partial<gh_UserstarredRepositoriesArgs>>;
  status?: Resolver<Maybe<ResolversTypes['gh_UserStatus']>, ParentType, ContextType>;
  suggestedListNames?: Resolver<Array<ResolversTypes['gh_UserListSuggestion']>, ParentType, ContextType>;
  topRepositories?: Resolver<ResolversTypes['gh_RepositoryConnection'], ParentType, ContextType, RequireFields<gh_UsertopRepositoriesArgs, 'orderBy'>>;
  totalSponsorshipAmountAsSponsorInCents?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<gh_UsertotalSponsorshipAmountAsSponsorInCentsArgs, 'sponsorableLogins'>>;
  twitterUsername?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  viewerCanChangePinnedItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanFollow?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSponsor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsFollowing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsSponsoring?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  watching?: Resolver<ResolversTypes['gh_RepositoryConnection'], ParentType, ContextType, RequireFields<gh_UserwatchingArgs, 'ownerAffiliations'>>;
  websiteUrl?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserBlockedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserBlockedEvent'] = ResolversParentTypes['gh_UserBlockedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  blockDuration?: Resolver<ResolversTypes['gh_UserBlockDuration'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserConnection'] = ResolversParentTypes['gh_UserConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_UserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserContentEditResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserContentEdit'] = ResolversParentTypes['gh_UserContentEdit']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  deletedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  deletedBy?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  diff?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['gh_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserContentEditConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserContentEditConnection'] = ResolversParentTypes['gh_UserContentEditConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_UserContentEditEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_UserContentEdit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserContentEditEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserContentEditEdge'] = ResolversParentTypes['gh_UserContentEditEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_UserContentEdit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserEdge'] = ResolversParentTypes['gh_UserEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserEmailMetadataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserEmailMetadata'] = ResolversParentTypes['gh_UserEmailMetadata']> = ResolversObject<{
  primary?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserListResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserList'] = ResolversParentTypes['gh_UserList']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  items?: Resolver<ResolversTypes['gh_UserListItemsConnection'], ParentType, ContextType, Partial<gh_UserListitemsArgs>>;
  lastAddedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserListConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserListConnection'] = ResolversParentTypes['gh_UserListConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_UserListEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_UserList']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserListEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserListEdge'] = ResolversParentTypes['gh_UserListEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserListItemsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserListItems'] = ResolversParentTypes['gh_UserListItems']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Repository', ParentType, ContextType>;
}>;

export type gh_UserListItemsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserListItemsConnection'] = ResolversParentTypes['gh_UserListItemsConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_UserListItemsEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_UserListItems']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserListItemsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserListItemsEdge'] = ResolversParentTypes['gh_UserListItemsEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_UserListItems']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserListSuggestionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserListSuggestion'] = ResolversParentTypes['gh_UserListSuggestion']> = ResolversObject<{
  id?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserStatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserStatus'] = ResolversParentTypes['gh_UserStatus']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  emoji?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emojiHTML?: Resolver<Maybe<ResolversTypes['gh_HTML']>, ParentType, ContextType>;
  expiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  indicatesLimitedAvailability?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserStatusConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserStatusConnection'] = ResolversParentTypes['gh_UserStatusConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_UserStatusEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_UserStatus']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_UserStatusEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_UserStatusEdge'] = ResolversParentTypes['gh_UserStatusEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_UserStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_VerifiableDomainResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_VerifiableDomain'] = ResolversParentTypes['gh_VerifiableDomain']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  dnsHostName?: Resolver<Maybe<ResolversTypes['gh_URI']>, ParentType, ContextType>;
  domain?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  hasFoundHostName?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasFoundVerificationToken?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isApproved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRequiredForPolicyEnforcement?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['gh_VerifiableDomainOwner'], ParentType, ContextType>;
  punycodeEncodedDomain?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  tokenExpirationTime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  verificationToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_VerifiableDomainConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_VerifiableDomainConnection'] = ResolversParentTypes['gh_VerifiableDomainConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_VerifiableDomainEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_VerifiableDomain']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_VerifiableDomainEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_VerifiableDomainEdge'] = ResolversParentTypes['gh_VerifiableDomainEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_VerifiableDomain']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_VerifiableDomainOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_VerifiableDomainOwner'] = ResolversParentTypes['gh_VerifiableDomainOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Enterprise' | 'gh_Organization', ParentType, ContextType>;
}>;

export type gh_VerifyVerifiableDomainPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_VerifyVerifiableDomainPayload'] = ResolversParentTypes['gh_VerifyVerifiableDomainPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domain?: Resolver<Maybe<ResolversTypes['gh_VerifiableDomain']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_ViewerHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_ViewerHovercardContext'] = ResolversParentTypes['gh_ViewerHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  viewer?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_VotableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Votable'] = ResolversParentTypes['gh_Votable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'gh_Discussion' | 'gh_DiscussionComment', ParentType, ContextType>;
  upvoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerCanUpvote?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasUpvoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type gh_WorkflowResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_Workflow'] = ResolversParentTypes['gh_Workflow']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  runs?: Resolver<ResolversTypes['gh_WorkflowRunConnection'], ParentType, ContextType, RequireFields<gh_WorkflowrunsArgs, 'orderBy'>>;
  state?: Resolver<ResolversTypes['gh_WorkflowState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_WorkflowFileReferenceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_WorkflowFileReference'] = ResolversParentTypes['gh_WorkflowFileReference']> = ResolversObject<{
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  sha?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_WorkflowRunResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_WorkflowRun'] = ResolversParentTypes['gh_WorkflowRun']> = ResolversObject<{
  checkSuite?: Resolver<ResolversTypes['gh_CheckSuite'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deploymentReviews?: Resolver<ResolversTypes['gh_DeploymentReviewConnection'], ParentType, ContextType, Partial<gh_WorkflowRundeploymentReviewsArgs>>;
  event?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['gh_WorkflowRunFile']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pendingDeploymentRequests?: Resolver<ResolversTypes['gh_DeploymentRequestConnection'], ParentType, ContextType, Partial<gh_WorkflowRunpendingDeploymentRequestsArgs>>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  runNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  workflow?: Resolver<ResolversTypes['gh_Workflow'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_WorkflowRunConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_WorkflowRunConnection'] = ResolversParentTypes['gh_WorkflowRunConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_WorkflowRunEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_WorkflowRun']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['gh_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_WorkflowRunEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_WorkflowRunEdge'] = ResolversParentTypes['gh_WorkflowRunEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['gh_WorkflowRun']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_WorkflowRunFileResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_WorkflowRunFile'] = ResolversParentTypes['gh_WorkflowRunFile']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  repositoryFileUrl?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  repositoryName?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  run?: Resolver<ResolversTypes['gh_WorkflowRun'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['gh_URI'], ParentType, ContextType>;
  viewerCanPushRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReadRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type gh_WorkflowsParametersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['gh_WorkflowsParameters'] = ResolversParentTypes['gh_WorkflowsParameters']> = ResolversObject<{
  workflows?: Resolver<Array<ResolversTypes['gh_WorkflowFileReference']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface gh_X509CertificateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['gh_X509Certificate'], any> {
  name: 'gh_X509Certificate';
}

export type GithubQueryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GithubQuery'] = ResolversParentTypes['GithubQuery']> = ResolversObject<{
  gh_codeOfConduct?: Resolver<Maybe<ResolversTypes['gh_CodeOfConduct']>, ParentType, ContextType, RequireFields<GithubQuerygh_codeOfConductArgs, 'key'>>;
  gh_codesOfConduct?: Resolver<Maybe<Array<Maybe<ResolversTypes['gh_CodeOfConduct']>>>, ParentType, ContextType>;
  gh_enterprise?: Resolver<Maybe<ResolversTypes['gh_Enterprise']>, ParentType, ContextType, RequireFields<GithubQuerygh_enterpriseArgs, 'slug'>>;
  gh_enterpriseAdministratorInvitation?: Resolver<Maybe<ResolversTypes['gh_EnterpriseAdministratorInvitation']>, ParentType, ContextType, RequireFields<GithubQuerygh_enterpriseAdministratorInvitationArgs, 'enterpriseSlug' | 'role' | 'userLogin'>>;
  gh_enterpriseAdministratorInvitationByToken?: Resolver<Maybe<ResolversTypes['gh_EnterpriseAdministratorInvitation']>, ParentType, ContextType, RequireFields<GithubQuerygh_enterpriseAdministratorInvitationByTokenArgs, 'invitationToken'>>;
  gh_license?: Resolver<Maybe<ResolversTypes['gh_License']>, ParentType, ContextType, RequireFields<GithubQuerygh_licenseArgs, 'key'>>;
  gh_licenses?: Resolver<Array<Maybe<ResolversTypes['gh_License']>>, ParentType, ContextType>;
  gh_marketplaceCategories?: Resolver<Array<ResolversTypes['gh_MarketplaceCategory']>, ParentType, ContextType, Partial<GithubQuerygh_marketplaceCategoriesArgs>>;
  gh_marketplaceCategory?: Resolver<Maybe<ResolversTypes['gh_MarketplaceCategory']>, ParentType, ContextType, RequireFields<GithubQuerygh_marketplaceCategoryArgs, 'slug'>>;
  gh_marketplaceListing?: Resolver<Maybe<ResolversTypes['gh_MarketplaceListing']>, ParentType, ContextType, RequireFields<GithubQuerygh_marketplaceListingArgs, 'slug'>>;
  gh_marketplaceListings?: Resolver<ResolversTypes['gh_MarketplaceListingConnection'], ParentType, ContextType, RequireFields<GithubQuerygh_marketplaceListingsArgs, 'primaryCategoryOnly' | 'withFreeTrialsOnly'>>;
  gh_meta?: Resolver<ResolversTypes['gh_GitHubMetadata'], ParentType, ContextType>;
  gh_node?: Resolver<Maybe<ResolversTypes['gh_Node']>, ParentType, ContextType, RequireFields<GithubQuerygh_nodeArgs, 'id'>>;
  gh_nodes?: Resolver<Array<Maybe<ResolversTypes['gh_Node']>>, ParentType, ContextType, RequireFields<GithubQuerygh_nodesArgs, 'ids'>>;
  gh_organization?: Resolver<Maybe<ResolversTypes['gh_Organization']>, ParentType, ContextType, RequireFields<GithubQuerygh_organizationArgs, 'login'>>;
  gh_rateLimit?: Resolver<Maybe<ResolversTypes['gh_RateLimit']>, ParentType, ContextType, RequireFields<GithubQuerygh_rateLimitArgs, 'dryRun'>>;
  gh_relay?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
  gh_repository?: Resolver<Maybe<ResolversTypes['gh_Repository']>, ParentType, ContextType, RequireFields<GithubQuerygh_repositoryArgs, 'followRenames' | 'name' | 'owner'>>;
  gh_repositoryOwner?: Resolver<Maybe<ResolversTypes['gh_RepositoryOwner']>, ParentType, ContextType, RequireFields<GithubQuerygh_repositoryOwnerArgs, 'login'>>;
  gh_resource?: Resolver<Maybe<ResolversTypes['gh_UniformResourceLocatable']>, ParentType, ContextType, RequireFields<GithubQuerygh_resourceArgs, 'url'>>;
  gh_search?: Resolver<ResolversTypes['gh_SearchResultItemConnection'], ParentType, ContextType, RequireFields<GithubQuerygh_searchArgs, 'query' | 'type'>>;
  gh_securityAdvisories?: Resolver<ResolversTypes['gh_SecurityAdvisoryConnection'], ParentType, ContextType, RequireFields<GithubQuerygh_securityAdvisoriesArgs, 'orderBy'>>;
  gh_securityAdvisory?: Resolver<Maybe<ResolversTypes['gh_SecurityAdvisory']>, ParentType, ContextType, RequireFields<GithubQuerygh_securityAdvisoryArgs, 'ghsaId'>>;
  gh_securityVulnerabilities?: Resolver<ResolversTypes['gh_SecurityVulnerabilityConnection'], ParentType, ContextType, RequireFields<GithubQuerygh_securityVulnerabilitiesArgs, 'orderBy'>>;
  gh_sponsorables?: Resolver<ResolversTypes['gh_SponsorableItemConnection'], ParentType, ContextType, RequireFields<GithubQuerygh_sponsorablesArgs, 'onlyDependencies' | 'orderBy'>>;
  gh_topic?: Resolver<Maybe<ResolversTypes['gh_Topic']>, ParentType, ContextType, RequireFields<GithubQuerygh_topicArgs, 'name'>>;
  gh_user?: Resolver<Maybe<ResolversTypes['gh_User']>, ParentType, ContextType, RequireFields<GithubQuerygh_userArgs, 'login'>>;
  gh_viewer?: Resolver<ResolversTypes['gh_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GithubMutationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GithubMutation'] = ResolversParentTypes['GithubMutation']> = ResolversObject<{
  gh_abortQueuedMigrations?: Resolver<Maybe<ResolversTypes['gh_AbortQueuedMigrationsPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_abortQueuedMigrationsArgs, 'input'>>;
  gh_abortRepositoryMigration?: Resolver<Maybe<ResolversTypes['gh_AbortRepositoryMigrationPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_abortRepositoryMigrationArgs, 'input'>>;
  gh_acceptEnterpriseAdministratorInvitation?: Resolver<Maybe<ResolversTypes['gh_AcceptEnterpriseAdministratorInvitationPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_acceptEnterpriseAdministratorInvitationArgs, 'input'>>;
  gh_acceptTopicSuggestion?: Resolver<Maybe<ResolversTypes['gh_AcceptTopicSuggestionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_acceptTopicSuggestionArgs, 'input'>>;
  gh_addAssigneesToAssignable?: Resolver<Maybe<ResolversTypes['gh_AddAssigneesToAssignablePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addAssigneesToAssignableArgs, 'input'>>;
  gh_addComment?: Resolver<Maybe<ResolversTypes['gh_AddCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addCommentArgs, 'input'>>;
  gh_addDiscussionComment?: Resolver<Maybe<ResolversTypes['gh_AddDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addDiscussionCommentArgs, 'input'>>;
  gh_addDiscussionPollVote?: Resolver<Maybe<ResolversTypes['gh_AddDiscussionPollVotePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addDiscussionPollVoteArgs, 'input'>>;
  gh_addEnterpriseOrganizationMember?: Resolver<Maybe<ResolversTypes['gh_AddEnterpriseOrganizationMemberPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addEnterpriseOrganizationMemberArgs, 'input'>>;
  gh_addEnterpriseSupportEntitlement?: Resolver<Maybe<ResolversTypes['gh_AddEnterpriseSupportEntitlementPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addEnterpriseSupportEntitlementArgs, 'input'>>;
  gh_addLabelsToLabelable?: Resolver<Maybe<ResolversTypes['gh_AddLabelsToLabelablePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addLabelsToLabelableArgs, 'input'>>;
  gh_addProjectCard?: Resolver<Maybe<ResolversTypes['gh_AddProjectCardPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addProjectCardArgs, 'input'>>;
  gh_addProjectColumn?: Resolver<Maybe<ResolversTypes['gh_AddProjectColumnPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addProjectColumnArgs, 'input'>>;
  gh_addProjectV2DraftIssue?: Resolver<Maybe<ResolversTypes['gh_AddProjectV2DraftIssuePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addProjectV2DraftIssueArgs, 'input'>>;
  gh_addProjectV2ItemById?: Resolver<Maybe<ResolversTypes['gh_AddProjectV2ItemByIdPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addProjectV2ItemByIdArgs, 'input'>>;
  gh_addPullRequestReview?: Resolver<Maybe<ResolversTypes['gh_AddPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addPullRequestReviewArgs, 'input'>>;
  gh_addPullRequestReviewComment?: Resolver<Maybe<ResolversTypes['gh_AddPullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addPullRequestReviewCommentArgs, 'input'>>;
  gh_addPullRequestReviewThread?: Resolver<Maybe<ResolversTypes['gh_AddPullRequestReviewThreadPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addPullRequestReviewThreadArgs, 'input'>>;
  gh_addPullRequestReviewThreadReply?: Resolver<Maybe<ResolversTypes['gh_AddPullRequestReviewThreadReplyPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addPullRequestReviewThreadReplyArgs, 'input'>>;
  gh_addReaction?: Resolver<Maybe<ResolversTypes['gh_AddReactionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addReactionArgs, 'input'>>;
  gh_addStar?: Resolver<Maybe<ResolversTypes['gh_AddStarPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addStarArgs, 'input'>>;
  gh_addUpvote?: Resolver<Maybe<ResolversTypes['gh_AddUpvotePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addUpvoteArgs, 'input'>>;
  gh_addVerifiableDomain?: Resolver<Maybe<ResolversTypes['gh_AddVerifiableDomainPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_addVerifiableDomainArgs, 'input'>>;
  gh_approveDeployments?: Resolver<Maybe<ResolversTypes['gh_ApproveDeploymentsPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_approveDeploymentsArgs, 'input'>>;
  gh_approveVerifiableDomain?: Resolver<Maybe<ResolversTypes['gh_ApproveVerifiableDomainPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_approveVerifiableDomainArgs, 'input'>>;
  gh_archiveProjectV2Item?: Resolver<Maybe<ResolversTypes['gh_ArchiveProjectV2ItemPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_archiveProjectV2ItemArgs, 'input'>>;
  gh_archiveRepository?: Resolver<Maybe<ResolversTypes['gh_ArchiveRepositoryPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_archiveRepositoryArgs, 'input'>>;
  gh_cancelEnterpriseAdminInvitation?: Resolver<Maybe<ResolversTypes['gh_CancelEnterpriseAdminInvitationPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_cancelEnterpriseAdminInvitationArgs, 'input'>>;
  gh_cancelSponsorship?: Resolver<Maybe<ResolversTypes['gh_CancelSponsorshipPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_cancelSponsorshipArgs, 'input'>>;
  gh_changeUserStatus?: Resolver<Maybe<ResolversTypes['gh_ChangeUserStatusPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_changeUserStatusArgs, 'input'>>;
  gh_clearLabelsFromLabelable?: Resolver<Maybe<ResolversTypes['gh_ClearLabelsFromLabelablePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_clearLabelsFromLabelableArgs, 'input'>>;
  gh_clearProjectV2ItemFieldValue?: Resolver<Maybe<ResolversTypes['gh_ClearProjectV2ItemFieldValuePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_clearProjectV2ItemFieldValueArgs, 'input'>>;
  gh_cloneProject?: Resolver<Maybe<ResolversTypes['gh_CloneProjectPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_cloneProjectArgs, 'input'>>;
  gh_cloneTemplateRepository?: Resolver<Maybe<ResolversTypes['gh_CloneTemplateRepositoryPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_cloneTemplateRepositoryArgs, 'input'>>;
  gh_closeDiscussion?: Resolver<Maybe<ResolversTypes['gh_CloseDiscussionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_closeDiscussionArgs, 'input'>>;
  gh_closeIssue?: Resolver<Maybe<ResolversTypes['gh_CloseIssuePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_closeIssueArgs, 'input'>>;
  gh_closePullRequest?: Resolver<Maybe<ResolversTypes['gh_ClosePullRequestPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_closePullRequestArgs, 'input'>>;
  gh_convertProjectCardNoteToIssue?: Resolver<Maybe<ResolversTypes['gh_ConvertProjectCardNoteToIssuePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_convertProjectCardNoteToIssueArgs, 'input'>>;
  gh_convertPullRequestToDraft?: Resolver<Maybe<ResolversTypes['gh_ConvertPullRequestToDraftPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_convertPullRequestToDraftArgs, 'input'>>;
  gh_copyProjectV2?: Resolver<Maybe<ResolversTypes['gh_CopyProjectV2Payload']>, ParentType, ContextType, RequireFields<GithubMutationgh_copyProjectV2Args, 'input'>>;
  gh_createAttributionInvitation?: Resolver<Maybe<ResolversTypes['gh_CreateAttributionInvitationPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createAttributionInvitationArgs, 'input'>>;
  gh_createBranchProtectionRule?: Resolver<Maybe<ResolversTypes['gh_CreateBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createBranchProtectionRuleArgs, 'input'>>;
  gh_createCheckRun?: Resolver<Maybe<ResolversTypes['gh_CreateCheckRunPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createCheckRunArgs, 'input'>>;
  gh_createCheckSuite?: Resolver<Maybe<ResolversTypes['gh_CreateCheckSuitePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createCheckSuiteArgs, 'input'>>;
  gh_createCommitOnBranch?: Resolver<Maybe<ResolversTypes['gh_CreateCommitOnBranchPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createCommitOnBranchArgs, 'input'>>;
  gh_createDeployment?: Resolver<Maybe<ResolversTypes['gh_CreateDeploymentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createDeploymentArgs, 'input'>>;
  gh_createDeploymentStatus?: Resolver<Maybe<ResolversTypes['gh_CreateDeploymentStatusPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createDeploymentStatusArgs, 'input'>>;
  gh_createDiscussion?: Resolver<Maybe<ResolversTypes['gh_CreateDiscussionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createDiscussionArgs, 'input'>>;
  gh_createEnterpriseOrganization?: Resolver<Maybe<ResolversTypes['gh_CreateEnterpriseOrganizationPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createEnterpriseOrganizationArgs, 'input'>>;
  gh_createEnvironment?: Resolver<Maybe<ResolversTypes['gh_CreateEnvironmentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createEnvironmentArgs, 'input'>>;
  gh_createIpAllowListEntry?: Resolver<Maybe<ResolversTypes['gh_CreateIpAllowListEntryPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createIpAllowListEntryArgs, 'input'>>;
  gh_createIssue?: Resolver<Maybe<ResolversTypes['gh_CreateIssuePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createIssueArgs, 'input'>>;
  gh_createLabel?: Resolver<Maybe<ResolversTypes['gh_CreateLabelPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createLabelArgs, 'input'>>;
  gh_createLinkedBranch?: Resolver<Maybe<ResolversTypes['gh_CreateLinkedBranchPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createLinkedBranchArgs, 'input'>>;
  gh_createMigrationSource?: Resolver<Maybe<ResolversTypes['gh_CreateMigrationSourcePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createMigrationSourceArgs, 'input'>>;
  gh_createProject?: Resolver<Maybe<ResolversTypes['gh_CreateProjectPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createProjectArgs, 'input'>>;
  gh_createProjectV2?: Resolver<Maybe<ResolversTypes['gh_CreateProjectV2Payload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createProjectV2Args, 'input'>>;
  gh_createProjectV2Field?: Resolver<Maybe<ResolversTypes['gh_CreateProjectV2FieldPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createProjectV2FieldArgs, 'input'>>;
  gh_createPullRequest?: Resolver<Maybe<ResolversTypes['gh_CreatePullRequestPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createPullRequestArgs, 'input'>>;
  gh_createRef?: Resolver<Maybe<ResolversTypes['gh_CreateRefPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createRefArgs, 'input'>>;
  gh_createRepository?: Resolver<Maybe<ResolversTypes['gh_CreateRepositoryPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createRepositoryArgs, 'input'>>;
  gh_createRepositoryRuleset?: Resolver<Maybe<ResolversTypes['gh_CreateRepositoryRulesetPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createRepositoryRulesetArgs, 'input'>>;
  gh_createSponsorsListing?: Resolver<Maybe<ResolversTypes['gh_CreateSponsorsListingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createSponsorsListingArgs, 'input'>>;
  gh_createSponsorsTier?: Resolver<Maybe<ResolversTypes['gh_CreateSponsorsTierPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createSponsorsTierArgs, 'input'>>;
  gh_createSponsorship?: Resolver<Maybe<ResolversTypes['gh_CreateSponsorshipPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createSponsorshipArgs, 'input'>>;
  gh_createSponsorships?: Resolver<Maybe<ResolversTypes['gh_CreateSponsorshipsPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createSponsorshipsArgs, 'input'>>;
  gh_createTeamDiscussion?: Resolver<Maybe<ResolversTypes['gh_CreateTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createTeamDiscussionArgs, 'input'>>;
  gh_createTeamDiscussionComment?: Resolver<Maybe<ResolversTypes['gh_CreateTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createTeamDiscussionCommentArgs, 'input'>>;
  gh_createUserList?: Resolver<Maybe<ResolversTypes['gh_CreateUserListPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_createUserListArgs, 'input'>>;
  gh_declineTopicSuggestion?: Resolver<Maybe<ResolversTypes['gh_DeclineTopicSuggestionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_declineTopicSuggestionArgs, 'input'>>;
  gh_deleteBranchProtectionRule?: Resolver<Maybe<ResolversTypes['gh_DeleteBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteBranchProtectionRuleArgs, 'input'>>;
  gh_deleteDeployment?: Resolver<Maybe<ResolversTypes['gh_DeleteDeploymentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteDeploymentArgs, 'input'>>;
  gh_deleteDiscussion?: Resolver<Maybe<ResolversTypes['gh_DeleteDiscussionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteDiscussionArgs, 'input'>>;
  gh_deleteDiscussionComment?: Resolver<Maybe<ResolversTypes['gh_DeleteDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteDiscussionCommentArgs, 'input'>>;
  gh_deleteEnvironment?: Resolver<Maybe<ResolversTypes['gh_DeleteEnvironmentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteEnvironmentArgs, 'input'>>;
  gh_deleteIpAllowListEntry?: Resolver<Maybe<ResolversTypes['gh_DeleteIpAllowListEntryPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteIpAllowListEntryArgs, 'input'>>;
  gh_deleteIssue?: Resolver<Maybe<ResolversTypes['gh_DeleteIssuePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteIssueArgs, 'input'>>;
  gh_deleteIssueComment?: Resolver<Maybe<ResolversTypes['gh_DeleteIssueCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteIssueCommentArgs, 'input'>>;
  gh_deleteLabel?: Resolver<Maybe<ResolversTypes['gh_DeleteLabelPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteLabelArgs, 'input'>>;
  gh_deleteLinkedBranch?: Resolver<Maybe<ResolversTypes['gh_DeleteLinkedBranchPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteLinkedBranchArgs, 'input'>>;
  gh_deletePackageVersion?: Resolver<Maybe<ResolversTypes['gh_DeletePackageVersionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deletePackageVersionArgs, 'input'>>;
  gh_deleteProject?: Resolver<Maybe<ResolversTypes['gh_DeleteProjectPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteProjectArgs, 'input'>>;
  gh_deleteProjectCard?: Resolver<Maybe<ResolversTypes['gh_DeleteProjectCardPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteProjectCardArgs, 'input'>>;
  gh_deleteProjectColumn?: Resolver<Maybe<ResolversTypes['gh_DeleteProjectColumnPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteProjectColumnArgs, 'input'>>;
  gh_deleteProjectV2?: Resolver<Maybe<ResolversTypes['gh_DeleteProjectV2Payload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteProjectV2Args, 'input'>>;
  gh_deleteProjectV2Field?: Resolver<Maybe<ResolversTypes['gh_DeleteProjectV2FieldPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteProjectV2FieldArgs, 'input'>>;
  gh_deleteProjectV2Item?: Resolver<Maybe<ResolversTypes['gh_DeleteProjectV2ItemPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteProjectV2ItemArgs, 'input'>>;
  gh_deleteProjectV2Workflow?: Resolver<Maybe<ResolversTypes['gh_DeleteProjectV2WorkflowPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteProjectV2WorkflowArgs, 'input'>>;
  gh_deletePullRequestReview?: Resolver<Maybe<ResolversTypes['gh_DeletePullRequestReviewPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deletePullRequestReviewArgs, 'input'>>;
  gh_deletePullRequestReviewComment?: Resolver<Maybe<ResolversTypes['gh_DeletePullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deletePullRequestReviewCommentArgs, 'input'>>;
  gh_deleteRef?: Resolver<Maybe<ResolversTypes['gh_DeleteRefPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteRefArgs, 'input'>>;
  gh_deleteRepositoryRuleset?: Resolver<Maybe<ResolversTypes['gh_DeleteRepositoryRulesetPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteRepositoryRulesetArgs, 'input'>>;
  gh_deleteTeamDiscussion?: Resolver<Maybe<ResolversTypes['gh_DeleteTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteTeamDiscussionArgs, 'input'>>;
  gh_deleteTeamDiscussionComment?: Resolver<Maybe<ResolversTypes['gh_DeleteTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteTeamDiscussionCommentArgs, 'input'>>;
  gh_deleteUserList?: Resolver<Maybe<ResolversTypes['gh_DeleteUserListPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteUserListArgs, 'input'>>;
  gh_deleteVerifiableDomain?: Resolver<Maybe<ResolversTypes['gh_DeleteVerifiableDomainPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_deleteVerifiableDomainArgs, 'input'>>;
  gh_dequeuePullRequest?: Resolver<Maybe<ResolversTypes['gh_DequeuePullRequestPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_dequeuePullRequestArgs, 'input'>>;
  gh_disablePullRequestAutoMerge?: Resolver<Maybe<ResolversTypes['gh_DisablePullRequestAutoMergePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_disablePullRequestAutoMergeArgs, 'input'>>;
  gh_dismissPullRequestReview?: Resolver<Maybe<ResolversTypes['gh_DismissPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_dismissPullRequestReviewArgs, 'input'>>;
  gh_dismissRepositoryVulnerabilityAlert?: Resolver<Maybe<ResolversTypes['gh_DismissRepositoryVulnerabilityAlertPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_dismissRepositoryVulnerabilityAlertArgs, 'input'>>;
  gh_enablePullRequestAutoMerge?: Resolver<Maybe<ResolversTypes['gh_EnablePullRequestAutoMergePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_enablePullRequestAutoMergeArgs, 'input'>>;
  gh_enqueuePullRequest?: Resolver<Maybe<ResolversTypes['gh_EnqueuePullRequestPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_enqueuePullRequestArgs, 'input'>>;
  gh_followOrganization?: Resolver<Maybe<ResolversTypes['gh_FollowOrganizationPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_followOrganizationArgs, 'input'>>;
  gh_followUser?: Resolver<Maybe<ResolversTypes['gh_FollowUserPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_followUserArgs, 'input'>>;
  gh_grantEnterpriseOrganizationsMigratorRole?: Resolver<Maybe<ResolversTypes['gh_GrantEnterpriseOrganizationsMigratorRolePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_grantEnterpriseOrganizationsMigratorRoleArgs, 'input'>>;
  gh_grantMigratorRole?: Resolver<Maybe<ResolversTypes['gh_GrantMigratorRolePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_grantMigratorRoleArgs, 'input'>>;
  gh_importProject?: Resolver<Maybe<ResolversTypes['gh_ImportProjectPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_importProjectArgs, 'input'>>;
  gh_inviteEnterpriseAdmin?: Resolver<Maybe<ResolversTypes['gh_InviteEnterpriseAdminPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_inviteEnterpriseAdminArgs, 'input'>>;
  gh_linkProjectV2ToRepository?: Resolver<Maybe<ResolversTypes['gh_LinkProjectV2ToRepositoryPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_linkProjectV2ToRepositoryArgs, 'input'>>;
  gh_linkProjectV2ToTeam?: Resolver<Maybe<ResolversTypes['gh_LinkProjectV2ToTeamPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_linkProjectV2ToTeamArgs, 'input'>>;
  gh_linkRepositoryToProject?: Resolver<Maybe<ResolversTypes['gh_LinkRepositoryToProjectPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_linkRepositoryToProjectArgs, 'input'>>;
  gh_lockLockable?: Resolver<Maybe<ResolversTypes['gh_LockLockablePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_lockLockableArgs, 'input'>>;
  gh_markDiscussionCommentAsAnswer?: Resolver<Maybe<ResolversTypes['gh_MarkDiscussionCommentAsAnswerPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_markDiscussionCommentAsAnswerArgs, 'input'>>;
  gh_markFileAsViewed?: Resolver<Maybe<ResolversTypes['gh_MarkFileAsViewedPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_markFileAsViewedArgs, 'input'>>;
  gh_markProjectV2AsTemplate?: Resolver<Maybe<ResolversTypes['gh_MarkProjectV2AsTemplatePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_markProjectV2AsTemplateArgs, 'input'>>;
  gh_markPullRequestReadyForReview?: Resolver<Maybe<ResolversTypes['gh_MarkPullRequestReadyForReviewPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_markPullRequestReadyForReviewArgs, 'input'>>;
  gh_mergeBranch?: Resolver<Maybe<ResolversTypes['gh_MergeBranchPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_mergeBranchArgs, 'input'>>;
  gh_mergePullRequest?: Resolver<Maybe<ResolversTypes['gh_MergePullRequestPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_mergePullRequestArgs, 'input'>>;
  gh_minimizeComment?: Resolver<Maybe<ResolversTypes['gh_MinimizeCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_minimizeCommentArgs, 'input'>>;
  gh_moveProjectCard?: Resolver<Maybe<ResolversTypes['gh_MoveProjectCardPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_moveProjectCardArgs, 'input'>>;
  gh_moveProjectColumn?: Resolver<Maybe<ResolversTypes['gh_MoveProjectColumnPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_moveProjectColumnArgs, 'input'>>;
  gh_pinIssue?: Resolver<Maybe<ResolversTypes['gh_PinIssuePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_pinIssueArgs, 'input'>>;
  gh_publishSponsorsTier?: Resolver<Maybe<ResolversTypes['gh_PublishSponsorsTierPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_publishSponsorsTierArgs, 'input'>>;
  gh_regenerateEnterpriseIdentityProviderRecoveryCodes?: Resolver<Maybe<ResolversTypes['gh_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_regenerateEnterpriseIdentityProviderRecoveryCodesArgs, 'input'>>;
  gh_regenerateVerifiableDomainToken?: Resolver<Maybe<ResolversTypes['gh_RegenerateVerifiableDomainTokenPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_regenerateVerifiableDomainTokenArgs, 'input'>>;
  gh_rejectDeployments?: Resolver<Maybe<ResolversTypes['gh_RejectDeploymentsPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_rejectDeploymentsArgs, 'input'>>;
  gh_removeAssigneesFromAssignable?: Resolver<Maybe<ResolversTypes['gh_RemoveAssigneesFromAssignablePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_removeAssigneesFromAssignableArgs, 'input'>>;
  gh_removeEnterpriseAdmin?: Resolver<Maybe<ResolversTypes['gh_RemoveEnterpriseAdminPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_removeEnterpriseAdminArgs, 'input'>>;
  gh_removeEnterpriseIdentityProvider?: Resolver<Maybe<ResolversTypes['gh_RemoveEnterpriseIdentityProviderPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_removeEnterpriseIdentityProviderArgs, 'input'>>;
  gh_removeEnterpriseMember?: Resolver<Maybe<ResolversTypes['gh_RemoveEnterpriseMemberPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_removeEnterpriseMemberArgs, 'input'>>;
  gh_removeEnterpriseOrganization?: Resolver<Maybe<ResolversTypes['gh_RemoveEnterpriseOrganizationPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_removeEnterpriseOrganizationArgs, 'input'>>;
  gh_removeEnterpriseSupportEntitlement?: Resolver<Maybe<ResolversTypes['gh_RemoveEnterpriseSupportEntitlementPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_removeEnterpriseSupportEntitlementArgs, 'input'>>;
  gh_removeLabelsFromLabelable?: Resolver<Maybe<ResolversTypes['gh_RemoveLabelsFromLabelablePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_removeLabelsFromLabelableArgs, 'input'>>;
  gh_removeOutsideCollaborator?: Resolver<Maybe<ResolversTypes['gh_RemoveOutsideCollaboratorPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_removeOutsideCollaboratorArgs, 'input'>>;
  gh_removeReaction?: Resolver<Maybe<ResolversTypes['gh_RemoveReactionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_removeReactionArgs, 'input'>>;
  gh_removeStar?: Resolver<Maybe<ResolversTypes['gh_RemoveStarPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_removeStarArgs, 'input'>>;
  gh_removeUpvote?: Resolver<Maybe<ResolversTypes['gh_RemoveUpvotePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_removeUpvoteArgs, 'input'>>;
  gh_reopenDiscussion?: Resolver<Maybe<ResolversTypes['gh_ReopenDiscussionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_reopenDiscussionArgs, 'input'>>;
  gh_reopenIssue?: Resolver<Maybe<ResolversTypes['gh_ReopenIssuePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_reopenIssueArgs, 'input'>>;
  gh_reopenPullRequest?: Resolver<Maybe<ResolversTypes['gh_ReopenPullRequestPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_reopenPullRequestArgs, 'input'>>;
  gh_requestReviews?: Resolver<Maybe<ResolversTypes['gh_RequestReviewsPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_requestReviewsArgs, 'input'>>;
  gh_rerequestCheckSuite?: Resolver<Maybe<ResolversTypes['gh_RerequestCheckSuitePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_rerequestCheckSuiteArgs, 'input'>>;
  gh_resolveReviewThread?: Resolver<Maybe<ResolversTypes['gh_ResolveReviewThreadPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_resolveReviewThreadArgs, 'input'>>;
  gh_retireSponsorsTier?: Resolver<Maybe<ResolversTypes['gh_RetireSponsorsTierPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_retireSponsorsTierArgs, 'input'>>;
  gh_revertPullRequest?: Resolver<Maybe<ResolversTypes['gh_RevertPullRequestPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_revertPullRequestArgs, 'input'>>;
  gh_revokeEnterpriseOrganizationsMigratorRole?: Resolver<Maybe<ResolversTypes['gh_RevokeEnterpriseOrganizationsMigratorRolePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_revokeEnterpriseOrganizationsMigratorRoleArgs, 'input'>>;
  gh_revokeMigratorRole?: Resolver<Maybe<ResolversTypes['gh_RevokeMigratorRolePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_revokeMigratorRoleArgs, 'input'>>;
  gh_setEnterpriseIdentityProvider?: Resolver<Maybe<ResolversTypes['gh_SetEnterpriseIdentityProviderPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_setEnterpriseIdentityProviderArgs, 'input'>>;
  gh_setOrganizationInteractionLimit?: Resolver<Maybe<ResolversTypes['gh_SetOrganizationInteractionLimitPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_setOrganizationInteractionLimitArgs, 'input'>>;
  gh_setRepositoryInteractionLimit?: Resolver<Maybe<ResolversTypes['gh_SetRepositoryInteractionLimitPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_setRepositoryInteractionLimitArgs, 'input'>>;
  gh_setUserInteractionLimit?: Resolver<Maybe<ResolversTypes['gh_SetUserInteractionLimitPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_setUserInteractionLimitArgs, 'input'>>;
  gh_startOrganizationMigration?: Resolver<Maybe<ResolversTypes['gh_StartOrganizationMigrationPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_startOrganizationMigrationArgs, 'input'>>;
  gh_startRepositoryMigration?: Resolver<Maybe<ResolversTypes['gh_StartRepositoryMigrationPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_startRepositoryMigrationArgs, 'input'>>;
  gh_submitPullRequestReview?: Resolver<Maybe<ResolversTypes['gh_SubmitPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_submitPullRequestReviewArgs, 'input'>>;
  gh_transferEnterpriseOrganization?: Resolver<Maybe<ResolversTypes['gh_TransferEnterpriseOrganizationPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_transferEnterpriseOrganizationArgs, 'input'>>;
  gh_transferIssue?: Resolver<Maybe<ResolversTypes['gh_TransferIssuePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_transferIssueArgs, 'input'>>;
  gh_unarchiveProjectV2Item?: Resolver<Maybe<ResolversTypes['gh_UnarchiveProjectV2ItemPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unarchiveProjectV2ItemArgs, 'input'>>;
  gh_unarchiveRepository?: Resolver<Maybe<ResolversTypes['gh_UnarchiveRepositoryPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unarchiveRepositoryArgs, 'input'>>;
  gh_unfollowOrganization?: Resolver<Maybe<ResolversTypes['gh_UnfollowOrganizationPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unfollowOrganizationArgs, 'input'>>;
  gh_unfollowUser?: Resolver<Maybe<ResolversTypes['gh_UnfollowUserPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unfollowUserArgs, 'input'>>;
  gh_unlinkProjectV2FromRepository?: Resolver<Maybe<ResolversTypes['gh_UnlinkProjectV2FromRepositoryPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unlinkProjectV2FromRepositoryArgs, 'input'>>;
  gh_unlinkProjectV2FromTeam?: Resolver<Maybe<ResolversTypes['gh_UnlinkProjectV2FromTeamPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unlinkProjectV2FromTeamArgs, 'input'>>;
  gh_unlinkRepositoryFromProject?: Resolver<Maybe<ResolversTypes['gh_UnlinkRepositoryFromProjectPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unlinkRepositoryFromProjectArgs, 'input'>>;
  gh_unlockLockable?: Resolver<Maybe<ResolversTypes['gh_UnlockLockablePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unlockLockableArgs, 'input'>>;
  gh_unmarkDiscussionCommentAsAnswer?: Resolver<Maybe<ResolversTypes['gh_UnmarkDiscussionCommentAsAnswerPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unmarkDiscussionCommentAsAnswerArgs, 'input'>>;
  gh_unmarkFileAsViewed?: Resolver<Maybe<ResolversTypes['gh_UnmarkFileAsViewedPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unmarkFileAsViewedArgs, 'input'>>;
  gh_unmarkIssueAsDuplicate?: Resolver<Maybe<ResolversTypes['gh_UnmarkIssueAsDuplicatePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unmarkIssueAsDuplicateArgs, 'input'>>;
  gh_unmarkProjectV2AsTemplate?: Resolver<Maybe<ResolversTypes['gh_UnmarkProjectV2AsTemplatePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unmarkProjectV2AsTemplateArgs, 'input'>>;
  gh_unminimizeComment?: Resolver<Maybe<ResolversTypes['gh_UnminimizeCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unminimizeCommentArgs, 'input'>>;
  gh_unpinIssue?: Resolver<Maybe<ResolversTypes['gh_UnpinIssuePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unpinIssueArgs, 'input'>>;
  gh_unresolveReviewThread?: Resolver<Maybe<ResolversTypes['gh_UnresolveReviewThreadPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unresolveReviewThreadArgs, 'input'>>;
  gh_unsubscribeFromNotifications?: Resolver<Maybe<ResolversTypes['gh_UnsubscribeFromNotificationsPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_unsubscribeFromNotificationsArgs, 'input'>>;
  gh_updateBranchProtectionRule?: Resolver<Maybe<ResolversTypes['gh_UpdateBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateBranchProtectionRuleArgs, 'input'>>;
  gh_updateCheckRun?: Resolver<Maybe<ResolversTypes['gh_UpdateCheckRunPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateCheckRunArgs, 'input'>>;
  gh_updateCheckSuitePreferences?: Resolver<Maybe<ResolversTypes['gh_UpdateCheckSuitePreferencesPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateCheckSuitePreferencesArgs, 'input'>>;
  gh_updateDiscussion?: Resolver<Maybe<ResolversTypes['gh_UpdateDiscussionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateDiscussionArgs, 'input'>>;
  gh_updateDiscussionComment?: Resolver<Maybe<ResolversTypes['gh_UpdateDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateDiscussionCommentArgs, 'input'>>;
  gh_updateEnterpriseAdministratorRole?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseAdministratorRolePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseAdministratorRoleArgs, 'input'>>;
  gh_updateEnterpriseAllowPrivateRepositoryForkingSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseAllowPrivateRepositoryForkingSettingArgs, 'input'>>;
  gh_updateEnterpriseDefaultRepositoryPermissionSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseDefaultRepositoryPermissionSettingArgs, 'input'>>;
  gh_updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs, 'input'>>;
  gh_updateEnterpriseMembersCanCreateRepositoriesSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseMembersCanCreateRepositoriesSettingArgs, 'input'>>;
  gh_updateEnterpriseMembersCanDeleteIssuesSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseMembersCanDeleteIssuesSettingArgs, 'input'>>;
  gh_updateEnterpriseMembersCanDeleteRepositoriesSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseMembersCanDeleteRepositoriesSettingArgs, 'input'>>;
  gh_updateEnterpriseMembersCanInviteCollaboratorsSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseMembersCanInviteCollaboratorsSettingArgs, 'input'>>;
  gh_updateEnterpriseMembersCanMakePurchasesSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseMembersCanMakePurchasesSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseMembersCanMakePurchasesSettingArgs, 'input'>>;
  gh_updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs, 'input'>>;
  gh_updateEnterpriseMembersCanViewDependencyInsightsSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseMembersCanViewDependencyInsightsSettingArgs, 'input'>>;
  gh_updateEnterpriseOrganizationProjectsSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseOrganizationProjectsSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseOrganizationProjectsSettingArgs, 'input'>>;
  gh_updateEnterpriseOwnerOrganizationRole?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseOwnerOrganizationRolePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseOwnerOrganizationRoleArgs, 'input'>>;
  gh_updateEnterpriseProfile?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseProfilePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseProfileArgs, 'input'>>;
  gh_updateEnterpriseRepositoryProjectsSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseRepositoryProjectsSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseRepositoryProjectsSettingArgs, 'input'>>;
  gh_updateEnterpriseTeamDiscussionsSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseTeamDiscussionsSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseTeamDiscussionsSettingArgs, 'input'>>;
  gh_updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnterpriseTwoFactorAuthenticationRequiredSettingArgs, 'input'>>;
  gh_updateEnvironment?: Resolver<Maybe<ResolversTypes['gh_UpdateEnvironmentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateEnvironmentArgs, 'input'>>;
  gh_updateIpAllowListEnabledSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateIpAllowListEnabledSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateIpAllowListEnabledSettingArgs, 'input'>>;
  gh_updateIpAllowListEntry?: Resolver<Maybe<ResolversTypes['gh_UpdateIpAllowListEntryPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateIpAllowListEntryArgs, 'input'>>;
  gh_updateIpAllowListForInstalledAppsEnabledSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateIpAllowListForInstalledAppsEnabledSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateIpAllowListForInstalledAppsEnabledSettingArgs, 'input'>>;
  gh_updateIssue?: Resolver<Maybe<ResolversTypes['gh_UpdateIssuePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateIssueArgs, 'input'>>;
  gh_updateIssueComment?: Resolver<Maybe<ResolversTypes['gh_UpdateIssueCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateIssueCommentArgs, 'input'>>;
  gh_updateLabel?: Resolver<Maybe<ResolversTypes['gh_UpdateLabelPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateLabelArgs, 'input'>>;
  gh_updateNotificationRestrictionSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateNotificationRestrictionSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateNotificationRestrictionSettingArgs, 'input'>>;
  gh_updateOrganizationAllowPrivateRepositoryForkingSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateOrganizationAllowPrivateRepositoryForkingSettingArgs, 'input'>>;
  gh_updateOrganizationWebCommitSignoffSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateOrganizationWebCommitSignoffSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateOrganizationWebCommitSignoffSettingArgs, 'input'>>;
  gh_updatePatreonSponsorability?: Resolver<Maybe<ResolversTypes['gh_UpdatePatreonSponsorabilityPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updatePatreonSponsorabilityArgs, 'input'>>;
  gh_updateProject?: Resolver<Maybe<ResolversTypes['gh_UpdateProjectPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateProjectArgs, 'input'>>;
  gh_updateProjectCard?: Resolver<Maybe<ResolversTypes['gh_UpdateProjectCardPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateProjectCardArgs, 'input'>>;
  gh_updateProjectColumn?: Resolver<Maybe<ResolversTypes['gh_UpdateProjectColumnPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateProjectColumnArgs, 'input'>>;
  gh_updateProjectV2?: Resolver<Maybe<ResolversTypes['gh_UpdateProjectV2Payload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateProjectV2Args, 'input'>>;
  gh_updateProjectV2Collaborators?: Resolver<Maybe<ResolversTypes['gh_UpdateProjectV2CollaboratorsPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateProjectV2CollaboratorsArgs, 'input'>>;
  gh_updateProjectV2DraftIssue?: Resolver<Maybe<ResolversTypes['gh_UpdateProjectV2DraftIssuePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateProjectV2DraftIssueArgs, 'input'>>;
  gh_updateProjectV2ItemFieldValue?: Resolver<Maybe<ResolversTypes['gh_UpdateProjectV2ItemFieldValuePayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateProjectV2ItemFieldValueArgs, 'input'>>;
  gh_updateProjectV2ItemPosition?: Resolver<Maybe<ResolversTypes['gh_UpdateProjectV2ItemPositionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateProjectV2ItemPositionArgs, 'input'>>;
  gh_updatePullRequest?: Resolver<Maybe<ResolversTypes['gh_UpdatePullRequestPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updatePullRequestArgs, 'input'>>;
  gh_updatePullRequestBranch?: Resolver<Maybe<ResolversTypes['gh_UpdatePullRequestBranchPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updatePullRequestBranchArgs, 'input'>>;
  gh_updatePullRequestReview?: Resolver<Maybe<ResolversTypes['gh_UpdatePullRequestReviewPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updatePullRequestReviewArgs, 'input'>>;
  gh_updatePullRequestReviewComment?: Resolver<Maybe<ResolversTypes['gh_UpdatePullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updatePullRequestReviewCommentArgs, 'input'>>;
  gh_updateRef?: Resolver<Maybe<ResolversTypes['gh_UpdateRefPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateRefArgs, 'input'>>;
  gh_updateRefs?: Resolver<Maybe<ResolversTypes['gh_UpdateRefsPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateRefsArgs, 'input'>>;
  gh_updateRepository?: Resolver<Maybe<ResolversTypes['gh_UpdateRepositoryPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateRepositoryArgs, 'input'>>;
  gh_updateRepositoryRuleset?: Resolver<Maybe<ResolversTypes['gh_UpdateRepositoryRulesetPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateRepositoryRulesetArgs, 'input'>>;
  gh_updateRepositoryWebCommitSignoffSetting?: Resolver<Maybe<ResolversTypes['gh_UpdateRepositoryWebCommitSignoffSettingPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateRepositoryWebCommitSignoffSettingArgs, 'input'>>;
  gh_updateSponsorshipPreferences?: Resolver<Maybe<ResolversTypes['gh_UpdateSponsorshipPreferencesPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateSponsorshipPreferencesArgs, 'input'>>;
  gh_updateSubscription?: Resolver<Maybe<ResolversTypes['gh_UpdateSubscriptionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateSubscriptionArgs, 'input'>>;
  gh_updateTeamDiscussion?: Resolver<Maybe<ResolversTypes['gh_UpdateTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateTeamDiscussionArgs, 'input'>>;
  gh_updateTeamDiscussionComment?: Resolver<Maybe<ResolversTypes['gh_UpdateTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateTeamDiscussionCommentArgs, 'input'>>;
  gh_updateTeamReviewAssignment?: Resolver<Maybe<ResolversTypes['gh_UpdateTeamReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateTeamReviewAssignmentArgs, 'input'>>;
  gh_updateTeamsRepository?: Resolver<Maybe<ResolversTypes['gh_UpdateTeamsRepositoryPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateTeamsRepositoryArgs, 'input'>>;
  gh_updateTopics?: Resolver<Maybe<ResolversTypes['gh_UpdateTopicsPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateTopicsArgs, 'input'>>;
  gh_updateUserList?: Resolver<Maybe<ResolversTypes['gh_UpdateUserListPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateUserListArgs, 'input'>>;
  gh_updateUserListsForItem?: Resolver<Maybe<ResolversTypes['gh_UpdateUserListsForItemPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_updateUserListsForItemArgs, 'input'>>;
  gh_verifyVerifiableDomain?: Resolver<Maybe<ResolversTypes['gh_VerifyVerifiableDomainPayload']>, ParentType, ContextType, RequireFields<GithubMutationgh_verifyVerifiableDomainArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface hn_ObjectIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['hn_ObjectId'], any> {
  name: 'hn_ObjectId';
}

export type hn_NodeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Node'] = ResolversParentTypes['hn_Node']> = ResolversObject<{
  __resolveType: TypeResolveFn<'hn_User' | 'hn_MyUser' | 'hn_Badge' | 'hn_Tag' | 'hn_PopularTag' | 'hn_Publication' | 'hn_RSSImport' | 'hn_Post' | 'hn_TableOfContentsItem' | 'hn_PostBadge' | 'hn_Comment' | 'hn_Reply' | 'hn_Series' | 'hn_Draft' | 'hn_BetaFeature' | 'hn_ScheduledPost' | 'hn_StaticPage' | 'hn_Webhook' | 'hn_WebhookMessage', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
}>;

export type hn_ConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Connection'] = ResolversParentTypes['hn_Connection']> = ResolversObject<{
  __resolveType: TypeResolveFn<'hn_UserPublicationsConnection' | 'hn_CommenterUserConnection' | 'hn_PostCommenterConnection' | 'hn_PostCommentConnection' | 'hn_PostLikerConnection' | 'hn_FeedPostConnection' | 'hn_SearchPostConnection' | 'hn_SeriesPostConnection' | 'hn_PublicationPostConnection' | 'hn_CommentReplyConnection' | 'hn_SeriesConnection' | 'hn_DraftConnection' | 'hn_StaticPageConnection' | 'hn_WebhookMessageConnection', ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['hn_Edge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
}>;

export type hn_EdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Edge'] = ResolversParentTypes['hn_Edge']> = ResolversObject<{
  __resolveType: TypeResolveFn<'hn_UserPublicationsEdge' | 'hn_UserEdge' | 'hn_PopularTagEdge' | 'hn_TagEdge' | 'hn_RecommendedPublicationEdge' | 'hn_PostCommenterEdge' | 'hn_PostCommentEdge' | 'hn_PostLikerEdge' | 'hn_PostEdge' | 'hn_CommentReplyEdge' | 'hn_SeriesEdge' | 'hn_DraftEdge' | 'hn_StaticPageEdge' | 'hn_WebhookMessageEdge', ParentType, ContextType>;
  node?: Resolver<ResolversTypes['hn_Node'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
}>;

export type hn_PageConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PageConnection'] = ResolversParentTypes['hn_PageConnection']> = ResolversObject<{
  __resolveType: TypeResolveFn<'hn_UserConnection' | 'hn_PublicationUserRecommendingPublicationConnection' | 'hn_UserPostConnection', ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['hn_Node']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_OffsetPageInfo'], ParentType, ContextType>;
}>;

export type hn_FeatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Feature'] = ResolversParentTypes['hn_Feature']> = ResolversObject<{
  __resolveType: TypeResolveFn<'hn_NewsletterFeature' | 'hn_ViewCountFeature' | 'hn_ReadTimeFeature' | 'hn_AudioBlogFeature' | 'hn_TextSelectionSharerFeature' | 'hn_CustomCSSFeature' | 'hn_TableOfContentsFeature' | 'hn_PostBadgesFeature', ParentType, ContextType>;
  isEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type hn_PageInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PageInfo'] = ResolversParentTypes['hn_PageInfo']> = ResolversObject<{
  hasNextPage?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_OffsetPageInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_OffsetPageInfo'] = ResolversParentTypes['hn_OffsetPageInfo']> = ResolversObject<{
  hasNextPage?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  hasPreviousPage?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  previousPage?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  nextPage?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_ContentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Content'] = ResolversParentTypes['hn_Content']> = ResolversObject<{
  markdown?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  html?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  text?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_SEOResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_SEO'] = ResolversParentTypes['hn_SEO']> = ResolversObject<{
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_OpenGraphMetaDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_OpenGraphMetaData'] = ResolversParentTypes['hn_OpenGraphMetaData']> = ResolversObject<{
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_UserConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_UserConnection'] = ResolversParentTypes['hn_UserConnection']> = ResolversObject<{
  nodes?: Resolver<Array<ResolversTypes['hn_User']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_OffsetPageInfo'], ParentType, ContextType>;
  totalDocuments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_IUserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_IUser'] = ResolversParentTypes['hn_IUser']> = ResolversObject<{
  __resolveType: TypeResolveFn<'hn_User' | 'hn_MyUser', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  username?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bio?: Resolver<Maybe<ResolversTypes['hn_Content']>, ParentType, ContextType>;
  profilePicture?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  socialMediaLinks?: Resolver<Maybe<ResolversTypes['hn_SocialMediaLinks']>, ParentType, ContextType>;
  badges?: Resolver<Array<ResolversTypes['hn_Badge']>, ParentType, ContextType>;
  publications?: Resolver<ResolversTypes['hn_UserPublicationsConnection'], ParentType, ContextType, RequireFields<hn_IUserpublicationsArgs, 'first'>>;
  posts?: Resolver<ResolversTypes['hn_UserPostConnection'], ParentType, ContextType, RequireFields<hn_IUserpostsArgs, 'pageSize' | 'page' | 'sortBy'>>;
  followersCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  followingsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  tagline?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dateJoined?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  availableFor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tagsFollowing?: Resolver<Array<ResolversTypes['hn_Tag']>, ParentType, ContextType>;
  ambassador?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  deactivated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  followers?: Resolver<ResolversTypes['hn_UserConnection'], ParentType, ContextType, RequireFields<hn_IUserfollowersArgs, 'pageSize' | 'page'>>;
  follows?: Resolver<ResolversTypes['hn_UserConnection'], ParentType, ContextType, RequireFields<hn_IUserfollowsArgs, 'pageSize' | 'page'>>;
}>;

export type hn_UserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_User'] = ResolversParentTypes['hn_User']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  username?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bio?: Resolver<Maybe<ResolversTypes['hn_Content']>, ParentType, ContextType>;
  bioV2?: Resolver<Maybe<ResolversTypes['hn_Content']>, ParentType, ContextType>;
  profilePicture?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  socialMediaLinks?: Resolver<Maybe<ResolversTypes['hn_SocialMediaLinks']>, ParentType, ContextType>;
  badges?: Resolver<Array<ResolversTypes['hn_Badge']>, ParentType, ContextType>;
  publications?: Resolver<ResolversTypes['hn_UserPublicationsConnection'], ParentType, ContextType, RequireFields<hn_UserpublicationsArgs, 'first'>>;
  posts?: Resolver<ResolversTypes['hn_UserPostConnection'], ParentType, ContextType, RequireFields<hn_UserpostsArgs, 'pageSize' | 'page' | 'sortBy'>>;
  followersCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  followingsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  tagline?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dateJoined?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  availableFor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tagsFollowing?: Resolver<Array<ResolversTypes['hn_Tag']>, ParentType, ContextType>;
  ambassador?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  deactivated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  following?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  followsBack?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPro?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  followers?: Resolver<ResolversTypes['hn_UserConnection'], ParentType, ContextType, RequireFields<hn_UserfollowersArgs, 'pageSize' | 'page'>>;
  follows?: Resolver<ResolversTypes['hn_UserConnection'], ParentType, ContextType, RequireFields<hn_UserfollowsArgs, 'pageSize' | 'page'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_MyUserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_MyUser'] = ResolversParentTypes['hn_MyUser']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  username?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bio?: Resolver<Maybe<ResolversTypes['hn_Content']>, ParentType, ContextType>;
  profilePicture?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  socialMediaLinks?: Resolver<Maybe<ResolversTypes['hn_SocialMediaLinks']>, ParentType, ContextType>;
  badges?: Resolver<Array<ResolversTypes['hn_Badge']>, ParentType, ContextType>;
  publications?: Resolver<ResolversTypes['hn_UserPublicationsConnection'], ParentType, ContextType, RequireFields<hn_MyUserpublicationsArgs, 'first'>>;
  posts?: Resolver<ResolversTypes['hn_UserPostConnection'], ParentType, ContextType, RequireFields<hn_MyUserpostsArgs, 'pageSize' | 'page' | 'sortBy'>>;
  followersCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  followingsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  tagline?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dateJoined?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  availableFor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tagsFollowing?: Resolver<Array<ResolversTypes['hn_Tag']>, ParentType, ContextType>;
  ambassador?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  provider?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deactivated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  betaFeatures?: Resolver<Array<ResolversTypes['hn_BetaFeature']>, ParentType, ContextType>;
  unsubscribeCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  followers?: Resolver<ResolversTypes['hn_UserConnection'], ParentType, ContextType, RequireFields<hn_MyUserfollowersArgs, 'pageSize' | 'page'>>;
  follows?: Resolver<ResolversTypes['hn_UserConnection'], ParentType, ContextType, RequireFields<hn_MyUserfollowsArgs, 'pageSize' | 'page'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_UserPublicationsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_UserPublicationsConnection'] = ResolversParentTypes['hn_UserPublicationsConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_UserPublicationsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  totalDocuments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_UserPublicationsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_UserPublicationsEdge'] = ResolversParentTypes['hn_UserPublicationsEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_Publication'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['hn_UserPublicationRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_SocialMediaLinksResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_SocialMediaLinks'] = ResolversParentTypes['hn_SocialMediaLinks']> = ResolversObject<{
  website?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  github?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  twitter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  instagram?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  facebook?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stackoverflow?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  linkedin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  youtube?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_BadgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Badge'] = ResolversParentTypes['hn_Badge']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  dateAssigned?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  infoURL?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  suppressed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_ToggleFollowUserPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_ToggleFollowUserPayload'] = ResolversParentTypes['hn_ToggleFollowUserPayload']> = ResolversObject<{
  user?: Resolver<Maybe<ResolversTypes['hn_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_CommenterUserConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_CommenterUserConnection'] = ResolversParentTypes['hn_CommenterUserConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_UserEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_UserEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_UserEdge'] = ResolversParentTypes['hn_UserEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_User'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_ITagResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_ITag'] = ResolversParentTypes['hn_ITag']> = ResolversObject<{
  __resolveType: TypeResolveFn<'hn_Tag' | 'hn_PopularTag', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tagline?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  info?: Resolver<Maybe<ResolversTypes['hn_Content']>, ParentType, ContextType>;
  followersCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  postsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
}>;

export type hn_TagResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Tag'] = ResolversParentTypes['hn_Tag']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tagline?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  info?: Resolver<Maybe<ResolversTypes['hn_Content']>, ParentType, ContextType>;
  followersCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  postsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  posts?: Resolver<ResolversTypes['hn_FeedPostConnection'], ParentType, ContextType, RequireFields<hn_TagpostsArgs, 'first' | 'filter'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PopularTagResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PopularTag'] = ResolversParentTypes['hn_PopularTag']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tagline?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  info?: Resolver<Maybe<ResolversTypes['hn_Content']>, ParentType, ContextType>;
  followersCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  postsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  postsCountInPeriod?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PopularTagEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PopularTagEdge'] = ResolversParentTypes['hn_PopularTagEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_PopularTag'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_TagEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_TagEdge'] = ResolversParentTypes['hn_TagEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_Tag'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PublicationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Publication'] = ResolversParentTypes['hn_Publication']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  displayTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionSEO?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  about?: Resolver<Maybe<ResolversTypes['hn_Content']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  canonicalURL?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  author?: Resolver<ResolversTypes['hn_User'], ParentType, ContextType>;
  favicon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  headerColor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaTags?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  integrations?: Resolver<Maybe<ResolversTypes['hn_PublicationIntegrations']>, ParentType, ContextType>;
  preferences?: Resolver<ResolversTypes['hn_Preferences'], ParentType, ContextType>;
  followersCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  imprint?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  imprintV2?: Resolver<Maybe<ResolversTypes['hn_Content']>, ParentType, ContextType>;
  isTeam?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  links?: Resolver<Maybe<ResolversTypes['hn_PublicationLinks']>, ParentType, ContextType>;
  domainInfo?: Resolver<ResolversTypes['hn_DomainInfo'], ParentType, ContextType>;
  isHeadless?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  series?: Resolver<Maybe<ResolversTypes['hn_Series']>, ParentType, ContextType, RequireFields<hn_PublicationseriesArgs, 'slug'>>;
  seriesList?: Resolver<ResolversTypes['hn_SeriesConnection'], ParentType, ContextType, RequireFields<hn_PublicationseriesListArgs, 'first'>>;
  posts?: Resolver<ResolversTypes['hn_PublicationPostConnection'], ParentType, ContextType, RequireFields<hn_PublicationpostsArgs, 'first'>>;
  pinnedPost?: Resolver<Maybe<ResolversTypes['hn_Post']>, ParentType, ContextType>;
  post?: Resolver<Maybe<ResolversTypes['hn_Post']>, ParentType, ContextType, RequireFields<hn_PublicationpostArgs, 'slug'>>;
  ogMetaData?: Resolver<ResolversTypes['hn_OpenGraphMetaData'], ParentType, ContextType>;
  features?: Resolver<ResolversTypes['hn_PublicationFeatures'], ParentType, ContextType>;
  drafts?: Resolver<ResolversTypes['hn_DraftConnection'], ParentType, ContextType, RequireFields<hn_PublicationdraftsArgs, 'first'>>;
  scheduledDrafts?: Resolver<ResolversTypes['hn_DraftConnection'], ParentType, ContextType, RequireFields<hn_PublicationscheduledDraftsArgs, 'first'>>;
  staticPage?: Resolver<Maybe<ResolversTypes['hn_StaticPage']>, ParentType, ContextType, RequireFields<hn_PublicationstaticPageArgs, 'slug'>>;
  staticPages?: Resolver<ResolversTypes['hn_StaticPageConnection'], ParentType, ContextType, RequireFields<hn_PublicationstaticPagesArgs, 'first'>>;
  submittedDrafts?: Resolver<ResolversTypes['hn_DraftConnection'], ParentType, ContextType, RequireFields<hn_PublicationsubmittedDraftsArgs, 'first'>>;
  isGitHubBackupEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  urlPattern?: Resolver<ResolversTypes['hn_UrlPattern'], ParentType, ContextType>;
  emailImport?: Resolver<Maybe<ResolversTypes['hn_EmailImport']>, ParentType, ContextType>;
  redirectionRules?: Resolver<Array<ResolversTypes['hn_RedirectionRule']>, ParentType, ContextType>;
  hasBadges?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sponsorship?: Resolver<Maybe<ResolversTypes['hn_PublicationSponsorship']>, ParentType, ContextType>;
  recommendedPublications?: Resolver<Array<ResolversTypes['hn_UserRecommendedPublicationEdge']>, ParentType, ContextType>;
  totalRecommendedPublications?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  recommendingPublications?: Resolver<ResolversTypes['hn_PublicationUserRecommendingPublicationConnection'], ParentType, ContextType, RequireFields<hn_PublicationrecommendingPublicationsArgs, 'pageSize' | 'page'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_UserRecommendedPublicationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_UserRecommendedPublicationEdge'] = ResolversParentTypes['hn_UserRecommendedPublicationEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_Publication'], ParentType, ContextType>;
  totalFollowersGained?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PublicationUserRecommendingPublicationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PublicationUserRecommendingPublicationConnection'] = ResolversParentTypes['hn_PublicationUserRecommendingPublicationConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_UserRecommendingPublicationEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['hn_Publication']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_OffsetPageInfo'], ParentType, ContextType>;
  totalDocuments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_UserRecommendingPublicationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_UserRecommendingPublicationEdge'] = ResolversParentTypes['hn_UserRecommendingPublicationEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_Publication'], ParentType, ContextType>;
  totalFollowersGained?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_RSSImportResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_RSSImport'] = ResolversParentTypes['hn_RSSImport']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  rssURL?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PublicationSponsorshipResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PublicationSponsorship'] = ResolversParentTypes['hn_PublicationSponsorship']> = ResolversObject<{
  content?: Resolver<Maybe<ResolversTypes['hn_Content']>, ParentType, ContextType>;
  stripe?: Resolver<Maybe<ResolversTypes['hn_StripeConfiguration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_StripeConfigurationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_StripeConfiguration'] = ResolversParentTypes['hn_StripeConfiguration']> = ResolversObject<{
  connected?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  accountId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_RedirectionRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_RedirectionRule'] = ResolversParentTypes['hn_RedirectionRule']> = ResolversObject<{
  type?: Resolver<ResolversTypes['hn_HttpRedirectionType'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  destination?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PublicationFeaturesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PublicationFeatures'] = ResolversParentTypes['hn_PublicationFeatures']> = ResolversObject<{
  newsletter?: Resolver<ResolversTypes['hn_NewsletterFeature'], ParentType, ContextType>;
  viewCount?: Resolver<ResolversTypes['hn_ViewCountFeature'], ParentType, ContextType>;
  readTime?: Resolver<ResolversTypes['hn_ReadTimeFeature'], ParentType, ContextType>;
  audioBlog?: Resolver<ResolversTypes['hn_AudioBlogFeature'], ParentType, ContextType>;
  textSelectionSharer?: Resolver<ResolversTypes['hn_TextSelectionSharerFeature'], ParentType, ContextType>;
  customCSS?: Resolver<ResolversTypes['hn_CustomCSSFeature'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_NewsletterFeatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_NewsletterFeature'] = ResolversParentTypes['hn_NewsletterFeature']> = ResolversObject<{
  isEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  frequency?: Resolver<Maybe<ResolversTypes['hn_NewsletterFrequency']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_ViewCountFeatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_ViewCountFeature'] = ResolversParentTypes['hn_ViewCountFeature']> = ResolversObject<{
  isEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_ReadTimeFeatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_ReadTimeFeature'] = ResolversParentTypes['hn_ReadTimeFeature']> = ResolversObject<{
  isEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_AudioBlogFeatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_AudioBlogFeature'] = ResolversParentTypes['hn_AudioBlogFeature']> = ResolversObject<{
  isEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  voiceType?: Resolver<ResolversTypes['hn_AudioBlogVoiceType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_TextSelectionSharerFeatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_TextSelectionSharerFeature'] = ResolversParentTypes['hn_TextSelectionSharerFeature']> = ResolversObject<{
  isEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_CustomCSSFeatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_CustomCSSFeature'] = ResolversParentTypes['hn_CustomCSSFeature']> = ResolversObject<{
  isEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  published?: Resolver<Maybe<ResolversTypes['hn_CustomCSS']>, ParentType, ContextType>;
  draft?: Resolver<Maybe<ResolversTypes['hn_CustomCSS']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_CustomCSSResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_CustomCSS'] = ResolversParentTypes['hn_CustomCSS']> = ResolversObject<{
  home?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  post?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  static?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  homeMinified?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  postMinified?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  staticMinified?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_DomainInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_DomainInfo'] = ResolversParentTypes['hn_DomainInfo']> = ResolversObject<{
  hashnodeSubdomain?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domain?: Resolver<Maybe<ResolversTypes['hn_DomainStatus']>, ParentType, ContextType>;
  wwwPrefixedDomain?: Resolver<Maybe<ResolversTypes['hn_DomainStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_DomainStatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_DomainStatus'] = ResolversParentTypes['hn_DomainStatus']> = ResolversObject<{
  host?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ready?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PreferencesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Preferences'] = ResolversParentTypes['hn_Preferences']> = ResolversObject<{
  logo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  darkMode?: Resolver<Maybe<ResolversTypes['hn_DarkModePreferences']>, ParentType, ContextType>;
  enabledPages?: Resolver<Maybe<ResolversTypes['hn_PagesPreferences']>, ParentType, ContextType>;
  navbarItems?: Resolver<Array<ResolversTypes['hn_PublicationNavbarItem']>, ParentType, ContextType>;
  layout?: Resolver<Maybe<ResolversTypes['hn_PublicationLayout']>, ParentType, ContextType>;
  disableFooterBranding?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isSubscriptionModalDisabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PublicationNavbarItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PublicationNavbarItem'] = ResolversParentTypes['hn_PublicationNavbarItem']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  priority?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['hn_PublicationNavigationType'], ParentType, ContextType>;
  series?: Resolver<Maybe<ResolversTypes['hn_Series']>, ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['hn_StaticPage']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PagesPreferencesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PagesPreferences'] = ResolversParentTypes['hn_PagesPreferences']> = ResolversObject<{
  badges?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  newsletter?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  members?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_DarkModePreferencesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_DarkModePreferences'] = ResolversParentTypes['hn_DarkModePreferences']> = ResolversObject<{
  enabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  logo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PublicationIntegrationsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PublicationIntegrations'] = ResolversParentTypes['hn_PublicationIntegrations']> = ResolversObject<{
  fbPixelID?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fathomSiteID?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fathomCustomDomainEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  fathomCustomDomain?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hotjarSiteID?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  matomoSiteID?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  matomoURL?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gaTrackingID?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  plausibleAnalyticsEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  wmPaymentPointer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  umamiWebsiteUUID?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gTagManagerID?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PublicationLinksResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PublicationLinks'] = ResolversParentTypes['hn_PublicationLinks']> = ResolversObject<{
  twitter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  instagram?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  github?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hashnode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  youtube?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dailydev?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  linkedin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mastodon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_EmailImportResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_EmailImport'] = ResolversParentTypes['hn_EmailImport']> = ResolversObject<{
  currentImport?: Resolver<Maybe<ResolversTypes['hn_EmailCurrentImport']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_EmailCurrentImportResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_EmailCurrentImport'] = ResolversParentTypes['hn_EmailCurrentImport']> = ResolversObject<{
  status?: Resolver<ResolversTypes['hn_EmailImportStatus'], ParentType, ContextType>;
  importStartedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  successfullyImported?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  attemptedToImport?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  filename?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_RecommendedPublicationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_RecommendedPublicationEdge'] = ResolversParentTypes['hn_RecommendedPublicationEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_Publication'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_SubscribeToNewsletterPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_SubscribeToNewsletterPayload'] = ResolversParentTypes['hn_SubscribeToNewsletterPayload']> = ResolversObject<{
  status?: Resolver<Maybe<ResolversTypes['hn_NewsletterSubscribeStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_UnsubscribeFromNewsletterPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_UnsubscribeFromNewsletterPayload'] = ResolversParentTypes['hn_UnsubscribeFromNewsletterPayload']> = ResolversObject<{
  status?: Resolver<Maybe<ResolversTypes['hn_NewsletterUnsubscribeStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PostResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Post'] = ResolversParentTypes['hn_Post']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subtitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  author?: Resolver<ResolversTypes['hn_User'], ParentType, ContextType>;
  coAuthors?: Resolver<Maybe<Array<ResolversTypes['hn_User']>>, ParentType, ContextType>;
  tags?: Resolver<Maybe<Array<ResolversTypes['hn_Tag']>>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  canonicalUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publication?: Resolver<Maybe<ResolversTypes['hn_Publication']>, ParentType, ContextType>;
  cuid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coverImage?: Resolver<Maybe<ResolversTypes['hn_PostCoverImage']>, ParentType, ContextType>;
  brief?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  readTimeInMinutes?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  views?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  series?: Resolver<Maybe<ResolversTypes['hn_Series']>, ParentType, ContextType>;
  reactionCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  replyCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  responseCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  featured?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  contributors?: Resolver<Array<ResolversTypes['hn_User']>, ParentType, ContextType>;
  commenters?: Resolver<ResolversTypes['hn_PostCommenterConnection'], ParentType, ContextType, RequireFields<hn_PostcommentersArgs, 'first'>>;
  comments?: Resolver<ResolversTypes['hn_PostCommentConnection'], ParentType, ContextType, RequireFields<hn_PostcommentsArgs, 'first'>>;
  bookmarked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  content?: Resolver<ResolversTypes['hn_Content'], ParentType, ContextType>;
  likedBy?: Resolver<ResolversTypes['hn_PostLikerConnection'], ParentType, ContextType, RequireFields<hn_PostlikedByArgs, 'first'>>;
  featuredAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  publishedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  preferences?: Resolver<ResolversTypes['hn_PostPreferences'], ParentType, ContextType>;
  audioUrls?: Resolver<Maybe<ResolversTypes['hn_AudioUrls']>, ParentType, ContextType>;
  seo?: Resolver<Maybe<ResolversTypes['hn_SEO']>, ParentType, ContextType>;
  ogMetaData?: Resolver<Maybe<ResolversTypes['hn_OpenGraphMetaData']>, ParentType, ContextType>;
  hasLatexInPost?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isFollowed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isAutoPublishedFromRSS?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  features?: Resolver<ResolversTypes['hn_PostFeatures'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PostFeaturesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PostFeatures'] = ResolversParentTypes['hn_PostFeatures']> = ResolversObject<{
  tableOfContents?: Resolver<ResolversTypes['hn_TableOfContentsFeature'], ParentType, ContextType>;
  badges?: Resolver<ResolversTypes['hn_PostBadgesFeature'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_TableOfContentsFeatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_TableOfContentsFeature'] = ResolversParentTypes['hn_TableOfContentsFeature']> = ResolversObject<{
  isEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  items?: Resolver<Array<ResolversTypes['hn_TableOfContentsItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PostBadgesFeatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PostBadgesFeature'] = ResolversParentTypes['hn_PostBadgesFeature']> = ResolversObject<{
  isEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  items?: Resolver<Array<ResolversTypes['hn_PostBadge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_TableOfContentsItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_TableOfContentsItem'] = ResolversParentTypes['hn_TableOfContentsItem']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  level?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parentId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PostBadgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PostBadge'] = ResolversParentTypes['hn_PostBadge']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['hn_PostBadgeType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_AudioUrlsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_AudioUrls'] = ResolversParentTypes['hn_AudioUrls']> = ResolversObject<{
  male?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  female?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PostPreferencesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PostPreferences'] = ResolversParentTypes['hn_PostPreferences']> = ResolversObject<{
  pinnedToBlog?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  disableComments?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  stickCoverToBottom?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDelisted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PostCommenterConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PostCommenterConnection'] = ResolversParentTypes['hn_PostCommenterConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_PostCommenterEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  totalDocuments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PostCommenterEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PostCommenterEdge'] = ResolversParentTypes['hn_PostCommenterEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_User'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PostCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PostCommentConnection'] = ResolversParentTypes['hn_PostCommentConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_PostCommentEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  totalDocuments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PostCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PostCommentEdge'] = ResolversParentTypes['hn_PostCommentEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_Comment'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PostLikerEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PostLikerEdge'] = ResolversParentTypes['hn_PostLikerEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_User'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  reactionCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PostLikerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PostLikerConnection'] = ResolversParentTypes['hn_PostLikerConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_PostLikerEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  totalDocuments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PostCoverImageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PostCoverImage'] = ResolversParentTypes['hn_PostCoverImage']> = ResolversObject<{
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isPortrait?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  attribution?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  photographer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isAttributionHidden?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PostEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PostEdge'] = ResolversParentTypes['hn_PostEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_Post'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_UserPostEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_UserPostEdge'] = ResolversParentTypes['hn_UserPostEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_Post'], ParentType, ContextType>;
  authorType?: Resolver<ResolversTypes['hn_PostAuthorType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_FeedPostConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_FeedPostConnection'] = ResolversParentTypes['hn_FeedPostConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_PostEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_SearchPostConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_SearchPostConnection'] = ResolversParentTypes['hn_SearchPostConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_PostEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_SeriesPostConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_SeriesPostConnection'] = ResolversParentTypes['hn_SeriesPostConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_PostEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  totalDocuments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PublicationPostConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PublicationPostConnection'] = ResolversParentTypes['hn_PublicationPostConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_PostEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  totalDocuments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_UserPostConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_UserPostConnection'] = ResolversParentTypes['hn_UserPostConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_UserPostEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['hn_Post']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_OffsetPageInfo'], ParentType, ContextType>;
  totalDocuments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_PublishPostPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_PublishPostPayload'] = ResolversParentTypes['hn_PublishPostPayload']> = ResolversObject<{
  post?: Resolver<Maybe<ResolversTypes['hn_Post']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_UpdatePostPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_UpdatePostPayload'] = ResolversParentTypes['hn_UpdatePostPayload']> = ResolversObject<{
  post?: Resolver<Maybe<ResolversTypes['hn_Post']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_RemovePostPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_RemovePostPayload'] = ResolversParentTypes['hn_RemovePostPayload']> = ResolversObject<{
  post?: Resolver<Maybe<ResolversTypes['hn_Post']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_AddPostToSeriesPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_AddPostToSeriesPayload'] = ResolversParentTypes['hn_AddPostToSeriesPayload']> = ResolversObject<{
  series?: Resolver<Maybe<ResolversTypes['hn_Series']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_CommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Comment'] = ResolversParentTypes['hn_Comment']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  content?: Resolver<ResolversTypes['hn_Content'], ParentType, ContextType>;
  author?: Resolver<ResolversTypes['hn_User'], ParentType, ContextType>;
  replies?: Resolver<ResolversTypes['hn_CommentReplyConnection'], ParentType, ContextType, RequireFields<hn_CommentrepliesArgs, 'first'>>;
  dateAdded?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  stamp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  totalReactions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  myTotalReactions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_CommentReplyConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_CommentReplyConnection'] = ResolversParentTypes['hn_CommentReplyConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_CommentReplyEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  totalDocuments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_CommentReplyEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_CommentReplyEdge'] = ResolversParentTypes['hn_CommentReplyEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_Reply'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_ReplyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Reply'] = ResolversParentTypes['hn_Reply']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  content?: Resolver<ResolversTypes['hn_Content'], ParentType, ContextType>;
  author?: Resolver<ResolversTypes['hn_User'], ParentType, ContextType>;
  dateAdded?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  stamp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  totalReactions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  myTotalReactions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_SeriesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Series'] = ResolversParentTypes['hn_Series']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['hn_Content']>, ParentType, ContextType>;
  coverImage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  author?: Resolver<ResolversTypes['hn_User'], ParentType, ContextType>;
  cuid?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sortOrder?: Resolver<ResolversTypes['hn_SortOrder'], ParentType, ContextType>;
  posts?: Resolver<ResolversTypes['hn_SeriesPostConnection'], ParentType, ContextType, RequireFields<hn_SeriespostsArgs, 'first'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_SeriesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_SeriesEdge'] = ResolversParentTypes['hn_SeriesEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_Series'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_SeriesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_SeriesConnection'] = ResolversParentTypes['hn_SeriesConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_SeriesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  totalDocuments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_DraftResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Draft'] = ResolversParentTypes['hn_Draft']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subtitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  author?: Resolver<ResolversTypes['hn_User'], ParentType, ContextType>;
  coAuthors?: Resolver<Maybe<Array<ResolversTypes['hn_User']>>, ParentType, ContextType>;
  tags?: Resolver<Array<ResolversTypes['hn_Tag']>, ParentType, ContextType>;
  canonicalUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coverImage?: Resolver<Maybe<ResolversTypes['hn_DraftCoverImage']>, ParentType, ContextType>;
  readTimeInMinutes?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  series?: Resolver<Maybe<ResolversTypes['hn_Series']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['hn_Content']>, ParentType, ContextType>;
  dateUpdated?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  settings?: Resolver<ResolversTypes['hn_DraftSettings'], ParentType, ContextType>;
  seo?: Resolver<Maybe<ResolversTypes['hn_SEO']>, ParentType, ContextType>;
  ogMetaData?: Resolver<Maybe<ResolversTypes['hn_OpenGraphMetaData']>, ParentType, ContextType>;
  features?: Resolver<ResolversTypes['hn_DraftFeatures'], ParentType, ContextType>;
  lastBackup?: Resolver<Maybe<ResolversTypes['hn_DraftBackup']>, ParentType, ContextType>;
  lastSuccessfulBackupAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  lastFailedBackupAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_DraftSettingsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_DraftSettings'] = ResolversParentTypes['hn_DraftSettings']> = ResolversObject<{
  disableComments?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  stickCoverToBottom?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDelisted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_DraftFeaturesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_DraftFeatures'] = ResolversParentTypes['hn_DraftFeatures']> = ResolversObject<{
  tableOfContents?: Resolver<ResolversTypes['hn_TableOfContentsFeature'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_DraftBackupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_DraftBackup'] = ResolversParentTypes['hn_DraftBackup']> = ResolversObject<{
  status?: Resolver<Maybe<ResolversTypes['hn_BackupStatus']>, ParentType, ContextType>;
  at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_DraftConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_DraftConnection'] = ResolversParentTypes['hn_DraftConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_DraftEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  totalDocuments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_DraftCoverImageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_DraftCoverImage'] = ResolversParentTypes['hn_DraftCoverImage']> = ResolversObject<{
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  attribution?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  photographer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isAttributionHidden?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_DraftEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_DraftEdge'] = ResolversParentTypes['hn_DraftEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_Draft'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_BetaFeatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_BetaFeature'] = ResolversParentTypes['hn_BetaFeature']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_ScheduledPostResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_ScheduledPost'] = ResolversParentTypes['hn_ScheduledPost']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  author?: Resolver<ResolversTypes['hn_User'], ParentType, ContextType>;
  draft?: Resolver<Maybe<ResolversTypes['hn_Draft']>, ParentType, ContextType>;
  scheduledDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  scheduledBy?: Resolver<Maybe<ResolversTypes['hn_User']>, ParentType, ContextType>;
  publication?: Resolver<ResolversTypes['hn_Publication'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_ScheduledPostPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_ScheduledPostPayload'] = ResolversParentTypes['hn_ScheduledPostPayload']> = ResolversObject<{
  payload?: Resolver<ResolversTypes['hn_ScheduledPost'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_StaticPageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_StaticPage'] = ResolversParentTypes['hn_StaticPage']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  content?: Resolver<ResolversTypes['hn_Content'], ParentType, ContextType>;
  hidden?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  ogMetaData?: Resolver<Maybe<ResolversTypes['hn_OpenGraphMetaData']>, ParentType, ContextType>;
  seo?: Resolver<Maybe<ResolversTypes['hn_SEO']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_StaticPageConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_StaticPageConnection'] = ResolversParentTypes['hn_StaticPageConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_StaticPageEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  totalDocuments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_StaticPageEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_StaticPageEdge'] = ResolversParentTypes['hn_StaticPageEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_StaticPage'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_WebhookResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_Webhook'] = ResolversParentTypes['hn_Webhook']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  publication?: Resolver<ResolversTypes['hn_Publication'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  events?: Resolver<Array<ResolversTypes['hn_WebhookEvent']>, ParentType, ContextType>;
  secret?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  messages?: Resolver<ResolversTypes['hn_WebhookMessageConnection'], ParentType, ContextType, RequireFields<hn_WebhookmessagesArgs, 'first'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_WebhookMessageConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_WebhookMessageConnection'] = ResolversParentTypes['hn_WebhookMessageConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['hn_WebhookMessageEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['hn_PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_WebhookMessageEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_WebhookMessageEdge'] = ResolversParentTypes['hn_WebhookMessageEdge']> = ResolversObject<{
  node?: Resolver<ResolversTypes['hn_WebhookMessage'], ParentType, ContextType>;
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_WebhookMessageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_WebhookMessage'] = ResolversParentTypes['hn_WebhookMessage']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  event?: Resolver<ResolversTypes['hn_WebhookEvent'], ParentType, ContextType>;
  isError?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isTest?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isResent?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  request?: Resolver<ResolversTypes['hn_WebhookMessageRequest'], ParentType, ContextType>;
  response?: Resolver<Maybe<ResolversTypes['hn_WebhookMessageResponse']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_WebhookMessageRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_WebhookMessageRequest'] = ResolversParentTypes['hn_WebhookMessageRequest']> = ResolversObject<{
  uuid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  headers?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  error?: Resolver<Maybe<ResolversTypes['hn_WebhookMessageRequestError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_WebhookMessageRequestErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_WebhookMessageRequestError'] = ResolversParentTypes['hn_WebhookMessageRequestError']> = ResolversObject<{
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type hn_WebhookMessageResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['hn_WebhookMessageResponse'] = ResolversParentTypes['hn_WebhookMessageResponse']> = ResolversObject<{
  httpStatus?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  headers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timeToFirstByteMilliseconds?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type HashnodeQueryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['HashnodeQuery'] = ResolversParentTypes['HashnodeQuery']> = ResolversObject<{
  hn_user?: Resolver<Maybe<ResolversTypes['hn_User']>, ParentType, ContextType, RequireFields<HashnodeQueryhn_userArgs, 'username'>>;
  hn_topCommenters?: Resolver<ResolversTypes['hn_CommenterUserConnection'], ParentType, ContextType, RequireFields<HashnodeQueryhn_topCommentersArgs, 'first'>>;
  hn_me?: Resolver<ResolversTypes['hn_MyUser'], ParentType, ContextType>;
  hn_tag?: Resolver<Maybe<ResolversTypes['hn_Tag']>, ParentType, ContextType, RequireFields<HashnodeQueryhn_tagArgs, 'slug'>>;
  hn_publication?: Resolver<Maybe<ResolversTypes['hn_Publication']>, ParentType, ContextType, Partial<HashnodeQueryhn_publicationArgs>>;
  hn_feed?: Resolver<ResolversTypes['hn_FeedPostConnection'], ParentType, ContextType, RequireFields<HashnodeQueryhn_feedArgs, 'first'>>;
  hn_searchPostsOfPublication?: Resolver<ResolversTypes['hn_SearchPostConnection'], ParentType, ContextType, RequireFields<HashnodeQueryhn_searchPostsOfPublicationArgs, 'first' | 'filter'>>;
  hn_draft?: Resolver<Maybe<ResolversTypes['hn_Draft']>, ParentType, ContextType, RequireFields<HashnodeQueryhn_draftArgs, 'id'>>;
  hn_scheduledPost?: Resolver<Maybe<ResolversTypes['hn_ScheduledPost']>, ParentType, ContextType, Partial<HashnodeQueryhn_scheduledPostArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type HashnodeMutationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['HashnodeMutation'] = ResolversParentTypes['HashnodeMutation']> = ResolversObject<{
  hn_toggleFollowUser?: Resolver<ResolversTypes['hn_ToggleFollowUserPayload'], ParentType, ContextType, Partial<HashnodeMutationhn_toggleFollowUserArgs>>;
  hn_subscribeToNewsletter?: Resolver<ResolversTypes['hn_SubscribeToNewsletterPayload'], ParentType, ContextType, RequireFields<HashnodeMutationhn_subscribeToNewsletterArgs, 'input'>>;
  hn_unsubscribeFromNewsletter?: Resolver<ResolversTypes['hn_UnsubscribeFromNewsletterPayload'], ParentType, ContextType, RequireFields<HashnodeMutationhn_unsubscribeFromNewsletterArgs, 'input'>>;
  hn_publishPost?: Resolver<ResolversTypes['hn_PublishPostPayload'], ParentType, ContextType, RequireFields<HashnodeMutationhn_publishPostArgs, 'input'>>;
  hn_addPostToSeries?: Resolver<ResolversTypes['hn_AddPostToSeriesPayload'], ParentType, ContextType, RequireFields<HashnodeMutationhn_addPostToSeriesArgs, 'input'>>;
  hn_updatePost?: Resolver<ResolversTypes['hn_UpdatePostPayload'], ParentType, ContextType, RequireFields<HashnodeMutationhn_updatePostArgs, 'input'>>;
  hn_removePost?: Resolver<ResolversTypes['hn_RemovePostPayload'], ParentType, ContextType, RequireFields<HashnodeMutationhn_removePostArgs, 'input'>>;
  hn_reschedulePost?: Resolver<Maybe<ResolversTypes['hn_ScheduledPostPayload']>, ParentType, ContextType, RequireFields<HashnodeMutationhn_reschedulePostArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Resolvers<ContextType = MeshContext> = ResolversObject<{
  Query?: QueryResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  gh_AbortQueuedMigrationsPayload?: gh_AbortQueuedMigrationsPayloadResolvers<ContextType>;
  gh_AbortRepositoryMigrationPayload?: gh_AbortRepositoryMigrationPayloadResolvers<ContextType>;
  gh_AcceptEnterpriseAdministratorInvitationPayload?: gh_AcceptEnterpriseAdministratorInvitationPayloadResolvers<ContextType>;
  gh_AcceptTopicSuggestionPayload?: gh_AcceptTopicSuggestionPayloadResolvers<ContextType>;
  gh_Actor?: gh_ActorResolvers<ContextType>;
  gh_ActorLocation?: gh_ActorLocationResolvers<ContextType>;
  gh_AddAssigneesToAssignablePayload?: gh_AddAssigneesToAssignablePayloadResolvers<ContextType>;
  gh_AddCommentPayload?: gh_AddCommentPayloadResolvers<ContextType>;
  gh_AddDiscussionCommentPayload?: gh_AddDiscussionCommentPayloadResolvers<ContextType>;
  gh_AddDiscussionPollVotePayload?: gh_AddDiscussionPollVotePayloadResolvers<ContextType>;
  gh_AddEnterpriseOrganizationMemberPayload?: gh_AddEnterpriseOrganizationMemberPayloadResolvers<ContextType>;
  gh_AddEnterpriseSupportEntitlementPayload?: gh_AddEnterpriseSupportEntitlementPayloadResolvers<ContextType>;
  gh_AddLabelsToLabelablePayload?: gh_AddLabelsToLabelablePayloadResolvers<ContextType>;
  gh_AddProjectCardPayload?: gh_AddProjectCardPayloadResolvers<ContextType>;
  gh_AddProjectColumnPayload?: gh_AddProjectColumnPayloadResolvers<ContextType>;
  gh_AddProjectV2DraftIssuePayload?: gh_AddProjectV2DraftIssuePayloadResolvers<ContextType>;
  gh_AddProjectV2ItemByIdPayload?: gh_AddProjectV2ItemByIdPayloadResolvers<ContextType>;
  gh_AddPullRequestReviewCommentPayload?: gh_AddPullRequestReviewCommentPayloadResolvers<ContextType>;
  gh_AddPullRequestReviewPayload?: gh_AddPullRequestReviewPayloadResolvers<ContextType>;
  gh_AddPullRequestReviewThreadPayload?: gh_AddPullRequestReviewThreadPayloadResolvers<ContextType>;
  gh_AddPullRequestReviewThreadReplyPayload?: gh_AddPullRequestReviewThreadReplyPayloadResolvers<ContextType>;
  gh_AddReactionPayload?: gh_AddReactionPayloadResolvers<ContextType>;
  gh_AddStarPayload?: gh_AddStarPayloadResolvers<ContextType>;
  gh_AddUpvotePayload?: gh_AddUpvotePayloadResolvers<ContextType>;
  gh_AddVerifiableDomainPayload?: gh_AddVerifiableDomainPayloadResolvers<ContextType>;
  gh_AddedToMergeQueueEvent?: gh_AddedToMergeQueueEventResolvers<ContextType>;
  gh_AddedToProjectEvent?: gh_AddedToProjectEventResolvers<ContextType>;
  gh_AnnouncementBanner?: gh_AnnouncementBannerResolvers<ContextType>;
  gh_App?: gh_AppResolvers<ContextType>;
  gh_ApproveDeploymentsPayload?: gh_ApproveDeploymentsPayloadResolvers<ContextType>;
  gh_ApproveVerifiableDomainPayload?: gh_ApproveVerifiableDomainPayloadResolvers<ContextType>;
  gh_ArchiveProjectV2ItemPayload?: gh_ArchiveProjectV2ItemPayloadResolvers<ContextType>;
  gh_ArchiveRepositoryPayload?: gh_ArchiveRepositoryPayloadResolvers<ContextType>;
  gh_Assignable?: gh_AssignableResolvers<ContextType>;
  gh_AssignedEvent?: gh_AssignedEventResolvers<ContextType>;
  gh_Assignee?: gh_AssigneeResolvers<ContextType>;
  gh_AuditEntry?: gh_AuditEntryResolvers<ContextType>;
  gh_AuditEntryActor?: gh_AuditEntryActorResolvers<ContextType>;
  gh_AutoMergeDisabledEvent?: gh_AutoMergeDisabledEventResolvers<ContextType>;
  gh_AutoMergeEnabledEvent?: gh_AutoMergeEnabledEventResolvers<ContextType>;
  gh_AutoMergeRequest?: gh_AutoMergeRequestResolvers<ContextType>;
  gh_AutoRebaseEnabledEvent?: gh_AutoRebaseEnabledEventResolvers<ContextType>;
  gh_AutoSquashEnabledEvent?: gh_AutoSquashEnabledEventResolvers<ContextType>;
  gh_AutomaticBaseChangeFailedEvent?: gh_AutomaticBaseChangeFailedEventResolvers<ContextType>;
  gh_AutomaticBaseChangeSucceededEvent?: gh_AutomaticBaseChangeSucceededEventResolvers<ContextType>;
  gh_Base64String?: GraphQLScalarType;
  gh_BaseRefChangedEvent?: gh_BaseRefChangedEventResolvers<ContextType>;
  gh_BaseRefDeletedEvent?: gh_BaseRefDeletedEventResolvers<ContextType>;
  gh_BaseRefForcePushedEvent?: gh_BaseRefForcePushedEventResolvers<ContextType>;
  BigInt?: GraphQLScalarType;
  gh_Blame?: gh_BlameResolvers<ContextType>;
  gh_BlameRange?: gh_BlameRangeResolvers<ContextType>;
  gh_Blob?: gh_BlobResolvers<ContextType>;
  gh_Bot?: gh_BotResolvers<ContextType>;
  gh_BranchActorAllowanceActor?: gh_BranchActorAllowanceActorResolvers<ContextType>;
  gh_BranchNamePatternParameters?: gh_BranchNamePatternParametersResolvers<ContextType>;
  gh_BranchProtectionRule?: gh_BranchProtectionRuleResolvers<ContextType>;
  gh_BranchProtectionRuleConflict?: gh_BranchProtectionRuleConflictResolvers<ContextType>;
  gh_BranchProtectionRuleConflictConnection?: gh_BranchProtectionRuleConflictConnectionResolvers<ContextType>;
  gh_BranchProtectionRuleConflictEdge?: gh_BranchProtectionRuleConflictEdgeResolvers<ContextType>;
  gh_BranchProtectionRuleConnection?: gh_BranchProtectionRuleConnectionResolvers<ContextType>;
  gh_BranchProtectionRuleEdge?: gh_BranchProtectionRuleEdgeResolvers<ContextType>;
  gh_BypassActor?: gh_BypassActorResolvers<ContextType>;
  gh_BypassForcePushAllowance?: gh_BypassForcePushAllowanceResolvers<ContextType>;
  gh_BypassForcePushAllowanceConnection?: gh_BypassForcePushAllowanceConnectionResolvers<ContextType>;
  gh_BypassForcePushAllowanceEdge?: gh_BypassForcePushAllowanceEdgeResolvers<ContextType>;
  gh_BypassPullRequestAllowance?: gh_BypassPullRequestAllowanceResolvers<ContextType>;
  gh_BypassPullRequestAllowanceConnection?: gh_BypassPullRequestAllowanceConnectionResolvers<ContextType>;
  gh_BypassPullRequestAllowanceEdge?: gh_BypassPullRequestAllowanceEdgeResolvers<ContextType>;
  gh_CVSS?: gh_CVSSResolvers<ContextType>;
  gh_CWE?: gh_CWEResolvers<ContextType>;
  gh_CWEConnection?: gh_CWEConnectionResolvers<ContextType>;
  gh_CWEEdge?: gh_CWEEdgeResolvers<ContextType>;
  gh_CancelEnterpriseAdminInvitationPayload?: gh_CancelEnterpriseAdminInvitationPayloadResolvers<ContextType>;
  gh_CancelSponsorshipPayload?: gh_CancelSponsorshipPayloadResolvers<ContextType>;
  gh_ChangeUserStatusPayload?: gh_ChangeUserStatusPayloadResolvers<ContextType>;
  gh_CheckAnnotation?: gh_CheckAnnotationResolvers<ContextType>;
  gh_CheckAnnotationConnection?: gh_CheckAnnotationConnectionResolvers<ContextType>;
  gh_CheckAnnotationEdge?: gh_CheckAnnotationEdgeResolvers<ContextType>;
  gh_CheckAnnotationPosition?: gh_CheckAnnotationPositionResolvers<ContextType>;
  gh_CheckAnnotationSpan?: gh_CheckAnnotationSpanResolvers<ContextType>;
  gh_CheckRun?: gh_CheckRunResolvers<ContextType>;
  gh_CheckRunConnection?: gh_CheckRunConnectionResolvers<ContextType>;
  gh_CheckRunEdge?: gh_CheckRunEdgeResolvers<ContextType>;
  gh_CheckRunStateCount?: gh_CheckRunStateCountResolvers<ContextType>;
  gh_CheckStep?: gh_CheckStepResolvers<ContextType>;
  gh_CheckStepConnection?: gh_CheckStepConnectionResolvers<ContextType>;
  gh_CheckStepEdge?: gh_CheckStepEdgeResolvers<ContextType>;
  gh_CheckSuite?: gh_CheckSuiteResolvers<ContextType>;
  gh_CheckSuiteConnection?: gh_CheckSuiteConnectionResolvers<ContextType>;
  gh_CheckSuiteEdge?: gh_CheckSuiteEdgeResolvers<ContextType>;
  gh_Claimable?: gh_ClaimableResolvers<ContextType>;
  gh_ClearLabelsFromLabelablePayload?: gh_ClearLabelsFromLabelablePayloadResolvers<ContextType>;
  gh_ClearProjectV2ItemFieldValuePayload?: gh_ClearProjectV2ItemFieldValuePayloadResolvers<ContextType>;
  gh_CloneProjectPayload?: gh_CloneProjectPayloadResolvers<ContextType>;
  gh_CloneTemplateRepositoryPayload?: gh_CloneTemplateRepositoryPayloadResolvers<ContextType>;
  gh_Closable?: gh_ClosableResolvers<ContextType>;
  gh_CloseDiscussionPayload?: gh_CloseDiscussionPayloadResolvers<ContextType>;
  gh_CloseIssuePayload?: gh_CloseIssuePayloadResolvers<ContextType>;
  gh_ClosePullRequestPayload?: gh_ClosePullRequestPayloadResolvers<ContextType>;
  gh_ClosedEvent?: gh_ClosedEventResolvers<ContextType>;
  gh_Closer?: gh_CloserResolvers<ContextType>;
  gh_CodeOfConduct?: gh_CodeOfConductResolvers<ContextType>;
  gh_Comment?: gh_CommentResolvers<ContextType>;
  gh_CommentDeletedEvent?: gh_CommentDeletedEventResolvers<ContextType>;
  gh_Commit?: gh_CommitResolvers<ContextType>;
  gh_CommitAuthorEmailPatternParameters?: gh_CommitAuthorEmailPatternParametersResolvers<ContextType>;
  gh_CommitComment?: gh_CommitCommentResolvers<ContextType>;
  gh_CommitCommentConnection?: gh_CommitCommentConnectionResolvers<ContextType>;
  gh_CommitCommentEdge?: gh_CommitCommentEdgeResolvers<ContextType>;
  gh_CommitCommentThread?: gh_CommitCommentThreadResolvers<ContextType>;
  gh_CommitConnection?: gh_CommitConnectionResolvers<ContextType>;
  gh_CommitContributionsByRepository?: gh_CommitContributionsByRepositoryResolvers<ContextType>;
  gh_CommitEdge?: gh_CommitEdgeResolvers<ContextType>;
  gh_CommitHistoryConnection?: gh_CommitHistoryConnectionResolvers<ContextType>;
  gh_CommitMessagePatternParameters?: gh_CommitMessagePatternParametersResolvers<ContextType>;
  gh_CommitterEmailPatternParameters?: gh_CommitterEmailPatternParametersResolvers<ContextType>;
  gh_Comparison?: gh_ComparisonResolvers<ContextType>;
  gh_ComparisonCommitConnection?: gh_ComparisonCommitConnectionResolvers<ContextType>;
  gh_ConnectedEvent?: gh_ConnectedEventResolvers<ContextType>;
  gh_ContributingGuidelines?: gh_ContributingGuidelinesResolvers<ContextType>;
  gh_Contribution?: gh_ContributionResolvers<ContextType>;
  gh_ContributionCalendar?: gh_ContributionCalendarResolvers<ContextType>;
  gh_ContributionCalendarDay?: gh_ContributionCalendarDayResolvers<ContextType>;
  gh_ContributionCalendarMonth?: gh_ContributionCalendarMonthResolvers<ContextType>;
  gh_ContributionCalendarWeek?: gh_ContributionCalendarWeekResolvers<ContextType>;
  gh_ContributionsCollection?: gh_ContributionsCollectionResolvers<ContextType>;
  gh_ConvertProjectCardNoteToIssuePayload?: gh_ConvertProjectCardNoteToIssuePayloadResolvers<ContextType>;
  gh_ConvertPullRequestToDraftPayload?: gh_ConvertPullRequestToDraftPayloadResolvers<ContextType>;
  gh_ConvertToDraftEvent?: gh_ConvertToDraftEventResolvers<ContextType>;
  gh_ConvertedNoteToIssueEvent?: gh_ConvertedNoteToIssueEventResolvers<ContextType>;
  gh_ConvertedToDiscussionEvent?: gh_ConvertedToDiscussionEventResolvers<ContextType>;
  gh_CopyProjectV2Payload?: gh_CopyProjectV2PayloadResolvers<ContextType>;
  gh_CreateAttributionInvitationPayload?: gh_CreateAttributionInvitationPayloadResolvers<ContextType>;
  gh_CreateBranchProtectionRulePayload?: gh_CreateBranchProtectionRulePayloadResolvers<ContextType>;
  gh_CreateCheckRunPayload?: gh_CreateCheckRunPayloadResolvers<ContextType>;
  gh_CreateCheckSuitePayload?: gh_CreateCheckSuitePayloadResolvers<ContextType>;
  gh_CreateCommitOnBranchPayload?: gh_CreateCommitOnBranchPayloadResolvers<ContextType>;
  gh_CreateDeploymentPayload?: gh_CreateDeploymentPayloadResolvers<ContextType>;
  gh_CreateDeploymentStatusPayload?: gh_CreateDeploymentStatusPayloadResolvers<ContextType>;
  gh_CreateDiscussionPayload?: gh_CreateDiscussionPayloadResolvers<ContextType>;
  gh_CreateEnterpriseOrganizationPayload?: gh_CreateEnterpriseOrganizationPayloadResolvers<ContextType>;
  gh_CreateEnvironmentPayload?: gh_CreateEnvironmentPayloadResolvers<ContextType>;
  gh_CreateIpAllowListEntryPayload?: gh_CreateIpAllowListEntryPayloadResolvers<ContextType>;
  gh_CreateIssuePayload?: gh_CreateIssuePayloadResolvers<ContextType>;
  gh_CreateLabelPayload?: gh_CreateLabelPayloadResolvers<ContextType>;
  gh_CreateLinkedBranchPayload?: gh_CreateLinkedBranchPayloadResolvers<ContextType>;
  gh_CreateMigrationSourcePayload?: gh_CreateMigrationSourcePayloadResolvers<ContextType>;
  gh_CreateProjectPayload?: gh_CreateProjectPayloadResolvers<ContextType>;
  gh_CreateProjectV2FieldPayload?: gh_CreateProjectV2FieldPayloadResolvers<ContextType>;
  gh_CreateProjectV2Payload?: gh_CreateProjectV2PayloadResolvers<ContextType>;
  gh_CreatePullRequestPayload?: gh_CreatePullRequestPayloadResolvers<ContextType>;
  gh_CreateRefPayload?: gh_CreateRefPayloadResolvers<ContextType>;
  gh_CreateRepositoryPayload?: gh_CreateRepositoryPayloadResolvers<ContextType>;
  gh_CreateRepositoryRulesetPayload?: gh_CreateRepositoryRulesetPayloadResolvers<ContextType>;
  gh_CreateSponsorsListingPayload?: gh_CreateSponsorsListingPayloadResolvers<ContextType>;
  gh_CreateSponsorsTierPayload?: gh_CreateSponsorsTierPayloadResolvers<ContextType>;
  gh_CreateSponsorshipPayload?: gh_CreateSponsorshipPayloadResolvers<ContextType>;
  gh_CreateSponsorshipsPayload?: gh_CreateSponsorshipsPayloadResolvers<ContextType>;
  gh_CreateTeamDiscussionCommentPayload?: gh_CreateTeamDiscussionCommentPayloadResolvers<ContextType>;
  gh_CreateTeamDiscussionPayload?: gh_CreateTeamDiscussionPayloadResolvers<ContextType>;
  gh_CreateUserListPayload?: gh_CreateUserListPayloadResolvers<ContextType>;
  gh_CreatedCommitContribution?: gh_CreatedCommitContributionResolvers<ContextType>;
  gh_CreatedCommitContributionConnection?: gh_CreatedCommitContributionConnectionResolvers<ContextType>;
  gh_CreatedCommitContributionEdge?: gh_CreatedCommitContributionEdgeResolvers<ContextType>;
  gh_CreatedIssueContribution?: gh_CreatedIssueContributionResolvers<ContextType>;
  gh_CreatedIssueContributionConnection?: gh_CreatedIssueContributionConnectionResolvers<ContextType>;
  gh_CreatedIssueContributionEdge?: gh_CreatedIssueContributionEdgeResolvers<ContextType>;
  gh_CreatedIssueOrRestrictedContribution?: gh_CreatedIssueOrRestrictedContributionResolvers<ContextType>;
  gh_CreatedPullRequestContribution?: gh_CreatedPullRequestContributionResolvers<ContextType>;
  gh_CreatedPullRequestContributionConnection?: gh_CreatedPullRequestContributionConnectionResolvers<ContextType>;
  gh_CreatedPullRequestContributionEdge?: gh_CreatedPullRequestContributionEdgeResolvers<ContextType>;
  gh_CreatedPullRequestOrRestrictedContribution?: gh_CreatedPullRequestOrRestrictedContributionResolvers<ContextType>;
  gh_CreatedPullRequestReviewContribution?: gh_CreatedPullRequestReviewContributionResolvers<ContextType>;
  gh_CreatedPullRequestReviewContributionConnection?: gh_CreatedPullRequestReviewContributionConnectionResolvers<ContextType>;
  gh_CreatedPullRequestReviewContributionEdge?: gh_CreatedPullRequestReviewContributionEdgeResolvers<ContextType>;
  gh_CreatedRepositoryContribution?: gh_CreatedRepositoryContributionResolvers<ContextType>;
  gh_CreatedRepositoryContributionConnection?: gh_CreatedRepositoryContributionConnectionResolvers<ContextType>;
  gh_CreatedRepositoryContributionEdge?: gh_CreatedRepositoryContributionEdgeResolvers<ContextType>;
  gh_CreatedRepositoryOrRestrictedContribution?: gh_CreatedRepositoryOrRestrictedContributionResolvers<ContextType>;
  gh_CrossReferencedEvent?: gh_CrossReferencedEventResolvers<ContextType>;
  Date?: GraphQLScalarType;
  DateTime?: GraphQLScalarType;
  gh_DeclineTopicSuggestionPayload?: gh_DeclineTopicSuggestionPayloadResolvers<ContextType>;
  gh_Deletable?: gh_DeletableResolvers<ContextType>;
  gh_DeleteBranchProtectionRulePayload?: gh_DeleteBranchProtectionRulePayloadResolvers<ContextType>;
  gh_DeleteDeploymentPayload?: gh_DeleteDeploymentPayloadResolvers<ContextType>;
  gh_DeleteDiscussionCommentPayload?: gh_DeleteDiscussionCommentPayloadResolvers<ContextType>;
  gh_DeleteDiscussionPayload?: gh_DeleteDiscussionPayloadResolvers<ContextType>;
  gh_DeleteEnvironmentPayload?: gh_DeleteEnvironmentPayloadResolvers<ContextType>;
  gh_DeleteIpAllowListEntryPayload?: gh_DeleteIpAllowListEntryPayloadResolvers<ContextType>;
  gh_DeleteIssueCommentPayload?: gh_DeleteIssueCommentPayloadResolvers<ContextType>;
  gh_DeleteIssuePayload?: gh_DeleteIssuePayloadResolvers<ContextType>;
  gh_DeleteLabelPayload?: gh_DeleteLabelPayloadResolvers<ContextType>;
  gh_DeleteLinkedBranchPayload?: gh_DeleteLinkedBranchPayloadResolvers<ContextType>;
  gh_DeletePackageVersionPayload?: gh_DeletePackageVersionPayloadResolvers<ContextType>;
  gh_DeleteProjectCardPayload?: gh_DeleteProjectCardPayloadResolvers<ContextType>;
  gh_DeleteProjectColumnPayload?: gh_DeleteProjectColumnPayloadResolvers<ContextType>;
  gh_DeleteProjectPayload?: gh_DeleteProjectPayloadResolvers<ContextType>;
  gh_DeleteProjectV2FieldPayload?: gh_DeleteProjectV2FieldPayloadResolvers<ContextType>;
  gh_DeleteProjectV2ItemPayload?: gh_DeleteProjectV2ItemPayloadResolvers<ContextType>;
  gh_DeleteProjectV2Payload?: gh_DeleteProjectV2PayloadResolvers<ContextType>;
  gh_DeleteProjectV2WorkflowPayload?: gh_DeleteProjectV2WorkflowPayloadResolvers<ContextType>;
  gh_DeletePullRequestReviewCommentPayload?: gh_DeletePullRequestReviewCommentPayloadResolvers<ContextType>;
  gh_DeletePullRequestReviewPayload?: gh_DeletePullRequestReviewPayloadResolvers<ContextType>;
  gh_DeleteRefPayload?: gh_DeleteRefPayloadResolvers<ContextType>;
  gh_DeleteRepositoryRulesetPayload?: gh_DeleteRepositoryRulesetPayloadResolvers<ContextType>;
  gh_DeleteTeamDiscussionCommentPayload?: gh_DeleteTeamDiscussionCommentPayloadResolvers<ContextType>;
  gh_DeleteTeamDiscussionPayload?: gh_DeleteTeamDiscussionPayloadResolvers<ContextType>;
  gh_DeleteUserListPayload?: gh_DeleteUserListPayloadResolvers<ContextType>;
  gh_DeleteVerifiableDomainPayload?: gh_DeleteVerifiableDomainPayloadResolvers<ContextType>;
  gh_DemilestonedEvent?: gh_DemilestonedEventResolvers<ContextType>;
  gh_DependabotUpdate?: gh_DependabotUpdateResolvers<ContextType>;
  gh_DependabotUpdateError?: gh_DependabotUpdateErrorResolvers<ContextType>;
  gh_DependencyGraphDependency?: gh_DependencyGraphDependencyResolvers<ContextType>;
  gh_DependencyGraphDependencyConnection?: gh_DependencyGraphDependencyConnectionResolvers<ContextType>;
  gh_DependencyGraphDependencyEdge?: gh_DependencyGraphDependencyEdgeResolvers<ContextType>;
  gh_DependencyGraphManifest?: gh_DependencyGraphManifestResolvers<ContextType>;
  gh_DependencyGraphManifestConnection?: gh_DependencyGraphManifestConnectionResolvers<ContextType>;
  gh_DependencyGraphManifestEdge?: gh_DependencyGraphManifestEdgeResolvers<ContextType>;
  gh_DeployKey?: gh_DeployKeyResolvers<ContextType>;
  gh_DeployKeyConnection?: gh_DeployKeyConnectionResolvers<ContextType>;
  gh_DeployKeyEdge?: gh_DeployKeyEdgeResolvers<ContextType>;
  gh_DeployedEvent?: gh_DeployedEventResolvers<ContextType>;
  gh_Deployment?: gh_DeploymentResolvers<ContextType>;
  gh_DeploymentConnection?: gh_DeploymentConnectionResolvers<ContextType>;
  gh_DeploymentEdge?: gh_DeploymentEdgeResolvers<ContextType>;
  gh_DeploymentEnvironmentChangedEvent?: gh_DeploymentEnvironmentChangedEventResolvers<ContextType>;
  gh_DeploymentProtectionRule?: gh_DeploymentProtectionRuleResolvers<ContextType>;
  gh_DeploymentProtectionRuleConnection?: gh_DeploymentProtectionRuleConnectionResolvers<ContextType>;
  gh_DeploymentProtectionRuleEdge?: gh_DeploymentProtectionRuleEdgeResolvers<ContextType>;
  gh_DeploymentRequest?: gh_DeploymentRequestResolvers<ContextType>;
  gh_DeploymentRequestConnection?: gh_DeploymentRequestConnectionResolvers<ContextType>;
  gh_DeploymentRequestEdge?: gh_DeploymentRequestEdgeResolvers<ContextType>;
  gh_DeploymentReview?: gh_DeploymentReviewResolvers<ContextType>;
  gh_DeploymentReviewConnection?: gh_DeploymentReviewConnectionResolvers<ContextType>;
  gh_DeploymentReviewEdge?: gh_DeploymentReviewEdgeResolvers<ContextType>;
  gh_DeploymentReviewer?: gh_DeploymentReviewerResolvers<ContextType>;
  gh_DeploymentReviewerConnection?: gh_DeploymentReviewerConnectionResolvers<ContextType>;
  gh_DeploymentReviewerEdge?: gh_DeploymentReviewerEdgeResolvers<ContextType>;
  gh_DeploymentStatus?: gh_DeploymentStatusResolvers<ContextType>;
  gh_DeploymentStatusConnection?: gh_DeploymentStatusConnectionResolvers<ContextType>;
  gh_DeploymentStatusEdge?: gh_DeploymentStatusEdgeResolvers<ContextType>;
  gh_DequeuePullRequestPayload?: gh_DequeuePullRequestPayloadResolvers<ContextType>;
  gh_DisablePullRequestAutoMergePayload?: gh_DisablePullRequestAutoMergePayloadResolvers<ContextType>;
  gh_DisconnectedEvent?: gh_DisconnectedEventResolvers<ContextType>;
  gh_Discussion?: gh_DiscussionResolvers<ContextType>;
  gh_DiscussionCategory?: gh_DiscussionCategoryResolvers<ContextType>;
  gh_DiscussionCategoryConnection?: gh_DiscussionCategoryConnectionResolvers<ContextType>;
  gh_DiscussionCategoryEdge?: gh_DiscussionCategoryEdgeResolvers<ContextType>;
  gh_DiscussionComment?: gh_DiscussionCommentResolvers<ContextType>;
  gh_DiscussionCommentConnection?: gh_DiscussionCommentConnectionResolvers<ContextType>;
  gh_DiscussionCommentEdge?: gh_DiscussionCommentEdgeResolvers<ContextType>;
  gh_DiscussionConnection?: gh_DiscussionConnectionResolvers<ContextType>;
  gh_DiscussionEdge?: gh_DiscussionEdgeResolvers<ContextType>;
  gh_DiscussionPoll?: gh_DiscussionPollResolvers<ContextType>;
  gh_DiscussionPollOption?: gh_DiscussionPollOptionResolvers<ContextType>;
  gh_DiscussionPollOptionConnection?: gh_DiscussionPollOptionConnectionResolvers<ContextType>;
  gh_DiscussionPollOptionEdge?: gh_DiscussionPollOptionEdgeResolvers<ContextType>;
  gh_DismissPullRequestReviewPayload?: gh_DismissPullRequestReviewPayloadResolvers<ContextType>;
  gh_DismissRepositoryVulnerabilityAlertPayload?: gh_DismissRepositoryVulnerabilityAlertPayloadResolvers<ContextType>;
  gh_DraftIssue?: gh_DraftIssueResolvers<ContextType>;
  gh_EnablePullRequestAutoMergePayload?: gh_EnablePullRequestAutoMergePayloadResolvers<ContextType>;
  gh_EnqueuePullRequestPayload?: gh_EnqueuePullRequestPayloadResolvers<ContextType>;
  gh_Enterprise?: gh_EnterpriseResolvers<ContextType>;
  gh_EnterpriseAdministratorConnection?: gh_EnterpriseAdministratorConnectionResolvers<ContextType>;
  gh_EnterpriseAdministratorEdge?: gh_EnterpriseAdministratorEdgeResolvers<ContextType>;
  gh_EnterpriseAdministratorInvitation?: gh_EnterpriseAdministratorInvitationResolvers<ContextType>;
  gh_EnterpriseAdministratorInvitationConnection?: gh_EnterpriseAdministratorInvitationConnectionResolvers<ContextType>;
  gh_EnterpriseAdministratorInvitationEdge?: gh_EnterpriseAdministratorInvitationEdgeResolvers<ContextType>;
  gh_EnterpriseAuditEntryData?: gh_EnterpriseAuditEntryDataResolvers<ContextType>;
  gh_EnterpriseBillingInfo?: gh_EnterpriseBillingInfoResolvers<ContextType>;
  gh_EnterpriseConnection?: gh_EnterpriseConnectionResolvers<ContextType>;
  gh_EnterpriseEdge?: gh_EnterpriseEdgeResolvers<ContextType>;
  gh_EnterpriseFailedInvitationConnection?: gh_EnterpriseFailedInvitationConnectionResolvers<ContextType>;
  gh_EnterpriseFailedInvitationEdge?: gh_EnterpriseFailedInvitationEdgeResolvers<ContextType>;
  gh_EnterpriseIdentityProvider?: gh_EnterpriseIdentityProviderResolvers<ContextType>;
  gh_EnterpriseMember?: gh_EnterpriseMemberResolvers<ContextType>;
  gh_EnterpriseMemberConnection?: gh_EnterpriseMemberConnectionResolvers<ContextType>;
  gh_EnterpriseMemberEdge?: gh_EnterpriseMemberEdgeResolvers<ContextType>;
  gh_EnterpriseOrganizationMembershipConnection?: gh_EnterpriseOrganizationMembershipConnectionResolvers<ContextType>;
  gh_EnterpriseOrganizationMembershipEdge?: gh_EnterpriseOrganizationMembershipEdgeResolvers<ContextType>;
  gh_EnterpriseOutsideCollaboratorConnection?: gh_EnterpriseOutsideCollaboratorConnectionResolvers<ContextType>;
  gh_EnterpriseOutsideCollaboratorEdge?: gh_EnterpriseOutsideCollaboratorEdgeResolvers<ContextType>;
  gh_EnterpriseOwnerInfo?: gh_EnterpriseOwnerInfoResolvers<ContextType>;
  gh_EnterprisePendingMemberInvitationConnection?: gh_EnterprisePendingMemberInvitationConnectionResolvers<ContextType>;
  gh_EnterprisePendingMemberInvitationEdge?: gh_EnterprisePendingMemberInvitationEdgeResolvers<ContextType>;
  gh_EnterpriseRepositoryInfo?: gh_EnterpriseRepositoryInfoResolvers<ContextType>;
  gh_EnterpriseRepositoryInfoConnection?: gh_EnterpriseRepositoryInfoConnectionResolvers<ContextType>;
  gh_EnterpriseRepositoryInfoEdge?: gh_EnterpriseRepositoryInfoEdgeResolvers<ContextType>;
  gh_EnterpriseServerInstallation?: gh_EnterpriseServerInstallationResolvers<ContextType>;
  gh_EnterpriseServerInstallationConnection?: gh_EnterpriseServerInstallationConnectionResolvers<ContextType>;
  gh_EnterpriseServerInstallationEdge?: gh_EnterpriseServerInstallationEdgeResolvers<ContextType>;
  gh_EnterpriseServerInstallationMembershipConnection?: gh_EnterpriseServerInstallationMembershipConnectionResolvers<ContextType>;
  gh_EnterpriseServerInstallationMembershipEdge?: gh_EnterpriseServerInstallationMembershipEdgeResolvers<ContextType>;
  gh_EnterpriseServerUserAccount?: gh_EnterpriseServerUserAccountResolvers<ContextType>;
  gh_EnterpriseServerUserAccountConnection?: gh_EnterpriseServerUserAccountConnectionResolvers<ContextType>;
  gh_EnterpriseServerUserAccountEdge?: gh_EnterpriseServerUserAccountEdgeResolvers<ContextType>;
  gh_EnterpriseServerUserAccountEmail?: gh_EnterpriseServerUserAccountEmailResolvers<ContextType>;
  gh_EnterpriseServerUserAccountEmailConnection?: gh_EnterpriseServerUserAccountEmailConnectionResolvers<ContextType>;
  gh_EnterpriseServerUserAccountEmailEdge?: gh_EnterpriseServerUserAccountEmailEdgeResolvers<ContextType>;
  gh_EnterpriseServerUserAccountsUpload?: gh_EnterpriseServerUserAccountsUploadResolvers<ContextType>;
  gh_EnterpriseServerUserAccountsUploadConnection?: gh_EnterpriseServerUserAccountsUploadConnectionResolvers<ContextType>;
  gh_EnterpriseServerUserAccountsUploadEdge?: gh_EnterpriseServerUserAccountsUploadEdgeResolvers<ContextType>;
  gh_EnterpriseUserAccount?: gh_EnterpriseUserAccountResolvers<ContextType>;
  gh_Environment?: gh_EnvironmentResolvers<ContextType>;
  gh_EnvironmentConnection?: gh_EnvironmentConnectionResolvers<ContextType>;
  gh_EnvironmentEdge?: gh_EnvironmentEdgeResolvers<ContextType>;
  gh_ExternalIdentity?: gh_ExternalIdentityResolvers<ContextType>;
  gh_ExternalIdentityAttribute?: gh_ExternalIdentityAttributeResolvers<ContextType>;
  gh_ExternalIdentityConnection?: gh_ExternalIdentityConnectionResolvers<ContextType>;
  gh_ExternalIdentityEdge?: gh_ExternalIdentityEdgeResolvers<ContextType>;
  gh_ExternalIdentitySamlAttributes?: gh_ExternalIdentitySamlAttributesResolvers<ContextType>;
  gh_ExternalIdentityScimAttributes?: gh_ExternalIdentityScimAttributesResolvers<ContextType>;
  gh_FollowOrganizationPayload?: gh_FollowOrganizationPayloadResolvers<ContextType>;
  gh_FollowUserPayload?: gh_FollowUserPayloadResolvers<ContextType>;
  gh_FollowerConnection?: gh_FollowerConnectionResolvers<ContextType>;
  gh_FollowingConnection?: gh_FollowingConnectionResolvers<ContextType>;
  gh_FundingLink?: gh_FundingLinkResolvers<ContextType>;
  gh_GenericHovercardContext?: gh_GenericHovercardContextResolvers<ContextType>;
  gh_Gist?: gh_GistResolvers<ContextType>;
  gh_GistComment?: gh_GistCommentResolvers<ContextType>;
  gh_GistCommentConnection?: gh_GistCommentConnectionResolvers<ContextType>;
  gh_GistCommentEdge?: gh_GistCommentEdgeResolvers<ContextType>;
  gh_GistConnection?: gh_GistConnectionResolvers<ContextType>;
  gh_GistEdge?: gh_GistEdgeResolvers<ContextType>;
  gh_GistFile?: gh_GistFileResolvers<ContextType>;
  gh_GitActor?: gh_GitActorResolvers<ContextType>;
  gh_GitActorConnection?: gh_GitActorConnectionResolvers<ContextType>;
  gh_GitActorEdge?: gh_GitActorEdgeResolvers<ContextType>;
  gh_GitHubMetadata?: gh_GitHubMetadataResolvers<ContextType>;
  gh_GitObject?: gh_GitObjectResolvers<ContextType>;
  gh_GitObjectID?: GraphQLScalarType;
  gh_GitRefname?: GraphQLScalarType;
  gh_GitSSHRemote?: GraphQLScalarType;
  gh_GitSignature?: gh_GitSignatureResolvers<ContextType>;
  gh_GitTimestamp?: GraphQLScalarType;
  gh_GpgSignature?: gh_GpgSignatureResolvers<ContextType>;
  gh_GrantEnterpriseOrganizationsMigratorRolePayload?: gh_GrantEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType>;
  gh_GrantMigratorRolePayload?: gh_GrantMigratorRolePayloadResolvers<ContextType>;
  gh_HTML?: GraphQLScalarType;
  gh_HeadRefDeletedEvent?: gh_HeadRefDeletedEventResolvers<ContextType>;
  gh_HeadRefForcePushedEvent?: gh_HeadRefForcePushedEventResolvers<ContextType>;
  gh_HeadRefRestoredEvent?: gh_HeadRefRestoredEventResolvers<ContextType>;
  gh_Hovercard?: gh_HovercardResolvers<ContextType>;
  gh_HovercardContext?: gh_HovercardContextResolvers<ContextType>;
  gh_ImportProjectPayload?: gh_ImportProjectPayloadResolvers<ContextType>;
  gh_InviteEnterpriseAdminPayload?: gh_InviteEnterpriseAdminPayloadResolvers<ContextType>;
  gh_IpAllowListEntry?: gh_IpAllowListEntryResolvers<ContextType>;
  gh_IpAllowListEntryConnection?: gh_IpAllowListEntryConnectionResolvers<ContextType>;
  gh_IpAllowListEntryEdge?: gh_IpAllowListEntryEdgeResolvers<ContextType>;
  gh_IpAllowListOwner?: gh_IpAllowListOwnerResolvers<ContextType>;
  gh_Issue?: gh_IssueResolvers<ContextType>;
  gh_IssueComment?: gh_IssueCommentResolvers<ContextType>;
  gh_IssueCommentConnection?: gh_IssueCommentConnectionResolvers<ContextType>;
  gh_IssueCommentEdge?: gh_IssueCommentEdgeResolvers<ContextType>;
  gh_IssueConnection?: gh_IssueConnectionResolvers<ContextType>;
  gh_IssueContributionsByRepository?: gh_IssueContributionsByRepositoryResolvers<ContextType>;
  gh_IssueEdge?: gh_IssueEdgeResolvers<ContextType>;
  gh_IssueOrPullRequest?: gh_IssueOrPullRequestResolvers<ContextType>;
  gh_IssueTemplate?: gh_IssueTemplateResolvers<ContextType>;
  gh_IssueTimelineConnection?: gh_IssueTimelineConnectionResolvers<ContextType>;
  gh_IssueTimelineItem?: gh_IssueTimelineItemResolvers<ContextType>;
  gh_IssueTimelineItemEdge?: gh_IssueTimelineItemEdgeResolvers<ContextType>;
  gh_IssueTimelineItems?: gh_IssueTimelineItemsResolvers<ContextType>;
  gh_IssueTimelineItemsConnection?: gh_IssueTimelineItemsConnectionResolvers<ContextType>;
  gh_IssueTimelineItemsEdge?: gh_IssueTimelineItemsEdgeResolvers<ContextType>;
  gh_JoinedGitHubContribution?: gh_JoinedGitHubContributionResolvers<ContextType>;
  gh_Label?: gh_LabelResolvers<ContextType>;
  gh_LabelConnection?: gh_LabelConnectionResolvers<ContextType>;
  gh_LabelEdge?: gh_LabelEdgeResolvers<ContextType>;
  gh_Labelable?: gh_LabelableResolvers<ContextType>;
  gh_LabeledEvent?: gh_LabeledEventResolvers<ContextType>;
  gh_Language?: gh_LanguageResolvers<ContextType>;
  gh_LanguageConnection?: gh_LanguageConnectionResolvers<ContextType>;
  gh_LanguageEdge?: gh_LanguageEdgeResolvers<ContextType>;
  gh_License?: gh_LicenseResolvers<ContextType>;
  gh_LicenseRule?: gh_LicenseRuleResolvers<ContextType>;
  gh_LinkProjectV2ToRepositoryPayload?: gh_LinkProjectV2ToRepositoryPayloadResolvers<ContextType>;
  gh_LinkProjectV2ToTeamPayload?: gh_LinkProjectV2ToTeamPayloadResolvers<ContextType>;
  gh_LinkRepositoryToProjectPayload?: gh_LinkRepositoryToProjectPayloadResolvers<ContextType>;
  gh_LinkedBranch?: gh_LinkedBranchResolvers<ContextType>;
  gh_LinkedBranchConnection?: gh_LinkedBranchConnectionResolvers<ContextType>;
  gh_LinkedBranchEdge?: gh_LinkedBranchEdgeResolvers<ContextType>;
  gh_LockLockablePayload?: gh_LockLockablePayloadResolvers<ContextType>;
  gh_Lockable?: gh_LockableResolvers<ContextType>;
  gh_LockedEvent?: gh_LockedEventResolvers<ContextType>;
  gh_Mannequin?: gh_MannequinResolvers<ContextType>;
  gh_MannequinConnection?: gh_MannequinConnectionResolvers<ContextType>;
  gh_MannequinEdge?: gh_MannequinEdgeResolvers<ContextType>;
  gh_MarkDiscussionCommentAsAnswerPayload?: gh_MarkDiscussionCommentAsAnswerPayloadResolvers<ContextType>;
  gh_MarkFileAsViewedPayload?: gh_MarkFileAsViewedPayloadResolvers<ContextType>;
  gh_MarkProjectV2AsTemplatePayload?: gh_MarkProjectV2AsTemplatePayloadResolvers<ContextType>;
  gh_MarkPullRequestReadyForReviewPayload?: gh_MarkPullRequestReadyForReviewPayloadResolvers<ContextType>;
  gh_MarkedAsDuplicateEvent?: gh_MarkedAsDuplicateEventResolvers<ContextType>;
  gh_MarketplaceCategory?: gh_MarketplaceCategoryResolvers<ContextType>;
  gh_MarketplaceListing?: gh_MarketplaceListingResolvers<ContextType>;
  gh_MarketplaceListingConnection?: gh_MarketplaceListingConnectionResolvers<ContextType>;
  gh_MarketplaceListingEdge?: gh_MarketplaceListingEdgeResolvers<ContextType>;
  gh_MemberFeatureRequestNotification?: gh_MemberFeatureRequestNotificationResolvers<ContextType>;
  gh_MemberStatusable?: gh_MemberStatusableResolvers<ContextType>;
  gh_MembersCanDeleteReposClearAuditEntry?: gh_MembersCanDeleteReposClearAuditEntryResolvers<ContextType>;
  gh_MembersCanDeleteReposDisableAuditEntry?: gh_MembersCanDeleteReposDisableAuditEntryResolvers<ContextType>;
  gh_MembersCanDeleteReposEnableAuditEntry?: gh_MembersCanDeleteReposEnableAuditEntryResolvers<ContextType>;
  gh_MentionedEvent?: gh_MentionedEventResolvers<ContextType>;
  gh_MergeBranchPayload?: gh_MergeBranchPayloadResolvers<ContextType>;
  gh_MergePullRequestPayload?: gh_MergePullRequestPayloadResolvers<ContextType>;
  gh_MergeQueue?: gh_MergeQueueResolvers<ContextType>;
  gh_MergeQueueConfiguration?: gh_MergeQueueConfigurationResolvers<ContextType>;
  gh_MergeQueueEntry?: gh_MergeQueueEntryResolvers<ContextType>;
  gh_MergeQueueEntryConnection?: gh_MergeQueueEntryConnectionResolvers<ContextType>;
  gh_MergeQueueEntryEdge?: gh_MergeQueueEntryEdgeResolvers<ContextType>;
  gh_MergedEvent?: gh_MergedEventResolvers<ContextType>;
  gh_Migration?: gh_MigrationResolvers<ContextType>;
  gh_MigrationSource?: gh_MigrationSourceResolvers<ContextType>;
  gh_Milestone?: gh_MilestoneResolvers<ContextType>;
  gh_MilestoneConnection?: gh_MilestoneConnectionResolvers<ContextType>;
  gh_MilestoneEdge?: gh_MilestoneEdgeResolvers<ContextType>;
  gh_MilestoneItem?: gh_MilestoneItemResolvers<ContextType>;
  gh_MilestonedEvent?: gh_MilestonedEventResolvers<ContextType>;
  gh_Minimizable?: gh_MinimizableResolvers<ContextType>;
  gh_MinimizeCommentPayload?: gh_MinimizeCommentPayloadResolvers<ContextType>;
  gh_MoveProjectCardPayload?: gh_MoveProjectCardPayloadResolvers<ContextType>;
  gh_MoveProjectColumnPayload?: gh_MoveProjectColumnPayloadResolvers<ContextType>;
  gh_MovedColumnsInProjectEvent?: gh_MovedColumnsInProjectEventResolvers<ContextType>;
  gh_Node?: gh_NodeResolvers<ContextType>;
  gh_OIDCProvider?: gh_OIDCProviderResolvers<ContextType>;
  gh_OauthApplicationAuditEntryData?: gh_OauthApplicationAuditEntryDataResolvers<ContextType>;
  gh_OauthApplicationCreateAuditEntry?: gh_OauthApplicationCreateAuditEntryResolvers<ContextType>;
  gh_OrgAddBillingManagerAuditEntry?: gh_OrgAddBillingManagerAuditEntryResolvers<ContextType>;
  gh_OrgAddMemberAuditEntry?: gh_OrgAddMemberAuditEntryResolvers<ContextType>;
  gh_OrgBlockUserAuditEntry?: gh_OrgBlockUserAuditEntryResolvers<ContextType>;
  gh_OrgConfigDisableCollaboratorsOnlyAuditEntry?: gh_OrgConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  gh_OrgConfigEnableCollaboratorsOnlyAuditEntry?: gh_OrgConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  gh_OrgCreateAuditEntry?: gh_OrgCreateAuditEntryResolvers<ContextType>;
  gh_OrgDisableOauthAppRestrictionsAuditEntry?: gh_OrgDisableOauthAppRestrictionsAuditEntryResolvers<ContextType>;
  gh_OrgDisableSamlAuditEntry?: gh_OrgDisableSamlAuditEntryResolvers<ContextType>;
  gh_OrgDisableTwoFactorRequirementAuditEntry?: gh_OrgDisableTwoFactorRequirementAuditEntryResolvers<ContextType>;
  gh_OrgEnableOauthAppRestrictionsAuditEntry?: gh_OrgEnableOauthAppRestrictionsAuditEntryResolvers<ContextType>;
  gh_OrgEnableSamlAuditEntry?: gh_OrgEnableSamlAuditEntryResolvers<ContextType>;
  gh_OrgEnableTwoFactorRequirementAuditEntry?: gh_OrgEnableTwoFactorRequirementAuditEntryResolvers<ContextType>;
  gh_OrgInviteMemberAuditEntry?: gh_OrgInviteMemberAuditEntryResolvers<ContextType>;
  gh_OrgInviteToBusinessAuditEntry?: gh_OrgInviteToBusinessAuditEntryResolvers<ContextType>;
  gh_OrgOauthAppAccessApprovedAuditEntry?: gh_OrgOauthAppAccessApprovedAuditEntryResolvers<ContextType>;
  gh_OrgOauthAppAccessBlockedAuditEntry?: gh_OrgOauthAppAccessBlockedAuditEntryResolvers<ContextType>;
  gh_OrgOauthAppAccessDeniedAuditEntry?: gh_OrgOauthAppAccessDeniedAuditEntryResolvers<ContextType>;
  gh_OrgOauthAppAccessRequestedAuditEntry?: gh_OrgOauthAppAccessRequestedAuditEntryResolvers<ContextType>;
  gh_OrgOauthAppAccessUnblockedAuditEntry?: gh_OrgOauthAppAccessUnblockedAuditEntryResolvers<ContextType>;
  gh_OrgRemoveBillingManagerAuditEntry?: gh_OrgRemoveBillingManagerAuditEntryResolvers<ContextType>;
  gh_OrgRemoveMemberAuditEntry?: gh_OrgRemoveMemberAuditEntryResolvers<ContextType>;
  gh_OrgRemoveOutsideCollaboratorAuditEntry?: gh_OrgRemoveOutsideCollaboratorAuditEntryResolvers<ContextType>;
  gh_OrgRestoreMemberAuditEntry?: gh_OrgRestoreMemberAuditEntryResolvers<ContextType>;
  gh_OrgRestoreMemberAuditEntryMembership?: gh_OrgRestoreMemberAuditEntryMembershipResolvers<ContextType>;
  gh_OrgRestoreMemberMembershipOrganizationAuditEntryData?: gh_OrgRestoreMemberMembershipOrganizationAuditEntryDataResolvers<ContextType>;
  gh_OrgRestoreMemberMembershipRepositoryAuditEntryData?: gh_OrgRestoreMemberMembershipRepositoryAuditEntryDataResolvers<ContextType>;
  gh_OrgRestoreMemberMembershipTeamAuditEntryData?: gh_OrgRestoreMemberMembershipTeamAuditEntryDataResolvers<ContextType>;
  gh_OrgUnblockUserAuditEntry?: gh_OrgUnblockUserAuditEntryResolvers<ContextType>;
  gh_OrgUpdateDefaultRepositoryPermissionAuditEntry?: gh_OrgUpdateDefaultRepositoryPermissionAuditEntryResolvers<ContextType>;
  gh_OrgUpdateMemberAuditEntry?: gh_OrgUpdateMemberAuditEntryResolvers<ContextType>;
  gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntry?: gh_OrgUpdateMemberRepositoryCreationPermissionAuditEntryResolvers<ContextType>;
  gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry?: gh_OrgUpdateMemberRepositoryInvitationPermissionAuditEntryResolvers<ContextType>;
  gh_Organization?: gh_OrganizationResolvers<ContextType>;
  gh_OrganizationAuditEntry?: gh_OrganizationAuditEntryResolvers<ContextType>;
  gh_OrganizationAuditEntryConnection?: gh_OrganizationAuditEntryConnectionResolvers<ContextType>;
  gh_OrganizationAuditEntryData?: gh_OrganizationAuditEntryDataResolvers<ContextType>;
  gh_OrganizationAuditEntryEdge?: gh_OrganizationAuditEntryEdgeResolvers<ContextType>;
  gh_OrganizationConnection?: gh_OrganizationConnectionResolvers<ContextType>;
  gh_OrganizationEdge?: gh_OrganizationEdgeResolvers<ContextType>;
  gh_OrganizationEnterpriseOwnerConnection?: gh_OrganizationEnterpriseOwnerConnectionResolvers<ContextType>;
  gh_OrganizationEnterpriseOwnerEdge?: gh_OrganizationEnterpriseOwnerEdgeResolvers<ContextType>;
  gh_OrganizationIdentityProvider?: gh_OrganizationIdentityProviderResolvers<ContextType>;
  gh_OrganizationInvitation?: gh_OrganizationInvitationResolvers<ContextType>;
  gh_OrganizationInvitationConnection?: gh_OrganizationInvitationConnectionResolvers<ContextType>;
  gh_OrganizationInvitationEdge?: gh_OrganizationInvitationEdgeResolvers<ContextType>;
  gh_OrganizationMemberConnection?: gh_OrganizationMemberConnectionResolvers<ContextType>;
  gh_OrganizationMemberEdge?: gh_OrganizationMemberEdgeResolvers<ContextType>;
  gh_OrganizationMigration?: gh_OrganizationMigrationResolvers<ContextType>;
  gh_OrganizationOrUser?: gh_OrganizationOrUserResolvers<ContextType>;
  gh_OrganizationTeamsHovercardContext?: gh_OrganizationTeamsHovercardContextResolvers<ContextType>;
  gh_OrganizationsHovercardContext?: gh_OrganizationsHovercardContextResolvers<ContextType>;
  gh_Package?: gh_PackageResolvers<ContextType>;
  gh_PackageConnection?: gh_PackageConnectionResolvers<ContextType>;
  gh_PackageEdge?: gh_PackageEdgeResolvers<ContextType>;
  gh_PackageFile?: gh_PackageFileResolvers<ContextType>;
  gh_PackageFileConnection?: gh_PackageFileConnectionResolvers<ContextType>;
  gh_PackageFileEdge?: gh_PackageFileEdgeResolvers<ContextType>;
  gh_PackageOwner?: gh_PackageOwnerResolvers<ContextType>;
  gh_PackageStatistics?: gh_PackageStatisticsResolvers<ContextType>;
  gh_PackageTag?: gh_PackageTagResolvers<ContextType>;
  gh_PackageVersion?: gh_PackageVersionResolvers<ContextType>;
  gh_PackageVersionConnection?: gh_PackageVersionConnectionResolvers<ContextType>;
  gh_PackageVersionEdge?: gh_PackageVersionEdgeResolvers<ContextType>;
  gh_PackageVersionStatistics?: gh_PackageVersionStatisticsResolvers<ContextType>;
  gh_PageInfo?: gh_PageInfoResolvers<ContextType>;
  gh_PermissionGranter?: gh_PermissionGranterResolvers<ContextType>;
  gh_PermissionSource?: gh_PermissionSourceResolvers<ContextType>;
  gh_PinIssuePayload?: gh_PinIssuePayloadResolvers<ContextType>;
  gh_PinnableItem?: gh_PinnableItemResolvers<ContextType>;
  gh_PinnableItemConnection?: gh_PinnableItemConnectionResolvers<ContextType>;
  gh_PinnableItemEdge?: gh_PinnableItemEdgeResolvers<ContextType>;
  gh_PinnedDiscussion?: gh_PinnedDiscussionResolvers<ContextType>;
  gh_PinnedDiscussionConnection?: gh_PinnedDiscussionConnectionResolvers<ContextType>;
  gh_PinnedDiscussionEdge?: gh_PinnedDiscussionEdgeResolvers<ContextType>;
  gh_PinnedEvent?: gh_PinnedEventResolvers<ContextType>;
  gh_PinnedIssue?: gh_PinnedIssueResolvers<ContextType>;
  gh_PinnedIssueConnection?: gh_PinnedIssueConnectionResolvers<ContextType>;
  gh_PinnedIssueEdge?: gh_PinnedIssueEdgeResolvers<ContextType>;
  gh_PreciseDateTime?: GraphQLScalarType;
  gh_PrivateRepositoryForkingDisableAuditEntry?: gh_PrivateRepositoryForkingDisableAuditEntryResolvers<ContextType>;
  gh_PrivateRepositoryForkingEnableAuditEntry?: gh_PrivateRepositoryForkingEnableAuditEntryResolvers<ContextType>;
  gh_ProfileItemShowcase?: gh_ProfileItemShowcaseResolvers<ContextType>;
  gh_ProfileOwner?: gh_ProfileOwnerResolvers<ContextType>;
  gh_Project?: gh_ProjectResolvers<ContextType>;
  gh_ProjectCard?: gh_ProjectCardResolvers<ContextType>;
  gh_ProjectCardConnection?: gh_ProjectCardConnectionResolvers<ContextType>;
  gh_ProjectCardEdge?: gh_ProjectCardEdgeResolvers<ContextType>;
  gh_ProjectCardItem?: gh_ProjectCardItemResolvers<ContextType>;
  gh_ProjectColumn?: gh_ProjectColumnResolvers<ContextType>;
  gh_ProjectColumnConnection?: gh_ProjectColumnConnectionResolvers<ContextType>;
  gh_ProjectColumnEdge?: gh_ProjectColumnEdgeResolvers<ContextType>;
  gh_ProjectConnection?: gh_ProjectConnectionResolvers<ContextType>;
  gh_ProjectEdge?: gh_ProjectEdgeResolvers<ContextType>;
  gh_ProjectOwner?: gh_ProjectOwnerResolvers<ContextType>;
  gh_ProjectProgress?: gh_ProjectProgressResolvers<ContextType>;
  gh_ProjectV2?: gh_ProjectV2Resolvers<ContextType>;
  gh_ProjectV2Actor?: gh_ProjectV2ActorResolvers<ContextType>;
  gh_ProjectV2ActorConnection?: gh_ProjectV2ActorConnectionResolvers<ContextType>;
  gh_ProjectV2ActorEdge?: gh_ProjectV2ActorEdgeResolvers<ContextType>;
  gh_ProjectV2Connection?: gh_ProjectV2ConnectionResolvers<ContextType>;
  gh_ProjectV2Edge?: gh_ProjectV2EdgeResolvers<ContextType>;
  gh_ProjectV2Field?: gh_ProjectV2FieldResolvers<ContextType>;
  gh_ProjectV2FieldCommon?: gh_ProjectV2FieldCommonResolvers<ContextType>;
  gh_ProjectV2FieldConfiguration?: gh_ProjectV2FieldConfigurationResolvers<ContextType>;
  gh_ProjectV2FieldConfigurationConnection?: gh_ProjectV2FieldConfigurationConnectionResolvers<ContextType>;
  gh_ProjectV2FieldConfigurationEdge?: gh_ProjectV2FieldConfigurationEdgeResolvers<ContextType>;
  gh_ProjectV2FieldConnection?: gh_ProjectV2FieldConnectionResolvers<ContextType>;
  gh_ProjectV2FieldEdge?: gh_ProjectV2FieldEdgeResolvers<ContextType>;
  gh_ProjectV2Item?: gh_ProjectV2ItemResolvers<ContextType>;
  gh_ProjectV2ItemConnection?: gh_ProjectV2ItemConnectionResolvers<ContextType>;
  gh_ProjectV2ItemContent?: gh_ProjectV2ItemContentResolvers<ContextType>;
  gh_ProjectV2ItemEdge?: gh_ProjectV2ItemEdgeResolvers<ContextType>;
  gh_ProjectV2ItemFieldDateValue?: gh_ProjectV2ItemFieldDateValueResolvers<ContextType>;
  gh_ProjectV2ItemFieldIterationValue?: gh_ProjectV2ItemFieldIterationValueResolvers<ContextType>;
  gh_ProjectV2ItemFieldLabelValue?: gh_ProjectV2ItemFieldLabelValueResolvers<ContextType>;
  gh_ProjectV2ItemFieldMilestoneValue?: gh_ProjectV2ItemFieldMilestoneValueResolvers<ContextType>;
  gh_ProjectV2ItemFieldNumberValue?: gh_ProjectV2ItemFieldNumberValueResolvers<ContextType>;
  gh_ProjectV2ItemFieldPullRequestValue?: gh_ProjectV2ItemFieldPullRequestValueResolvers<ContextType>;
  gh_ProjectV2ItemFieldRepositoryValue?: gh_ProjectV2ItemFieldRepositoryValueResolvers<ContextType>;
  gh_ProjectV2ItemFieldReviewerValue?: gh_ProjectV2ItemFieldReviewerValueResolvers<ContextType>;
  gh_ProjectV2ItemFieldSingleSelectValue?: gh_ProjectV2ItemFieldSingleSelectValueResolvers<ContextType>;
  gh_ProjectV2ItemFieldTextValue?: gh_ProjectV2ItemFieldTextValueResolvers<ContextType>;
  gh_ProjectV2ItemFieldUserValue?: gh_ProjectV2ItemFieldUserValueResolvers<ContextType>;
  gh_ProjectV2ItemFieldValue?: gh_ProjectV2ItemFieldValueResolvers<ContextType>;
  gh_ProjectV2ItemFieldValueCommon?: gh_ProjectV2ItemFieldValueCommonResolvers<ContextType>;
  gh_ProjectV2ItemFieldValueConnection?: gh_ProjectV2ItemFieldValueConnectionResolvers<ContextType>;
  gh_ProjectV2ItemFieldValueEdge?: gh_ProjectV2ItemFieldValueEdgeResolvers<ContextType>;
  gh_ProjectV2IterationField?: gh_ProjectV2IterationFieldResolvers<ContextType>;
  gh_ProjectV2IterationFieldConfiguration?: gh_ProjectV2IterationFieldConfigurationResolvers<ContextType>;
  gh_ProjectV2IterationFieldIteration?: gh_ProjectV2IterationFieldIterationResolvers<ContextType>;
  gh_ProjectV2Owner?: gh_ProjectV2OwnerResolvers<ContextType>;
  gh_ProjectV2Recent?: gh_ProjectV2RecentResolvers<ContextType>;
  gh_ProjectV2SingleSelectField?: gh_ProjectV2SingleSelectFieldResolvers<ContextType>;
  gh_ProjectV2SingleSelectFieldOption?: gh_ProjectV2SingleSelectFieldOptionResolvers<ContextType>;
  gh_ProjectV2SortBy?: gh_ProjectV2SortByResolvers<ContextType>;
  gh_ProjectV2SortByConnection?: gh_ProjectV2SortByConnectionResolvers<ContextType>;
  gh_ProjectV2SortByEdge?: gh_ProjectV2SortByEdgeResolvers<ContextType>;
  gh_ProjectV2SortByField?: gh_ProjectV2SortByFieldResolvers<ContextType>;
  gh_ProjectV2SortByFieldConnection?: gh_ProjectV2SortByFieldConnectionResolvers<ContextType>;
  gh_ProjectV2SortByFieldEdge?: gh_ProjectV2SortByFieldEdgeResolvers<ContextType>;
  gh_ProjectV2View?: gh_ProjectV2ViewResolvers<ContextType>;
  gh_ProjectV2ViewConnection?: gh_ProjectV2ViewConnectionResolvers<ContextType>;
  gh_ProjectV2ViewEdge?: gh_ProjectV2ViewEdgeResolvers<ContextType>;
  gh_ProjectV2Workflow?: gh_ProjectV2WorkflowResolvers<ContextType>;
  gh_ProjectV2WorkflowConnection?: gh_ProjectV2WorkflowConnectionResolvers<ContextType>;
  gh_ProjectV2WorkflowEdge?: gh_ProjectV2WorkflowEdgeResolvers<ContextType>;
  gh_PublicKey?: gh_PublicKeyResolvers<ContextType>;
  gh_PublicKeyConnection?: gh_PublicKeyConnectionResolvers<ContextType>;
  gh_PublicKeyEdge?: gh_PublicKeyEdgeResolvers<ContextType>;
  gh_PublishSponsorsTierPayload?: gh_PublishSponsorsTierPayloadResolvers<ContextType>;
  gh_PullRequest?: gh_PullRequestResolvers<ContextType>;
  gh_PullRequestChangedFile?: gh_PullRequestChangedFileResolvers<ContextType>;
  gh_PullRequestChangedFileConnection?: gh_PullRequestChangedFileConnectionResolvers<ContextType>;
  gh_PullRequestChangedFileEdge?: gh_PullRequestChangedFileEdgeResolvers<ContextType>;
  gh_PullRequestCommit?: gh_PullRequestCommitResolvers<ContextType>;
  gh_PullRequestCommitCommentThread?: gh_PullRequestCommitCommentThreadResolvers<ContextType>;
  gh_PullRequestCommitConnection?: gh_PullRequestCommitConnectionResolvers<ContextType>;
  gh_PullRequestCommitEdge?: gh_PullRequestCommitEdgeResolvers<ContextType>;
  gh_PullRequestConnection?: gh_PullRequestConnectionResolvers<ContextType>;
  gh_PullRequestContributionsByRepository?: gh_PullRequestContributionsByRepositoryResolvers<ContextType>;
  gh_PullRequestEdge?: gh_PullRequestEdgeResolvers<ContextType>;
  gh_PullRequestParameters?: gh_PullRequestParametersResolvers<ContextType>;
  gh_PullRequestReview?: gh_PullRequestReviewResolvers<ContextType>;
  gh_PullRequestReviewComment?: gh_PullRequestReviewCommentResolvers<ContextType>;
  gh_PullRequestReviewCommentConnection?: gh_PullRequestReviewCommentConnectionResolvers<ContextType>;
  gh_PullRequestReviewCommentEdge?: gh_PullRequestReviewCommentEdgeResolvers<ContextType>;
  gh_PullRequestReviewConnection?: gh_PullRequestReviewConnectionResolvers<ContextType>;
  gh_PullRequestReviewContributionsByRepository?: gh_PullRequestReviewContributionsByRepositoryResolvers<ContextType>;
  gh_PullRequestReviewEdge?: gh_PullRequestReviewEdgeResolvers<ContextType>;
  gh_PullRequestReviewThread?: gh_PullRequestReviewThreadResolvers<ContextType>;
  gh_PullRequestReviewThreadConnection?: gh_PullRequestReviewThreadConnectionResolvers<ContextType>;
  gh_PullRequestReviewThreadEdge?: gh_PullRequestReviewThreadEdgeResolvers<ContextType>;
  gh_PullRequestRevisionMarker?: gh_PullRequestRevisionMarkerResolvers<ContextType>;
  gh_PullRequestTemplate?: gh_PullRequestTemplateResolvers<ContextType>;
  gh_PullRequestThread?: gh_PullRequestThreadResolvers<ContextType>;
  gh_PullRequestTimelineConnection?: gh_PullRequestTimelineConnectionResolvers<ContextType>;
  gh_PullRequestTimelineItem?: gh_PullRequestTimelineItemResolvers<ContextType>;
  gh_PullRequestTimelineItemEdge?: gh_PullRequestTimelineItemEdgeResolvers<ContextType>;
  gh_PullRequestTimelineItems?: gh_PullRequestTimelineItemsResolvers<ContextType>;
  gh_PullRequestTimelineItemsConnection?: gh_PullRequestTimelineItemsConnectionResolvers<ContextType>;
  gh_PullRequestTimelineItemsEdge?: gh_PullRequestTimelineItemsEdgeResolvers<ContextType>;
  gh_Push?: gh_PushResolvers<ContextType>;
  gh_PushAllowance?: gh_PushAllowanceResolvers<ContextType>;
  gh_PushAllowanceActor?: gh_PushAllowanceActorResolvers<ContextType>;
  gh_PushAllowanceConnection?: gh_PushAllowanceConnectionResolvers<ContextType>;
  gh_PushAllowanceEdge?: gh_PushAllowanceEdgeResolvers<ContextType>;
  gh_RateLimit?: gh_RateLimitResolvers<ContextType>;
  gh_Reactable?: gh_ReactableResolvers<ContextType>;
  gh_ReactingUserConnection?: gh_ReactingUserConnectionResolvers<ContextType>;
  gh_ReactingUserEdge?: gh_ReactingUserEdgeResolvers<ContextType>;
  gh_Reaction?: gh_ReactionResolvers<ContextType>;
  gh_ReactionConnection?: gh_ReactionConnectionResolvers<ContextType>;
  gh_ReactionEdge?: gh_ReactionEdgeResolvers<ContextType>;
  gh_ReactionGroup?: gh_ReactionGroupResolvers<ContextType>;
  gh_Reactor?: gh_ReactorResolvers<ContextType>;
  gh_ReactorConnection?: gh_ReactorConnectionResolvers<ContextType>;
  gh_ReactorEdge?: gh_ReactorEdgeResolvers<ContextType>;
  gh_ReadyForReviewEvent?: gh_ReadyForReviewEventResolvers<ContextType>;
  gh_Ref?: gh_RefResolvers<ContextType>;
  gh_RefConnection?: gh_RefConnectionResolvers<ContextType>;
  gh_RefEdge?: gh_RefEdgeResolvers<ContextType>;
  gh_RefNameConditionTarget?: gh_RefNameConditionTargetResolvers<ContextType>;
  gh_RefUpdateRule?: gh_RefUpdateRuleResolvers<ContextType>;
  gh_ReferencedEvent?: gh_ReferencedEventResolvers<ContextType>;
  gh_ReferencedSubject?: gh_ReferencedSubjectResolvers<ContextType>;
  gh_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload?: gh_RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadResolvers<ContextType>;
  gh_RegenerateVerifiableDomainTokenPayload?: gh_RegenerateVerifiableDomainTokenPayloadResolvers<ContextType>;
  gh_RejectDeploymentsPayload?: gh_RejectDeploymentsPayloadResolvers<ContextType>;
  gh_Release?: gh_ReleaseResolvers<ContextType>;
  gh_ReleaseAsset?: gh_ReleaseAssetResolvers<ContextType>;
  gh_ReleaseAssetConnection?: gh_ReleaseAssetConnectionResolvers<ContextType>;
  gh_ReleaseAssetEdge?: gh_ReleaseAssetEdgeResolvers<ContextType>;
  gh_ReleaseConnection?: gh_ReleaseConnectionResolvers<ContextType>;
  gh_ReleaseEdge?: gh_ReleaseEdgeResolvers<ContextType>;
  gh_RemoveAssigneesFromAssignablePayload?: gh_RemoveAssigneesFromAssignablePayloadResolvers<ContextType>;
  gh_RemoveEnterpriseAdminPayload?: gh_RemoveEnterpriseAdminPayloadResolvers<ContextType>;
  gh_RemoveEnterpriseIdentityProviderPayload?: gh_RemoveEnterpriseIdentityProviderPayloadResolvers<ContextType>;
  gh_RemoveEnterpriseMemberPayload?: gh_RemoveEnterpriseMemberPayloadResolvers<ContextType>;
  gh_RemoveEnterpriseOrganizationPayload?: gh_RemoveEnterpriseOrganizationPayloadResolvers<ContextType>;
  gh_RemoveEnterpriseSupportEntitlementPayload?: gh_RemoveEnterpriseSupportEntitlementPayloadResolvers<ContextType>;
  gh_RemoveLabelsFromLabelablePayload?: gh_RemoveLabelsFromLabelablePayloadResolvers<ContextType>;
  gh_RemoveOutsideCollaboratorPayload?: gh_RemoveOutsideCollaboratorPayloadResolvers<ContextType>;
  gh_RemoveReactionPayload?: gh_RemoveReactionPayloadResolvers<ContextType>;
  gh_RemoveStarPayload?: gh_RemoveStarPayloadResolvers<ContextType>;
  gh_RemoveUpvotePayload?: gh_RemoveUpvotePayloadResolvers<ContextType>;
  gh_RemovedFromMergeQueueEvent?: gh_RemovedFromMergeQueueEventResolvers<ContextType>;
  gh_RemovedFromProjectEvent?: gh_RemovedFromProjectEventResolvers<ContextType>;
  gh_RenamedTitleEvent?: gh_RenamedTitleEventResolvers<ContextType>;
  gh_RenamedTitleSubject?: gh_RenamedTitleSubjectResolvers<ContextType>;
  gh_ReopenDiscussionPayload?: gh_ReopenDiscussionPayloadResolvers<ContextType>;
  gh_ReopenIssuePayload?: gh_ReopenIssuePayloadResolvers<ContextType>;
  gh_ReopenPullRequestPayload?: gh_ReopenPullRequestPayloadResolvers<ContextType>;
  gh_ReopenedEvent?: gh_ReopenedEventResolvers<ContextType>;
  gh_RepoAccessAuditEntry?: gh_RepoAccessAuditEntryResolvers<ContextType>;
  gh_RepoAddMemberAuditEntry?: gh_RepoAddMemberAuditEntryResolvers<ContextType>;
  gh_RepoAddTopicAuditEntry?: gh_RepoAddTopicAuditEntryResolvers<ContextType>;
  gh_RepoArchivedAuditEntry?: gh_RepoArchivedAuditEntryResolvers<ContextType>;
  gh_RepoChangeMergeSettingAuditEntry?: gh_RepoChangeMergeSettingAuditEntryResolvers<ContextType>;
  gh_RepoConfigDisableAnonymousGitAccessAuditEntry?: gh_RepoConfigDisableAnonymousGitAccessAuditEntryResolvers<ContextType>;
  gh_RepoConfigDisableCollaboratorsOnlyAuditEntry?: gh_RepoConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  gh_RepoConfigDisableContributorsOnlyAuditEntry?: gh_RepoConfigDisableContributorsOnlyAuditEntryResolvers<ContextType>;
  gh_RepoConfigDisableSockpuppetDisallowedAuditEntry?: gh_RepoConfigDisableSockpuppetDisallowedAuditEntryResolvers<ContextType>;
  gh_RepoConfigEnableAnonymousGitAccessAuditEntry?: gh_RepoConfigEnableAnonymousGitAccessAuditEntryResolvers<ContextType>;
  gh_RepoConfigEnableCollaboratorsOnlyAuditEntry?: gh_RepoConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  gh_RepoConfigEnableContributorsOnlyAuditEntry?: gh_RepoConfigEnableContributorsOnlyAuditEntryResolvers<ContextType>;
  gh_RepoConfigEnableSockpuppetDisallowedAuditEntry?: gh_RepoConfigEnableSockpuppetDisallowedAuditEntryResolvers<ContextType>;
  gh_RepoConfigLockAnonymousGitAccessAuditEntry?: gh_RepoConfigLockAnonymousGitAccessAuditEntryResolvers<ContextType>;
  gh_RepoConfigUnlockAnonymousGitAccessAuditEntry?: gh_RepoConfigUnlockAnonymousGitAccessAuditEntryResolvers<ContextType>;
  gh_RepoCreateAuditEntry?: gh_RepoCreateAuditEntryResolvers<ContextType>;
  gh_RepoDestroyAuditEntry?: gh_RepoDestroyAuditEntryResolvers<ContextType>;
  gh_RepoRemoveMemberAuditEntry?: gh_RepoRemoveMemberAuditEntryResolvers<ContextType>;
  gh_RepoRemoveTopicAuditEntry?: gh_RepoRemoveTopicAuditEntryResolvers<ContextType>;
  gh_Repository?: gh_RepositoryResolvers<ContextType>;
  gh_RepositoryAuditEntryData?: gh_RepositoryAuditEntryDataResolvers<ContextType>;
  gh_RepositoryCodeowners?: gh_RepositoryCodeownersResolvers<ContextType>;
  gh_RepositoryCodeownersError?: gh_RepositoryCodeownersErrorResolvers<ContextType>;
  gh_RepositoryCollaboratorConnection?: gh_RepositoryCollaboratorConnectionResolvers<ContextType>;
  gh_RepositoryCollaboratorEdge?: gh_RepositoryCollaboratorEdgeResolvers<ContextType>;
  gh_RepositoryConnection?: gh_RepositoryConnectionResolvers<ContextType>;
  gh_RepositoryContactLink?: gh_RepositoryContactLinkResolvers<ContextType>;
  gh_RepositoryDiscussionAuthor?: gh_RepositoryDiscussionAuthorResolvers<ContextType>;
  gh_RepositoryDiscussionCommentAuthor?: gh_RepositoryDiscussionCommentAuthorResolvers<ContextType>;
  gh_RepositoryEdge?: gh_RepositoryEdgeResolvers<ContextType>;
  gh_RepositoryIdConditionTarget?: gh_RepositoryIdConditionTargetResolvers<ContextType>;
  gh_RepositoryInfo?: gh_RepositoryInfoResolvers<ContextType>;
  gh_RepositoryInteractionAbility?: gh_RepositoryInteractionAbilityResolvers<ContextType>;
  gh_RepositoryInvitation?: gh_RepositoryInvitationResolvers<ContextType>;
  gh_RepositoryInvitationConnection?: gh_RepositoryInvitationConnectionResolvers<ContextType>;
  gh_RepositoryInvitationEdge?: gh_RepositoryInvitationEdgeResolvers<ContextType>;
  gh_RepositoryMigration?: gh_RepositoryMigrationResolvers<ContextType>;
  gh_RepositoryMigrationConnection?: gh_RepositoryMigrationConnectionResolvers<ContextType>;
  gh_RepositoryMigrationEdge?: gh_RepositoryMigrationEdgeResolvers<ContextType>;
  gh_RepositoryNameConditionTarget?: gh_RepositoryNameConditionTargetResolvers<ContextType>;
  gh_RepositoryNode?: gh_RepositoryNodeResolvers<ContextType>;
  gh_RepositoryOwner?: gh_RepositoryOwnerResolvers<ContextType>;
  gh_RepositoryRule?: gh_RepositoryRuleResolvers<ContextType>;
  gh_RepositoryRuleConditions?: gh_RepositoryRuleConditionsResolvers<ContextType>;
  gh_RepositoryRuleConnection?: gh_RepositoryRuleConnectionResolvers<ContextType>;
  gh_RepositoryRuleEdge?: gh_RepositoryRuleEdgeResolvers<ContextType>;
  gh_RepositoryRuleset?: gh_RepositoryRulesetResolvers<ContextType>;
  gh_RepositoryRulesetBypassActor?: gh_RepositoryRulesetBypassActorResolvers<ContextType>;
  gh_RepositoryRulesetBypassActorConnection?: gh_RepositoryRulesetBypassActorConnectionResolvers<ContextType>;
  gh_RepositoryRulesetBypassActorEdge?: gh_RepositoryRulesetBypassActorEdgeResolvers<ContextType>;
  gh_RepositoryRulesetConnection?: gh_RepositoryRulesetConnectionResolvers<ContextType>;
  gh_RepositoryRulesetEdge?: gh_RepositoryRulesetEdgeResolvers<ContextType>;
  gh_RepositoryTopic?: gh_RepositoryTopicResolvers<ContextType>;
  gh_RepositoryTopicConnection?: gh_RepositoryTopicConnectionResolvers<ContextType>;
  gh_RepositoryTopicEdge?: gh_RepositoryTopicEdgeResolvers<ContextType>;
  gh_RepositoryVisibilityChangeDisableAuditEntry?: gh_RepositoryVisibilityChangeDisableAuditEntryResolvers<ContextType>;
  gh_RepositoryVisibilityChangeEnableAuditEntry?: gh_RepositoryVisibilityChangeEnableAuditEntryResolvers<ContextType>;
  gh_RepositoryVulnerabilityAlert?: gh_RepositoryVulnerabilityAlertResolvers<ContextType>;
  gh_RepositoryVulnerabilityAlertConnection?: gh_RepositoryVulnerabilityAlertConnectionResolvers<ContextType>;
  gh_RepositoryVulnerabilityAlertEdge?: gh_RepositoryVulnerabilityAlertEdgeResolvers<ContextType>;
  gh_RequestReviewsPayload?: gh_RequestReviewsPayloadResolvers<ContextType>;
  gh_RequestedReviewer?: gh_RequestedReviewerResolvers<ContextType>;
  gh_RequestedReviewerConnection?: gh_RequestedReviewerConnectionResolvers<ContextType>;
  gh_RequestedReviewerEdge?: gh_RequestedReviewerEdgeResolvers<ContextType>;
  gh_RequirableByPullRequest?: gh_RequirableByPullRequestResolvers<ContextType>;
  gh_RequiredDeploymentsParameters?: gh_RequiredDeploymentsParametersResolvers<ContextType>;
  gh_RequiredStatusCheckDescription?: gh_RequiredStatusCheckDescriptionResolvers<ContextType>;
  gh_RequiredStatusChecksParameters?: gh_RequiredStatusChecksParametersResolvers<ContextType>;
  gh_RerequestCheckSuitePayload?: gh_RerequestCheckSuitePayloadResolvers<ContextType>;
  gh_ResolveReviewThreadPayload?: gh_ResolveReviewThreadPayloadResolvers<ContextType>;
  gh_RestrictedContribution?: gh_RestrictedContributionResolvers<ContextType>;
  gh_RetireSponsorsTierPayload?: gh_RetireSponsorsTierPayloadResolvers<ContextType>;
  gh_RevertPullRequestPayload?: gh_RevertPullRequestPayloadResolvers<ContextType>;
  gh_ReviewDismissalAllowance?: gh_ReviewDismissalAllowanceResolvers<ContextType>;
  gh_ReviewDismissalAllowanceActor?: gh_ReviewDismissalAllowanceActorResolvers<ContextType>;
  gh_ReviewDismissalAllowanceConnection?: gh_ReviewDismissalAllowanceConnectionResolvers<ContextType>;
  gh_ReviewDismissalAllowanceEdge?: gh_ReviewDismissalAllowanceEdgeResolvers<ContextType>;
  gh_ReviewDismissedEvent?: gh_ReviewDismissedEventResolvers<ContextType>;
  gh_ReviewRequest?: gh_ReviewRequestResolvers<ContextType>;
  gh_ReviewRequestConnection?: gh_ReviewRequestConnectionResolvers<ContextType>;
  gh_ReviewRequestEdge?: gh_ReviewRequestEdgeResolvers<ContextType>;
  gh_ReviewRequestRemovedEvent?: gh_ReviewRequestRemovedEventResolvers<ContextType>;
  gh_ReviewRequestedEvent?: gh_ReviewRequestedEventResolvers<ContextType>;
  gh_ReviewStatusHovercardContext?: gh_ReviewStatusHovercardContextResolvers<ContextType>;
  gh_RevokeEnterpriseOrganizationsMigratorRolePayload?: gh_RevokeEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType>;
  gh_RevokeMigratorRolePayload?: gh_RevokeMigratorRolePayloadResolvers<ContextType>;
  gh_RuleParameters?: gh_RuleParametersResolvers<ContextType>;
  gh_RuleSource?: gh_RuleSourceResolvers<ContextType>;
  gh_SavedReply?: gh_SavedReplyResolvers<ContextType>;
  gh_SavedReplyConnection?: gh_SavedReplyConnectionResolvers<ContextType>;
  gh_SavedReplyEdge?: gh_SavedReplyEdgeResolvers<ContextType>;
  gh_SearchResultItem?: gh_SearchResultItemResolvers<ContextType>;
  gh_SearchResultItemConnection?: gh_SearchResultItemConnectionResolvers<ContextType>;
  gh_SearchResultItemEdge?: gh_SearchResultItemEdgeResolvers<ContextType>;
  gh_SecurityAdvisory?: gh_SecurityAdvisoryResolvers<ContextType>;
  gh_SecurityAdvisoryConnection?: gh_SecurityAdvisoryConnectionResolvers<ContextType>;
  gh_SecurityAdvisoryEdge?: gh_SecurityAdvisoryEdgeResolvers<ContextType>;
  gh_SecurityAdvisoryIdentifier?: gh_SecurityAdvisoryIdentifierResolvers<ContextType>;
  gh_SecurityAdvisoryPackage?: gh_SecurityAdvisoryPackageResolvers<ContextType>;
  gh_SecurityAdvisoryPackageVersion?: gh_SecurityAdvisoryPackageVersionResolvers<ContextType>;
  gh_SecurityAdvisoryReference?: gh_SecurityAdvisoryReferenceResolvers<ContextType>;
  gh_SecurityVulnerability?: gh_SecurityVulnerabilityResolvers<ContextType>;
  gh_SecurityVulnerabilityConnection?: gh_SecurityVulnerabilityConnectionResolvers<ContextType>;
  gh_SecurityVulnerabilityEdge?: gh_SecurityVulnerabilityEdgeResolvers<ContextType>;
  gh_SetEnterpriseIdentityProviderPayload?: gh_SetEnterpriseIdentityProviderPayloadResolvers<ContextType>;
  gh_SetOrganizationInteractionLimitPayload?: gh_SetOrganizationInteractionLimitPayloadResolvers<ContextType>;
  gh_SetRepositoryInteractionLimitPayload?: gh_SetRepositoryInteractionLimitPayloadResolvers<ContextType>;
  gh_SetUserInteractionLimitPayload?: gh_SetUserInteractionLimitPayloadResolvers<ContextType>;
  gh_SmimeSignature?: gh_SmimeSignatureResolvers<ContextType>;
  gh_SocialAccount?: gh_SocialAccountResolvers<ContextType>;
  gh_SocialAccountConnection?: gh_SocialAccountConnectionResolvers<ContextType>;
  gh_SocialAccountEdge?: gh_SocialAccountEdgeResolvers<ContextType>;
  gh_Sponsor?: gh_SponsorResolvers<ContextType>;
  gh_SponsorConnection?: gh_SponsorConnectionResolvers<ContextType>;
  gh_SponsorEdge?: gh_SponsorEdgeResolvers<ContextType>;
  gh_Sponsorable?: gh_SponsorableResolvers<ContextType>;
  gh_SponsorableItem?: gh_SponsorableItemResolvers<ContextType>;
  gh_SponsorableItemConnection?: gh_SponsorableItemConnectionResolvers<ContextType>;
  gh_SponsorableItemEdge?: gh_SponsorableItemEdgeResolvers<ContextType>;
  gh_SponsorsActivity?: gh_SponsorsActivityResolvers<ContextType>;
  gh_SponsorsActivityConnection?: gh_SponsorsActivityConnectionResolvers<ContextType>;
  gh_SponsorsActivityEdge?: gh_SponsorsActivityEdgeResolvers<ContextType>;
  gh_SponsorsGoal?: gh_SponsorsGoalResolvers<ContextType>;
  gh_SponsorsListing?: gh_SponsorsListingResolvers<ContextType>;
  gh_SponsorsListingFeatureableItem?: gh_SponsorsListingFeatureableItemResolvers<ContextType>;
  gh_SponsorsListingFeaturedItem?: gh_SponsorsListingFeaturedItemResolvers<ContextType>;
  gh_SponsorsTier?: gh_SponsorsTierResolvers<ContextType>;
  gh_SponsorsTierAdminInfo?: gh_SponsorsTierAdminInfoResolvers<ContextType>;
  gh_SponsorsTierConnection?: gh_SponsorsTierConnectionResolvers<ContextType>;
  gh_SponsorsTierEdge?: gh_SponsorsTierEdgeResolvers<ContextType>;
  gh_Sponsorship?: gh_SponsorshipResolvers<ContextType>;
  gh_SponsorshipConnection?: gh_SponsorshipConnectionResolvers<ContextType>;
  gh_SponsorshipEdge?: gh_SponsorshipEdgeResolvers<ContextType>;
  gh_SponsorshipNewsletter?: gh_SponsorshipNewsletterResolvers<ContextType>;
  gh_SponsorshipNewsletterConnection?: gh_SponsorshipNewsletterConnectionResolvers<ContextType>;
  gh_SponsorshipNewsletterEdge?: gh_SponsorshipNewsletterEdgeResolvers<ContextType>;
  gh_SshSignature?: gh_SshSignatureResolvers<ContextType>;
  gh_StargazerConnection?: gh_StargazerConnectionResolvers<ContextType>;
  gh_StargazerEdge?: gh_StargazerEdgeResolvers<ContextType>;
  gh_Starrable?: gh_StarrableResolvers<ContextType>;
  gh_StarredRepositoryConnection?: gh_StarredRepositoryConnectionResolvers<ContextType>;
  gh_StarredRepositoryEdge?: gh_StarredRepositoryEdgeResolvers<ContextType>;
  gh_StartOrganizationMigrationPayload?: gh_StartOrganizationMigrationPayloadResolvers<ContextType>;
  gh_StartRepositoryMigrationPayload?: gh_StartRepositoryMigrationPayloadResolvers<ContextType>;
  gh_Status?: gh_StatusResolvers<ContextType>;
  gh_StatusCheckConfiguration?: gh_StatusCheckConfigurationResolvers<ContextType>;
  gh_StatusCheckRollup?: gh_StatusCheckRollupResolvers<ContextType>;
  gh_StatusCheckRollupContext?: gh_StatusCheckRollupContextResolvers<ContextType>;
  gh_StatusCheckRollupContextConnection?: gh_StatusCheckRollupContextConnectionResolvers<ContextType>;
  gh_StatusCheckRollupContextEdge?: gh_StatusCheckRollupContextEdgeResolvers<ContextType>;
  gh_StatusContext?: gh_StatusContextResolvers<ContextType>;
  gh_StatusContextStateCount?: gh_StatusContextStateCountResolvers<ContextType>;
  gh_StripeConnectAccount?: gh_StripeConnectAccountResolvers<ContextType>;
  gh_SubmitPullRequestReviewPayload?: gh_SubmitPullRequestReviewPayloadResolvers<ContextType>;
  gh_Submodule?: gh_SubmoduleResolvers<ContextType>;
  gh_SubmoduleConnection?: gh_SubmoduleConnectionResolvers<ContextType>;
  gh_SubmoduleEdge?: gh_SubmoduleEdgeResolvers<ContextType>;
  gh_Subscribable?: gh_SubscribableResolvers<ContextType>;
  gh_SubscribableThread?: gh_SubscribableThreadResolvers<ContextType>;
  gh_SubscribedEvent?: gh_SubscribedEventResolvers<ContextType>;
  gh_SuggestedReviewer?: gh_SuggestedReviewerResolvers<ContextType>;
  gh_Tag?: gh_TagResolvers<ContextType>;
  gh_TagNamePatternParameters?: gh_TagNamePatternParametersResolvers<ContextType>;
  gh_Team?: gh_TeamResolvers<ContextType>;
  gh_TeamAddMemberAuditEntry?: gh_TeamAddMemberAuditEntryResolvers<ContextType>;
  gh_TeamAddRepositoryAuditEntry?: gh_TeamAddRepositoryAuditEntryResolvers<ContextType>;
  gh_TeamAuditEntryData?: gh_TeamAuditEntryDataResolvers<ContextType>;
  gh_TeamChangeParentTeamAuditEntry?: gh_TeamChangeParentTeamAuditEntryResolvers<ContextType>;
  gh_TeamConnection?: gh_TeamConnectionResolvers<ContextType>;
  gh_TeamDiscussion?: gh_TeamDiscussionResolvers<ContextType>;
  gh_TeamDiscussionComment?: gh_TeamDiscussionCommentResolvers<ContextType>;
  gh_TeamDiscussionCommentConnection?: gh_TeamDiscussionCommentConnectionResolvers<ContextType>;
  gh_TeamDiscussionCommentEdge?: gh_TeamDiscussionCommentEdgeResolvers<ContextType>;
  gh_TeamDiscussionConnection?: gh_TeamDiscussionConnectionResolvers<ContextType>;
  gh_TeamDiscussionEdge?: gh_TeamDiscussionEdgeResolvers<ContextType>;
  gh_TeamEdge?: gh_TeamEdgeResolvers<ContextType>;
  gh_TeamMemberConnection?: gh_TeamMemberConnectionResolvers<ContextType>;
  gh_TeamMemberEdge?: gh_TeamMemberEdgeResolvers<ContextType>;
  gh_TeamRemoveMemberAuditEntry?: gh_TeamRemoveMemberAuditEntryResolvers<ContextType>;
  gh_TeamRemoveRepositoryAuditEntry?: gh_TeamRemoveRepositoryAuditEntryResolvers<ContextType>;
  gh_TeamRepositoryConnection?: gh_TeamRepositoryConnectionResolvers<ContextType>;
  gh_TeamRepositoryEdge?: gh_TeamRepositoryEdgeResolvers<ContextType>;
  gh_TextMatch?: gh_TextMatchResolvers<ContextType>;
  gh_TextMatchHighlight?: gh_TextMatchHighlightResolvers<ContextType>;
  gh_Topic?: gh_TopicResolvers<ContextType>;
  gh_TopicAuditEntryData?: gh_TopicAuditEntryDataResolvers<ContextType>;
  gh_TransferEnterpriseOrganizationPayload?: gh_TransferEnterpriseOrganizationPayloadResolvers<ContextType>;
  gh_TransferIssuePayload?: gh_TransferIssuePayloadResolvers<ContextType>;
  gh_TransferredEvent?: gh_TransferredEventResolvers<ContextType>;
  gh_Tree?: gh_TreeResolvers<ContextType>;
  gh_TreeEntry?: gh_TreeEntryResolvers<ContextType>;
  gh_URI?: GraphQLScalarType;
  gh_UnarchiveProjectV2ItemPayload?: gh_UnarchiveProjectV2ItemPayloadResolvers<ContextType>;
  gh_UnarchiveRepositoryPayload?: gh_UnarchiveRepositoryPayloadResolvers<ContextType>;
  gh_UnassignedEvent?: gh_UnassignedEventResolvers<ContextType>;
  gh_UnfollowOrganizationPayload?: gh_UnfollowOrganizationPayloadResolvers<ContextType>;
  gh_UnfollowUserPayload?: gh_UnfollowUserPayloadResolvers<ContextType>;
  gh_UniformResourceLocatable?: gh_UniformResourceLocatableResolvers<ContextType>;
  gh_UnknownSignature?: gh_UnknownSignatureResolvers<ContextType>;
  gh_UnlabeledEvent?: gh_UnlabeledEventResolvers<ContextType>;
  gh_UnlinkProjectV2FromRepositoryPayload?: gh_UnlinkProjectV2FromRepositoryPayloadResolvers<ContextType>;
  gh_UnlinkProjectV2FromTeamPayload?: gh_UnlinkProjectV2FromTeamPayloadResolvers<ContextType>;
  gh_UnlinkRepositoryFromProjectPayload?: gh_UnlinkRepositoryFromProjectPayloadResolvers<ContextType>;
  gh_UnlockLockablePayload?: gh_UnlockLockablePayloadResolvers<ContextType>;
  gh_UnlockedEvent?: gh_UnlockedEventResolvers<ContextType>;
  gh_UnmarkDiscussionCommentAsAnswerPayload?: gh_UnmarkDiscussionCommentAsAnswerPayloadResolvers<ContextType>;
  gh_UnmarkFileAsViewedPayload?: gh_UnmarkFileAsViewedPayloadResolvers<ContextType>;
  gh_UnmarkIssueAsDuplicatePayload?: gh_UnmarkIssueAsDuplicatePayloadResolvers<ContextType>;
  gh_UnmarkProjectV2AsTemplatePayload?: gh_UnmarkProjectV2AsTemplatePayloadResolvers<ContextType>;
  gh_UnmarkedAsDuplicateEvent?: gh_UnmarkedAsDuplicateEventResolvers<ContextType>;
  gh_UnminimizeCommentPayload?: gh_UnminimizeCommentPayloadResolvers<ContextType>;
  gh_UnpinIssuePayload?: gh_UnpinIssuePayloadResolvers<ContextType>;
  gh_UnpinnedEvent?: gh_UnpinnedEventResolvers<ContextType>;
  gh_UnresolveReviewThreadPayload?: gh_UnresolveReviewThreadPayloadResolvers<ContextType>;
  gh_UnsubscribeFromNotificationsPayload?: gh_UnsubscribeFromNotificationsPayloadResolvers<ContextType>;
  gh_UnsubscribedEvent?: gh_UnsubscribedEventResolvers<ContextType>;
  gh_Updatable?: gh_UpdatableResolvers<ContextType>;
  gh_UpdatableComment?: gh_UpdatableCommentResolvers<ContextType>;
  gh_UpdateBranchProtectionRulePayload?: gh_UpdateBranchProtectionRulePayloadResolvers<ContextType>;
  gh_UpdateCheckRunPayload?: gh_UpdateCheckRunPayloadResolvers<ContextType>;
  gh_UpdateCheckSuitePreferencesPayload?: gh_UpdateCheckSuitePreferencesPayloadResolvers<ContextType>;
  gh_UpdateDiscussionCommentPayload?: gh_UpdateDiscussionCommentPayloadResolvers<ContextType>;
  gh_UpdateDiscussionPayload?: gh_UpdateDiscussionPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseAdministratorRolePayload?: gh_UpdateEnterpriseAdministratorRolePayloadResolvers<ContextType>;
  gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload?: gh_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload?: gh_UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload?: gh_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload?: gh_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload?: gh_UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload?: gh_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload?: gh_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseMembersCanMakePurchasesSettingPayload?: gh_UpdateEnterpriseMembersCanMakePurchasesSettingPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload?: gh_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload?: gh_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseOrganizationProjectsSettingPayload?: gh_UpdateEnterpriseOrganizationProjectsSettingPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseOwnerOrganizationRolePayload?: gh_UpdateEnterpriseOwnerOrganizationRolePayloadResolvers<ContextType>;
  gh_UpdateEnterpriseProfilePayload?: gh_UpdateEnterpriseProfilePayloadResolvers<ContextType>;
  gh_UpdateEnterpriseRepositoryProjectsSettingPayload?: gh_UpdateEnterpriseRepositoryProjectsSettingPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseTeamDiscussionsSettingPayload?: gh_UpdateEnterpriseTeamDiscussionsSettingPayloadResolvers<ContextType>;
  gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload?: gh_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadResolvers<ContextType>;
  gh_UpdateEnvironmentPayload?: gh_UpdateEnvironmentPayloadResolvers<ContextType>;
  gh_UpdateIpAllowListEnabledSettingPayload?: gh_UpdateIpAllowListEnabledSettingPayloadResolvers<ContextType>;
  gh_UpdateIpAllowListEntryPayload?: gh_UpdateIpAllowListEntryPayloadResolvers<ContextType>;
  gh_UpdateIpAllowListForInstalledAppsEnabledSettingPayload?: gh_UpdateIpAllowListForInstalledAppsEnabledSettingPayloadResolvers<ContextType>;
  gh_UpdateIssueCommentPayload?: gh_UpdateIssueCommentPayloadResolvers<ContextType>;
  gh_UpdateIssuePayload?: gh_UpdateIssuePayloadResolvers<ContextType>;
  gh_UpdateLabelPayload?: gh_UpdateLabelPayloadResolvers<ContextType>;
  gh_UpdateNotificationRestrictionSettingPayload?: gh_UpdateNotificationRestrictionSettingPayloadResolvers<ContextType>;
  gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload?: gh_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType>;
  gh_UpdateOrganizationWebCommitSignoffSettingPayload?: gh_UpdateOrganizationWebCommitSignoffSettingPayloadResolvers<ContextType>;
  gh_UpdateParameters?: gh_UpdateParametersResolvers<ContextType>;
  gh_UpdatePatreonSponsorabilityPayload?: gh_UpdatePatreonSponsorabilityPayloadResolvers<ContextType>;
  gh_UpdateProjectCardPayload?: gh_UpdateProjectCardPayloadResolvers<ContextType>;
  gh_UpdateProjectColumnPayload?: gh_UpdateProjectColumnPayloadResolvers<ContextType>;
  gh_UpdateProjectPayload?: gh_UpdateProjectPayloadResolvers<ContextType>;
  gh_UpdateProjectV2CollaboratorsPayload?: gh_UpdateProjectV2CollaboratorsPayloadResolvers<ContextType>;
  gh_UpdateProjectV2DraftIssuePayload?: gh_UpdateProjectV2DraftIssuePayloadResolvers<ContextType>;
  gh_UpdateProjectV2ItemFieldValuePayload?: gh_UpdateProjectV2ItemFieldValuePayloadResolvers<ContextType>;
  gh_UpdateProjectV2ItemPositionPayload?: gh_UpdateProjectV2ItemPositionPayloadResolvers<ContextType>;
  gh_UpdateProjectV2Payload?: gh_UpdateProjectV2PayloadResolvers<ContextType>;
  gh_UpdatePullRequestBranchPayload?: gh_UpdatePullRequestBranchPayloadResolvers<ContextType>;
  gh_UpdatePullRequestPayload?: gh_UpdatePullRequestPayloadResolvers<ContextType>;
  gh_UpdatePullRequestReviewCommentPayload?: gh_UpdatePullRequestReviewCommentPayloadResolvers<ContextType>;
  gh_UpdatePullRequestReviewPayload?: gh_UpdatePullRequestReviewPayloadResolvers<ContextType>;
  gh_UpdateRefPayload?: gh_UpdateRefPayloadResolvers<ContextType>;
  gh_UpdateRefsPayload?: gh_UpdateRefsPayloadResolvers<ContextType>;
  gh_UpdateRepositoryPayload?: gh_UpdateRepositoryPayloadResolvers<ContextType>;
  gh_UpdateRepositoryRulesetPayload?: gh_UpdateRepositoryRulesetPayloadResolvers<ContextType>;
  gh_UpdateRepositoryWebCommitSignoffSettingPayload?: gh_UpdateRepositoryWebCommitSignoffSettingPayloadResolvers<ContextType>;
  gh_UpdateSponsorshipPreferencesPayload?: gh_UpdateSponsorshipPreferencesPayloadResolvers<ContextType>;
  gh_UpdateSubscriptionPayload?: gh_UpdateSubscriptionPayloadResolvers<ContextType>;
  gh_UpdateTeamDiscussionCommentPayload?: gh_UpdateTeamDiscussionCommentPayloadResolvers<ContextType>;
  gh_UpdateTeamDiscussionPayload?: gh_UpdateTeamDiscussionPayloadResolvers<ContextType>;
  gh_UpdateTeamReviewAssignmentPayload?: gh_UpdateTeamReviewAssignmentPayloadResolvers<ContextType>;
  gh_UpdateTeamsRepositoryPayload?: gh_UpdateTeamsRepositoryPayloadResolvers<ContextType>;
  gh_UpdateTopicsPayload?: gh_UpdateTopicsPayloadResolvers<ContextType>;
  gh_UpdateUserListPayload?: gh_UpdateUserListPayloadResolvers<ContextType>;
  gh_UpdateUserListsForItemPayload?: gh_UpdateUserListsForItemPayloadResolvers<ContextType>;
  gh_User?: gh_UserResolvers<ContextType>;
  gh_UserBlockedEvent?: gh_UserBlockedEventResolvers<ContextType>;
  gh_UserConnection?: gh_UserConnectionResolvers<ContextType>;
  gh_UserContentEdit?: gh_UserContentEditResolvers<ContextType>;
  gh_UserContentEditConnection?: gh_UserContentEditConnectionResolvers<ContextType>;
  gh_UserContentEditEdge?: gh_UserContentEditEdgeResolvers<ContextType>;
  gh_UserEdge?: gh_UserEdgeResolvers<ContextType>;
  gh_UserEmailMetadata?: gh_UserEmailMetadataResolvers<ContextType>;
  gh_UserList?: gh_UserListResolvers<ContextType>;
  gh_UserListConnection?: gh_UserListConnectionResolvers<ContextType>;
  gh_UserListEdge?: gh_UserListEdgeResolvers<ContextType>;
  gh_UserListItems?: gh_UserListItemsResolvers<ContextType>;
  gh_UserListItemsConnection?: gh_UserListItemsConnectionResolvers<ContextType>;
  gh_UserListItemsEdge?: gh_UserListItemsEdgeResolvers<ContextType>;
  gh_UserListSuggestion?: gh_UserListSuggestionResolvers<ContextType>;
  gh_UserStatus?: gh_UserStatusResolvers<ContextType>;
  gh_UserStatusConnection?: gh_UserStatusConnectionResolvers<ContextType>;
  gh_UserStatusEdge?: gh_UserStatusEdgeResolvers<ContextType>;
  gh_VerifiableDomain?: gh_VerifiableDomainResolvers<ContextType>;
  gh_VerifiableDomainConnection?: gh_VerifiableDomainConnectionResolvers<ContextType>;
  gh_VerifiableDomainEdge?: gh_VerifiableDomainEdgeResolvers<ContextType>;
  gh_VerifiableDomainOwner?: gh_VerifiableDomainOwnerResolvers<ContextType>;
  gh_VerifyVerifiableDomainPayload?: gh_VerifyVerifiableDomainPayloadResolvers<ContextType>;
  gh_ViewerHovercardContext?: gh_ViewerHovercardContextResolvers<ContextType>;
  gh_Votable?: gh_VotableResolvers<ContextType>;
  gh_Workflow?: gh_WorkflowResolvers<ContextType>;
  gh_WorkflowFileReference?: gh_WorkflowFileReferenceResolvers<ContextType>;
  gh_WorkflowRun?: gh_WorkflowRunResolvers<ContextType>;
  gh_WorkflowRunConnection?: gh_WorkflowRunConnectionResolvers<ContextType>;
  gh_WorkflowRunEdge?: gh_WorkflowRunEdgeResolvers<ContextType>;
  gh_WorkflowRunFile?: gh_WorkflowRunFileResolvers<ContextType>;
  gh_WorkflowsParameters?: gh_WorkflowsParametersResolvers<ContextType>;
  gh_X509Certificate?: GraphQLScalarType;
  GithubQuery?: GithubQueryResolvers<ContextType>;
  GithubMutation?: GithubMutationResolvers<ContextType>;
  hn_ObjectId?: GraphQLScalarType;
  hn_Node?: hn_NodeResolvers<ContextType>;
  hn_Connection?: hn_ConnectionResolvers<ContextType>;
  hn_Edge?: hn_EdgeResolvers<ContextType>;
  hn_PageConnection?: hn_PageConnectionResolvers<ContextType>;
  hn_Feature?: hn_FeatureResolvers<ContextType>;
  hn_PageInfo?: hn_PageInfoResolvers<ContextType>;
  hn_OffsetPageInfo?: hn_OffsetPageInfoResolvers<ContextType>;
  hn_Content?: hn_ContentResolvers<ContextType>;
  hn_SEO?: hn_SEOResolvers<ContextType>;
  hn_OpenGraphMetaData?: hn_OpenGraphMetaDataResolvers<ContextType>;
  hn_UserConnection?: hn_UserConnectionResolvers<ContextType>;
  hn_IUser?: hn_IUserResolvers<ContextType>;
  hn_User?: hn_UserResolvers<ContextType>;
  hn_MyUser?: hn_MyUserResolvers<ContextType>;
  hn_UserPublicationsConnection?: hn_UserPublicationsConnectionResolvers<ContextType>;
  hn_UserPublicationsEdge?: hn_UserPublicationsEdgeResolvers<ContextType>;
  hn_SocialMediaLinks?: hn_SocialMediaLinksResolvers<ContextType>;
  hn_Badge?: hn_BadgeResolvers<ContextType>;
  hn_ToggleFollowUserPayload?: hn_ToggleFollowUserPayloadResolvers<ContextType>;
  hn_CommenterUserConnection?: hn_CommenterUserConnectionResolvers<ContextType>;
  hn_UserEdge?: hn_UserEdgeResolvers<ContextType>;
  hn_ITag?: hn_ITagResolvers<ContextType>;
  hn_Tag?: hn_TagResolvers<ContextType>;
  hn_PopularTag?: hn_PopularTagResolvers<ContextType>;
  hn_PopularTagEdge?: hn_PopularTagEdgeResolvers<ContextType>;
  hn_TagEdge?: hn_TagEdgeResolvers<ContextType>;
  hn_Publication?: hn_PublicationResolvers<ContextType>;
  hn_UserRecommendedPublicationEdge?: hn_UserRecommendedPublicationEdgeResolvers<ContextType>;
  hn_PublicationUserRecommendingPublicationConnection?: hn_PublicationUserRecommendingPublicationConnectionResolvers<ContextType>;
  hn_UserRecommendingPublicationEdge?: hn_UserRecommendingPublicationEdgeResolvers<ContextType>;
  hn_RSSImport?: hn_RSSImportResolvers<ContextType>;
  hn_PublicationSponsorship?: hn_PublicationSponsorshipResolvers<ContextType>;
  hn_StripeConfiguration?: hn_StripeConfigurationResolvers<ContextType>;
  hn_RedirectionRule?: hn_RedirectionRuleResolvers<ContextType>;
  hn_PublicationFeatures?: hn_PublicationFeaturesResolvers<ContextType>;
  hn_NewsletterFeature?: hn_NewsletterFeatureResolvers<ContextType>;
  hn_ViewCountFeature?: hn_ViewCountFeatureResolvers<ContextType>;
  hn_ReadTimeFeature?: hn_ReadTimeFeatureResolvers<ContextType>;
  hn_AudioBlogFeature?: hn_AudioBlogFeatureResolvers<ContextType>;
  hn_TextSelectionSharerFeature?: hn_TextSelectionSharerFeatureResolvers<ContextType>;
  hn_CustomCSSFeature?: hn_CustomCSSFeatureResolvers<ContextType>;
  hn_CustomCSS?: hn_CustomCSSResolvers<ContextType>;
  hn_DomainInfo?: hn_DomainInfoResolvers<ContextType>;
  hn_DomainStatus?: hn_DomainStatusResolvers<ContextType>;
  hn_Preferences?: hn_PreferencesResolvers<ContextType>;
  hn_PublicationNavbarItem?: hn_PublicationNavbarItemResolvers<ContextType>;
  hn_PagesPreferences?: hn_PagesPreferencesResolvers<ContextType>;
  hn_DarkModePreferences?: hn_DarkModePreferencesResolvers<ContextType>;
  hn_PublicationIntegrations?: hn_PublicationIntegrationsResolvers<ContextType>;
  hn_PublicationLinks?: hn_PublicationLinksResolvers<ContextType>;
  hn_EmailImport?: hn_EmailImportResolvers<ContextType>;
  hn_EmailCurrentImport?: hn_EmailCurrentImportResolvers<ContextType>;
  hn_RecommendedPublicationEdge?: hn_RecommendedPublicationEdgeResolvers<ContextType>;
  hn_SubscribeToNewsletterPayload?: hn_SubscribeToNewsletterPayloadResolvers<ContextType>;
  hn_UnsubscribeFromNewsletterPayload?: hn_UnsubscribeFromNewsletterPayloadResolvers<ContextType>;
  hn_Post?: hn_PostResolvers<ContextType>;
  hn_PostFeatures?: hn_PostFeaturesResolvers<ContextType>;
  hn_TableOfContentsFeature?: hn_TableOfContentsFeatureResolvers<ContextType>;
  hn_PostBadgesFeature?: hn_PostBadgesFeatureResolvers<ContextType>;
  hn_TableOfContentsItem?: hn_TableOfContentsItemResolvers<ContextType>;
  hn_PostBadge?: hn_PostBadgeResolvers<ContextType>;
  hn_AudioUrls?: hn_AudioUrlsResolvers<ContextType>;
  hn_PostPreferences?: hn_PostPreferencesResolvers<ContextType>;
  hn_PostCommenterConnection?: hn_PostCommenterConnectionResolvers<ContextType>;
  hn_PostCommenterEdge?: hn_PostCommenterEdgeResolvers<ContextType>;
  hn_PostCommentConnection?: hn_PostCommentConnectionResolvers<ContextType>;
  hn_PostCommentEdge?: hn_PostCommentEdgeResolvers<ContextType>;
  hn_PostLikerEdge?: hn_PostLikerEdgeResolvers<ContextType>;
  hn_PostLikerConnection?: hn_PostLikerConnectionResolvers<ContextType>;
  hn_PostCoverImage?: hn_PostCoverImageResolvers<ContextType>;
  hn_PostEdge?: hn_PostEdgeResolvers<ContextType>;
  hn_UserPostEdge?: hn_UserPostEdgeResolvers<ContextType>;
  hn_FeedPostConnection?: hn_FeedPostConnectionResolvers<ContextType>;
  hn_SearchPostConnection?: hn_SearchPostConnectionResolvers<ContextType>;
  hn_SeriesPostConnection?: hn_SeriesPostConnectionResolvers<ContextType>;
  hn_PublicationPostConnection?: hn_PublicationPostConnectionResolvers<ContextType>;
  hn_UserPostConnection?: hn_UserPostConnectionResolvers<ContextType>;
  hn_PublishPostPayload?: hn_PublishPostPayloadResolvers<ContextType>;
  hn_UpdatePostPayload?: hn_UpdatePostPayloadResolvers<ContextType>;
  hn_RemovePostPayload?: hn_RemovePostPayloadResolvers<ContextType>;
  hn_AddPostToSeriesPayload?: hn_AddPostToSeriesPayloadResolvers<ContextType>;
  hn_Comment?: hn_CommentResolvers<ContextType>;
  hn_CommentReplyConnection?: hn_CommentReplyConnectionResolvers<ContextType>;
  hn_CommentReplyEdge?: hn_CommentReplyEdgeResolvers<ContextType>;
  hn_Reply?: hn_ReplyResolvers<ContextType>;
  hn_Series?: hn_SeriesResolvers<ContextType>;
  hn_SeriesEdge?: hn_SeriesEdgeResolvers<ContextType>;
  hn_SeriesConnection?: hn_SeriesConnectionResolvers<ContextType>;
  hn_Draft?: hn_DraftResolvers<ContextType>;
  hn_DraftSettings?: hn_DraftSettingsResolvers<ContextType>;
  hn_DraftFeatures?: hn_DraftFeaturesResolvers<ContextType>;
  hn_DraftBackup?: hn_DraftBackupResolvers<ContextType>;
  hn_DraftConnection?: hn_DraftConnectionResolvers<ContextType>;
  hn_DraftCoverImage?: hn_DraftCoverImageResolvers<ContextType>;
  hn_DraftEdge?: hn_DraftEdgeResolvers<ContextType>;
  hn_BetaFeature?: hn_BetaFeatureResolvers<ContextType>;
  hn_ScheduledPost?: hn_ScheduledPostResolvers<ContextType>;
  hn_ScheduledPostPayload?: hn_ScheduledPostPayloadResolvers<ContextType>;
  hn_StaticPage?: hn_StaticPageResolvers<ContextType>;
  hn_StaticPageConnection?: hn_StaticPageConnectionResolvers<ContextType>;
  hn_StaticPageEdge?: hn_StaticPageEdgeResolvers<ContextType>;
  hn_Webhook?: hn_WebhookResolvers<ContextType>;
  hn_WebhookMessageConnection?: hn_WebhookMessageConnectionResolvers<ContextType>;
  hn_WebhookMessageEdge?: hn_WebhookMessageEdgeResolvers<ContextType>;
  hn_WebhookMessage?: hn_WebhookMessageResolvers<ContextType>;
  hn_WebhookMessageRequest?: hn_WebhookMessageRequestResolvers<ContextType>;
  hn_WebhookMessageRequestError?: hn_WebhookMessageRequestErrorResolvers<ContextType>;
  hn_WebhookMessageResponse?: hn_WebhookMessageResponseResolvers<ContextType>;
  HashnodeQuery?: HashnodeQueryResolvers<ContextType>;
  HashnodeMutation?: HashnodeMutationResolvers<ContextType>;
}>;

export type DirectiveResolvers<ContextType = MeshContext> = ResolversObject<{
  requiredCapabilities?: requiredCapabilitiesDirectiveResolver<any, any, ContextType>;
  preview?: previewDirectiveResolver<any, any, ContextType>;
  possibleTypes?: possibleTypesDirectiveResolver<any, any, ContextType>;
  requireAuth?: requireAuthDirectiveResolver<any, any, ContextType>;
  constraint?: constraintDirectiveResolver<any, any, ContextType>;
  hidden?: hiddenDirectiveResolver<any, any, ContextType>;
  private?: privateDirectiveResolver<any, any, ContextType>;
}>;

export type MeshContext = GithubTypes.Context & HashnodeTypes.Context & BaseMeshContext;


const baseDir = pathModule.join(typeof __dirname === 'string' ? __dirname : '/', '..');

const importFn: ImportFn = <T>(moduleId: string) => {
  const relativeModuleId = (pathModule.isAbsolute(moduleId) ? pathModule.relative(baseDir, moduleId) : moduleId).split('\\').join('/').replace(baseDir + '/', '');
  switch(relativeModuleId) {
    case ".mesh/sources/Hashnode/introspectionSchema":
      return Promise.resolve(importedModule$0) as T;
    
    default:
      return Promise.reject(new Error(`Cannot find module '${relativeModuleId}'.`));
  }
};

const rootStore = new MeshStore('.mesh', new FsStoreStorageAdapter({
  cwd: baseDir,
  importFn,
  fileType: "ts",
}), {
  readonly: true,
  validate: false
});

export const rawServeConfig: YamlConfig.Config['serve'] = undefined as any
export async function getMeshOptions(): Promise<GetMeshOptions> {
const pubsub = new PubSub();
const sourcesStore = rootStore.child('sources');
const logger = new DefaultLogger("🕸️  Mesh");
const cache = new (MeshCache as any)({
      ...({} as any),
      importFn,
      store: rootStore.child('cache'),
      pubsub,
      logger,
    } as any)

const sources: MeshResolvedSource[] = [];
const transforms: MeshTransform[] = [];
const additionalEnvelopPlugins: MeshPlugin<any>[] = [];
const hashnodeTransforms = [];
const githubTransforms = [];
const additionalTypeDefs = [] as any[];
const hashnodeHandler = new GraphqlHandler({
              name: "Hashnode",
              config: {"endpoint":"https://gql.hashnode.com"},
              baseDir,
              cache,
              pubsub,
              store: sourcesStore.child("Hashnode"),
              logger: logger.child("Hashnode"),
              importFn,
            });
const githubHandler = new GraphqlHandler({
              name: "Github",
              config: {"endpoint":"https://api.github.com/graphql","source":"https://docs.github.com/public/schema.docs.graphql","operationHeaders":{"Authorization":"bearer {env.NEXT_PUBLIC_GITHUB_TOKEN}","User-Agent":"GraphQL"}},
              baseDir,
              cache,
              pubsub,
              store: sourcesStore.child("Github"),
              logger: logger.child("Github"),
              importFn,
            });
hashnodeTransforms[0] = new PrefixTransform({
                  apiName: "Hashnode",
                  config: {"mode":"wrap","value":"hn_","includeRootOperations":true,"includeTypes":true},
                  baseDir,
                  cache,
                  pubsub,
                  importFn,
                  logger,
                });
hashnodeTransforms[1] = new EncapsulateTransform({
                  apiName: "Hashnode",
                  config: {"applyTo":{"query":true,"mutation":true,"subscription":true}},
                  baseDir,
                  cache,
                  pubsub,
                  importFn,
                  logger,
                });
githubTransforms[0] = new PrefixTransform({
                  apiName: "Github",
                  config: {"mode":"wrap","value":"gh_","includeRootOperations":true,"includeTypes":true},
                  baseDir,
                  cache,
                  pubsub,
                  importFn,
                  logger,
                });
githubTransforms[1] = new EncapsulateTransform({
                  apiName: "Github",
                  config: {"applyTo":{"query":true,"mutation":true,"subscription":true}},
                  baseDir,
                  cache,
                  pubsub,
                  importFn,
                  logger,
                });
sources[0] = {
          name: 'Hashnode',
          handler: hashnodeHandler,
          transforms: hashnodeTransforms
        }
sources[1] = {
          name: 'Github',
          handler: githubHandler,
          transforms: githubTransforms
        }
const additionalResolvers = [] as any[]
const merger = new(StitchingMerger as any)({
        cache,
        pubsub,
        logger: logger.child('stitchingMerger'),
        store: rootStore.child('stitchingMerger')
      })
const documentHashMap = {
        "d2c03154c60b622a05e911123142c585629b8007adf842f73996e2025418912b": GithubProfileDocument,
"f2773b02961bf699f22df66911ea310d724a741619426eeb696084ae75e6c01e": LatestBlogPostsDocument
      }
additionalEnvelopPlugins.push(usePersistedOperations({
        getPersistedOperation(key) {
          return documentHashMap[key];
        },
      }))

  return {
    sources,
    transforms,
    additionalTypeDefs,
    additionalResolvers,
    cache,
    pubsub,
    merger,
    logger,
    additionalEnvelopPlugins,
    get documents() {
      return [
      {
        document: GithubProfileDocument,
        get rawSDL() {
          return printWithCache(GithubProfileDocument);
        },
        location: 'GithubProfileDocument.graphql',
        sha256Hash: 'd2c03154c60b622a05e911123142c585629b8007adf842f73996e2025418912b'
      },{
        document: LatestBlogPostsDocument,
        get rawSDL() {
          return printWithCache(LatestBlogPostsDocument);
        },
        location: 'LatestBlogPostsDocument.graphql',
        sha256Hash: 'f2773b02961bf699f22df66911ea310d724a741619426eeb696084ae75e6c01e'
      }
    ];
    },
    fetchFn,
  };
}

export function createBuiltMeshHTTPHandler<TServerContext = {}>(): MeshHTTPHandler<TServerContext> {
  return createMeshHTTPHandler<TServerContext>({
    baseDir,
    getBuiltMesh: getBuiltMesh,
    rawServeConfig: undefined,
  })
}


let meshInstance$: Promise<MeshInstance> | undefined;

export const pollingInterval = null;

export function getBuiltMesh(): Promise<MeshInstance> {
  if (meshInstance$ == null) {
    if (pollingInterval) {
      setInterval(() => {
        getMeshOptions()
        .then(meshOptions => getMesh(meshOptions))
        .then(newMesh =>
          meshInstance$.then(oldMesh => {
            oldMesh.destroy()
            meshInstance$ = Promise.resolve(newMesh)
          })
        ).catch(err => {
          console.error("Mesh polling failed so the existing version will be used:", err);
        });
      }, pollingInterval)
    }
    meshInstance$ = getMeshOptions().then(meshOptions => getMesh(meshOptions)).then(mesh => {
      const id = mesh.pubsub.subscribe('destroy', () => {
        meshInstance$ = undefined;
        mesh.pubsub.unsubscribe(id);
      });
      return mesh;
    });
  }
  return meshInstance$;
}

export const execute: ExecuteMeshFn = (...args) => getBuiltMesh().then(({ execute }) => execute(...args));

export const subscribe: SubscribeMeshFn = (...args) => getBuiltMesh().then(({ subscribe }) => subscribe(...args));
export function getMeshSDK<TGlobalContext = any, TOperationContext = any>(globalContext?: TGlobalContext) {
  const sdkRequester$ = getBuiltMesh().then(({ sdkRequesterFactory }) => sdkRequesterFactory(globalContext));
  return getSdk<TOperationContext, TGlobalContext>((...args) => sdkRequester$.then(sdkRequester => sdkRequester(...args)));
}
export type GithubProfileQueryVariables = Exact<{
  username: Scalars['String']['input'];
}>;


export type GithubProfileQuery = { Github: { gh_user?: Maybe<(
      Pick<gh_User, 'login' | 'avatarUrl' | 'bio'>
      & { socialAccounts: { edges?: Maybe<Array<Maybe<{ node?: Maybe<Pick<gh_SocialAccount, 'displayName' | 'provider' | 'url'>> }>>> } }
    )> } };

export type LatestBlogPostsQueryVariables = Exact<{
  host: Scalars['String']['input'];
  posts: Scalars['Int']['input'];
}>;


export type LatestBlogPostsQuery = { Hashnode: { hn_publication?: Maybe<{ posts: { edges: Array<{ node: (
            Pick<hn_Post, 'id' | 'title' | 'publishedAt' | 'readTimeInMinutes'>
            & { content: Pick<hn_Content, 'text'>, tags?: Maybe<Array<Pick<hn_Tag, 'name'>>>, coverImage?: Maybe<Pick<hn_PostCoverImage, 'url'>>, author: Pick<hn_User, 'id' | 'username' | 'name' | 'profilePicture'> }
          ) }> } }> } };


export const GithubProfileDocument = gql`
    query GithubProfile($username: String!) {
  Github {
    gh_user(login: $username) {
      login
      avatarUrl
      bio
      socialAccounts(first: 10) {
        edges {
          node {
            displayName
            provider
            url
          }
        }
      }
    }
  }
}
    ` as unknown as DocumentNode<GithubProfileQuery, GithubProfileQueryVariables>;
export const LatestBlogPostsDocument = gql`
    query LatestBlogPosts($host: String!, $posts: Int!) {
  Hashnode {
    hn_publication(host: $host) {
      posts(first: $posts) {
        edges {
          node {
            id
            title
            content {
              text
            }
            tags {
              name
            }
            coverImage {
              url
            }
            author {
              id
              username
              name
              profilePicture
            }
            publishedAt
            readTimeInMinutes
          }
        }
      }
    }
  }
}
    ` as unknown as DocumentNode<LatestBlogPostsQuery, LatestBlogPostsQueryVariables>;



export type Requester<C = {}, E = unknown> = <R, V>(doc: DocumentNode, vars?: V, options?: C) => Promise<R> | AsyncIterable<R>
export function getSdk<C, E>(requester: Requester<C, E>) {
  return {
    GithubProfile(variables: GithubProfileQueryVariables, options?: C): Promise<GithubProfileQuery> {
      return requester<GithubProfileQuery, GithubProfileQueryVariables>(GithubProfileDocument, variables, options) as Promise<GithubProfileQuery>;
    },
    LatestBlogPosts(variables: LatestBlogPostsQueryVariables, options?: C): Promise<LatestBlogPostsQuery> {
      return requester<LatestBlogPostsQuery, LatestBlogPostsQueryVariables>(LatestBlogPostsDocument, variables, options) as Promise<LatestBlogPostsQuery>;
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;